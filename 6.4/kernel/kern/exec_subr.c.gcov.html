<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - kern/exec_subr.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">kern</a> - exec_subr.c<span style="font-size: 80%;"> (source / <a href="exec_subr.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">125</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: exec_subr.c,v 1.55 2018/04/12 17:13:44 deraadt Exp $  */</a>
<span class="lineNum">       2 </span>            : /*      $NetBSD: exec_subr.c,v 1.9 1994/12/04 03:10:42 mycroft Exp $    */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /*
<span class="lineNum">       5 </span>            :  * Copyright (c) 1993, 1994 Christopher G. Demetriou
<span class="lineNum">       6 </span>            :  * All rights reserved.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       9 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      10 </span>            :  * are met:
<span class="lineNum">      11 </span>            :  * 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      12 </span>            :  *    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      13 </span>            :  * 2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      14 </span>            :  *    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      15 </span>            :  *    documentation and/or other materials provided with the distribution.
<span class="lineNum">      16 </span>            :  * 3. All advertising materials mentioning features or use of this software
<span class="lineNum">      17 </span>            :  *    must display the following acknowledgement:
<span class="lineNum">      18 </span>            :  *      This product includes software developed by Christopher G. Demetriou.
<span class="lineNum">      19 </span>            :  * 4. The name of the author may not be used to endorse or promote products
<span class="lineNum">      20 </span>            :  *    derived from this software without specific prior written permission
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
<span class="lineNum">      23 </span>            :  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
<span class="lineNum">      24 </span>            :  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
<span class="lineNum">      25 </span>            :  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
<span class="lineNum">      26 </span>            :  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
<span class="lineNum">      27 </span>            :  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      28 </span>            :  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      29 </span>            :  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      30 </span>            :  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
<span class="lineNum">      31 </span>            :  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      32 </span>            :  */
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;sys/systm.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;sys/proc.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;sys/malloc.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;sys/vnode.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;sys/exec.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;sys/mman.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;sys/resourcevar.h&gt;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #include &lt;uvm/uvm_extern.h&gt;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #ifdef DEBUG
<span class="lineNum">      46 </span>            : /*
<span class="lineNum">      47 </span>            :  * new_vmcmd():
<span class="lineNum">      48 </span>            :  *      create a new vmcmd structure and fill in its fields based
<span class="lineNum">      49 </span>            :  *      on function call arguments.  make sure objects ref'd by
<span class="lineNum">      50 </span>            :  *      the vmcmd are 'held'.
<span class="lineNum">      51 </span>            :  *
<span class="lineNum">      52 </span>            :  * If not debugging, this is a macro, so it's expanded inline.
<span class="lineNum">      53 </span>            :  */
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : void
<span class="lineNum">      56 </span>            : new_vmcmd(struct exec_vmcmd_set *evsp,
<span class="lineNum">      57 </span>            :     int (*proc)(struct proc *, struct exec_vmcmd *), u_long len, u_long addr,
<span class="lineNum">      58 </span>            :     struct vnode *vp, u_long offset, u_int prot, int flags)
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span>            :         struct exec_vmcmd    *vcp;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :         if (evsp-&gt;evs_used &gt;= evsp-&gt;evs_cnt)
<span class="lineNum">      63 </span>            :                 vmcmdset_extend(evsp);
<span class="lineNum">      64 </span>            :         vcp = &amp;evsp-&gt;evs_cmds[evsp-&gt;evs_used++];
<span class="lineNum">      65 </span>            :         vcp-&gt;ev_proc = proc;
<span class="lineNum">      66 </span>            :         vcp-&gt;ev_len = len;
<span class="lineNum">      67 </span>            :         vcp-&gt;ev_addr = addr;
<span class="lineNum">      68 </span>            :         if ((vcp-&gt;ev_vp = vp) != NULL)
<span class="lineNum">      69 </span>            :                 vref(vp);
<span class="lineNum">      70 </span>            :         vcp-&gt;ev_offset = offset;
<span class="lineNum">      71 </span>            :         vcp-&gt;ev_prot = prot;
<span class="lineNum">      72 </span>            :         vcp-&gt;ev_flags = flags;
<span class="lineNum">      73 </span>            : }
<span class="lineNum">      74 </span>            : #endif /* DEBUG */
<a name="75"><span class="lineNum">      75 </span>            : </a>
<span class="lineNum">      76 </span>            : void
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : vmcmdset_extend(struct exec_vmcmd_set *evsp)</span>
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span>            :         struct exec_vmcmd *nvcp;
<span class="lineNum">      80 </span>            :         u_int ocnt;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : #ifdef DIAGNOSTIC
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :         if (evsp-&gt;evs_used &lt; evsp-&gt;evs_cnt)</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :                 panic(&quot;vmcmdset_extend: not necessary&quot;);</span>
<span class="lineNum">      85 </span>            : #endif
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :         ocnt = evsp-&gt;evs_cnt;
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :         KASSERT(ocnt &gt; 0);</span>
<span class="lineNum">      89 </span>            :         /* figure out number of entries in new set */
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         evsp-&gt;evs_cnt += ocnt;</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :         /* reallocate the command set */
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :         nvcp = mallocarray(evsp-&gt;evs_cnt, sizeof(*nvcp), M_EXEC,</span>
<span class="lineNum">      94 </span>            :             M_WAITOK);
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :         memcpy(nvcp, evsp-&gt;evs_cmds, ocnt * sizeof(*nvcp));</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         if (evsp-&gt;evs_cmds != evsp-&gt;evs_start)</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                 free(evsp-&gt;evs_cmds, M_EXEC, ocnt * sizeof(*nvcp));</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :         evsp-&gt;evs_cmds = nvcp;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 : }</span>
<a name="100"><span class="lineNum">     100 </span>            : </a>
<span class="lineNum">     101 </span>            : void
<span class="lineNum">     102 </span><span class="lineNoCov">          0 : kill_vmcmds(struct exec_vmcmd_set *evsp)</span>
<span class="lineNum">     103 </span>            : {
<span class="lineNum">     104 </span>            :         struct exec_vmcmd *vcp;
<span class="lineNum">     105 </span>            :         int i;
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; evsp-&gt;evs_used; i++) {</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 vcp = &amp;evsp-&gt;evs_cmds[i];</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :                 if (vcp-&gt;ev_vp != NULLVP)</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :                         vrele(vcp-&gt;ev_vp);</span>
<span class="lineNum">     111 </span>            :         }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :         /*
<span class="lineNum">     114 </span>            :          * Free old vmcmds and reset the array.
<span class="lineNum">     115 </span>            :          */
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         evsp-&gt;evs_used = 0;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :         if (evsp-&gt;evs_cmds != evsp-&gt;evs_start)</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :                 free(evsp-&gt;evs_cmds, M_EXEC,</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :                     evsp-&gt;evs_cnt * sizeof(struct exec_vmcmd));</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :         evsp-&gt;evs_cmds = evsp-&gt;evs_start;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         evsp-&gt;evs_cnt = EXEC_DEFAULT_VMCMD_SETSIZE;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 : }</span>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<span class="lineNum">     124 </span>            : int
<span class="lineNum">     125 </span><span class="lineNoCov">          0 : exec_process_vmcmds(struct proc *p, struct exec_package *epp)</span>
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span>            :         struct exec_vmcmd *base_vc = NULL;
<span class="lineNum">     128 </span>            :         int error = 0;
<span class="lineNum">     129 </span>            :         int i;
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; epp-&gt;ep_vmcmds.evs_used &amp;&amp; !error; i++) {</span>
<span class="lineNum">     132 </span>            :                 struct exec_vmcmd *vcp;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                 vcp = &amp;epp-&gt;ep_vmcmds.evs_cmds[i];</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :                 if (vcp-&gt;ev_flags &amp; VMCMD_RELATIVE) {</span>
<span class="lineNum">     137 </span>            : #ifdef DIAGNOSTIC
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :                         if (base_vc == NULL)</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :                                 panic(&quot;exec_process_vmcmds: RELATIVE no base&quot;);</span>
<span class="lineNum">     140 </span>            : #endif
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :                         vcp-&gt;ev_addr += base_vc-&gt;ev_addr;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :                 error = (*vcp-&gt;ev_proc)(p, vcp);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :                 if (vcp-&gt;ev_flags &amp; VMCMD_BASE) {</span>
<span class="lineNum">     145 </span>            :                         base_vc = vcp;
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     147 </span>            :         }
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         kill_vmcmds(&amp;epp-&gt;ep_vmcmds);</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         return (error);</span>
<span class="lineNum">     152 </span>            : }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /*
<span class="lineNum">     155 </span>            :  * vmcmd_map_pagedvn():
<span class="lineNum">     156 </span>            :  *      handle vmcmd which specifies that a vnode should be mmap'd.
<span class="lineNum">     157 </span>            :  *      appropriate for handling demand-paged text and data segments.
<span class="lineNum">     158 </span>            :  */
<a name="159"><span class="lineNum">     159 </span>            : </a>
<span class="lineNum">     160 </span>            : int
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : vmcmd_map_pagedvn(struct proc *p, struct exec_vmcmd *cmd)</span>
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span>            :         /*
<span class="lineNum">     164 </span>            :          * note that if you're going to map part of a process as being
<span class="lineNum">     165 </span>            :          * paged from a vnode, that vnode had damn well better be marked as
<span class="lineNum">     166 </span>            :          * VTEXT.  that's handled in the routine which sets up the vmcmd to
<span class="lineNum">     167 </span>            :          * call this routine.
<span class="lineNum">     168 </span>            :          */
<span class="lineNum">     169 </span>            :         struct uvm_object *uobj;
<span class="lineNum">     170 </span>            :         int error;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :         /*
<span class="lineNum">     173 </span>            :          * map the vnode in using uvm_map.
<span class="lineNum">     174 </span>            :          */
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         if (cmd-&gt;ev_len == 0)</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 return (0);</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         if (cmd-&gt;ev_offset &amp; PAGE_MASK)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                 return (EINVAL);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         if (cmd-&gt;ev_addr &amp; PAGE_MASK)</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :                 return (EINVAL);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :         if (cmd-&gt;ev_len &amp; PAGE_MASK)</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :                 return (EINVAL);</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :         /*
<span class="lineNum">     186 </span>            :          * first, attach to the object
<span class="lineNum">     187 </span>            :          */
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         uobj = uvn_attach(cmd-&gt;ev_vp, PROT_READ | PROT_EXEC);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :         if (uobj == NULL)</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :                 return (ENOMEM);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :         /*
<span class="lineNum">     194 </span>            :          * do the map
<span class="lineNum">     195 </span>            :          */
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         error = uvm_map(&amp;p-&gt;p_vmspace-&gt;vm_map, &amp;cmd-&gt;ev_addr, cmd-&gt;ev_len,</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :             uobj, cmd-&gt;ev_offset, 0,</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :             UVM_MAPFLAG(cmd-&gt;ev_prot, PROT_MASK, MAP_INHERIT_COPY,</span>
<span class="lineNum">     200 </span>            :             MADV_NORMAL, UVM_FLAG_COPYONW|UVM_FLAG_FIXED));
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :         /*
<span class="lineNum">     203 </span>            :          * check for error
<span class="lineNum">     204 </span>            :          */
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         if (error) {</span>
<span class="lineNum">     207 </span>            :                 /*
<span class="lineNum">     208 </span>            :                  * error: detach from object
<span class="lineNum">     209 </span>            :                  */
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :                 uobj-&gt;pgops-&gt;pgo_detach(uobj);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         return (error);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : /*
<span class="lineNum">     217 </span>            :  * vmcmd_map_readvn():
<span class="lineNum">     218 </span>            :  *      handle vmcmd which specifies that a vnode should be read from.
<span class="lineNum">     219 </span>            :  *      appropriate for non-demand-paged text/data segments, i.e. impure
<span class="lineNum">     220 </span>            :  *      objects (a la OMAGIC and NMAGIC).
<span class="lineNum">     221 </span>            :  */
<a name="222"><span class="lineNum">     222 </span>            : </a>
<span class="lineNum">     223 </span>            : int
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : vmcmd_map_readvn(struct proc *p, struct exec_vmcmd *cmd)</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            :         int error;
<span class="lineNum">     227 </span>            :         vm_prot_t prot;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         if (cmd-&gt;ev_len == 0)</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :                 return (0);</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         prot = cmd-&gt;ev_prot;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         cmd-&gt;ev_addr = trunc_page(cmd-&gt;ev_addr); /* required by uvm_map */</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         error = uvm_map(&amp;p-&gt;p_vmspace-&gt;vm_map, &amp;cmd-&gt;ev_addr,</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :             round_page(cmd-&gt;ev_len), NULL, UVM_UNKNOWN_OFFSET, 0,</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :             UVM_MAPFLAG(prot | PROT_WRITE, PROT_MASK, MAP_INHERIT_COPY,</span>
<span class="lineNum">     238 </span>            :             MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW));
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         if (error)</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         error = vn_rdwr(UIO_READ, cmd-&gt;ev_vp, (caddr_t)cmd-&gt;ev_addr,</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :             cmd-&gt;ev_len, cmd-&gt;ev_offset, UIO_USERSPACE, IO_UNIT,</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :             p-&gt;p_ucred, NULL, p);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         if (error)</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         if ((prot &amp; PROT_WRITE) == 0) {</span>
<span class="lineNum">     250 </span>            :                 /*
<span class="lineNum">     251 </span>            :                  * we had to map in the area at PROT_WRITE so that vn_rdwr()
<span class="lineNum">     252 </span>            :                  * could write to it.   however, the caller seems to want
<span class="lineNum">     253 </span>            :                  * it mapped read-only, so now we are going to have to call
<span class="lineNum">     254 </span>            :                  * uvm_map_protect() to fix up the protection.  ICK.
<span class="lineNum">     255 </span>            :                  */
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :                 return (uvm_map_protect(&amp;p-&gt;p_vmspace-&gt;vm_map,</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                     trunc_page(cmd-&gt;ev_addr),</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :                     round_page(cmd-&gt;ev_addr + cmd-&gt;ev_len),</span>
<span class="lineNum">     259 </span>            :                     prot, FALSE));
<span class="lineNum">     260 </span>            :         }
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : /*
<span class="lineNum">     265 </span>            :  * vmcmd_map_zero():
<span class="lineNum">     266 </span>            :  *      handle vmcmd which specifies a zero-filled address space region.
<span class="lineNum">     267 </span>            :  */
<a name="268"><span class="lineNum">     268 </span>            : </a>
<span class="lineNum">     269 </span>            : int
<span class="lineNum">     270 </span><span class="lineNoCov">          0 : vmcmd_map_zero(struct proc *p, struct exec_vmcmd *cmd)</span>
<span class="lineNum">     271 </span>            : {
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         if (cmd-&gt;ev_len == 0)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                 return (0);</span>
<span class="lineNum">     274 </span>            :         
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         cmd-&gt;ev_addr = trunc_page(cmd-&gt;ev_addr); /* required by uvm_map */</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         return (uvm_map(&amp;p-&gt;p_vmspace-&gt;vm_map, &amp;cmd-&gt;ev_addr,</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :             round_page(cmd-&gt;ev_len), NULL, UVM_UNKNOWN_OFFSET, 0,</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :             UVM_MAPFLAG(cmd-&gt;ev_prot, PROT_MASK, MAP_INHERIT_COPY,</span>
<span class="lineNum">     279 </span>            :             MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_COPYONW |
<span class="lineNum">     280 </span>            :             (cmd-&gt;ev_flags &amp; VMCMD_STACK ? UVM_FLAG_STACK : 0))));
<span class="lineNum">     281 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : /*
<span class="lineNum">     284 </span>            :  * vmcmd_randomize():
<span class="lineNum">     285 </span>            :  *      handle vmcmd which specifies a randomized address space region.
<span class="lineNum">     286 </span>            :  */
<a name="287"><span class="lineNum">     287 </span>            : #define RANDOMIZE_CTX_THRESHOLD 512</a>
<span class="lineNum">     288 </span>            : int
<span class="lineNum">     289 </span><span class="lineNoCov">          0 : vmcmd_randomize(struct proc *p, struct exec_vmcmd *cmd)</span>
<span class="lineNum">     290 </span>            : {
<span class="lineNum">     291 </span>            :         int error;
<span class="lineNum">     292 </span>            :         struct arc4random_ctx *ctx;
<span class="lineNum">     293 </span>            :         char *buf;
<span class="lineNum">     294 </span>            :         size_t sublen, off = 0;
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         size_t len = cmd-&gt;ev_len;</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         if (len == 0)</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                 return (0);</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         if (len &gt; ELF_RANDOMIZE_LIMIT)</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                 return (EINVAL);</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         if (len &lt; RANDOMIZE_CTX_THRESHOLD) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :                 arc4random_buf(buf, len);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                 error = copyout(buf, (void *)cmd-&gt;ev_addr, len);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :                 explicit_bzero(buf, len);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                 ctx = arc4random_ctx_new();</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                 do {</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :                         sublen = MIN(len, PAGE_SIZE);</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                         arc4random_ctx_buf(ctx, buf, sublen);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                         error = copyout(buf, (void *)cmd-&gt;ev_addr + off, sublen);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                         if (error)</span>
<span class="lineNum">     314 </span>            :                                 break;
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                         off += sublen;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                         len -= sublen;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                         sched_pause(yield);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 } while (len);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                 arc4random_ctx_free(ctx);</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                 explicit_bzero(buf, PAGE_SIZE);</span>
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         free(buf, M_TEMP, PAGE_SIZE);</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         return (error);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : #ifndef MAXSSIZ_GUARD
<span class="lineNum">     327 </span>            : #define MAXSSIZ_GUARD   (1024 * 1024)
<span class="lineNum">     328 </span>            : #endif
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : /*
<span class="lineNum">     331 </span>            :  * exec_setup_stack(): Set up the stack segment for an executable.
<span class="lineNum">     332 </span>            :  *
<span class="lineNum">     333 </span>            :  * Note that the ep_ssize parameter must be set to be the current stack
<span class="lineNum">     334 </span>            :  * limit; this is adjusted in the body of execve() to yield the
<span class="lineNum">     335 </span>            :  * appropriate stack segment usage once the argument length is
<span class="lineNum">     336 </span>            :  * calculated.
<span class="lineNum">     337 </span>            :  *
<span class="lineNum">     338 </span>            :  * This function returns an int for uniformity with other (future) formats'
<span class="lineNum">     339 </span>            :  * stack setup functions.  They might have errors to return.
<span class="lineNum">     340 </span>            :  */
<a name="341"><span class="lineNum">     341 </span>            : </a>
<span class="lineNum">     342 </span>            : int
<span class="lineNum">     343 </span><span class="lineNoCov">          0 : exec_setup_stack(struct proc *p, struct exec_package *epp)</span>
<span class="lineNum">     344 </span>            : {
<span class="lineNum">     345 </span>            :         vaddr_t sgap;
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : #ifdef MACHINE_STACK_GROWS_UP
<span class="lineNum">     348 </span>            :         epp-&gt;ep_maxsaddr = USRSTACK;
<span class="lineNum">     349 </span>            :         epp-&gt;ep_minsaddr = USRSTACK + MAXSSIZ;
<span class="lineNum">     350 </span>            : #else
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         epp-&gt;ep_maxsaddr = USRSTACK - MAXSSIZ - MAXSSIZ_GUARD;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         epp-&gt;ep_minsaddr = USRSTACK;</span>
<span class="lineNum">     353 </span>            : #endif
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         epp-&gt;ep_ssize = round_page(p-&gt;p_rlimit[RLIMIT_STACK].rlim_cur);</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         if (stackgap_random != 0) {</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                 sgap = arc4random() &amp; (stackgap_random - 1);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                 sgap = trunc_page(sgap);</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : #ifdef MACHINE_STACK_GROWS_UP
<span class="lineNum">     361 </span>            :                 epp-&gt;ep_maxsaddr += sgap;
<span class="lineNum">     362 </span>            :                 epp-&gt;ep_minsaddr += sgap;
<span class="lineNum">     363 </span>            : #else
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                 epp-&gt;ep_maxsaddr -= sgap;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                 epp-&gt;ep_minsaddr -= sgap;</span>
<span class="lineNum">     366 </span>            : #endif
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :         /*
<span class="lineNum">     370 </span>            :          * set up commands for stack.  note that this takes *two*, one to
<span class="lineNum">     371 </span>            :          * map the part of the stack which we can access, and one to map
<span class="lineNum">     372 </span>            :          * the part which we can't.
<span class="lineNum">     373 </span>            :          *
<span class="lineNum">     374 </span>            :          * arguably, it could be made into one, but that would require the
<span class="lineNum">     375 </span>            :          * addition of another mapping proc, which is unnecessary
<span class="lineNum">     376 </span>            :          *
<span class="lineNum">     377 </span>            :          * note that in memory, things assumed to be: 0 ....... ep_maxsaddr
<span class="lineNum">     378 </span>            :          * &lt;stack&gt; ep_minsaddr
<span class="lineNum">     379 </span>            :          */
<span class="lineNum">     380 </span>            : #ifdef MACHINE_STACK_GROWS_UP
<span class="lineNum">     381 </span>            :         NEW_VMCMD(&amp;epp-&gt;ep_vmcmds, vmcmd_map_zero,
<span class="lineNum">     382 </span>            :             ((epp-&gt;ep_minsaddr - epp-&gt;ep_ssize) - epp-&gt;ep_maxsaddr),
<span class="lineNum">     383 </span>            :             epp-&gt;ep_maxsaddr + epp-&gt;ep_ssize, NULLVP, 0,
<span class="lineNum">     384 </span>            :             PROT_NONE);
<span class="lineNum">     385 </span>            :         NEW_VMCMD2(&amp;epp-&gt;ep_vmcmds, vmcmd_map_zero, epp-&gt;ep_ssize,
<span class="lineNum">     386 </span>            :             epp-&gt;ep_maxsaddr, NULLVP, 0,
<span class="lineNum">     387 </span>            :             PROT_READ | PROT_WRITE, VMCMD_STACK);
<span class="lineNum">     388 </span>            : #else
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         NEW_VMCMD(&amp;epp-&gt;ep_vmcmds, vmcmd_map_zero,</span>
<span class="lineNum">     390 </span>            :             ((epp-&gt;ep_minsaddr - epp-&gt;ep_ssize) - epp-&gt;ep_maxsaddr),
<span class="lineNum">     391 </span>            :             epp-&gt;ep_maxsaddr, NULLVP, 0,
<span class="lineNum">     392 </span>            :             PROT_NONE);
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         NEW_VMCMD2(&amp;epp-&gt;ep_vmcmds, vmcmd_map_zero, epp-&gt;ep_ssize,</span>
<span class="lineNum">     394 </span>            :             (epp-&gt;ep_minsaddr - epp-&gt;ep_ssize), NULLVP, 0,
<span class="lineNum">     395 </span>            :             PROT_READ | PROT_WRITE, VMCMD_STACK);
<span class="lineNum">     396 </span>            : #endif
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     399 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
