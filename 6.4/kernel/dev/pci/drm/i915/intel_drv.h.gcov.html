<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/i915/intel_drv.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/i915</a> - intel_drv.h<span style="font-size: 80%;"> (source / <a href="intel_drv.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2006 Dave Airlie &lt;airlied@linux.ie&gt;
<span class="lineNum">       3 </span>            :  * Copyright (c) 2007-2008 Intel Corporation
<span class="lineNum">       4 </span>            :  *   Jesse Barnes &lt;jesse.barnes@intel.com&gt;
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       7 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">       8 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">       9 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">      10 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">      11 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      14 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      15 </span>            :  * Software.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      18 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      19 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      20 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      21 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      22 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
<span class="lineNum">      23 </span>            :  * IN THE SOFTWARE.
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : #ifndef __INTEL_DRV_H__
<span class="lineNum">      26 </span>            : #define __INTEL_DRV_H__
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #ifdef __linux__
<span class="lineNum">      29 </span>            : #include &lt;linux/async.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;linux/i2c.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;linux/hdmi.h&gt;
<span class="lineNum">      32 </span>            : #else
<span class="lineNum">      33 </span>            : #include &lt;dev/pci/drm/linux_hdmi.h&gt;
<span class="lineNum">      34 </span>            : #endif
<span class="lineNum">      35 </span>            : #include &lt;dev/pci/drm/i915_drm.h&gt;
<span class="lineNum">      36 </span>            : #include &quot;i915_drv.h&quot;
<span class="lineNum">      37 </span>            : #include &lt;dev/pci/drm/drm_crtc.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;dev/pci/drm/drm_crtc_helper.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;dev/pci/drm/drm_fb_helper.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;dev/pci/drm/drm_dp_mst_helper.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;dev/pci/drm/drm_rect.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;dev/pci/drm/drm_atomic.h&gt;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : /**
<span class="lineNum">      45 </span>            :  * _wait_for - magic (register) wait macro
<span class="lineNum">      46 </span>            :  *
<span class="lineNum">      47 </span>            :  * Does the right thing for modeset paths when run under kdgb or similar atomic
<span class="lineNum">      48 </span>            :  * contexts. Note that it's important that we check the condition again after
<span class="lineNum">      49 </span>            :  * having timed out, since the timeout could be due to preemption or similar and
<span class="lineNum">      50 </span>            :  * we've never had a chance to check the condition before the timeout.
<span class="lineNum">      51 </span>            :  */
<span class="lineNum">      52 </span>            : #define _wait_for(COND, MS, W) ({ \
<span class="lineNum">      53 </span>            :         unsigned long timeout__ = jiffies + msecs_to_jiffies(MS) + 1;   \
<span class="lineNum">      54 </span>            :         int ret__ = 0;                                                  \
<span class="lineNum">      55 </span>            :         while (!(COND)) {                                               \
<span class="lineNum">      56 </span>            :                 if (time_after(jiffies, timeout__)) {                   \
<span class="lineNum">      57 </span>            :                         if (!(COND))                                    \
<span class="lineNum">      58 </span>            :                                 ret__ = -ETIMEDOUT;                     \
<span class="lineNum">      59 </span>            :                         break;                                          \
<span class="lineNum">      60 </span>            :                 }                                                       \
<span class="lineNum">      61 </span>            :                 if ((W) &amp;&amp; drm_can_sleep()) {                           \
<span class="lineNum">      62 </span>            :                         usleep_range((W)*1000, (W)*2000);               \
<span class="lineNum">      63 </span>            :                 } else {                                                \
<span class="lineNum">      64 </span>            :                         cpu_relax();                                    \
<span class="lineNum">      65 </span>            :                 }                                                       \
<span class="lineNum">      66 </span>            :         }                                                               \
<span class="lineNum">      67 </span>            :         ret__;                                                          \
<span class="lineNum">      68 </span>            : })
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : #define wait_for(COND, MS) _wait_for(COND, MS, 1)
<span class="lineNum">      71 </span>            : #define wait_for_atomic(COND, MS) _wait_for(COND, MS, 0)
<span class="lineNum">      72 </span>            : #define wait_for_atomic_us(COND, US) _wait_for((COND), \
<span class="lineNum">      73 </span>            :                                                DIV_ROUND_UP((US), 1000), 0)
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : #define KHz(x) (1000 * (x))
<span class="lineNum">      76 </span>            : #define MHz(x) KHz(1000 * (x))
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /*
<span class="lineNum">      79 </span>            :  * Display related stuff
<span class="lineNum">      80 </span>            :  */
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : /* store information about an Ixxx DVO */
<span class="lineNum">      83 </span>            : /* The i830-&gt;i865 use multiple DVOs with multiple i2cs */
<span class="lineNum">      84 </span>            : /* the i915, i945 have a single sDVO i2c bus - which is different */
<span class="lineNum">      85 </span>            : #define MAX_OUTPUTS 6
<span class="lineNum">      86 </span>            : /* maximum connectors per crtcs in the mode set */
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /* Maximum cursor sizes */
<span class="lineNum">      89 </span>            : #define GEN2_CURSOR_WIDTH 64
<span class="lineNum">      90 </span>            : #define GEN2_CURSOR_HEIGHT 64
<span class="lineNum">      91 </span>            : #define MAX_CURSOR_WIDTH 256
<span class="lineNum">      92 </span>            : #define MAX_CURSOR_HEIGHT 256
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : #define INTEL_I2C_BUS_DVO 1
<span class="lineNum">      95 </span>            : #define INTEL_I2C_BUS_SDVO 2
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /* these are outputs from the chip - integrated only
<span class="lineNum">      98 </span>            :    external chips are via DVO or SDVO output */
<span class="lineNum">      99 </span>            : enum intel_output_type {
<span class="lineNum">     100 </span>            :         INTEL_OUTPUT_UNUSED = 0,
<span class="lineNum">     101 </span>            :         INTEL_OUTPUT_ANALOG = 1,
<span class="lineNum">     102 </span>            :         INTEL_OUTPUT_DVO = 2,
<span class="lineNum">     103 </span>            :         INTEL_OUTPUT_SDVO = 3,
<span class="lineNum">     104 </span>            :         INTEL_OUTPUT_LVDS = 4,
<span class="lineNum">     105 </span>            :         INTEL_OUTPUT_TVOUT = 5,
<span class="lineNum">     106 </span>            :         INTEL_OUTPUT_HDMI = 6,
<span class="lineNum">     107 </span>            :         INTEL_OUTPUT_DISPLAYPORT = 7,
<span class="lineNum">     108 </span>            :         INTEL_OUTPUT_EDP = 8,
<span class="lineNum">     109 </span>            :         INTEL_OUTPUT_DSI = 9,
<span class="lineNum">     110 </span>            :         INTEL_OUTPUT_UNKNOWN = 10,
<span class="lineNum">     111 </span>            :         INTEL_OUTPUT_DP_MST = 11,
<span class="lineNum">     112 </span>            : };
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : #define INTEL_DVO_CHIP_NONE 0
<span class="lineNum">     115 </span>            : #define INTEL_DVO_CHIP_LVDS 1
<span class="lineNum">     116 </span>            : #define INTEL_DVO_CHIP_TMDS 2
<span class="lineNum">     117 </span>            : #define INTEL_DVO_CHIP_TVOUT 4
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : #define INTEL_DSI_VIDEO_MODE    0
<span class="lineNum">     120 </span>            : #define INTEL_DSI_COMMAND_MODE  1
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : struct intel_framebuffer {
<span class="lineNum">     123 </span>            :         struct drm_framebuffer base;
<span class="lineNum">     124 </span>            :         struct drm_i915_gem_object *obj;
<span class="lineNum">     125 </span>            : };
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : struct intel_fbdev {
<span class="lineNum">     128 </span>            :         struct drm_fb_helper helper;
<span class="lineNum">     129 </span>            :         struct intel_framebuffer *fb;
<span class="lineNum">     130 </span>            :         struct list_head fbdev_list;
<span class="lineNum">     131 </span>            :         struct drm_display_mode *our_mode;
<span class="lineNum">     132 </span>            :         int preferred_bpp;
<span class="lineNum">     133 </span>            : };
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : struct intel_encoder {
<span class="lineNum">     136 </span>            :         struct drm_encoder base;
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :         enum intel_output_type type;
<span class="lineNum">     139 </span>            :         unsigned int cloneable;
<span class="lineNum">     140 </span>            :         void (*hot_plug)(struct intel_encoder *);
<span class="lineNum">     141 </span>            :         bool (*compute_config)(struct intel_encoder *,
<span class="lineNum">     142 </span>            :                                struct intel_crtc_state *);
<span class="lineNum">     143 </span>            :         void (*pre_pll_enable)(struct intel_encoder *);
<span class="lineNum">     144 </span>            :         void (*pre_enable)(struct intel_encoder *);
<span class="lineNum">     145 </span>            :         void (*enable)(struct intel_encoder *);
<span class="lineNum">     146 </span>            :         void (*mode_set)(struct intel_encoder *intel_encoder);
<span class="lineNum">     147 </span>            :         void (*disable)(struct intel_encoder *);
<span class="lineNum">     148 </span>            :         void (*post_disable)(struct intel_encoder *);
<span class="lineNum">     149 </span>            :         void (*post_pll_disable)(struct intel_encoder *);
<span class="lineNum">     150 </span>            :         /* Read out the current hw state of this connector, returning true if
<span class="lineNum">     151 </span>            :          * the encoder is active. If the encoder is enabled it also set the pipe
<span class="lineNum">     152 </span>            :          * it is connected to in the pipe parameter. */
<span class="lineNum">     153 </span>            :         bool (*get_hw_state)(struct intel_encoder *, enum pipe *pipe);
<span class="lineNum">     154 </span>            :         /* Reconstructs the equivalent mode flags for the current hardware
<span class="lineNum">     155 </span>            :          * state. This must be called _after_ display-&gt;get_pipe_config has
<span class="lineNum">     156 </span>            :          * pre-filled the pipe config. Note that intel_encoder-&gt;base.crtc must
<span class="lineNum">     157 </span>            :          * be set correctly before calling this function. */
<span class="lineNum">     158 </span>            :         void (*get_config)(struct intel_encoder *,
<span class="lineNum">     159 </span>            :                            struct intel_crtc_state *pipe_config);
<span class="lineNum">     160 </span>            :         /*
<span class="lineNum">     161 </span>            :          * Called during system suspend after all pending requests for the
<span class="lineNum">     162 </span>            :          * encoder are flushed (for example for DP AUX transactions) and
<span class="lineNum">     163 </span>            :          * device interrupts are disabled.
<span class="lineNum">     164 </span>            :          */
<span class="lineNum">     165 </span>            :         void (*suspend)(struct intel_encoder *);
<span class="lineNum">     166 </span>            :         int crtc_mask;
<span class="lineNum">     167 </span>            :         enum hpd_pin hpd_pin;
<span class="lineNum">     168 </span>            : };
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : struct intel_panel {
<span class="lineNum">     171 </span>            :         struct drm_display_mode *fixed_mode;
<span class="lineNum">     172 </span>            :         struct drm_display_mode *downclock_mode;
<span class="lineNum">     173 </span>            :         int fitting_mode;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :         /* backlight */
<span class="lineNum">     176 </span>            :         struct {
<span class="lineNum">     177 </span>            :                 bool present;
<span class="lineNum">     178 </span>            :                 u32 level;
<span class="lineNum">     179 </span>            :                 u32 min;
<span class="lineNum">     180 </span>            :                 u32 max;
<span class="lineNum">     181 </span>            :                 bool enabled;
<span class="lineNum">     182 </span>            :                 bool combination_mode;  /* gen 2/4 only */
<span class="lineNum">     183 </span>            :                 bool active_low_pwm;
<span class="lineNum">     184 </span>            :                 bool alternate_pwm_increment;   /* lpt+ */
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :                 /* PWM chip */
<span class="lineNum">     187 </span>            :                 bool util_pin_active_low;       /* bxt+ */
<span class="lineNum">     188 </span>            :                 u8 controller;          /* bxt+ only */
<span class="lineNum">     189 </span>            :                 struct pwm_device *pwm;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :                 struct backlight_device *device;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :                 /* Connector and platform specific backlight functions */
<span class="lineNum">     194 </span>            :                 int (*setup)(struct intel_connector *connector, enum pipe pipe);
<span class="lineNum">     195 </span>            :                 uint32_t (*get)(struct intel_connector *connector);
<span class="lineNum">     196 </span>            :                 void (*set)(struct intel_connector *connector, uint32_t level);
<span class="lineNum">     197 </span>            :                 void (*disable)(struct intel_connector *connector);
<span class="lineNum">     198 </span>            :                 void (*enable)(struct intel_connector *connector);
<span class="lineNum">     199 </span>            :                 uint32_t (*hz_to_pwm)(struct intel_connector *connector,
<span class="lineNum">     200 </span>            :                                       uint32_t hz);
<span class="lineNum">     201 </span>            :                 void (*power)(struct intel_connector *, bool enable);
<span class="lineNum">     202 </span>            :         } backlight;
<span class="lineNum">     203 </span>            : };
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            : struct intel_connector {
<span class="lineNum">     206 </span>            :         struct drm_connector base;
<span class="lineNum">     207 </span>            :         /*
<span class="lineNum">     208 </span>            :          * The fixed encoder this connector is connected to.
<span class="lineNum">     209 </span>            :          */
<span class="lineNum">     210 </span>            :         struct intel_encoder *encoder;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :         /* Reads out the current hw, returning true if the connector is enabled
<span class="lineNum">     213 </span>            :          * and active (i.e. dpms ON state). */
<span class="lineNum">     214 </span>            :         bool (*get_hw_state)(struct intel_connector *);
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :         /*
<span class="lineNum">     217 </span>            :          * Removes all interfaces through which the connector is accessible
<span class="lineNum">     218 </span>            :          * - like sysfs, debugfs entries -, so that no new operations can be
<span class="lineNum">     219 </span>            :          * started on the connector. Also makes sure all currently pending
<span class="lineNum">     220 </span>            :          * operations finish before returing.
<span class="lineNum">     221 </span>            :          */
<span class="lineNum">     222 </span>            :         void (*unregister)(struct intel_connector *);
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :         /* Panel info for eDP and LVDS */
<span class="lineNum">     225 </span>            :         struct intel_panel panel;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :         /* Cached EDID for eDP and LVDS. May hold ERR_PTR for invalid EDID. */
<span class="lineNum">     228 </span>            :         struct edid *edid;
<span class="lineNum">     229 </span>            :         struct edid *detect_edid;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :         /* since POLL and HPD connectors may use the same HPD line keep the native
<span class="lineNum">     232 </span>            :            state of connector-&gt;polled in case hotplug storm detection changes it */
<span class="lineNum">     233 </span>            :         u8 polled;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :         void *port; /* store this opaque as its illegal to dereference it */
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :         struct intel_dp *mst_port;
<span class="lineNum">     238 </span>            : };
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : typedef struct dpll {
<span class="lineNum">     241 </span>            :         /* given values */
<span class="lineNum">     242 </span>            :         int n;
<span class="lineNum">     243 </span>            :         int m1, m2;
<span class="lineNum">     244 </span>            :         int p1, p2;
<span class="lineNum">     245 </span>            :         /* derived values */
<span class="lineNum">     246 </span>            :         int     dot;
<span class="lineNum">     247 </span>            :         int     vco;
<span class="lineNum">     248 </span>            :         int     m;
<span class="lineNum">     249 </span>            :         int     p;
<span class="lineNum">     250 </span>            : } intel_clock_t;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : struct intel_atomic_state {
<span class="lineNum">     253 </span>            :         struct drm_atomic_state base;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :         unsigned int cdclk;
<span class="lineNum">     256 </span>            :         bool dpll_set;
<span class="lineNum">     257 </span>            :         struct intel_shared_dpll_config shared_dpll[I915_NUM_PLLS];
<span class="lineNum">     258 </span>            : };
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : struct intel_plane_state {
<span class="lineNum">     261 </span>            :         struct drm_plane_state base;
<span class="lineNum">     262 </span>            :         struct drm_rect src;
<span class="lineNum">     263 </span>            :         struct drm_rect dst;
<span class="lineNum">     264 </span>            :         struct drm_rect clip;
<span class="lineNum">     265 </span>            :         bool visible;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :         /*
<span class="lineNum">     268 </span>            :          * scaler_id
<span class="lineNum">     269 </span>            :          *    = -1 : not using a scaler
<span class="lineNum">     270 </span>            :          *    &gt;=  0 : using a scalers
<span class="lineNum">     271 </span>            :          *
<span class="lineNum">     272 </span>            :          * plane requiring a scaler:
<span class="lineNum">     273 </span>            :          *   - During check_plane, its bit is set in
<span class="lineNum">     274 </span>            :          *     crtc_state-&gt;scaler_state.scaler_users by calling helper function
<span class="lineNum">     275 </span>            :          *     update_scaler_plane.
<span class="lineNum">     276 </span>            :          *   - scaler_id indicates the scaler it got assigned.
<span class="lineNum">     277 </span>            :          *
<span class="lineNum">     278 </span>            :          * plane doesn't require a scaler:
<span class="lineNum">     279 </span>            :          *   - this can happen when scaling is no more required or plane simply
<span class="lineNum">     280 </span>            :          *     got disabled.
<span class="lineNum">     281 </span>            :          *   - During check_plane, corresponding bit is reset in
<span class="lineNum">     282 </span>            :          *     crtc_state-&gt;scaler_state.scaler_users by calling helper function
<span class="lineNum">     283 </span>            :          *     update_scaler_plane.
<span class="lineNum">     284 </span>            :          */
<span class="lineNum">     285 </span>            :         int scaler_id;
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :         struct drm_intel_sprite_colorkey ckey;
<span class="lineNum">     288 </span>            : };
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : struct intel_initial_plane_config {
<span class="lineNum">     291 </span>            :         struct intel_framebuffer *fb;
<span class="lineNum">     292 </span>            :         unsigned int tiling;
<span class="lineNum">     293 </span>            :         int size;
<span class="lineNum">     294 </span>            :         u32 base;
<span class="lineNum">     295 </span>            : };
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : #define SKL_MIN_SRC_W 8
<span class="lineNum">     298 </span>            : #define SKL_MAX_SRC_W 4096
<span class="lineNum">     299 </span>            : #define SKL_MIN_SRC_H 8
<span class="lineNum">     300 </span>            : #define SKL_MAX_SRC_H 4096
<span class="lineNum">     301 </span>            : #define SKL_MIN_DST_W 8
<span class="lineNum">     302 </span>            : #define SKL_MAX_DST_W 4096
<span class="lineNum">     303 </span>            : #define SKL_MIN_DST_H 8
<span class="lineNum">     304 </span>            : #define SKL_MAX_DST_H 4096
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : struct intel_scaler {
<span class="lineNum">     307 </span>            :         int in_use;
<span class="lineNum">     308 </span>            :         uint32_t mode;
<span class="lineNum">     309 </span>            : };
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : struct intel_crtc_scaler_state {
<span class="lineNum">     312 </span>            : #define SKL_NUM_SCALERS 2
<span class="lineNum">     313 </span>            :         struct intel_scaler scalers[SKL_NUM_SCALERS];
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :         /*
<span class="lineNum">     316 </span>            :          * scaler_users: keeps track of users requesting scalers on this crtc.
<span class="lineNum">     317 </span>            :          *
<span class="lineNum">     318 </span>            :          *     If a bit is set, a user is using a scaler.
<span class="lineNum">     319 </span>            :          *     Here user can be a plane or crtc as defined below:
<span class="lineNum">     320 </span>            :          *       bits 0-30 - plane (bit position is index from drm_plane_index)
<span class="lineNum">     321 </span>            :          *       bit 31    - crtc
<span class="lineNum">     322 </span>            :          *
<span class="lineNum">     323 </span>            :          * Instead of creating a new index to cover planes and crtc, using
<span class="lineNum">     324 </span>            :          * existing drm_plane_index for planes which is well less than 31
<span class="lineNum">     325 </span>            :          * planes and bit 31 for crtc. This should be fine to cover all
<span class="lineNum">     326 </span>            :          * our platforms.
<span class="lineNum">     327 </span>            :          *
<span class="lineNum">     328 </span>            :          * intel_atomic_setup_scalers will setup available scalers to users
<span class="lineNum">     329 </span>            :          * requesting scalers. It will gracefully fail if request exceeds
<span class="lineNum">     330 </span>            :          * avilability.
<span class="lineNum">     331 </span>            :          */
<span class="lineNum">     332 </span>            : #define SKL_CRTC_INDEX 31
<span class="lineNum">     333 </span>            :         unsigned scaler_users;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :         /* scaler used by crtc for panel fitting purpose */
<span class="lineNum">     336 </span>            :         int scaler_id;
<span class="lineNum">     337 </span>            : };
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : /* drm_mode-&gt;private_flags */
<span class="lineNum">     340 </span>            : #define I915_MODE_FLAG_INHERITED 1
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : struct intel_crtc_state {
<span class="lineNum">     343 </span>            :         struct drm_crtc_state base;
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :         /**
<span class="lineNum">     346 </span>            :          * quirks - bitfield with hw state readout quirks
<span class="lineNum">     347 </span>            :          *
<span class="lineNum">     348 </span>            :          * For various reasons the hw state readout code might not be able to
<span class="lineNum">     349 </span>            :          * completely faithfully read out the current state. These cases are
<span class="lineNum">     350 </span>            :          * tracked with quirk flags so that fastboot and state checker can act
<span class="lineNum">     351 </span>            :          * accordingly.
<span class="lineNum">     352 </span>            :          */
<span class="lineNum">     353 </span>            : #define PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS       (1&lt;&lt;0) /* unreliable sync mode.flags */
<span class="lineNum">     354 </span>            :         unsigned long quirks;
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :         bool update_pipe;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :         /* Pipe source size (ie. panel fitter input size)
<span class="lineNum">     359 </span>            :          * All planes will be positioned inside this space,
<span class="lineNum">     360 </span>            :          * and get clipped at the edges. */
<span class="lineNum">     361 </span>            :         int pipe_src_w, pipe_src_h;
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :         /* Whether to set up the PCH/FDI. Note that we never allow sharing
<span class="lineNum">     364 </span>            :          * between pch encoders and cpu encoders. */
<span class="lineNum">     365 </span>            :         bool has_pch_encoder;
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :         /* Are we sending infoframes on the attached port */
<span class="lineNum">     368 </span>            :         bool has_infoframe;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :         /* CPU Transcoder for the pipe. Currently this can only differ from the
<span class="lineNum">     371 </span>            :          * pipe on Haswell (where we have a special eDP transcoder). */
<span class="lineNum">     372 </span>            :         enum transcoder cpu_transcoder;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :         /*
<span class="lineNum">     375 </span>            :          * Use reduced/limited/broadcast rbg range, compressing from the full
<span class="lineNum">     376 </span>            :          * range fed into the crtcs.
<span class="lineNum">     377 </span>            :          */
<span class="lineNum">     378 </span>            :         bool limited_color_range;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :         /* DP has a bunch of special case unfortunately, so mark the pipe
<span class="lineNum">     381 </span>            :          * accordingly. */
<span class="lineNum">     382 </span>            :         bool has_dp_encoder;
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :         /* Whether we should send NULL infoframes. Required for audio. */
<span class="lineNum">     385 </span>            :         bool has_hdmi_sink;
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :         /* Audio enabled on this pipe. Only valid if either has_hdmi_sink or
<span class="lineNum">     388 </span>            :          * has_dp_encoder is set. */
<span class="lineNum">     389 </span>            :         bool has_audio;
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :         /*
<span class="lineNum">     392 </span>            :          * Enable dithering, used when the selected pipe bpp doesn't match the
<span class="lineNum">     393 </span>            :          * plane bpp.
<span class="lineNum">     394 </span>            :          */
<span class="lineNum">     395 </span>            :         bool dither;
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :         /* Controls for the clock computation, to override various stages. */
<span class="lineNum">     398 </span>            :         bool clock_set;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :         /* SDVO TV has a bunch of special case. To make multifunction encoders
<span class="lineNum">     401 </span>            :          * work correctly, we need to track this at runtime.*/
<span class="lineNum">     402 </span>            :         bool sdvo_tv_clock;
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :         /*
<span class="lineNum">     405 </span>            :          * crtc bandwidth limit, don't increase pipe bpp or clock if not really
<span class="lineNum">     406 </span>            :          * required. This is set in the 2nd loop of calling encoder's
<span class="lineNum">     407 </span>            :          * -&gt;compute_config if the first pick doesn't work out.
<span class="lineNum">     408 </span>            :          */
<span class="lineNum">     409 </span>            :         bool bw_constrained;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :         /* Settings for the intel dpll used on pretty much everything but
<span class="lineNum">     412 </span>            :          * haswell. */
<span class="lineNum">     413 </span>            :         struct dpll dpll;
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :         /* Selected dpll when shared or DPLL_ID_PRIVATE. */
<span class="lineNum">     416 </span>            :         enum intel_dpll_id shared_dpll;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :         /*
<span class="lineNum">     419 </span>            :          * - PORT_CLK_SEL for DDI ports on HSW/BDW.
<span class="lineNum">     420 </span>            :          * - enum skl_dpll on SKL
<span class="lineNum">     421 </span>            :          */
<span class="lineNum">     422 </span>            :         uint32_t ddi_pll_sel;
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :         /* Actual register state of the dpll, for shared dpll cross-checking. */
<span class="lineNum">     425 </span>            :         struct intel_dpll_hw_state dpll_hw_state;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :         int pipe_bpp;
<span class="lineNum">     428 </span>            :         struct intel_link_m_n dp_m_n;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :         /* m2_n2 for eDP downclock */
<span class="lineNum">     431 </span>            :         struct intel_link_m_n dp_m2_n2;
<span class="lineNum">     432 </span>            :         bool has_drrs;
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :         /*
<span class="lineNum">     435 </span>            :          * Frequence the dpll for the port should run at. Differs from the
<span class="lineNum">     436 </span>            :          * adjusted dotclock e.g. for DP or 12bpc hdmi mode. This is also
<span class="lineNum">     437 </span>            :          * already multiplied by pixel_multiplier.
<span class="lineNum">     438 </span>            :          */
<span class="lineNum">     439 </span>            :         int port_clock;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :         /* Used by SDVO (and if we ever fix it, HDMI). */
<span class="lineNum">     442 </span>            :         unsigned pixel_multiplier;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :         uint8_t lane_count;
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :         /* Panel fitter controls for gen2-gen4 + VLV */
<span class="lineNum">     447 </span>            :         struct {
<span class="lineNum">     448 </span>            :                 u32 control;
<span class="lineNum">     449 </span>            :                 u32 pgm_ratios;
<span class="lineNum">     450 </span>            :                 u32 lvds_border_bits;
<span class="lineNum">     451 </span>            :         } gmch_pfit;
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :         /* Panel fitter placement and size for Ironlake+ */
<span class="lineNum">     454 </span>            :         struct {
<span class="lineNum">     455 </span>            :                 u32 pos;
<span class="lineNum">     456 </span>            :                 u32 size;
<span class="lineNum">     457 </span>            :                 bool enabled;
<span class="lineNum">     458 </span>            :                 bool force_thru;
<span class="lineNum">     459 </span>            :         } pch_pfit;
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :         /* FDI configuration, only valid if has_pch_encoder is set. */
<span class="lineNum">     462 </span>            :         int fdi_lanes;
<span class="lineNum">     463 </span>            :         struct intel_link_m_n fdi_m_n;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :         bool ips_enabled;
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :         bool double_wide;
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :         bool dp_encoder_is_mst;
<span class="lineNum">     470 </span>            :         int pbn;
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :         struct intel_crtc_scaler_state scaler_state;
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :         /* w/a for waiting 2 vblanks during crtc enable */
<span class="lineNum">     475 </span>            :         enum pipe hsw_workaround_pipe;
<span class="lineNum">     476 </span>            : };
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : struct vlv_wm_state {
<span class="lineNum">     479 </span>            :         struct vlv_pipe_wm wm[3];
<span class="lineNum">     480 </span>            :         struct vlv_sr_wm sr[3];
<span class="lineNum">     481 </span>            :         uint8_t num_active_planes;
<span class="lineNum">     482 </span>            :         uint8_t num_levels;
<span class="lineNum">     483 </span>            :         uint8_t level;
<span class="lineNum">     484 </span>            :         bool cxsr;
<span class="lineNum">     485 </span>            : };
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            : struct intel_pipe_wm {
<span class="lineNum">     488 </span>            :         struct intel_wm_level wm[5];
<span class="lineNum">     489 </span>            :         uint32_t linetime;
<span class="lineNum">     490 </span>            :         bool fbc_wm_enabled;
<span class="lineNum">     491 </span>            :         bool pipe_enabled;
<span class="lineNum">     492 </span>            :         bool sprites_enabled;
<span class="lineNum">     493 </span>            :         bool sprites_scaled;
<span class="lineNum">     494 </span>            : };
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : struct intel_mmio_flip {
<span class="lineNum">     497 </span>            :         struct work_struct work;
<span class="lineNum">     498 </span>            :         struct drm_i915_private *i915;
<span class="lineNum">     499 </span>            :         struct drm_i915_gem_request *req;
<span class="lineNum">     500 </span>            :         struct intel_crtc *crtc;
<span class="lineNum">     501 </span>            : };
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : struct skl_pipe_wm {
<span class="lineNum">     504 </span>            :         struct skl_wm_level wm[8];
<span class="lineNum">     505 </span>            :         struct skl_wm_level trans_wm;
<span class="lineNum">     506 </span>            :         uint32_t linetime;
<span class="lineNum">     507 </span>            : };
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : /*
<span class="lineNum">     510 </span>            :  * Tracking of operations that need to be performed at the beginning/end of an
<span class="lineNum">     511 </span>            :  * atomic commit, outside the atomic section where interrupts are disabled.
<span class="lineNum">     512 </span>            :  * These are generally operations that grab mutexes or might otherwise sleep
<span class="lineNum">     513 </span>            :  * and thus can't be run with interrupts disabled.
<span class="lineNum">     514 </span>            :  */
<span class="lineNum">     515 </span>            : struct intel_crtc_atomic_commit {
<span class="lineNum">     516 </span>            :         /* Sleepable operations to perform before commit */
<span class="lineNum">     517 </span>            :         bool wait_for_flips;
<span class="lineNum">     518 </span>            :         bool disable_fbc;
<span class="lineNum">     519 </span>            :         bool disable_ips;
<span class="lineNum">     520 </span>            :         bool disable_cxsr;
<span class="lineNum">     521 </span>            :         bool pre_disable_primary;
<span class="lineNum">     522 </span>            :         bool update_wm_pre, update_wm_post;
<span class="lineNum">     523 </span>            :         unsigned disabled_planes;
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            :         /* Sleepable operations to perform after commit */
<span class="lineNum">     526 </span>            :         unsigned fb_bits;
<span class="lineNum">     527 </span>            :         bool wait_vblank;
<span class="lineNum">     528 </span>            :         bool update_fbc;
<span class="lineNum">     529 </span>            :         bool post_enable_primary;
<span class="lineNum">     530 </span>            :         unsigned update_sprite_watermarks;
<span class="lineNum">     531 </span>            : };
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : struct intel_crtc {
<span class="lineNum">     534 </span>            :         struct drm_crtc base;
<span class="lineNum">     535 </span>            :         enum pipe pipe;
<span class="lineNum">     536 </span>            :         enum plane plane;
<span class="lineNum">     537 </span>            :         u8 lut_r[256], lut_g[256], lut_b[256];
<span class="lineNum">     538 </span>            :         /*
<span class="lineNum">     539 </span>            :          * Whether the crtc and the connected output pipeline is active. Implies
<span class="lineNum">     540 </span>            :          * that crtc-&gt;enabled is set, i.e. the current mode configuration has
<span class="lineNum">     541 </span>            :          * some outputs connected to this crtc.
<span class="lineNum">     542 </span>            :          */
<span class="lineNum">     543 </span>            :         bool active;
<span class="lineNum">     544 </span>            :         unsigned long enabled_power_domains;
<span class="lineNum">     545 </span>            :         bool lowfreq_avail;
<span class="lineNum">     546 </span>            :         struct intel_overlay *overlay;
<span class="lineNum">     547 </span>            :         struct intel_unpin_work *unpin_work;
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :         atomic_t unpin_work_count;
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :         /* Display surface base address adjustement for pageflips. Note that on
<span class="lineNum">     552 </span>            :          * gen4+ this only adjusts up to a tile, offsets within a tile are
<span class="lineNum">     553 </span>            :          * handled in the hw itself (with the TILEOFF register). */
<span class="lineNum">     554 </span>            :         unsigned long dspaddr_offset;
<span class="lineNum">     555 </span>            :         int adjusted_x;
<span class="lineNum">     556 </span>            :         int adjusted_y;
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :         uint32_t cursor_addr;
<span class="lineNum">     559 </span>            :         uint32_t cursor_cntl;
<span class="lineNum">     560 </span>            :         uint32_t cursor_size;
<span class="lineNum">     561 </span>            :         uint32_t cursor_base;
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            :         struct intel_crtc_state *config;
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :         /* reset counter value when the last flip was submitted */
<span class="lineNum">     566 </span>            :         unsigned int reset_counter;
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :         /* Access to these should be protected by dev_priv-&gt;irq_lock. */
<span class="lineNum">     569 </span>            :         bool cpu_fifo_underrun_disabled;
<span class="lineNum">     570 </span>            :         bool pch_fifo_underrun_disabled;
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :         /* per-pipe watermark state */
<span class="lineNum">     573 </span>            :         struct {
<span class="lineNum">     574 </span>            :                 /* watermarks currently being used  */
<span class="lineNum">     575 </span>            :                 struct intel_pipe_wm active;
<span class="lineNum">     576 </span>            :                 /* SKL wm values currently in use */
<span class="lineNum">     577 </span>            :                 struct skl_pipe_wm skl_active;
<span class="lineNum">     578 </span>            :                 /* allow CxSR on this pipe */
<span class="lineNum">     579 </span>            :                 bool cxsr_allowed;
<span class="lineNum">     580 </span>            :         } wm;
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :         int scanline_offset;
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :         struct {
<span class="lineNum">     585 </span>            :                 unsigned start_vbl_count;
<span class="lineNum">     586 </span>            :                 ktime_t start_vbl_time;
<span class="lineNum">     587 </span>            :                 int min_vbl, max_vbl;
<span class="lineNum">     588 </span>            :                 int scanline_start;
<span class="lineNum">     589 </span>            :         } debug;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :         struct intel_crtc_atomic_commit atomic;
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :         /* scalers available on this crtc */
<span class="lineNum">     594 </span>            :         int num_scalers;
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :         struct vlv_wm_state wm_state;
<span class="lineNum">     597 </span>            : };
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            : struct intel_plane_wm_parameters {
<span class="lineNum">     600 </span>            :         uint32_t horiz_pixels;
<span class="lineNum">     601 </span>            :         uint32_t vert_pixels;
<span class="lineNum">     602 </span>            :         /*
<span class="lineNum">     603 </span>            :          *   For packed pixel formats:
<span class="lineNum">     604 </span>            :          *     bytes_per_pixel - holds bytes per pixel
<span class="lineNum">     605 </span>            :          *   For planar pixel formats:
<span class="lineNum">     606 </span>            :          *     bytes_per_pixel - holds bytes per pixel for uv-plane
<span class="lineNum">     607 </span>            :          *     y_bytes_per_pixel - holds bytes per pixel for y-plane
<span class="lineNum">     608 </span>            :          */
<span class="lineNum">     609 </span>            :         uint8_t bytes_per_pixel;
<span class="lineNum">     610 </span>            :         uint8_t y_bytes_per_pixel;
<span class="lineNum">     611 </span>            :         bool enabled;
<span class="lineNum">     612 </span>            :         bool scaled;
<span class="lineNum">     613 </span>            :         u64 tiling;
<span class="lineNum">     614 </span>            :         unsigned int rotation;
<span class="lineNum">     615 </span>            :         uint16_t fifo_size;
<span class="lineNum">     616 </span>            : };
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            : struct intel_plane {
<span class="lineNum">     619 </span>            :         struct drm_plane base;
<span class="lineNum">     620 </span>            :         int plane;
<span class="lineNum">     621 </span>            :         enum pipe pipe;
<span class="lineNum">     622 </span>            :         bool can_scale;
<span class="lineNum">     623 </span>            :         int max_downscale;
<span class="lineNum">     624 </span>            :         uint32_t frontbuffer_bit;
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :         /* Since we need to change the watermarks before/after
<span class="lineNum">     627 </span>            :          * enabling/disabling the planes, we need to store the parameters here
<span class="lineNum">     628 </span>            :          * as the other pieces of the struct may not reflect the values we want
<span class="lineNum">     629 </span>            :          * for the watermark calculations. Currently only Haswell uses this.
<span class="lineNum">     630 </span>            :          */
<span class="lineNum">     631 </span>            :         struct intel_plane_wm_parameters wm;
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :         /*
<span class="lineNum">     634 </span>            :          * NOTE: Do not place new plane state fields here (e.g., when adding
<span class="lineNum">     635 </span>            :          * new plane properties).  New runtime state should now be placed in
<span class="lineNum">     636 </span>            :          * the intel_plane_state structure and accessed via drm_plane-&gt;state.
<span class="lineNum">     637 </span>            :          */
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :         void (*update_plane)(struct drm_plane *plane,
<span class="lineNum">     640 </span>            :                              struct drm_crtc *crtc,
<span class="lineNum">     641 </span>            :                              struct drm_framebuffer *fb,
<span class="lineNum">     642 </span>            :                              int crtc_x, int crtc_y,
<span class="lineNum">     643 </span>            :                              unsigned int crtc_w, unsigned int crtc_h,
<span class="lineNum">     644 </span>            :                              uint32_t x, uint32_t y,
<span class="lineNum">     645 </span>            :                              uint32_t src_w, uint32_t src_h);
<span class="lineNum">     646 </span>            :         void (*disable_plane)(struct drm_plane *plane,
<span class="lineNum">     647 </span>            :                               struct drm_crtc *crtc);
<span class="lineNum">     648 </span>            :         int (*check_plane)(struct drm_plane *plane,
<span class="lineNum">     649 </span>            :                            struct intel_crtc_state *crtc_state,
<span class="lineNum">     650 </span>            :                            struct intel_plane_state *state);
<span class="lineNum">     651 </span>            :         void (*commit_plane)(struct drm_plane *plane,
<span class="lineNum">     652 </span>            :                              struct intel_plane_state *state);
<span class="lineNum">     653 </span>            : };
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            : struct intel_watermark_params {
<span class="lineNum">     656 </span>            :         unsigned long fifo_size;
<span class="lineNum">     657 </span>            :         unsigned long max_wm;
<span class="lineNum">     658 </span>            :         unsigned long default_wm;
<span class="lineNum">     659 </span>            :         unsigned long guard_size;
<span class="lineNum">     660 </span>            :         unsigned long cacheline_size;
<span class="lineNum">     661 </span>            : };
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : struct cxsr_latency {
<span class="lineNum">     664 </span>            :         int is_desktop;
<span class="lineNum">     665 </span>            :         int is_ddr3;
<span class="lineNum">     666 </span>            :         unsigned long fsb_freq;
<span class="lineNum">     667 </span>            :         unsigned long mem_freq;
<span class="lineNum">     668 </span>            :         unsigned long display_sr;
<span class="lineNum">     669 </span>            :         unsigned long display_hpll_disable;
<span class="lineNum">     670 </span>            :         unsigned long cursor_sr;
<span class="lineNum">     671 </span>            :         unsigned long cursor_hpll_disable;
<span class="lineNum">     672 </span>            : };
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : #define to_intel_atomic_state(x) container_of(x, struct intel_atomic_state, base)
<span class="lineNum">     675 </span>            : #define to_intel_crtc(x) container_of(x, struct intel_crtc, base)
<span class="lineNum">     676 </span>            : #define to_intel_crtc_state(x) container_of(x, struct intel_crtc_state, base)
<span class="lineNum">     677 </span>            : #define to_intel_connector(x) container_of(x, struct intel_connector, base)
<span class="lineNum">     678 </span>            : #define to_intel_encoder(x) container_of(x, struct intel_encoder, base)
<span class="lineNum">     679 </span>            : #define to_intel_framebuffer(x) container_of(x, struct intel_framebuffer, base)
<span class="lineNum">     680 </span>            : #define to_intel_plane(x) container_of(x, struct intel_plane, base)
<span class="lineNum">     681 </span>            : #define to_intel_plane_state(x) container_of(x, struct intel_plane_state, base)
<span class="lineNum">     682 </span>            : #define intel_fb_obj(x) (x ? to_intel_framebuffer(x)-&gt;obj : NULL)
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : struct intel_hdmi {
<span class="lineNum">     685 </span>            :         u32 hdmi_reg;
<span class="lineNum">     686 </span>            :         int ddc_bus;
<span class="lineNum">     687 </span>            :         bool limited_color_range;
<span class="lineNum">     688 </span>            :         bool color_range_auto;
<span class="lineNum">     689 </span>            :         bool has_hdmi_sink;
<span class="lineNum">     690 </span>            :         bool has_audio;
<span class="lineNum">     691 </span>            :         enum hdmi_force_audio force_audio;
<span class="lineNum">     692 </span>            :         bool rgb_quant_range_selectable;
<span class="lineNum">     693 </span>            :         enum hdmi_picture_aspect aspect_ratio;
<span class="lineNum">     694 </span>            :         struct intel_connector *attached_connector;
<span class="lineNum">     695 </span>            :         void (*write_infoframe)(struct drm_encoder *encoder,
<span class="lineNum">     696 </span>            :                                 enum hdmi_infoframe_type type,
<span class="lineNum">     697 </span>            :                                 const void *frame, ssize_t len);
<span class="lineNum">     698 </span>            :         void (*set_infoframes)(struct drm_encoder *encoder,
<span class="lineNum">     699 </span>            :                                bool enable,
<span class="lineNum">     700 </span>            :                                const struct drm_display_mode *adjusted_mode);
<span class="lineNum">     701 </span>            :         bool (*infoframe_enabled)(struct drm_encoder *encoder);
<span class="lineNum">     702 </span>            : };
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : struct intel_dp_mst_encoder;
<span class="lineNum">     705 </span>            : #define DP_MAX_DOWNSTREAM_PORTS         0x10
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : /*
<span class="lineNum">     708 </span>            :  * enum link_m_n_set:
<span class="lineNum">     709 </span>            :  *      When platform provides two set of M_N registers for dp, we can
<span class="lineNum">     710 </span>            :  *      program them and switch between them incase of DRRS.
<span class="lineNum">     711 </span>            :  *      But When only one such register is provided, we have to program the
<span class="lineNum">     712 </span>            :  *      required divider value on that registers itself based on the DRRS state.
<span class="lineNum">     713 </span>            :  *
<span class="lineNum">     714 </span>            :  * M1_N1        : Program dp_m_n on M1_N1 registers
<span class="lineNum">     715 </span>            :  *                        dp_m2_n2 on M2_N2 registers (If supported)
<span class="lineNum">     716 </span>            :  *
<span class="lineNum">     717 </span>            :  * M2_N2        : Program dp_m2_n2 on M1_N1 registers
<span class="lineNum">     718 </span>            :  *                        M2_N2 registers are not supported
<span class="lineNum">     719 </span>            :  */
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            : enum link_m_n_set {
<span class="lineNum">     722 </span>            :         /* Sets the m1_n1 and m2_n2 */
<span class="lineNum">     723 </span>            :         M1_N1 = 0,
<span class="lineNum">     724 </span>            :         M2_N2
<span class="lineNum">     725 </span>            : };
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : struct sink_crc {
<span class="lineNum">     728 </span>            :         bool started;
<span class="lineNum">     729 </span>            :         u8 last_crc[6];
<span class="lineNum">     730 </span>            :         int last_count;
<span class="lineNum">     731 </span>            : };
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : struct intel_dp {
<span class="lineNum">     734 </span>            :         uint32_t output_reg;
<span class="lineNum">     735 </span>            :         uint32_t aux_ch_ctl_reg;
<span class="lineNum">     736 </span>            :         uint32_t DP;
<span class="lineNum">     737 </span>            :         int link_rate;
<span class="lineNum">     738 </span>            :         uint8_t lane_count;
<span class="lineNum">     739 </span>            :         bool has_audio;
<span class="lineNum">     740 </span>            :         enum hdmi_force_audio force_audio;
<span class="lineNum">     741 </span>            :         bool limited_color_range;
<span class="lineNum">     742 </span>            :         bool color_range_auto;
<span class="lineNum">     743 </span>            :         uint8_t dpcd[DP_RECEIVER_CAP_SIZE];
<span class="lineNum">     744 </span>            :         uint8_t psr_dpcd[EDP_PSR_RECEIVER_CAP_SIZE];
<span class="lineNum">     745 </span>            :         uint8_t downstream_ports[DP_MAX_DOWNSTREAM_PORTS];
<span class="lineNum">     746 </span>            :         /* sink rates as reported by DP_SUPPORTED_LINK_RATES */
<span class="lineNum">     747 </span>            :         uint8_t num_sink_rates;
<span class="lineNum">     748 </span>            :         int sink_rates[DP_MAX_SUPPORTED_RATES];
<span class="lineNum">     749 </span>            :         struct sink_crc sink_crc;
<span class="lineNum">     750 </span>            :         struct drm_dp_aux aux;
<span class="lineNum">     751 </span>            :         uint8_t train_set[4];
<span class="lineNum">     752 </span>            :         int panel_power_up_delay;
<span class="lineNum">     753 </span>            :         int panel_power_down_delay;
<span class="lineNum">     754 </span>            :         int panel_power_cycle_delay;
<span class="lineNum">     755 </span>            :         int backlight_on_delay;
<span class="lineNum">     756 </span>            :         int backlight_off_delay;
<span class="lineNum">     757 </span>            :         struct delayed_work panel_vdd_work;
<span class="lineNum">     758 </span>            :         bool want_panel_vdd;
<span class="lineNum">     759 </span>            :         unsigned long last_power_cycle;
<span class="lineNum">     760 </span>            :         unsigned long last_power_on;
<span class="lineNum">     761 </span>            :         unsigned long last_backlight_off;
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :         struct notifier_block edp_notifier;
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :         /*
<span class="lineNum">     766 </span>            :          * Pipe whose power sequencer is currently locked into
<span class="lineNum">     767 </span>            :          * this port. Only relevant on VLV/CHV.
<span class="lineNum">     768 </span>            :          */
<span class="lineNum">     769 </span>            :         enum pipe pps_pipe;
<span class="lineNum">     770 </span>            :         struct edp_power_seq pps_delays;
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :         bool can_mst; /* this port supports mst */
<span class="lineNum">     773 </span>            :         bool is_mst;
<span class="lineNum">     774 </span>            :         int active_mst_links;
<span class="lineNum">     775 </span>            :         /* connector directly attached - won't be use for modeset in mst world */
<span class="lineNum">     776 </span>            :         struct intel_connector *attached_connector;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :         /* mst connector list */
<span class="lineNum">     779 </span>            :         struct intel_dp_mst_encoder *mst_encoders[I915_MAX_PIPES];
<span class="lineNum">     780 </span>            :         struct drm_dp_mst_topology_mgr mst_mgr;
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            :         uint32_t (*get_aux_clock_divider)(struct intel_dp *dp, int index);
<span class="lineNum">     783 </span>            :         /*
<span class="lineNum">     784 </span>            :          * This function returns the value we have to program the AUX_CTL
<span class="lineNum">     785 </span>            :          * register with to kick off an AUX transaction.
<span class="lineNum">     786 </span>            :          */
<span class="lineNum">     787 </span>            :         uint32_t (*get_aux_send_ctl)(struct intel_dp *dp,
<span class="lineNum">     788 </span>            :                                      bool has_aux_irq,
<span class="lineNum">     789 </span>            :                                      int send_bytes,
<span class="lineNum">     790 </span>            :                                      uint32_t aux_clock_divider);
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :         /* Displayport compliance testing */
<span class="lineNum">     793 </span>            :         unsigned long compliance_test_type;
<span class="lineNum">     794 </span>            :         unsigned long compliance_test_data;
<span class="lineNum">     795 </span>            :         bool compliance_test_active;
<span class="lineNum">     796 </span>            : };
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : struct intel_digital_port {
<span class="lineNum">     799 </span>            :         struct intel_encoder base;
<span class="lineNum">     800 </span>            :         enum port port;
<span class="lineNum">     801 </span>            :         u32 saved_port_bits;
<span class="lineNum">     802 </span>            :         struct intel_dp dp;
<span class="lineNum">     803 </span>            :         struct intel_hdmi hdmi;
<span class="lineNum">     804 </span>            :         enum irqreturn (*hpd_pulse)(struct intel_digital_port *, bool);
<span class="lineNum">     805 </span>            :         bool release_cl2_override;
<span class="lineNum">     806 </span>            : };
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            : struct intel_dp_mst_encoder {
<span class="lineNum">     809 </span>            :         struct intel_encoder base;
<span class="lineNum">     810 </span>            :         enum pipe pipe;
<span class="lineNum">     811 </span>            :         struct intel_digital_port *primary;
<span class="lineNum">     812 </span>            :         void *port; /* store this opaque as its illegal to dereference it */
<span class="lineNum">     813 </span>            : };
<a name="814"><span class="lineNum">     814 </span>            : </a>
<span class="lineNum">     815 </span>            : static inline enum dpio_channel
<span class="lineNum">     816 </span><span class="lineNoCov">          0 : vlv_dport_to_channel(struct intel_digital_port *dport)</span>
<span class="lineNum">     817 </span>            : {
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         switch (dport-&gt;port) {</span>
<span class="lineNum">     819 </span>            :         case PORT_B:
<span class="lineNum">     820 </span>            :         case PORT_D:
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :                 return DPIO_CH0;</span>
<span class="lineNum">     822 </span>            :         case PORT_C:
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :                 return DPIO_CH1;</span>
<span class="lineNum">     824 </span>            :         default:
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">     826 </span>            :         }
<span class="lineNum">     827 </span><span class="lineNoCov">          0 : }</span>
<a name="828"><span class="lineNum">     828 </span>            : </a>
<span class="lineNum">     829 </span>            : static inline enum dpio_phy
<span class="lineNum">     830 </span><span class="lineNoCov">          0 : vlv_dport_to_phy(struct intel_digital_port *dport)</span>
<span class="lineNum">     831 </span>            : {
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :         switch (dport-&gt;port) {</span>
<span class="lineNum">     833 </span>            :         case PORT_B:
<span class="lineNum">     834 </span>            :         case PORT_C:
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                 return DPIO_PHY0;</span>
<span class="lineNum">     836 </span>            :         case PORT_D:
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                 return DPIO_PHY1;</span>
<span class="lineNum">     838 </span>            :         default:
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">     840 </span>            :         }
<span class="lineNum">     841 </span><span class="lineNoCov">          0 : }</span>
<a name="842"><span class="lineNum">     842 </span>            : </a>
<span class="lineNum">     843 </span>            : static inline enum dpio_channel
<span class="lineNum">     844 </span><span class="lineNoCov">          0 : vlv_pipe_to_channel(enum pipe pipe)</span>
<span class="lineNum">     845 </span>            : {
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :         switch (pipe) {</span>
<span class="lineNum">     847 </span>            :         case PIPE_A:
<span class="lineNum">     848 </span>            :         case PIPE_C:
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                 return DPIO_CH0;</span>
<span class="lineNum">     850 </span>            :         case PIPE_B:
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :                 return DPIO_CH1;</span>
<span class="lineNum">     852 </span>            :         default:
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">     854 </span>            :         }
<span class="lineNum">     855 </span><span class="lineNoCov">          0 : }</span>
<a name="856"><span class="lineNum">     856 </span>            : </a>
<span class="lineNum">     857 </span>            : static inline struct drm_crtc *
<span class="lineNum">     858 </span><span class="lineNoCov">          0 : intel_get_crtc_for_pipe(struct drm_device *dev, int pipe)</span>
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         return dev_priv-&gt;pipe_to_crtc_mapping[pipe];</span>
<span class="lineNum">     862 </span>            : }
<a name="863"><span class="lineNum">     863 </span>            : </a>
<span class="lineNum">     864 </span>            : static inline struct drm_crtc *
<span class="lineNum">     865 </span><span class="lineNoCov">          0 : intel_get_crtc_for_plane(struct drm_device *dev, int plane)</span>
<span class="lineNum">     866 </span>            : {
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         return dev_priv-&gt;plane_to_crtc_mapping[plane];</span>
<span class="lineNum">     869 </span>            : }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : struct intel_unpin_work {
<span class="lineNum">     872 </span>            :         struct work_struct work;
<span class="lineNum">     873 </span>            :         struct drm_crtc *crtc;
<span class="lineNum">     874 </span>            :         struct drm_framebuffer *old_fb;
<span class="lineNum">     875 </span>            :         struct drm_i915_gem_object *pending_flip_obj;
<span class="lineNum">     876 </span>            :         struct drm_pending_vblank_event *event;
<span class="lineNum">     877 </span>            :         atomic_t pending;
<span class="lineNum">     878 </span>            : #define INTEL_FLIP_INACTIVE     0
<span class="lineNum">     879 </span>            : #define INTEL_FLIP_PENDING      1
<span class="lineNum">     880 </span>            : #define INTEL_FLIP_COMPLETE     2
<span class="lineNum">     881 </span>            :         u32 flip_count;
<span class="lineNum">     882 </span>            :         u32 gtt_offset;
<span class="lineNum">     883 </span>            :         struct drm_i915_gem_request *flip_queued_req;
<span class="lineNum">     884 </span>            :         u32 flip_queued_vblank;
<span class="lineNum">     885 </span>            :         u32 flip_ready_vblank;
<span class="lineNum">     886 </span>            :         bool enable_stall_check;
<span class="lineNum">     887 </span>            : };
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            : struct intel_load_detect_pipe {
<span class="lineNum">     890 </span>            :         struct drm_framebuffer *release_fb;
<span class="lineNum">     891 </span>            :         bool load_detect_temp;
<span class="lineNum">     892 </span>            :         int dpms_mode;
<span class="lineNum">     893 </span>            : };
<a name="894"><span class="lineNum">     894 </span>            : </a>
<span class="lineNum">     895 </span>            : static inline struct intel_encoder *
<span class="lineNum">     896 </span><span class="lineNoCov">          0 : intel_attached_encoder(struct drm_connector *connector)</span>
<span class="lineNum">     897 </span>            : {
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         return to_intel_connector(connector)-&gt;encoder;</span>
<span class="lineNum">     899 </span>            : }
<a name="900"><span class="lineNum">     900 </span>            : </a>
<span class="lineNum">     901 </span>            : static inline struct intel_digital_port *
<span class="lineNum">     902 </span><span class="lineNoCov">          0 : enc_to_dig_port(struct drm_encoder *encoder)</span>
<span class="lineNum">     903 </span>            : {
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :         return container_of(encoder, struct intel_digital_port, base.base);</span>
<span class="lineNum">     905 </span>            : }
<a name="906"><span class="lineNum">     906 </span>            : </a>
<span class="lineNum">     907 </span>            : static inline struct intel_dp_mst_encoder *
<span class="lineNum">     908 </span><span class="lineNoCov">          0 : enc_to_mst(struct drm_encoder *encoder)</span>
<span class="lineNum">     909 </span>            : {
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         return container_of(encoder, struct intel_dp_mst_encoder, base.base);</span>
<a name="911"><span class="lineNum">     911 </span>            : }</a>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span><span class="lineNoCov">          0 : static inline struct intel_dp *enc_to_intel_dp(struct drm_encoder *encoder)</span>
<span class="lineNum">     914 </span>            : {
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :         return &amp;enc_to_dig_port(encoder)-&gt;dp;</span>
<span class="lineNum">     916 </span>            : }
<a name="917"><span class="lineNum">     917 </span>            : </a>
<span class="lineNum">     918 </span>            : static inline struct intel_digital_port *
<span class="lineNum">     919 </span><span class="lineNoCov">          0 : dp_to_dig_port(struct intel_dp *intel_dp)</span>
<span class="lineNum">     920 </span>            : {
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :         return container_of(intel_dp, struct intel_digital_port, dp);</span>
<span class="lineNum">     922 </span>            : }
<a name="923"><span class="lineNum">     923 </span>            : </a>
<span class="lineNum">     924 </span>            : static inline struct intel_digital_port *
<span class="lineNum">     925 </span><span class="lineNoCov">          0 : hdmi_to_dig_port(struct intel_hdmi *intel_hdmi)</span>
<span class="lineNum">     926 </span>            : {
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :         return container_of(intel_hdmi, struct intel_digital_port, hdmi);</span>
<span class="lineNum">     928 </span>            : }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            : /*
<span class="lineNum">     931 </span>            :  * Returns the number of planes for this pipe, ie the number of sprites + 1
<a name="932"><span class="lineNum">     932 </span>            :  * (primary plane). This doesn't count the cursor plane then.</a>
<span class="lineNum">     933 </span>            :  */
<span class="lineNum">     934 </span><span class="lineNoCov">          0 : static inline unsigned int intel_num_planes(struct intel_crtc *crtc)</span>
<span class="lineNum">     935 </span>            : {
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         return INTEL_INFO(crtc-&gt;base.dev)-&gt;num_sprites[crtc-&gt;pipe] + 1;</span>
<span class="lineNum">     937 </span>            : }
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            : /* intel_fifo_underrun.c */
<span class="lineNum">     940 </span>            : bool intel_set_cpu_fifo_underrun_reporting(struct drm_i915_private *dev_priv,
<span class="lineNum">     941 </span>            :                                            enum pipe pipe, bool enable);
<span class="lineNum">     942 </span>            : bool intel_set_pch_fifo_underrun_reporting(struct drm_i915_private *dev_priv,
<span class="lineNum">     943 </span>            :                                            enum transcoder pch_transcoder,
<span class="lineNum">     944 </span>            :                                            bool enable);
<span class="lineNum">     945 </span>            : void intel_cpu_fifo_underrun_irq_handler(struct drm_i915_private *dev_priv,
<span class="lineNum">     946 </span>            :                                          enum pipe pipe);
<span class="lineNum">     947 </span>            : void intel_pch_fifo_underrun_irq_handler(struct drm_i915_private *dev_priv,
<span class="lineNum">     948 </span>            :                                          enum transcoder pch_transcoder);
<span class="lineNum">     949 </span>            : void i9xx_check_fifo_underruns(struct drm_i915_private *dev_priv);
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /* i915_irq.c */
<span class="lineNum">     952 </span>            : void gen5_enable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
<span class="lineNum">     953 </span>            : void gen5_disable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
<span class="lineNum">     954 </span>            : void gen6_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
<span class="lineNum">     955 </span>            : void gen6_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
<span class="lineNum">     956 </span>            : void gen6_reset_rps_interrupts(struct drm_device *dev);
<span class="lineNum">     957 </span>            : void gen6_enable_rps_interrupts(struct drm_device *dev);
<span class="lineNum">     958 </span>            : void gen6_disable_rps_interrupts(struct drm_device *dev);
<span class="lineNum">     959 </span>            : u32 gen6_sanitize_rps_pm_mask(struct drm_i915_private *dev_priv, u32 mask);
<a name="960"><span class="lineNum">     960 </span>            : void intel_runtime_pm_disable_interrupts(struct drm_i915_private *dev_priv);</a>
<span class="lineNum">     961 </span>            : void intel_runtime_pm_enable_interrupts(struct drm_i915_private *dev_priv);
<span class="lineNum">     962 </span><span class="lineNoCov">          0 : static inline bool intel_irqs_enabled(struct drm_i915_private *dev_priv)</span>
<span class="lineNum">     963 </span>            : {
<span class="lineNum">     964 </span>            :         /*
<span class="lineNum">     965 </span>            :          * We only use drm_irq_uninstall() at unload and VT switch, so
<span class="lineNum">     966 </span>            :          * this is the only thing we need to check.
<span class="lineNum">     967 </span>            :          */
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :         return dev_priv-&gt;pm.irqs_enabled;</span>
<span class="lineNum">     969 </span>            : }
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            : int intel_get_crtc_scanline(struct intel_crtc *crtc);
<span class="lineNum">     972 </span>            : void gen8_irq_power_well_post_enable(struct drm_i915_private *dev_priv,
<span class="lineNum">     973 </span>            :                                      unsigned int pipe_mask);
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /* intel_crt.c */
<span class="lineNum">     976 </span>            : void intel_crt_init(struct drm_device *dev);
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            : /* intel_ddi.c */
<span class="lineNum">     980 </span>            : void intel_prepare_ddi(struct drm_device *dev);
<span class="lineNum">     981 </span>            : void hsw_fdi_link_train(struct drm_crtc *crtc);
<span class="lineNum">     982 </span>            : void intel_ddi_init(struct drm_device *dev, enum port port);
<span class="lineNum">     983 </span>            : enum port intel_ddi_get_encoder_port(struct intel_encoder *intel_encoder);
<span class="lineNum">     984 </span>            : bool intel_ddi_get_hw_state(struct intel_encoder *encoder, enum pipe *pipe);
<span class="lineNum">     985 </span>            : void intel_ddi_pll_init(struct drm_device *dev);
<span class="lineNum">     986 </span>            : void intel_ddi_enable_transcoder_func(struct drm_crtc *crtc);
<span class="lineNum">     987 </span>            : void intel_ddi_disable_transcoder_func(struct drm_i915_private *dev_priv,
<span class="lineNum">     988 </span>            :                                        enum transcoder cpu_transcoder);
<span class="lineNum">     989 </span>            : void intel_ddi_enable_pipe_clock(struct intel_crtc *intel_crtc);
<span class="lineNum">     990 </span>            : void intel_ddi_disable_pipe_clock(struct intel_crtc *intel_crtc);
<span class="lineNum">     991 </span>            : bool intel_ddi_pll_select(struct intel_crtc *crtc,
<span class="lineNum">     992 </span>            :                           struct intel_crtc_state *crtc_state);
<span class="lineNum">     993 </span>            : void intel_ddi_set_pipe_settings(struct drm_crtc *crtc);
<span class="lineNum">     994 </span>            : void intel_ddi_prepare_link_retrain(struct drm_encoder *encoder);
<span class="lineNum">     995 </span>            : bool intel_ddi_connector_get_hw_state(struct intel_connector *intel_connector);
<span class="lineNum">     996 </span>            : void intel_ddi_fdi_disable(struct drm_crtc *crtc);
<span class="lineNum">     997 </span>            : void intel_ddi_get_config(struct intel_encoder *encoder,
<span class="lineNum">     998 </span>            :                           struct intel_crtc_state *pipe_config);
<span class="lineNum">     999 </span>            : struct intel_encoder *
<span class="lineNum">    1000 </span>            : intel_ddi_get_crtc_new_encoder(struct intel_crtc_state *crtc_state);
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            : void intel_ddi_init_dp_buf_reg(struct intel_encoder *encoder);
<span class="lineNum">    1003 </span>            : void intel_ddi_clock_get(struct intel_encoder *encoder,
<span class="lineNum">    1004 </span>            :                          struct intel_crtc_state *pipe_config);
<span class="lineNum">    1005 </span>            : void intel_ddi_set_vc_payload_alloc(struct drm_crtc *crtc, bool state);
<span class="lineNum">    1006 </span>            : uint32_t ddi_signal_levels(struct intel_dp *intel_dp);
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            : /* intel_frontbuffer.c */
<span class="lineNum">    1009 </span>            : void intel_fb_obj_invalidate(struct drm_i915_gem_object *obj,
<span class="lineNum">    1010 </span>            :                              enum fb_op_origin origin);
<span class="lineNum">    1011 </span>            : void intel_frontbuffer_flip_prepare(struct drm_device *dev,
<span class="lineNum">    1012 </span>            :                                     unsigned frontbuffer_bits);
<span class="lineNum">    1013 </span>            : void intel_frontbuffer_flip_complete(struct drm_device *dev,
<span class="lineNum">    1014 </span>            :                                      unsigned frontbuffer_bits);
<span class="lineNum">    1015 </span>            : void intel_frontbuffer_flip(struct drm_device *dev,
<span class="lineNum">    1016 </span>            :                             unsigned frontbuffer_bits);
<span class="lineNum">    1017 </span>            : unsigned int intel_fb_align_height(struct drm_device *dev,
<span class="lineNum">    1018 </span>            :                                    unsigned int height,
<span class="lineNum">    1019 </span>            :                                    uint32_t pixel_format,
<span class="lineNum">    1020 </span>            :                                    uint64_t fb_format_modifier);
<span class="lineNum">    1021 </span>            : void intel_fb_obj_flush(struct drm_i915_gem_object *obj, bool retire,
<span class="lineNum">    1022 </span>            :                         enum fb_op_origin origin);
<span class="lineNum">    1023 </span>            : u32 intel_fb_stride_alignment(struct drm_device *dev, uint64_t fb_modifier,
<span class="lineNum">    1024 </span>            :                               uint32_t pixel_format);
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : /* intel_audio.c */
<span class="lineNum">    1027 </span>            : void intel_init_audio(struct drm_device *dev);
<span class="lineNum">    1028 </span>            : void intel_audio_codec_enable(struct intel_encoder *encoder);
<span class="lineNum">    1029 </span>            : void intel_audio_codec_disable(struct intel_encoder *encoder);
<span class="lineNum">    1030 </span>            : void i915_audio_component_init(struct drm_i915_private *dev_priv);
<span class="lineNum">    1031 </span>            : void i915_audio_component_cleanup(struct drm_i915_private *dev_priv);
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            : /* intel_display.c */
<span class="lineNum">    1034 </span>            : extern const struct drm_plane_funcs intel_plane_funcs;
<span class="lineNum">    1035 </span>            : bool intel_has_pending_fb_unpin(struct drm_device *dev);
<span class="lineNum">    1036 </span>            : int intel_pch_rawclk(struct drm_device *dev);
<span class="lineNum">    1037 </span>            : int intel_hrawclk(struct drm_device *dev);
<span class="lineNum">    1038 </span>            : void intel_mark_busy(struct drm_device *dev);
<span class="lineNum">    1039 </span>            : void intel_mark_idle(struct drm_device *dev);
<span class="lineNum">    1040 </span>            : void intel_crtc_restore_mode(struct drm_crtc *crtc);
<span class="lineNum">    1041 </span>            : int intel_display_suspend(struct drm_device *dev);
<span class="lineNum">    1042 </span>            : void intel_encoder_destroy(struct drm_encoder *encoder);
<span class="lineNum">    1043 </span>            : int intel_connector_init(struct intel_connector *);
<span class="lineNum">    1044 </span>            : struct intel_connector *intel_connector_alloc(void);
<span class="lineNum">    1045 </span>            : bool intel_connector_get_hw_state(struct intel_connector *connector);
<span class="lineNum">    1046 </span>            : void intel_connector_attach_encoder(struct intel_connector *connector,
<span class="lineNum">    1047 </span>            :                                     struct intel_encoder *encoder);
<span class="lineNum">    1048 </span>            : struct drm_encoder *intel_best_encoder(struct drm_connector *connector);
<span class="lineNum">    1049 </span>            : struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
<span class="lineNum">    1050 </span>            :                                              struct drm_crtc *crtc);
<span class="lineNum">    1051 </span>            : enum pipe intel_get_pipe_from_connector(struct intel_connector *connector);
<span class="lineNum">    1052 </span>            : int intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
<span class="lineNum">    1053 </span>            :                                 struct drm_file *file_priv);
<span class="lineNum">    1054 </span>            : enum transcoder intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
<span class="lineNum">    1055 </span>            :                                              enum pipe pipe);
<a name="1056"><span class="lineNum">    1056 </span>            : bool intel_pipe_has_type(struct intel_crtc *crtc, enum intel_output_type type);</a>
<span class="lineNum">    1057 </span>            : static inline void
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 : intel_wait_for_vblank(struct drm_device *dev, int pipe)</span>
<span class="lineNum">    1059 </span>            : {
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         drm_wait_one_vblank(dev, pipe);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1062 </span>            : int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp);
<span class="lineNum">    1063 </span>            : void vlv_wait_port_ready(struct drm_i915_private *dev_priv,
<span class="lineNum">    1064 </span>            :                          struct intel_digital_port *dport,
<span class="lineNum">    1065 </span>            :                          unsigned int expected_mask);
<span class="lineNum">    1066 </span>            : bool intel_get_load_detect_pipe(struct drm_connector *connector,
<span class="lineNum">    1067 </span>            :                                 struct drm_display_mode *mode,
<span class="lineNum">    1068 </span>            :                                 struct intel_load_detect_pipe *old,
<span class="lineNum">    1069 </span>            :                                 struct drm_modeset_acquire_ctx *ctx);
<span class="lineNum">    1070 </span>            : void intel_release_load_detect_pipe(struct drm_connector *connector,
<span class="lineNum">    1071 </span>            :                                     struct intel_load_detect_pipe *old,
<span class="lineNum">    1072 </span>            :                                     struct drm_modeset_acquire_ctx *ctx);
<span class="lineNum">    1073 </span>            : int intel_pin_and_fence_fb_obj(struct drm_plane *plane,
<span class="lineNum">    1074 </span>            :                                struct drm_framebuffer *fb,
<span class="lineNum">    1075 </span>            :                                const struct drm_plane_state *plane_state,
<span class="lineNum">    1076 </span>            :                                struct intel_engine_cs *pipelined,
<span class="lineNum">    1077 </span>            :                                struct drm_i915_gem_request **pipelined_request);
<span class="lineNum">    1078 </span>            : struct drm_framebuffer *
<span class="lineNum">    1079 </span>            : __intel_framebuffer_create(struct drm_device *dev,
<span class="lineNum">    1080 </span>            :                            struct drm_mode_fb_cmd2 *mode_cmd,
<span class="lineNum">    1081 </span>            :                            struct drm_i915_gem_object *obj);
<span class="lineNum">    1082 </span>            : void intel_prepare_page_flip(struct drm_device *dev, int plane);
<span class="lineNum">    1083 </span>            : void intel_finish_page_flip(struct drm_device *dev, int pipe);
<span class="lineNum">    1084 </span>            : void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
<span class="lineNum">    1085 </span>            : void intel_check_page_flip(struct drm_device *dev, int pipe);
<span class="lineNum">    1086 </span>            : int intel_prepare_plane_fb(struct drm_plane *plane,
<span class="lineNum">    1087 </span>            :                            const struct drm_plane_state *new_state);
<span class="lineNum">    1088 </span>            : void intel_cleanup_plane_fb(struct drm_plane *plane,
<span class="lineNum">    1089 </span>            :                             const struct drm_plane_state *old_state);
<span class="lineNum">    1090 </span>            : int intel_plane_atomic_get_property(struct drm_plane *plane,
<span class="lineNum">    1091 </span>            :                                     const struct drm_plane_state *state,
<span class="lineNum">    1092 </span>            :                                     struct drm_property *property,
<span class="lineNum">    1093 </span>            :                                     uint64_t *val);
<span class="lineNum">    1094 </span>            : int intel_plane_atomic_set_property(struct drm_plane *plane,
<span class="lineNum">    1095 </span>            :                                     struct drm_plane_state *state,
<span class="lineNum">    1096 </span>            :                                     struct drm_property *property,
<span class="lineNum">    1097 </span>            :                                     uint64_t val);
<span class="lineNum">    1098 </span>            : int intel_plane_atomic_calc_changes(struct drm_crtc_state *crtc_state,
<span class="lineNum">    1099 </span>            :                                     struct drm_plane_state *plane_state);
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            : unsigned int
<span class="lineNum">    1102 </span>            : intel_tile_height(struct drm_device *dev, uint32_t pixel_format,
<span class="lineNum">    1103 </span>            :                   uint64_t fb_format_modifier, unsigned int plane);
<a name="1104"><span class="lineNum">    1104 </span>            : </a>
<span class="lineNum">    1105 </span>            : static inline bool
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 : intel_rotation_90_or_270(unsigned int rotation)</span>
<span class="lineNum">    1107 </span>            : {
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         return rotation &amp; (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270));</span>
<span class="lineNum">    1109 </span>            : }
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : void intel_create_rotation_property(struct drm_device *dev,
<span class="lineNum">    1112 </span>            :                                         struct intel_plane *plane);
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            : /* shared dpll functions */
<span class="lineNum">    1115 </span>            : struct intel_shared_dpll *intel_crtc_to_shared_dpll(struct intel_crtc *crtc);
<span class="lineNum">    1116 </span>            : void assert_shared_dpll(struct drm_i915_private *dev_priv,
<span class="lineNum">    1117 </span>            :                         struct intel_shared_dpll *pll,
<span class="lineNum">    1118 </span>            :                         bool state);
<span class="lineNum">    1119 </span>            : #define assert_shared_dpll_enabled(d, p) assert_shared_dpll(d, p, true)
<span class="lineNum">    1120 </span>            : #define assert_shared_dpll_disabled(d, p) assert_shared_dpll(d, p, false)
<span class="lineNum">    1121 </span>            : struct intel_shared_dpll *intel_get_shared_dpll(struct intel_crtc *crtc,
<span class="lineNum">    1122 </span>            :                                                 struct intel_crtc_state *state);
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            : void vlv_force_pll_on(struct drm_device *dev, enum pipe pipe,
<span class="lineNum">    1125 </span>            :                       const struct dpll *dpll);
<span class="lineNum">    1126 </span>            : void vlv_force_pll_off(struct drm_device *dev, enum pipe pipe);
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            : /* modesetting asserts */
<span class="lineNum">    1129 </span>            : void assert_panel_unlocked(struct drm_i915_private *dev_priv,
<span class="lineNum">    1130 </span>            :                            enum pipe pipe);
<span class="lineNum">    1131 </span>            : void assert_pll(struct drm_i915_private *dev_priv,
<span class="lineNum">    1132 </span>            :                 enum pipe pipe, bool state);
<span class="lineNum">    1133 </span>            : #define assert_pll_enabled(d, p) assert_pll(d, p, true)
<span class="lineNum">    1134 </span>            : #define assert_pll_disabled(d, p) assert_pll(d, p, false)
<span class="lineNum">    1135 </span>            : void assert_fdi_rx_pll(struct drm_i915_private *dev_priv,
<span class="lineNum">    1136 </span>            :                        enum pipe pipe, bool state);
<span class="lineNum">    1137 </span>            : #define assert_fdi_rx_pll_enabled(d, p) assert_fdi_rx_pll(d, p, true)
<span class="lineNum">    1138 </span>            : #define assert_fdi_rx_pll_disabled(d, p) assert_fdi_rx_pll(d, p, false)
<span class="lineNum">    1139 </span>            : void assert_pipe(struct drm_i915_private *dev_priv, enum pipe pipe, bool state);
<span class="lineNum">    1140 </span>            : #define assert_pipe_enabled(d, p) assert_pipe(d, p, true)
<span class="lineNum">    1141 </span>            : #define assert_pipe_disabled(d, p) assert_pipe(d, p, false)
<span class="lineNum">    1142 </span>            : unsigned long intel_gen4_compute_page_offset(struct drm_i915_private *dev_priv,
<span class="lineNum">    1143 </span>            :                                              int *x, int *y,
<span class="lineNum">    1144 </span>            :                                              unsigned int tiling_mode,
<span class="lineNum">    1145 </span>            :                                              unsigned int bpp,
<span class="lineNum">    1146 </span>            :                                              unsigned int pitch);
<span class="lineNum">    1147 </span>            : void intel_prepare_reset(struct drm_device *dev);
<span class="lineNum">    1148 </span>            : void intel_finish_reset(struct drm_device *dev);
<span class="lineNum">    1149 </span>            : void hsw_enable_pc8(struct drm_i915_private *dev_priv);
<span class="lineNum">    1150 </span>            : void hsw_disable_pc8(struct drm_i915_private *dev_priv);
<span class="lineNum">    1151 </span>            : void broxton_init_cdclk(struct drm_device *dev);
<span class="lineNum">    1152 </span>            : void broxton_uninit_cdclk(struct drm_device *dev);
<span class="lineNum">    1153 </span>            : void broxton_ddi_phy_init(struct drm_device *dev);
<span class="lineNum">    1154 </span>            : void broxton_ddi_phy_uninit(struct drm_device *dev);
<span class="lineNum">    1155 </span>            : void bxt_enable_dc9(struct drm_i915_private *dev_priv);
<span class="lineNum">    1156 </span>            : void bxt_disable_dc9(struct drm_i915_private *dev_priv);
<span class="lineNum">    1157 </span>            : void skl_init_cdclk(struct drm_i915_private *dev_priv);
<span class="lineNum">    1158 </span>            : void skl_uninit_cdclk(struct drm_i915_private *dev_priv);
<span class="lineNum">    1159 </span>            : void intel_dp_get_m_n(struct intel_crtc *crtc,
<span class="lineNum">    1160 </span>            :                       struct intel_crtc_state *pipe_config);
<span class="lineNum">    1161 </span>            : void intel_dp_set_m_n(struct intel_crtc *crtc, enum link_m_n_set m_n);
<span class="lineNum">    1162 </span>            : int intel_dotclock_calculate(int link_freq, const struct intel_link_m_n *m_n);
<span class="lineNum">    1163 </span>            : void
<span class="lineNum">    1164 </span>            : ironlake_check_encoder_dotclock(const struct intel_crtc_state *pipe_config,
<span class="lineNum">    1165 </span>            :                                 int dotclock);
<span class="lineNum">    1166 </span>            : bool bxt_find_best_dpll(struct intel_crtc_state *crtc_state, int target_clock,
<span class="lineNum">    1167 </span>            :                         intel_clock_t *best_clock);
<span class="lineNum">    1168 </span>            : int chv_calc_dpll_params(int refclk, intel_clock_t *pll_clock);
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            : bool intel_crtc_active(struct drm_crtc *crtc);
<span class="lineNum">    1171 </span>            : void hsw_enable_ips(struct intel_crtc *crtc);
<span class="lineNum">    1172 </span>            : void hsw_disable_ips(struct intel_crtc *crtc);
<span class="lineNum">    1173 </span>            : enum intel_display_power_domain
<span class="lineNum">    1174 </span>            : intel_display_port_power_domain(struct intel_encoder *intel_encoder);
<span class="lineNum">    1175 </span>            : enum intel_display_power_domain
<span class="lineNum">    1176 </span>            : intel_display_port_aux_power_domain(struct intel_encoder *intel_encoder);
<span class="lineNum">    1177 </span>            : void intel_mode_from_pipe_config(struct drm_display_mode *mode,
<span class="lineNum">    1178 </span>            :                                  struct intel_crtc_state *pipe_config);
<span class="lineNum">    1179 </span>            : void intel_crtc_wait_for_pending_flips(struct drm_crtc *crtc);
<span class="lineNum">    1180 </span>            : void intel_modeset_preclose(struct drm_device *dev, struct drm_file *file);
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            : int skl_update_scaler_crtc(struct intel_crtc_state *crtc_state);
<span class="lineNum">    1183 </span>            : int skl_max_scale(struct intel_crtc *crtc, struct intel_crtc_state *crtc_state);
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            : u32 intel_plane_obj_offset(struct intel_plane *intel_plane,
<span class="lineNum">    1186 </span>            :                            struct drm_i915_gem_object *obj,
<span class="lineNum">    1187 </span>            :                            unsigned int plane);
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            : u32 skl_plane_ctl_format(uint32_t pixel_format);
<span class="lineNum">    1190 </span>            : u32 skl_plane_ctl_tiling(uint64_t fb_modifier);
<span class="lineNum">    1191 </span>            : u32 skl_plane_ctl_rotation(unsigned int rotation);
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            : /* intel_csr.c */
<span class="lineNum">    1194 </span>            : void intel_csr_ucode_init(struct drm_device *dev);
<span class="lineNum">    1195 </span>            : enum csr_state intel_csr_load_status_get(struct drm_i915_private *dev_priv);
<span class="lineNum">    1196 </span>            : void intel_csr_load_status_set(struct drm_i915_private *dev_priv,
<span class="lineNum">    1197 </span>            :                                         enum csr_state state);
<span class="lineNum">    1198 </span>            : void intel_csr_load_program(struct drm_device *dev);
<span class="lineNum">    1199 </span>            : void intel_csr_ucode_fini(struct drm_device *dev);
<span class="lineNum">    1200 </span>            : void assert_csr_loaded(struct drm_i915_private *dev_priv);
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            : /* intel_dp.c */
<span class="lineNum">    1203 </span>            : bool intel_dp_init(struct drm_device *dev, int output_reg, enum port port);
<span class="lineNum">    1204 </span>            : bool intel_dp_init_connector(struct intel_digital_port *intel_dig_port,
<span class="lineNum">    1205 </span>            :                              struct intel_connector *intel_connector);
<span class="lineNum">    1206 </span>            : void intel_dp_set_link_params(struct intel_dp *intel_dp,
<span class="lineNum">    1207 </span>            :                               const struct intel_crtc_state *pipe_config);
<span class="lineNum">    1208 </span>            : void intel_dp_start_link_train(struct intel_dp *intel_dp);
<span class="lineNum">    1209 </span>            : void intel_dp_stop_link_train(struct intel_dp *intel_dp);
<span class="lineNum">    1210 </span>            : void intel_dp_sink_dpms(struct intel_dp *intel_dp, int mode);
<span class="lineNum">    1211 </span>            : void intel_dp_encoder_reset(struct drm_encoder *encoder);
<span class="lineNum">    1212 </span>            : void intel_dp_encoder_suspend(struct intel_encoder *intel_encoder);
<span class="lineNum">    1213 </span>            : void intel_dp_encoder_destroy(struct drm_encoder *encoder);
<span class="lineNum">    1214 </span>            : int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc);
<span class="lineNum">    1215 </span>            : bool intel_dp_compute_config(struct intel_encoder *encoder,
<span class="lineNum">    1216 </span>            :                              struct intel_crtc_state *pipe_config);
<span class="lineNum">    1217 </span>            : bool intel_dp_is_edp(struct drm_device *dev, enum port port);
<span class="lineNum">    1218 </span>            : enum irqreturn intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port,
<span class="lineNum">    1219 </span>            :                                   bool long_hpd);
<span class="lineNum">    1220 </span>            : void intel_edp_backlight_on(struct intel_dp *intel_dp);
<span class="lineNum">    1221 </span>            : void intel_edp_backlight_off(struct intel_dp *intel_dp);
<span class="lineNum">    1222 </span>            : void intel_edp_panel_vdd_on(struct intel_dp *intel_dp);
<span class="lineNum">    1223 </span>            : void intel_edp_panel_on(struct intel_dp *intel_dp);
<span class="lineNum">    1224 </span>            : void intel_edp_panel_off(struct intel_dp *intel_dp);
<span class="lineNum">    1225 </span>            : void intel_dp_add_properties(struct intel_dp *intel_dp, struct drm_connector *connector);
<span class="lineNum">    1226 </span>            : void intel_dp_mst_suspend(struct drm_device *dev);
<span class="lineNum">    1227 </span>            : void intel_dp_mst_resume(struct drm_device *dev);
<span class="lineNum">    1228 </span>            : int intel_dp_max_link_rate(struct intel_dp *intel_dp);
<span class="lineNum">    1229 </span>            : int intel_dp_rate_select(struct intel_dp *intel_dp, int rate);
<span class="lineNum">    1230 </span>            : void intel_dp_hot_plug(struct intel_encoder *intel_encoder);
<span class="lineNum">    1231 </span>            : void vlv_power_sequencer_reset(struct drm_i915_private *dev_priv);
<span class="lineNum">    1232 </span>            : uint32_t intel_dp_pack_aux(const uint8_t *src, int src_bytes);
<span class="lineNum">    1233 </span>            : void intel_plane_destroy(struct drm_plane *plane);
<span class="lineNum">    1234 </span>            : void intel_edp_drrs_enable(struct intel_dp *intel_dp);
<span class="lineNum">    1235 </span>            : void intel_edp_drrs_disable(struct intel_dp *intel_dp);
<span class="lineNum">    1236 </span>            : void intel_edp_drrs_invalidate(struct drm_device *dev,
<span class="lineNum">    1237 </span>            :                 unsigned frontbuffer_bits);
<span class="lineNum">    1238 </span>            : void intel_edp_drrs_flush(struct drm_device *dev, unsigned frontbuffer_bits);
<span class="lineNum">    1239 </span>            : void hsw_dp_set_ddi_pll_sel(struct intel_crtc_state *pipe_config);
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : /* intel_dp_mst.c */
<span class="lineNum">    1242 </span>            : int intel_dp_mst_encoder_init(struct intel_digital_port *intel_dig_port, int conn_id);
<span class="lineNum">    1243 </span>            : void intel_dp_mst_encoder_cleanup(struct intel_digital_port *intel_dig_port);
<span class="lineNum">    1244 </span>            : /* intel_dsi.c */
<span class="lineNum">    1245 </span>            : void intel_dsi_init(struct drm_device *dev);
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            : /* intel_dvo.c */
<span class="lineNum">    1249 </span>            : void intel_dvo_init(struct drm_device *dev);
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            : /* legacy fbdev emulation in intel_fbdev.c */
<span class="lineNum">    1253 </span>            : #ifdef CONFIG_DRM_FBDEV_EMULATION
<span class="lineNum">    1254 </span>            : extern int intel_fbdev_init(struct drm_device *dev);
<span class="lineNum">    1255 </span>            : extern void intel_fbdev_initial_config(void *data, async_cookie_t cookie);
<span class="lineNum">    1256 </span>            : extern void intel_fbdev_fini(struct drm_device *dev);
<span class="lineNum">    1257 </span>            : extern void intel_fbdev_set_suspend(struct drm_device *dev, int state, bool synchronous);
<span class="lineNum">    1258 </span>            : extern void intel_fbdev_output_poll_changed(struct drm_device *dev);
<span class="lineNum">    1259 </span>            : extern void intel_fbdev_restore_mode(struct drm_device *dev);
<span class="lineNum">    1260 </span>            : #else
<span class="lineNum">    1261 </span>            : static inline int intel_fbdev_init(struct drm_device *dev)
<span class="lineNum">    1262 </span>            : {
<span class="lineNum">    1263 </span>            :         return 0;
<span class="lineNum">    1264 </span>            : }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            : static inline void intel_fbdev_initial_config(void *data, async_cookie_t cookie)
<span class="lineNum">    1267 </span>            : {
<span class="lineNum">    1268 </span>            : }
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            : static inline void intel_fbdev_fini(struct drm_device *dev)
<span class="lineNum">    1271 </span>            : {
<span class="lineNum">    1272 </span>            : }
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            : static inline void intel_fbdev_set_suspend(struct drm_device *dev, int state, bool synchronous)
<span class="lineNum">    1275 </span>            : {
<span class="lineNum">    1276 </span>            : }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : static inline void intel_fbdev_restore_mode(struct drm_device *dev)
<span class="lineNum">    1279 </span>            : {
<span class="lineNum">    1280 </span>            : }
<span class="lineNum">    1281 </span>            : #endif
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            : /* intel_fbc.c */
<span class="lineNum">    1284 </span>            : bool intel_fbc_enabled(struct drm_i915_private *dev_priv);
<span class="lineNum">    1285 </span>            : void intel_fbc_update(struct drm_i915_private *dev_priv);
<span class="lineNum">    1286 </span>            : void intel_fbc_init(struct drm_i915_private *dev_priv);
<span class="lineNum">    1287 </span>            : void intel_fbc_disable(struct drm_i915_private *dev_priv);
<span class="lineNum">    1288 </span>            : void intel_fbc_disable_crtc(struct intel_crtc *crtc);
<span class="lineNum">    1289 </span>            : void intel_fbc_invalidate(struct drm_i915_private *dev_priv,
<span class="lineNum">    1290 </span>            :                           unsigned int frontbuffer_bits,
<span class="lineNum">    1291 </span>            :                           enum fb_op_origin origin);
<span class="lineNum">    1292 </span>            : void intel_fbc_flush(struct drm_i915_private *dev_priv,
<span class="lineNum">    1293 </span>            :                      unsigned int frontbuffer_bits, enum fb_op_origin origin);
<span class="lineNum">    1294 </span>            : const char *intel_no_fbc_reason_str(enum no_fbc_reason reason);
<span class="lineNum">    1295 </span>            : void intel_fbc_cleanup_cfb(struct drm_i915_private *dev_priv);
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            : /* intel_hdmi.c */
<span class="lineNum">    1298 </span>            : void intel_hdmi_init(struct drm_device *dev, int hdmi_reg, enum port port);
<span class="lineNum">    1299 </span>            : void intel_hdmi_init_connector(struct intel_digital_port *intel_dig_port,
<span class="lineNum">    1300 </span>            :                                struct intel_connector *intel_connector);
<span class="lineNum">    1301 </span>            : struct intel_hdmi *enc_to_intel_hdmi(struct drm_encoder *encoder);
<span class="lineNum">    1302 </span>            : bool intel_hdmi_compute_config(struct intel_encoder *encoder,
<span class="lineNum">    1303 </span>            :                                struct intel_crtc_state *pipe_config);
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            : /* intel_lvds.c */
<span class="lineNum">    1307 </span>            : void intel_lvds_init(struct drm_device *dev);
<span class="lineNum">    1308 </span>            : bool intel_is_dual_link_lvds(struct drm_device *dev);
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            : /* intel_modes.c */
<span class="lineNum">    1312 </span>            : int intel_connector_update_modes(struct drm_connector *connector,
<span class="lineNum">    1313 </span>            :                                  struct edid *edid);
<span class="lineNum">    1314 </span>            : int intel_ddc_get_modes(struct drm_connector *c, struct i2c_adapter *adapter);
<span class="lineNum">    1315 </span>            : void intel_attach_force_audio_property(struct drm_connector *connector);
<span class="lineNum">    1316 </span>            : void intel_attach_broadcast_rgb_property(struct drm_connector *connector);
<span class="lineNum">    1317 </span>            : void intel_attach_aspect_ratio_property(struct drm_connector *connector);
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            : /* intel_overlay.c */
<span class="lineNum">    1321 </span>            : void intel_setup_overlay(struct drm_device *dev);
<span class="lineNum">    1322 </span>            : void intel_cleanup_overlay(struct drm_device *dev);
<span class="lineNum">    1323 </span>            : int intel_overlay_switch_off(struct intel_overlay *overlay);
<span class="lineNum">    1324 </span>            : int intel_overlay_put_image(struct drm_device *dev, void *data,
<span class="lineNum">    1325 </span>            :                             struct drm_file *file_priv);
<span class="lineNum">    1326 </span>            : int intel_overlay_attrs(struct drm_device *dev, void *data,
<span class="lineNum">    1327 </span>            :                         struct drm_file *file_priv);
<span class="lineNum">    1328 </span>            : void intel_overlay_reset(struct drm_i915_private *dev_priv);
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            : /* intel_panel.c */
<span class="lineNum">    1332 </span>            : int intel_panel_init(struct intel_panel *panel,
<span class="lineNum">    1333 </span>            :                      struct drm_display_mode *fixed_mode,
<span class="lineNum">    1334 </span>            :                      struct drm_display_mode *downclock_mode);
<span class="lineNum">    1335 </span>            : void intel_panel_fini(struct intel_panel *panel);
<span class="lineNum">    1336 </span>            : void intel_fixed_panel_mode(const struct drm_display_mode *fixed_mode,
<span class="lineNum">    1337 </span>            :                             struct drm_display_mode *adjusted_mode);
<span class="lineNum">    1338 </span>            : void intel_pch_panel_fitting(struct intel_crtc *crtc,
<span class="lineNum">    1339 </span>            :                              struct intel_crtc_state *pipe_config,
<span class="lineNum">    1340 </span>            :                              int fitting_mode);
<span class="lineNum">    1341 </span>            : void intel_gmch_panel_fitting(struct intel_crtc *crtc,
<span class="lineNum">    1342 </span>            :                               struct intel_crtc_state *pipe_config,
<span class="lineNum">    1343 </span>            :                               int fitting_mode);
<span class="lineNum">    1344 </span>            : void intel_panel_set_backlight_acpi(struct intel_connector *connector,
<span class="lineNum">    1345 </span>            :                                     u32 level, u32 max);
<span class="lineNum">    1346 </span>            : int intel_panel_setup_backlight(struct drm_connector *connector, enum pipe pipe);
<span class="lineNum">    1347 </span>            : void intel_panel_enable_backlight(struct intel_connector *connector);
<span class="lineNum">    1348 </span>            : void intel_panel_disable_backlight(struct intel_connector *connector);
<span class="lineNum">    1349 </span>            : void intel_panel_destroy_backlight(struct drm_connector *connector);
<span class="lineNum">    1350 </span>            : enum drm_connector_status intel_panel_detect(struct drm_device *dev);
<span class="lineNum">    1351 </span>            : extern struct drm_display_mode *intel_find_panel_downclock(
<span class="lineNum">    1352 </span>            :                                 struct drm_device *dev,
<span class="lineNum">    1353 </span>            :                                 struct drm_display_mode *fixed_mode,
<span class="lineNum">    1354 </span>            :                                 struct drm_connector *connector);
<span class="lineNum">    1355 </span>            : void intel_backlight_register(struct drm_device *dev);
<span class="lineNum">    1356 </span>            : void intel_backlight_unregister(struct drm_device *dev);
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : /* intel_psr.c */
<span class="lineNum">    1360 </span>            : void intel_psr_enable(struct intel_dp *intel_dp);
<span class="lineNum">    1361 </span>            : void intel_psr_disable(struct intel_dp *intel_dp);
<span class="lineNum">    1362 </span>            : void intel_psr_invalidate(struct drm_device *dev,
<span class="lineNum">    1363 </span>            :                           unsigned frontbuffer_bits);
<span class="lineNum">    1364 </span>            : void intel_psr_flush(struct drm_device *dev,
<span class="lineNum">    1365 </span>            :                      unsigned frontbuffer_bits,
<span class="lineNum">    1366 </span>            :                      enum fb_op_origin origin);
<span class="lineNum">    1367 </span>            : void intel_psr_init(struct drm_device *dev);
<span class="lineNum">    1368 </span>            : void intel_psr_single_frame_update(struct drm_device *dev,
<span class="lineNum">    1369 </span>            :                                    unsigned frontbuffer_bits);
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            : /* intel_runtime_pm.c */
<span class="lineNum">    1372 </span>            : int intel_power_domains_init(struct drm_i915_private *);
<span class="lineNum">    1373 </span>            : void intel_power_domains_fini(struct drm_i915_private *);
<span class="lineNum">    1374 </span>            : void intel_power_domains_init_hw(struct drm_i915_private *dev_priv);
<span class="lineNum">    1375 </span>            : void intel_runtime_pm_enable(struct drm_i915_private *dev_priv);
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            : bool intel_display_power_is_enabled(struct drm_i915_private *dev_priv,
<span class="lineNum">    1378 </span>            :                                     enum intel_display_power_domain domain);
<span class="lineNum">    1379 </span>            : bool __intel_display_power_is_enabled(struct drm_i915_private *dev_priv,
<span class="lineNum">    1380 </span>            :                                       enum intel_display_power_domain domain);
<span class="lineNum">    1381 </span>            : void intel_display_power_get(struct drm_i915_private *dev_priv,
<span class="lineNum">    1382 </span>            :                              enum intel_display_power_domain domain);
<span class="lineNum">    1383 </span>            : void intel_display_power_put(struct drm_i915_private *dev_priv,
<span class="lineNum">    1384 </span>            :                              enum intel_display_power_domain domain);
<span class="lineNum">    1385 </span>            : void intel_runtime_pm_get(struct drm_i915_private *dev_priv);
<span class="lineNum">    1386 </span>            : void intel_runtime_pm_get_noresume(struct drm_i915_private *dev_priv);
<span class="lineNum">    1387 </span>            : void intel_runtime_pm_put(struct drm_i915_private *dev_priv);
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            : void intel_display_set_init_power(struct drm_i915_private *dev, bool enable);
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : void chv_phy_powergate_lanes(struct intel_encoder *encoder,
<span class="lineNum">    1392 </span>            :                              bool override, unsigned int mask);
<span class="lineNum">    1393 </span>            : bool chv_phy_powergate_ch(struct drm_i915_private *dev_priv, enum dpio_phy phy,
<span class="lineNum">    1394 </span>            :                           enum dpio_channel ch, bool override);
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            : /* intel_pm.c */
<span class="lineNum">    1398 </span>            : void intel_init_clock_gating(struct drm_device *dev);
<span class="lineNum">    1399 </span>            : void intel_suspend_hw(struct drm_device *dev);
<span class="lineNum">    1400 </span>            : int ilk_wm_max_level(const struct drm_device *dev);
<span class="lineNum">    1401 </span>            : void intel_update_watermarks(struct drm_crtc *crtc);
<span class="lineNum">    1402 </span>            : void intel_update_sprite_watermarks(struct drm_plane *plane,
<span class="lineNum">    1403 </span>            :                                     struct drm_crtc *crtc,
<span class="lineNum">    1404 </span>            :                                     uint32_t sprite_width,
<span class="lineNum">    1405 </span>            :                                     uint32_t sprite_height,
<span class="lineNum">    1406 </span>            :                                     int pixel_size,
<span class="lineNum">    1407 </span>            :                                     bool enabled, bool scaled);
<span class="lineNum">    1408 </span>            : void intel_init_pm(struct drm_device *dev);
<span class="lineNum">    1409 </span>            : void intel_pm_setup(struct drm_device *dev);
<span class="lineNum">    1410 </span>            : void intel_gpu_ips_init(struct drm_i915_private *dev_priv);
<span class="lineNum">    1411 </span>            : void intel_gpu_ips_teardown(void);
<span class="lineNum">    1412 </span>            : void intel_init_gt_powersave(struct drm_device *dev);
<span class="lineNum">    1413 </span>            : void intel_cleanup_gt_powersave(struct drm_device *dev);
<span class="lineNum">    1414 </span>            : void intel_enable_gt_powersave(struct drm_device *dev);
<span class="lineNum">    1415 </span>            : void intel_disable_gt_powersave(struct drm_device *dev);
<span class="lineNum">    1416 </span>            : void intel_suspend_gt_powersave(struct drm_device *dev);
<span class="lineNum">    1417 </span>            : void intel_reset_gt_powersave(struct drm_device *dev);
<span class="lineNum">    1418 </span>            : void gen6_update_ring_freq(struct drm_device *dev);
<span class="lineNum">    1419 </span>            : void gen6_rps_busy(struct drm_i915_private *dev_priv);
<span class="lineNum">    1420 </span>            : void gen6_rps_reset_ei(struct drm_i915_private *dev_priv);
<span class="lineNum">    1421 </span>            : void gen6_rps_idle(struct drm_i915_private *dev_priv);
<span class="lineNum">    1422 </span>            : void gen6_rps_boost(struct drm_i915_private *dev_priv,
<span class="lineNum">    1423 </span>            :                     struct intel_rps_client *rps,
<span class="lineNum">    1424 </span>            :                     unsigned long submitted);
<span class="lineNum">    1425 </span>            : void intel_queue_rps_boost_for_request(struct drm_device *dev,
<span class="lineNum">    1426 </span>            :                                        struct drm_i915_gem_request *req);
<span class="lineNum">    1427 </span>            : void vlv_wm_get_hw_state(struct drm_device *dev);
<span class="lineNum">    1428 </span>            : void ilk_wm_get_hw_state(struct drm_device *dev);
<span class="lineNum">    1429 </span>            : void skl_wm_get_hw_state(struct drm_device *dev);
<span class="lineNum">    1430 </span>            : void skl_ddb_get_hw_state(struct drm_i915_private *dev_priv,
<span class="lineNum">    1431 </span>            :                           struct skl_ddb_allocation *ddb /* out */);
<span class="lineNum">    1432 </span>            : uint32_t ilk_pipe_pixel_rate(const struct intel_crtc_state *pipe_config);
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            : /* intel_sdvo.c */
<span class="lineNum">    1435 </span>            : bool intel_sdvo_init(struct drm_device *dev, uint32_t sdvo_reg, bool is_sdvob);
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            : /* intel_sprite.c */
<span class="lineNum">    1439 </span>            : int intel_plane_init(struct drm_device *dev, enum pipe pipe, int plane);
<span class="lineNum">    1440 </span>            : int intel_sprite_set_colorkey(struct drm_device *dev, void *data,
<span class="lineNum">    1441 </span>            :                               struct drm_file *file_priv);
<span class="lineNum">    1442 </span>            : void intel_pipe_update_start(struct intel_crtc *crtc);
<span class="lineNum">    1443 </span>            : void intel_pipe_update_end(struct intel_crtc *crtc);
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            : /* intel_tv.c */
<span class="lineNum">    1446 </span>            : void intel_tv_init(struct drm_device *dev);
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            : /* intel_atomic.c */
<span class="lineNum">    1449 </span>            : int intel_connector_atomic_get_property(struct drm_connector *connector,
<span class="lineNum">    1450 </span>            :                                         const struct drm_connector_state *state,
<span class="lineNum">    1451 </span>            :                                         struct drm_property *property,
<span class="lineNum">    1452 </span>            :                                         uint64_t *val);
<span class="lineNum">    1453 </span>            : struct drm_crtc_state *intel_crtc_duplicate_state(struct drm_crtc *crtc);
<span class="lineNum">    1454 </span>            : void intel_crtc_destroy_state(struct drm_crtc *crtc,
<span class="lineNum">    1455 </span>            :                                struct drm_crtc_state *state);
<span class="lineNum">    1456 </span>            : struct drm_atomic_state *intel_atomic_state_alloc(struct drm_device *dev);
<span class="lineNum">    1457 </span>            : void intel_atomic_state_clear(struct drm_atomic_state *);
<span class="lineNum">    1458 </span>            : struct intel_shared_dpll_config *
<span class="lineNum">    1459 </span>            : intel_atomic_get_shared_dpll_state(struct drm_atomic_state *s);
<a name="1460"><span class="lineNum">    1460 </span>            : </a>
<span class="lineNum">    1461 </span>            : static inline struct intel_crtc_state *
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 : intel_atomic_get_crtc_state(struct drm_atomic_state *state,</span>
<span class="lineNum">    1463 </span>            :                             struct intel_crtc *crtc)
<span class="lineNum">    1464 </span>            : {
<span class="lineNum">    1465 </span>            :         struct drm_crtc_state *crtc_state;
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         crtc_state = drm_atomic_get_crtc_state(state, &amp;crtc-&gt;base);</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :         if (IS_ERR(crtc_state))</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :                 return ERR_CAST(crtc_state);</span>
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :         return to_intel_crtc_state(crtc_state);</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1472 </span>            : int intel_atomic_setup_scalers(struct drm_device *dev,
<span class="lineNum">    1473 </span>            :         struct intel_crtc *intel_crtc,
<span class="lineNum">    1474 </span>            :         struct intel_crtc_state *crtc_state);
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            : /* intel_atomic_plane.c */
<span class="lineNum">    1477 </span>            : struct intel_plane_state *intel_create_plane_state(struct drm_plane *plane);
<span class="lineNum">    1478 </span>            : struct drm_plane_state *intel_plane_duplicate_state(struct drm_plane *plane);
<span class="lineNum">    1479 </span>            : void intel_plane_destroy_state(struct drm_plane *plane,
<span class="lineNum">    1480 </span>            :                                struct drm_plane_state *state);
<span class="lineNum">    1481 </span>            : extern const struct drm_plane_helper_funcs intel_plane_helper_funcs;
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            : #endif /* __INTEL_DRV_H__ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
