<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/i915/intel_lrc.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/i915</a> - intel_lrc.c<span style="font-size: 80%;"> (source / <a href="intel_lrc.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1155</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright Â© 2014 Intel Corporation
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       5 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">       6 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">       7 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">       8 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">       9 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      12 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      13 </span>            :  * Software.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      16 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      17 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      18 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      19 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      20 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
<span class="lineNum">      21 </span>            :  * IN THE SOFTWARE.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * Authors:
<span class="lineNum">      24 </span>            :  *    Ben Widawsky &lt;ben@bwidawsk.net&gt;
<span class="lineNum">      25 </span>            :  *    Michel Thierry &lt;michel.thierry@intel.com&gt;
<span class="lineNum">      26 </span>            :  *    Thomas Daniel &lt;thomas.daniel@intel.com&gt;
<span class="lineNum">      27 </span>            :  *    Oscar Mateo &lt;oscar.mateo@intel.com&gt;
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  */
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : /**
<span class="lineNum">      32 </span>            :  * DOC: Logical Rings, Logical Ring Contexts and Execlists
<span class="lineNum">      33 </span>            :  *
<span class="lineNum">      34 </span>            :  * Motivation:
<span class="lineNum">      35 </span>            :  * GEN8 brings an expansion of the HW contexts: &quot;Logical Ring Contexts&quot;.
<span class="lineNum">      36 </span>            :  * These expanded contexts enable a number of new abilities, especially
<span class="lineNum">      37 </span>            :  * &quot;Execlists&quot; (also implemented in this file).
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * One of the main differences with the legacy HW contexts is that logical
<span class="lineNum">      40 </span>            :  * ring contexts incorporate many more things to the context's state, like
<span class="lineNum">      41 </span>            :  * PDPs or ringbuffer control registers:
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * The reason why PDPs are included in the context is straightforward: as
<span class="lineNum">      44 </span>            :  * PPGTTs (per-process GTTs) are actually per-context, having the PDPs
<span class="lineNum">      45 </span>            :  * contained there mean you don't need to do a ppgtt-&gt;switch_mm yourself,
<span class="lineNum">      46 </span>            :  * instead, the GPU will do it for you on the context switch.
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * But, what about the ringbuffer control registers (head, tail, etc..)?
<span class="lineNum">      49 </span>            :  * shouldn't we just need a set of those per engine command streamer? This is
<span class="lineNum">      50 </span>            :  * where the name &quot;Logical Rings&quot; starts to make sense: by virtualizing the
<span class="lineNum">      51 </span>            :  * rings, the engine cs shifts to a new &quot;ring buffer&quot; with every context
<span class="lineNum">      52 </span>            :  * switch. When you want to submit a workload to the GPU you: A) choose your
<span class="lineNum">      53 </span>            :  * context, B) find its appropriate virtualized ring, C) write commands to it
<span class="lineNum">      54 </span>            :  * and then, finally, D) tell the GPU to switch to that context.
<span class="lineNum">      55 </span>            :  *
<span class="lineNum">      56 </span>            :  * Instead of the legacy MI_SET_CONTEXT, the way you tell the GPU to switch
<span class="lineNum">      57 </span>            :  * to a contexts is via a context execution list, ergo &quot;Execlists&quot;.
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  * LRC implementation:
<span class="lineNum">      60 </span>            :  * Regarding the creation of contexts, we have:
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  * - One global default context.
<span class="lineNum">      63 </span>            :  * - One local default context for each opened fd.
<span class="lineNum">      64 </span>            :  * - One local extra context for each context create ioctl call.
<span class="lineNum">      65 </span>            :  *
<span class="lineNum">      66 </span>            :  * Now that ringbuffers belong per-context (and not per-engine, like before)
<span class="lineNum">      67 </span>            :  * and that contexts are uniquely tied to a given engine (and not reusable,
<span class="lineNum">      68 </span>            :  * like before) we need:
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * - One ringbuffer per-engine inside each context.
<span class="lineNum">      71 </span>            :  * - One backing object per-engine inside each context.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * The global default context starts its life with these new objects fully
<span class="lineNum">      74 </span>            :  * allocated and populated. The local default context for each opened fd is
<span class="lineNum">      75 </span>            :  * more complex, because we don't know at creation time which engine is going
<span class="lineNum">      76 </span>            :  * to use them. To handle this, we have implemented a deferred creation of LR
<span class="lineNum">      77 </span>            :  * contexts:
<span class="lineNum">      78 </span>            :  *
<span class="lineNum">      79 </span>            :  * The local context starts its life as a hollow or blank holder, that only
<span class="lineNum">      80 </span>            :  * gets populated for a given engine once we receive an execbuffer. If later
<span class="lineNum">      81 </span>            :  * on we receive another execbuffer ioctl for the same context but a different
<span class="lineNum">      82 </span>            :  * engine, we allocate/populate a new ringbuffer and context backing object and
<span class="lineNum">      83 </span>            :  * so on.
<span class="lineNum">      84 </span>            :  *
<span class="lineNum">      85 </span>            :  * Finally, regarding local contexts created using the ioctl call: as they are
<span class="lineNum">      86 </span>            :  * only allowed with the render ring, we can allocate &amp; populate them right
<span class="lineNum">      87 </span>            :  * away (no need to defer anything, at least for now).
<span class="lineNum">      88 </span>            :  *
<span class="lineNum">      89 </span>            :  * Execlists implementation:
<span class="lineNum">      90 </span>            :  * Execlists are the new method by which, on gen8+ hardware, workloads are
<span class="lineNum">      91 </span>            :  * submitted for execution (as opposed to the legacy, ringbuffer-based, method).
<span class="lineNum">      92 </span>            :  * This method works as follows:
<span class="lineNum">      93 </span>            :  *
<span class="lineNum">      94 </span>            :  * When a request is committed, its commands (the BB start and any leading or
<span class="lineNum">      95 </span>            :  * trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer
<span class="lineNum">      96 </span>            :  * for the appropriate context. The tail pointer in the hardware context is not
<span class="lineNum">      97 </span>            :  * updated at this time, but instead, kept by the driver in the ringbuffer
<span class="lineNum">      98 </span>            :  * structure. A structure representing this request is added to a request queue
<span class="lineNum">      99 </span>            :  * for the appropriate engine: this structure contains a copy of the context's
<span class="lineNum">     100 </span>            :  * tail after the request was written to the ring buffer and a pointer to the
<span class="lineNum">     101 </span>            :  * context itself.
<span class="lineNum">     102 </span>            :  *
<span class="lineNum">     103 </span>            :  * If the engine's request queue was empty before the request was added, the
<span class="lineNum">     104 </span>            :  * queue is processed immediately. Otherwise the queue will be processed during
<span class="lineNum">     105 </span>            :  * a context switch interrupt. In any case, elements on the queue will get sent
<span class="lineNum">     106 </span>            :  * (in pairs) to the GPU's ExecLists Submit Port (ELSP, for short) with a
<span class="lineNum">     107 </span>            :  * globally unique 20-bits submission ID.
<span class="lineNum">     108 </span>            :  *
<span class="lineNum">     109 </span>            :  * When execution of a request completes, the GPU updates the context status
<span class="lineNum">     110 </span>            :  * buffer with a context complete event and generates a context switch interrupt.
<span class="lineNum">     111 </span>            :  * During the interrupt handling, the driver examines the events in the buffer:
<span class="lineNum">     112 </span>            :  * for each context complete event, if the announced ID matches that on the head
<span class="lineNum">     113 </span>            :  * of the request queue, then that request is retired and removed from the queue.
<span class="lineNum">     114 </span>            :  *
<span class="lineNum">     115 </span>            :  * After processing, if any requests were retired and the queue is not empty
<span class="lineNum">     116 </span>            :  * then a new execution list can be submitted. The two requests at the front of
<span class="lineNum">     117 </span>            :  * the queue are next to be submitted but since a context may not occur twice in
<span class="lineNum">     118 </span>            :  * an execution list, if subsequent requests have the same ID as the first then
<span class="lineNum">     119 </span>            :  * the two requests must be combined. This is done simply by discarding requests
<span class="lineNum">     120 </span>            :  * at the head of the queue until either only one requests is left (in which case
<span class="lineNum">     121 </span>            :  * we use a NULL second context) or the first two requests have unique IDs.
<span class="lineNum">     122 </span>            :  *
<span class="lineNum">     123 </span>            :  * By always executing the first two requests in the queue the driver ensures
<span class="lineNum">     124 </span>            :  * that the GPU is kept as busy as possible. In the case where a single context
<span class="lineNum">     125 </span>            :  * completes but a second context is still executing, the request for this second
<span class="lineNum">     126 </span>            :  * context will be at the head of the queue when we remove the first one. This
<span class="lineNum">     127 </span>            :  * request will then be resubmitted along with a new request for a different context,
<span class="lineNum">     128 </span>            :  * which will cause the hardware to continue executing the second request and queue
<span class="lineNum">     129 </span>            :  * the new request (the GPU detects the condition of a context getting preempted
<span class="lineNum">     130 </span>            :  * with the same context and optimizes the context switch flow by not doing
<span class="lineNum">     131 </span>            :  * preemption, but just sampling the new tail pointer).
<span class="lineNum">     132 </span>            :  *
<span class="lineNum">     133 </span>            :  */
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : #include &lt;dev/pci/drm/drmP.h&gt;
<span class="lineNum">     136 </span>            : #include &lt;dev/pci/drm/i915_drm.h&gt;
<span class="lineNum">     137 </span>            : #include &quot;i915_drv.h&quot;
<span class="lineNum">     138 </span>            : #include &quot;intel_mocs.h&quot;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : #define GEN9_LR_CONTEXT_RENDER_SIZE (22 * PAGE_SIZE)
<span class="lineNum">     141 </span>            : #define GEN8_LR_CONTEXT_RENDER_SIZE (20 * PAGE_SIZE)
<span class="lineNum">     142 </span>            : #define GEN8_LR_CONTEXT_OTHER_SIZE (2 * PAGE_SIZE)
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : #define RING_EXECLIST_QFULL             (1 &lt;&lt; 0x2)
<span class="lineNum">     145 </span>            : #define RING_EXECLIST1_VALID            (1 &lt;&lt; 0x3)
<span class="lineNum">     146 </span>            : #define RING_EXECLIST0_VALID            (1 &lt;&lt; 0x4)
<span class="lineNum">     147 </span>            : #define RING_EXECLIST_ACTIVE_STATUS     (3 &lt;&lt; 0xE)
<span class="lineNum">     148 </span>            : #define RING_EXECLIST1_ACTIVE           (1 &lt;&lt; 0x11)
<span class="lineNum">     149 </span>            : #define RING_EXECLIST0_ACTIVE           (1 &lt;&lt; 0x12)
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : #define GEN8_CTX_STATUS_IDLE_ACTIVE     (1 &lt;&lt; 0)
<span class="lineNum">     152 </span>            : #define GEN8_CTX_STATUS_PREEMPTED       (1 &lt;&lt; 1)
<span class="lineNum">     153 </span>            : #define GEN8_CTX_STATUS_ELEMENT_SWITCH  (1 &lt;&lt; 2)
<span class="lineNum">     154 </span>            : #define GEN8_CTX_STATUS_ACTIVE_IDLE     (1 &lt;&lt; 3)
<span class="lineNum">     155 </span>            : #define GEN8_CTX_STATUS_COMPLETE        (1 &lt;&lt; 4)
<span class="lineNum">     156 </span>            : #define GEN8_CTX_STATUS_LITE_RESTORE    (1 &lt;&lt; 15)
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : #define CTX_LRI_HEADER_0                0x01
<span class="lineNum">     159 </span>            : #define CTX_CONTEXT_CONTROL             0x02
<span class="lineNum">     160 </span>            : #define CTX_RING_HEAD                   0x04
<span class="lineNum">     161 </span>            : #define CTX_RING_TAIL                   0x06
<span class="lineNum">     162 </span>            : #define CTX_RING_BUFFER_START           0x08
<span class="lineNum">     163 </span>            : #define CTX_RING_BUFFER_CONTROL         0x0a
<span class="lineNum">     164 </span>            : #define CTX_BB_HEAD_U                   0x0c
<span class="lineNum">     165 </span>            : #define CTX_BB_HEAD_L                   0x0e
<span class="lineNum">     166 </span>            : #define CTX_BB_STATE                    0x10
<span class="lineNum">     167 </span>            : #define CTX_SECOND_BB_HEAD_U            0x12
<span class="lineNum">     168 </span>            : #define CTX_SECOND_BB_HEAD_L            0x14
<span class="lineNum">     169 </span>            : #define CTX_SECOND_BB_STATE             0x16
<span class="lineNum">     170 </span>            : #define CTX_BB_PER_CTX_PTR              0x18
<span class="lineNum">     171 </span>            : #define CTX_RCS_INDIRECT_CTX            0x1a
<span class="lineNum">     172 </span>            : #define CTX_RCS_INDIRECT_CTX_OFFSET     0x1c
<span class="lineNum">     173 </span>            : #define CTX_LRI_HEADER_1                0x21
<span class="lineNum">     174 </span>            : #define CTX_CTX_TIMESTAMP               0x22
<span class="lineNum">     175 </span>            : #define CTX_PDP3_UDW                    0x24
<span class="lineNum">     176 </span>            : #define CTX_PDP3_LDW                    0x26
<span class="lineNum">     177 </span>            : #define CTX_PDP2_UDW                    0x28
<span class="lineNum">     178 </span>            : #define CTX_PDP2_LDW                    0x2a
<span class="lineNum">     179 </span>            : #define CTX_PDP1_UDW                    0x2c
<span class="lineNum">     180 </span>            : #define CTX_PDP1_LDW                    0x2e
<span class="lineNum">     181 </span>            : #define CTX_PDP0_UDW                    0x30
<span class="lineNum">     182 </span>            : #define CTX_PDP0_LDW                    0x32
<span class="lineNum">     183 </span>            : #define CTX_LRI_HEADER_2                0x41
<span class="lineNum">     184 </span>            : #define CTX_R_PWR_CLK_STATE             0x42
<span class="lineNum">     185 </span>            : #define CTX_GPGPU_CSR_BASE_ADDRESS      0x44
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : #define GEN8_CTX_VALID (1&lt;&lt;0)
<span class="lineNum">     188 </span>            : #define GEN8_CTX_FORCE_PD_RESTORE (1&lt;&lt;1)
<span class="lineNum">     189 </span>            : #define GEN8_CTX_FORCE_RESTORE (1&lt;&lt;2)
<span class="lineNum">     190 </span>            : #define GEN8_CTX_L3LLC_COHERENT (1&lt;&lt;5)
<span class="lineNum">     191 </span>            : #define GEN8_CTX_PRIVILEGE (1&lt;&lt;8)
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : #define ASSIGN_CTX_PDP(ppgtt, reg_state, n) { \
<span class="lineNum">     194 </span>            :         const u64 _addr = i915_page_dir_dma_addr((ppgtt), (n)); \
<span class="lineNum">     195 </span>            :         reg_state[CTX_PDP ## n ## _UDW+1] = upper_32_bits(_addr); \
<span class="lineNum">     196 </span>            :         reg_state[CTX_PDP ## n ## _LDW+1] = lower_32_bits(_addr); \
<span class="lineNum">     197 </span>            : }
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : #define ASSIGN_CTX_PML4(ppgtt, reg_state) { \
<span class="lineNum">     200 </span>            :         reg_state[CTX_PDP0_UDW + 1] = upper_32_bits(px_dma(&amp;ppgtt-&gt;pml4)); \
<span class="lineNum">     201 </span>            :         reg_state[CTX_PDP0_LDW + 1] = lower_32_bits(px_dma(&amp;ppgtt-&gt;pml4)); \
<span class="lineNum">     202 </span>            : }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : enum {
<span class="lineNum">     205 </span>            :         ADVANCED_CONTEXT = 0,
<span class="lineNum">     206 </span>            :         LEGACY_32B_CONTEXT,
<span class="lineNum">     207 </span>            :         ADVANCED_AD_CONTEXT,
<span class="lineNum">     208 </span>            :         LEGACY_64B_CONTEXT
<span class="lineNum">     209 </span>            : };
<span class="lineNum">     210 </span>            : #define GEN8_CTX_ADDRESSING_MODE_SHIFT 3
<span class="lineNum">     211 </span>            : #define GEN8_CTX_ADDRESSING_MODE(dev)  (USES_FULL_48BIT_PPGTT(dev) ?\
<span class="lineNum">     212 </span>            :                 LEGACY_64B_CONTEXT :\
<span class="lineNum">     213 </span>            :                 LEGACY_32B_CONTEXT)
<span class="lineNum">     214 </span>            : enum {
<span class="lineNum">     215 </span>            :         FAULT_AND_HANG = 0,
<span class="lineNum">     216 </span>            :         FAULT_AND_HALT, /* Debug only */
<span class="lineNum">     217 </span>            :         FAULT_AND_STREAM,
<span class="lineNum">     218 </span>            :         FAULT_AND_CONTINUE /* Unsupported */
<span class="lineNum">     219 </span>            : };
<span class="lineNum">     220 </span>            : #define GEN8_CTX_ID_SHIFT 32
<span class="lineNum">     221 </span>            : #define CTX_RCS_INDIRECT_CTX_OFFSET_DEFAULT  0x17
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : static int intel_lr_context_pin(struct drm_i915_gem_request *rq);
<span class="lineNum">     224 </span>            : static void lrc_setup_hardware_status_page(struct intel_engine_cs *ring,
<span class="lineNum">     225 </span>            :                 struct drm_i915_gem_object *default_ctx_obj);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : /**
<span class="lineNum">     229 </span>            :  * intel_sanitize_enable_execlists() - sanitize i915.enable_execlists
<span class="lineNum">     230 </span>            :  * @dev: DRM device.
<span class="lineNum">     231 </span>            :  * @enable_execlists: value of i915.enable_execlists module parameter.
<span class="lineNum">     232 </span>            :  *
<span class="lineNum">     233 </span>            :  * Only certain platforms support Execlists (the prerequisites being
<span class="lineNum">     234 </span>            :  * support for Logical Ring Contexts and Aliasing PPGTT or better).
<span class="lineNum">     235 </span>            :  *
<a name="236"><span class="lineNum">     236 </span>            :  * Return: 1 if Execlists is supported and has to be enabled.</a>
<span class="lineNum">     237 </span>            :  */
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : int intel_sanitize_enable_execlists(struct drm_device *dev, int enable_execlists)</span>
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         WARN_ON(i915.enable_ppgtt == -1);</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :         /* On platforms with execlist available, vGPU will only
<span class="lineNum">     243 </span>            :          * support execlist mode, no ring buffer mode.
<span class="lineNum">     244 </span>            :          */
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         if (HAS_LOGICAL_RING_CONTEXTS(dev) &amp;&amp; intel_vgpu_active(dev))</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(dev)-&gt;gen &gt;= 9)</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         if (enable_execlists == 0)</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         if (HAS_LOGICAL_RING_CONTEXTS(dev) &amp;&amp; USES_PPGTT(dev) &amp;&amp;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             i915.use_mmio_flip &gt;= 0)</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : /**
<span class="lineNum">     262 </span>            :  * intel_execlists_ctx_id() - get the Execlists Context ID
<span class="lineNum">     263 </span>            :  * @ctx_obj: Logical Ring Context backing object.
<span class="lineNum">     264 </span>            :  *
<span class="lineNum">     265 </span>            :  * Do not confuse with ctx-&gt;id! Unfortunately we have a name overload
<span class="lineNum">     266 </span>            :  * here: the old context ID we pass to userspace as a handler so that
<span class="lineNum">     267 </span>            :  * they can refer to a context, and the new context ID we pass to the
<span class="lineNum">     268 </span>            :  * ELSP so that the GPU can inform us of the context status via
<span class="lineNum">     269 </span>            :  * interrupts.
<span class="lineNum">     270 </span>            :  *
<a name="271"><span class="lineNum">     271 </span>            :  * Return: 20-bits globally unique context ID.</a>
<span class="lineNum">     272 </span>            :  */
<span class="lineNum">     273 </span><span class="lineNoCov">          0 : u32 intel_execlists_ctx_id(struct drm_i915_gem_object *ctx_obj)</span>
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         u32 lrca = i915_gem_obj_ggtt_offset(ctx_obj) +</span>
<span class="lineNum">     276 </span>            :                         LRC_PPHWSP_PN * PAGE_SIZE;
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :         /* LRCA is required to be 4K aligned so the more significant 20 bits
<span class="lineNum">     279 </span>            :          * are globally unique */
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         return lrca &gt;&gt; 12;</span>
<a name="281"><span class="lineNum">     281 </span>            : }</a>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 : static bool disable_lite_restore_wa(struct intel_engine_cs *ring)</span>
<span class="lineNum">     284 </span>            : {
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         return (IS_SKL_REVID(dev, 0, SKL_REVID_B0) ||</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 IS_BXT_REVID(dev, 0, BXT_REVID_A0)) &amp;&amp;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                (ring-&gt;id == VCS || ring-&gt;id == VCS2);</span>
<a name="290"><span class="lineNum">     290 </span>            : }</a>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 : uint64_t intel_lr_context_descriptor(struct intel_context *ctx,</span>
<span class="lineNum">     293 </span>            :                                      struct intel_engine_cs *ring)
<span class="lineNum">     294 </span>            : {
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         struct drm_i915_gem_object *ctx_obj = ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">     296 </span>            :         uint64_t desc;
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         uint64_t lrca = i915_gem_obj_ggtt_offset(ctx_obj) +</span>
<span class="lineNum">     298 </span>            :                         LRC_PPHWSP_PN * PAGE_SIZE;
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         WARN_ON(lrca &amp; 0xFFFFFFFF00000FFFULL);</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :         desc = GEN8_CTX_VALID;
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         desc |= GEN8_CTX_ADDRESSING_MODE(dev) &lt;&lt; GEN8_CTX_ADDRESSING_MODE_SHIFT;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         if (IS_GEN8(ctx_obj-&gt;base.dev))</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                 desc |= GEN8_CTX_L3LLC_COHERENT;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         desc |= GEN8_CTX_PRIVILEGE;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         desc |= lrca;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         desc |= (u64)intel_execlists_ctx_id(ctx_obj) &lt;&lt; GEN8_CTX_ID_SHIFT;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :         /* TODO: WaDisableLiteRestore when we start using semaphore
<span class="lineNum">     311 </span>            :          * signalling between Command Streamers */
<span class="lineNum">     312 </span>            :         /* desc |= GEN8_CTX_FORCE_RESTORE; */
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :         /* WaEnableForceRestoreInCtxtDescForVCS:skl */
<span class="lineNum">     315 </span>            :         /* WaEnableForceRestoreInCtxtDescForVCS:bxt */
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         if (disable_lite_restore_wa(ring))</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                 desc |= GEN8_CTX_FORCE_RESTORE;</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         return desc;</span>
<a name="320"><span class="lineNum">     320 </span>            : }</a>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 : static void execlists_elsp_write(struct drm_i915_gem_request *rq0,</span>
<span class="lineNum">     323 </span>            :                                  struct drm_i915_gem_request *rq1)
<span class="lineNum">     324 </span>            : {
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = rq0-&gt;ring;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     329 </span>            :         uint64_t desc[2];
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         if (rq1) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                 desc[1] = intel_lr_context_descriptor(rq1-&gt;ctx, rq1-&gt;ring);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                 rq1-&gt;elsp_submitted++;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     335 </span>            :                 desc[1] = 0;
<span class="lineNum">     336 </span>            :         }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         desc[0] = intel_lr_context_descriptor(rq0-&gt;ctx, rq0-&gt;ring);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         rq0-&gt;elsp_submitted++;</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :         /* You must always write both descriptors in the order below. */
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         spin_lock(&amp;dev_priv-&gt;uncore.lock);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         intel_uncore_forcewake_get__locked(dev_priv, FORCEWAKE_ALL);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         I915_WRITE_FW(RING_ELSP(ring), upper_32_bits(desc[1]));</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         I915_WRITE_FW(RING_ELSP(ring), lower_32_bits(desc[1]));</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :         I915_WRITE_FW(RING_ELSP(ring), upper_32_bits(desc[0]));</span>
<span class="lineNum">     348 </span>            :         /* The context is automatically loaded after the following */
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         I915_WRITE_FW(RING_ELSP(ring), lower_32_bits(desc[0]));</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :         /* ELSP is a wo register, use another nearby reg for posting */
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         POSTING_READ_FW(RING_EXECLIST_STATUS_LO(ring));</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         intel_uncore_forcewake_put__locked(dev_priv, FORCEWAKE_ALL);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         spin_unlock(&amp;dev_priv-&gt;uncore.lock);</span>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 : static int execlists_update_context(struct drm_i915_gem_request *rq)</span>
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = rq-&gt;ring;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         struct i915_hw_ppgtt *ppgtt = rq-&gt;ctx-&gt;ppgtt;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         struct drm_i915_gem_object *ctx_obj = rq-&gt;ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         struct drm_i915_gem_object *rb_obj = rq-&gt;ringbuf-&gt;obj;</span>
<span class="lineNum">     363 </span>            :         struct vm_page *page;
<span class="lineNum">     364 </span>            :         uint32_t *reg_state;
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         BUG_ON(!ctx_obj);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         WARN_ON(!i915_gem_obj_is_pinned(ctx_obj));</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         WARN_ON(!i915_gem_obj_is_pinned(rb_obj));</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         page = i915_gem_object_get_page(ctx_obj, LRC_STATE_PN);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         reg_state = kmap_atomic(page);</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_TAIL+1] = rq-&gt;tail;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_BUFFER_START+1] = i915_gem_obj_ggtt_offset(rb_obj);</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         if (ppgtt &amp;&amp; !USES_FULL_48BIT_PPGTT(ppgtt-&gt;base.dev)) {</span>
<span class="lineNum">     377 </span>            :                 /* True 32b PPGTT with dynamic page allocation: update PDP
<span class="lineNum">     378 </span>            :                  * registers and point the unallocated PDPs to scratch page.
<span class="lineNum">     379 </span>            :                  * PML4 is allocated during ppgtt init, so this is not needed
<span class="lineNum">     380 </span>            :                  * in 48-bit mode.
<span class="lineNum">     381 </span>            :                  */
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 3);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 2);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 1);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 0);</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         kunmap_atomic(reg_state);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="391"><span class="lineNum">     391 </span>            : }</a>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineNoCov">          0 : static void execlists_submit_requests(struct drm_i915_gem_request *rq0,</span>
<span class="lineNum">     394 </span>            :                                       struct drm_i915_gem_request *rq1)
<span class="lineNum">     395 </span>            : {
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         execlists_update_context(rq0);</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         if (rq1)</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                 execlists_update_context(rq1);</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         execlists_elsp_write(rq0, rq1);</span>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 : static void execlists_context_unqueue(struct intel_engine_cs *ring)</span>
<span class="lineNum">     405 </span>            : {
<span class="lineNum">     406 </span>            :         struct drm_i915_gem_request *req0 = NULL, *req1 = NULL;
<span class="lineNum">     407 </span>            :         struct drm_i915_gem_request *cursor = NULL, *tmp = NULL;
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         assert_spin_locked(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :         /*
<span class="lineNum">     412 </span>            :          * If irqs are not active generate a warning as batches that finish
<span class="lineNum">     413 </span>            :          * without the irqs may get lost and a GPU Hang may occur.
<span class="lineNum">     414 </span>            :          */
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         WARN_ON(!intel_irqs_enabled(ring-&gt;dev-&gt;dev_private));</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         if (list_empty(&amp;ring-&gt;execlist_queue))</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :         /* Try to read in pairs */
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         list_for_each_entry_safe(cursor, tmp, &amp;ring-&gt;execlist_queue,</span>
<span class="lineNum">     422 </span>            :                                  execlist_link) {
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                 if (!req0) {</span>
<span class="lineNum">     424 </span>            :                         req0 = cursor;
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :                 } else if (req0-&gt;ctx == cursor-&gt;ctx) {</span>
<span class="lineNum">     426 </span>            :                         /* Same ctx: ignore first request, as second request
<span class="lineNum">     427 </span>            :                          * will update tail past first request's workload */
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                         cursor-&gt;elsp_submitted = req0-&gt;elsp_submitted;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                         list_del(&amp;req0-&gt;execlist_link);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                         list_add_tail(&amp;req0-&gt;execlist_link,</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                                 &amp;ring-&gt;execlist_retired_req_list);</span>
<span class="lineNum">     432 </span>            :                         req0 = cursor;
<span class="lineNum">     433 </span>            :                 } else {
<span class="lineNum">     434 </span>            :                         req1 = cursor;
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     436 </span>            :                 }
<span class="lineNum">     437 </span>            :         }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         if (IS_GEN8(ring-&gt;dev) || IS_GEN9(ring-&gt;dev)) {</span>
<span class="lineNum">     440 </span>            :                 /*
<span class="lineNum">     441 </span>            :                  * WaIdleLiteRestore: make sure we never cause a lite
<span class="lineNum">     442 </span>            :                  * restore with HEAD==TAIL
<span class="lineNum">     443 </span>            :                  */
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                 if (req0-&gt;elsp_submitted) {</span>
<span class="lineNum">     445 </span>            :                         /*
<span class="lineNum">     446 </span>            :                          * Apply the wa NOOPS to prevent ring:HEAD == req:TAIL
<span class="lineNum">     447 </span>            :                          * as we resubmit the request. See gen8_emit_request()
<span class="lineNum">     448 </span>            :                          * for where we prepare the padding after the end of the
<span class="lineNum">     449 </span>            :                          * request.
<span class="lineNum">     450 </span>            :                          */
<span class="lineNum">     451 </span>            :                         struct intel_ringbuffer *ringbuf;
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                         ringbuf = req0-&gt;ctx-&gt;engine[ring-&gt;id].ringbuf;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                         req0-&gt;tail += 8;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                         req0-&gt;tail &amp;= ringbuf-&gt;size - 1;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     457 </span>            :         }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         WARN_ON(req1 &amp;&amp; req1-&gt;elsp_submitted);</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         execlists_submit_requests(req0, req1);</span>
<a name="462"><span class="lineNum">     462 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineNoCov">          0 : static bool execlists_check_remove_request(struct intel_engine_cs *ring,</span>
<span class="lineNum">     465 </span>            :                                            u32 request_id)
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span>            :         struct drm_i915_gem_request *head_req;
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         assert_spin_locked(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         head_req = list_first_entry_or_null(&amp;ring-&gt;execlist_queue,</span>
<span class="lineNum">     472 </span>            :                                             struct drm_i915_gem_request,
<span class="lineNum">     473 </span>            :                                             execlist_link);
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         if (head_req != NULL) {</span>
<span class="lineNum">     476 </span>            :                 struct drm_i915_gem_object *ctx_obj =
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                                 head_req-&gt;ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                 if (intel_execlists_ctx_id(ctx_obj) == request_id) {</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                         WARN(head_req-&gt;elsp_submitted == 0,</span>
<span class="lineNum">     480 </span>            :                              &quot;Never submitted head request\n&quot;);
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                         if (--head_req-&gt;elsp_submitted &lt;= 0) {</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                                 list_del(&amp;head_req-&gt;execlist_link);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                                 list_add_tail(&amp;head_req-&gt;execlist_link,</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                                         &amp;ring-&gt;execlist_retired_req_list);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                                 return true;</span>
<span class="lineNum">     487 </span>            :                         }
<span class="lineNum">     488 </span>            :                 }
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : /**
<span class="lineNum">     495 </span>            :  * intel_lrc_irq_handler() - handle Context Switch interrupts
<span class="lineNum">     496 </span>            :  * @ring: Engine Command Streamer to handle.
<span class="lineNum">     497 </span>            :  *
<span class="lineNum">     498 </span>            :  * Check the unread Context Status Buffers and manage the submission of new
<a name="499"><span class="lineNum">     499 </span>            :  * contexts to the ELSP accordingly.</a>
<span class="lineNum">     500 </span>            :  */
<span class="lineNum">     501 </span><span class="lineNoCov">          0 : void intel_lrc_irq_handler(struct intel_engine_cs *ring)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = ring-&gt;dev-&gt;dev_private;</span>
<span class="lineNum">     504 </span>            :         u32 status_pointer;
<span class="lineNum">     505 </span>            :         u8 read_pointer;
<span class="lineNum">     506 </span>            :         u8 write_pointer;
<span class="lineNum">     507 </span>            :         u32 status = 0;
<span class="lineNum">     508 </span>            :         u32 status_id;
<span class="lineNum">     509 </span>            :         u32 submit_contexts = 0;
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         status_pointer = I915_READ(RING_CONTEXT_STATUS_PTR(ring));</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         read_pointer = ring-&gt;next_context_status_buffer;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         write_pointer = status_pointer &amp; GEN8_CSB_PTR_MASK;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         if (read_pointer &gt; write_pointer)</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                 write_pointer += GEN8_CSB_ENTRIES;</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         spin_lock(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         while (read_pointer &lt; write_pointer) {</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                 read_pointer++;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                 status = I915_READ(RING_CONTEXT_STATUS_BUF_LO(ring, read_pointer % GEN8_CSB_ENTRIES));</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                 status_id = I915_READ(RING_CONTEXT_STATUS_BUF_HI(ring, read_pointer % GEN8_CSB_ENTRIES));</span>
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                 if (status &amp; GEN8_CTX_STATUS_IDLE_ACTIVE)</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 if (status &amp; GEN8_CTX_STATUS_PREEMPTED) {</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                         if (status &amp; GEN8_CTX_STATUS_LITE_RESTORE) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                                 if (execlists_check_remove_request(ring, status_id))</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                                         WARN(1, &quot;Lite Restored request removed from queue\n&quot;);</span>
<span class="lineNum">     532 </span>            :                         } else
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                                 WARN(1, &quot;Preemption without Lite Restore\n&quot;);</span>
<span class="lineNum">     534 </span>            :                 }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                  if ((status &amp; GEN8_CTX_STATUS_ACTIVE_IDLE) ||</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                      (status &amp; GEN8_CTX_STATUS_ELEMENT_SWITCH)) {</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :                         if (execlists_check_remove_request(ring, status_id))</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                                 submit_contexts++;</span>
<span class="lineNum">     540 </span>            :                 }
<span class="lineNum">     541 </span>            :         }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         if (disable_lite_restore_wa(ring)) {</span>
<span class="lineNum">     544 </span>            :                 /* Prevent a ctx to preempt itself */
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 if ((status &amp; GEN8_CTX_STATUS_ACTIVE_IDLE) &amp;&amp;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                     (submit_contexts != 0))</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                         execlists_context_unqueue(ring);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         } else if (submit_contexts != 0) {</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                 execlists_context_unqueue(ring);</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         spin_unlock(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         WARN(submit_contexts &gt; 2, &quot;More than two context complete events?\n&quot;);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         ring-&gt;next_context_status_buffer = write_pointer % GEN8_CSB_ENTRIES;</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         I915_WRITE(RING_CONTEXT_STATUS_PTR(ring),</span>
<span class="lineNum">     558 </span>            :                    _MASKED_FIELD(GEN8_CSB_PTR_MASK &lt;&lt; 8,
<span class="lineNum">     559 </span>            :                                  ((u32)ring-&gt;next_context_status_buffer &amp;
<span class="lineNum">     560 </span>            :                                   GEN8_CSB_PTR_MASK) &lt;&lt; 8));
<a name="561"><span class="lineNum">     561 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : static int execlists_context_queue(struct drm_i915_gem_request *request)</span>
<span class="lineNum">     564 </span>            : {
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = request-&gt;ring;</span>
<span class="lineNum">     566 </span>            :         struct drm_i915_gem_request *cursor;
<span class="lineNum">     567 </span>            :         int num_elements = 0;
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         if (request-&gt;ctx != ring-&gt;default_context)</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                 intel_lr_context_pin(request);</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         i915_gem_request_reference(request);</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         spin_lock_irq(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         list_for_each_entry(cursor, &amp;ring-&gt;execlist_queue, execlist_link)</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :                 if (++num_elements &gt; 2)</span>
<span class="lineNum">     578 </span>            :                         break;
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         if (num_elements &gt; 2) {</span>
<span class="lineNum">     581 </span>            :                 struct drm_i915_gem_request *tail_req;
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                 tail_req = list_last_entry(&amp;ring-&gt;execlist_queue,</span>
<span class="lineNum">     584 </span>            :                                            struct drm_i915_gem_request,
<span class="lineNum">     585 </span>            :                                            execlist_link);
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 if (request-&gt;ctx == tail_req-&gt;ctx) {</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                         WARN(tail_req-&gt;elsp_submitted != 0,</span>
<span class="lineNum">     589 </span>            :                                 &quot;More than 2 already-submitted reqs queued\n&quot;);
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                         list_del(&amp;tail_req-&gt;execlist_link);</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                         list_add_tail(&amp;tail_req-&gt;execlist_link,</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                                 &amp;ring-&gt;execlist_retired_req_list);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         list_add_tail(&amp;request-&gt;execlist_link, &amp;ring-&gt;execlist_queue);</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         if (num_elements == 0)</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                 execlists_context_unqueue(ring);</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         spin_unlock_irq(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="603"><span class="lineNum">     603 </span>            : }</a>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineNoCov">          0 : static int logical_ring_invalidate_all_caches(struct drm_i915_gem_request *req)</span>
<span class="lineNum">     606 </span>            : {
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = req-&gt;ring;</span>
<span class="lineNum">     608 </span>            :         uint32_t flush_domains;
<span class="lineNum">     609 </span>            :         int ret;
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :         flush_domains = 0;
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         if (ring-&gt;gpu_caches_dirty)</span>
<span class="lineNum">     613 </span>            :                 flush_domains = I915_GEM_GPU_DOMAINS;
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         ret = ring-&gt;emit_flush(req, I915_GEM_GPU_DOMAINS, flush_domains);</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         ring-&gt;gpu_caches_dirty = false;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineNoCov">          0 : static int execlists_move_to_gpu(struct drm_i915_gem_request *req,</span>
<span class="lineNum">     624 </span>            :                                  struct list_head *vmas)
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         const unsigned other_rings = ~intel_ring_flag(req-&gt;ring);</span>
<span class="lineNum">     627 </span>            :         struct i915_vma *vma;
<span class="lineNum">     628 </span>            :         uint32_t flush_domains = 0;
<span class="lineNum">     629 </span>            :         bool flush_chipset = false;
<span class="lineNum">     630 </span>            :         int ret;
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         list_for_each_entry(vma, vmas, exec_list) {</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                 struct drm_i915_gem_object *obj = vma-&gt;obj;</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :                 if (obj-&gt;active &amp; other_rings) {</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :                         ret = i915_gem_object_sync(obj, req-&gt;ring, &amp;req);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                         if (ret)</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                                 return ret;</span>
<span class="lineNum">     639 </span>            :                 }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :                 if (obj-&gt;base.write_domain &amp; I915_GEM_DOMAIN_CPU)</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :                         flush_chipset |= i915_gem_clflush_object(obj, false);</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                 flush_domains |= obj-&gt;base.write_domain;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         if (flush_domains &amp; I915_GEM_DOMAIN_GTT)</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :                 wmb();</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :         /* Unconditionally invalidate gpu caches and ensure that we do flush
<span class="lineNum">     651 </span>            :          * any residual writes from the previous batch.
<span class="lineNum">     652 </span>            :          */
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         return logical_ring_invalidate_all_caches(req);</span>
<a name="654"><span class="lineNum">     654 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineNoCov">          0 : int intel_logical_ring_alloc_request_extras(struct drm_i915_gem_request *request)</span>
<span class="lineNum">     657 </span>            : {
<span class="lineNum">     658 </span>            :         int ret;
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         request-&gt;ringbuf = request-&gt;ctx-&gt;engine[request-&gt;ring-&gt;id].ringbuf;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         if (request-&gt;ctx != request-&gt;ring-&gt;default_context) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 ret = intel_lr_context_pin(request);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                         return ret;</span>
<span class="lineNum">     666 </span>            :         }
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="669"><span class="lineNum">     669 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : static int logical_ring_wait_for_space(struct drm_i915_gem_request *req,</span>
<span class="lineNum">     672 </span>            :                                        int bytes)
<span class="lineNum">     673 </span>            : {
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = req-&gt;ringbuf;</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = req-&gt;ring;</span>
<span class="lineNum">     676 </span>            :         struct drm_i915_gem_request *target;
<span class="lineNum">     677 </span>            :         unsigned space;
<span class="lineNum">     678 </span>            :         int ret;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         if (intel_ring_space(ringbuf) &gt;= bytes)</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :         /* The whole point of reserving space is to not wait! */
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         WARN_ON(ringbuf-&gt;reserved_in_use);</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         list_for_each_entry(target, &amp;ring-&gt;request_list, list) {</span>
<span class="lineNum">     687 </span>            :                 /*
<span class="lineNum">     688 </span>            :                  * The request queue is per-engine, so can contain requests
<span class="lineNum">     689 </span>            :                  * from multiple ringbuffers. Here, we must ignore any that
<span class="lineNum">     690 </span>            :                  * aren't from the ringbuffer we're considering.
<span class="lineNum">     691 </span>            :                  */
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :                 if (target-&gt;ringbuf != ringbuf)</span>
<span class="lineNum">     693 </span>            :                         continue;
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :                 /* Would completion of this request free enough space? */
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :                 space = __intel_ring_space(target-&gt;postfix, ringbuf-&gt;tail,</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                                            ringbuf-&gt;size);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                 if (space &gt;= bytes)</span>
<span class="lineNum">     699 </span>            :                         break;
<span class="lineNum">     700 </span>            :         }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         if (WARN_ON(&amp;target-&gt;list == &amp;ring-&gt;request_list))</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                 return -ENOSPC;</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         ret = i915_wait_request(target);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         ringbuf-&gt;space = space;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : /*
<span class="lineNum">     714 </span>            :  * intel_logical_ring_advance_and_submit() - advance the tail and submit the workload
<span class="lineNum">     715 </span>            :  * @request: Request to advance the logical ringbuffer of.
<span class="lineNum">     716 </span>            :  *
<span class="lineNum">     717 </span>            :  * The tail is updated in our logical ringbuffer struct, not in the actual context. What
<span class="lineNum">     718 </span>            :  * really happens during submission is that the context and current tail will be placed
<span class="lineNum">     719 </span>            :  * on a queue waiting for the ELSP to be ready to accept a new context submission. At that
<span class="lineNum">     720 </span>            :  * point, the tail *inside* the context is updated and the ELSP written to.
<a name="721"><span class="lineNum">     721 </span>            :  */</a>
<span class="lineNum">     722 </span>            : static void
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : intel_logical_ring_advance_and_submit(struct drm_i915_gem_request *request)</span>
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = request-&gt;ring;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = request-&gt;i915;</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(request-&gt;ringbuf);</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :         request-&gt;tail = request-&gt;ringbuf-&gt;tail;</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         if (intel_ring_stopped(ring))</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :         if (dev_priv-&gt;guc.execbuf_client)</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :                 i915_guc_submit(dev_priv-&gt;guc.execbuf_client, request);</span>
<span class="lineNum">     737 </span>            :         else
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :                 execlists_context_queue(request);</span>
<a name="739"><span class="lineNum">     739 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 : static void __wrap_ring_buffer(struct intel_ringbuffer *ringbuf)</span>
<span class="lineNum">     742 </span>            : {
<span class="lineNum">     743 </span>            :         uint32_t __iomem *virt;
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :         int rem = ringbuf-&gt;size - ringbuf-&gt;tail;</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         virt = ringbuf-&gt;virtual_start + ringbuf-&gt;tail;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         rem /= 4;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         while (rem--)</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :                 iowrite32(MI_NOOP, virt++);</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :         ringbuf-&gt;tail = 0;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         intel_ring_update_space(ringbuf);</span>
<a name="753"><span class="lineNum">     753 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineNoCov">          0 : static int logical_ring_prepare(struct drm_i915_gem_request *req, int bytes)</span>
<span class="lineNum">     756 </span>            : {
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = req-&gt;ringbuf;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         int remain_usable = ringbuf-&gt;effective_size - ringbuf-&gt;tail;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         int remain_actual = ringbuf-&gt;size - ringbuf-&gt;tail;</span>
<span class="lineNum">     760 </span>            :         int ret, total_bytes, wait_bytes = 0;
<span class="lineNum">     761 </span>            :         bool need_wrap = false;
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         if (ringbuf-&gt;reserved_in_use)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :                 total_bytes = bytes;</span>
<span class="lineNum">     765 </span>            :         else
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 total_bytes = bytes + ringbuf-&gt;reserved_size;</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         if (unlikely(bytes &gt; remain_usable)) {</span>
<span class="lineNum">     769 </span>            :                 /*
<span class="lineNum">     770 </span>            :                  * Not enough space for the basic request. So need to flush
<span class="lineNum">     771 </span>            :                  * out the remainder and then wait for base + reserved.
<span class="lineNum">     772 </span>            :                  */
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 wait_bytes = remain_actual + total_bytes;</span>
<span class="lineNum">     774 </span>            :                 need_wrap = true;
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :                 if (unlikely(total_bytes &gt; remain_usable)) {</span>
<span class="lineNum">     777 </span>            :                         /*
<span class="lineNum">     778 </span>            :                          * The base request will fit but the reserved space
<span class="lineNum">     779 </span>            :                          * falls off the end. So don't need an immediate wrap
<span class="lineNum">     780 </span>            :                          * and only need to effectively wait for the reserved
<span class="lineNum">     781 </span>            :                          * size space from the start of ringbuffer.
<span class="lineNum">     782 </span>            :                          */
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :                         wait_bytes = remain_actual + ringbuf-&gt;reserved_size;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :                 } else if (total_bytes &gt; ringbuf-&gt;space) {</span>
<span class="lineNum">     785 </span>            :                         /* No wrapping required, just waiting. */
<span class="lineNum">     786 </span>            :                         wait_bytes = total_bytes;
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     788 </span>            :         }
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         if (wait_bytes) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :                 ret = logical_ring_wait_for_space(req, wait_bytes);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :                 if (unlikely(ret))</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                         return ret;</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :                 if (need_wrap)</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                         __wrap_ring_buffer(ringbuf);</span>
<span class="lineNum">     797 </span>            :         }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            : /**
<span class="lineNum">     803 </span>            :  * intel_logical_ring_begin() - prepare the logical ringbuffer to accept some commands
<span class="lineNum">     804 </span>            :  *
<span class="lineNum">     805 </span>            :  * @req: The request to start some new work for
<span class="lineNum">     806 </span>            :  * @num_dwords: number of DWORDs that we plan to write to the ringbuffer.
<span class="lineNum">     807 </span>            :  *
<span class="lineNum">     808 </span>            :  * The ringbuffer might not be ready to accept the commands right away (maybe it needs to
<span class="lineNum">     809 </span>            :  * be wrapped, or wait a bit for the tail to be updated). This function takes care of that
<span class="lineNum">     810 </span>            :  * and also preallocates a request (every workload submission is still mediated through
<span class="lineNum">     811 </span>            :  * requests, same as it did with legacy ringbuffer submission).
<span class="lineNum">     812 </span>            :  *
<a name="813"><span class="lineNum">     813 </span>            :  * Return: non-zero if the ringbuffer is not ready to be written to.</a>
<span class="lineNum">     814 </span>            :  */
<span class="lineNum">     815 </span><span class="lineNoCov">          0 : int intel_logical_ring_begin(struct drm_i915_gem_request *req, int num_dwords)</span>
<span class="lineNum">     816 </span>            : {
<span class="lineNum">     817 </span>            :         struct drm_i915_private *dev_priv;
<span class="lineNum">     818 </span>            :         int ret;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         WARN_ON(req == NULL);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         dev_priv = req-&gt;ring-&gt;dev-&gt;dev_private;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         ret = i915_gem_check_wedge(&amp;dev_priv-&gt;gpu_error,</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                                    dev_priv-&gt;mm.interruptible);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         ret = logical_ring_prepare(req, num_dwords * sizeof(uint32_t));</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :         req-&gt;ringbuf-&gt;space -= num_dwords * sizeof(uint32_t);</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="834"><span class="lineNum">     834 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 : int intel_logical_ring_reserve_space(struct drm_i915_gem_request *request)</span>
<span class="lineNum">     837 </span>            : {
<span class="lineNum">     838 </span>            :         /*
<span class="lineNum">     839 </span>            :          * The first call merely notes the reserve request and is common for
<span class="lineNum">     840 </span>            :          * all back ends. The subsequent localised _begin() call actually
<span class="lineNum">     841 </span>            :          * ensures that the reservation is available. Without the begin, if
<span class="lineNum">     842 </span>            :          * the request creator immediately submitted the request without
<span class="lineNum">     843 </span>            :          * adding any commands to it then there might not actually be
<span class="lineNum">     844 </span>            :          * sufficient room for the submission commands.
<span class="lineNum">     845 </span>            :          */
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :         intel_ring_reserved_space_reserve(request-&gt;ringbuf, MIN_SPACE_FOR_ADD_REQUEST);</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         return intel_logical_ring_begin(request, 0);</span>
<span class="lineNum">     849 </span>            : }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            : /**
<span class="lineNum">     852 </span>            :  * execlists_submission() - submit a batchbuffer for execution, Execlists style
<span class="lineNum">     853 </span>            :  * @dev: DRM device.
<span class="lineNum">     854 </span>            :  * @file: DRM file.
<span class="lineNum">     855 </span>            :  * @ring: Engine Command Streamer to submit to.
<span class="lineNum">     856 </span>            :  * @ctx: Context to employ for this submission.
<span class="lineNum">     857 </span>            :  * @args: execbuffer call arguments.
<span class="lineNum">     858 </span>            :  * @vmas: list of vmas.
<span class="lineNum">     859 </span>            :  * @batch_obj: the batchbuffer to submit.
<span class="lineNum">     860 </span>            :  * @exec_start: batchbuffer start virtual address pointer.
<span class="lineNum">     861 </span>            :  * @dispatch_flags: translated execbuffer call flags.
<span class="lineNum">     862 </span>            :  *
<span class="lineNum">     863 </span>            :  * This is the evil twin version of i915_gem_ringbuffer_submission. It abstracts
<span class="lineNum">     864 </span>            :  * away the submission details of the execbuffer ioctl call.
<span class="lineNum">     865 </span>            :  *
<a name="866"><span class="lineNum">     866 </span>            :  * Return: non-zero if the submission fails.</a>
<span class="lineNum">     867 </span>            :  */
<span class="lineNum">     868 </span><span class="lineNoCov">          0 : int intel_execlists_submission(struct i915_execbuffer_params *params,</span>
<span class="lineNum">     869 </span>            :                                struct drm_i915_gem_execbuffer2 *args,
<span class="lineNum">     870 </span>            :                                struct list_head *vmas)
<span class="lineNum">     871 </span>            : {
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         struct drm_device       *dev = params-&gt;dev;</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         struct intel_engine_cs  *ring = params-&gt;ring;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = params-&gt;ctx-&gt;engine[ring-&gt;id].ringbuf;</span>
<span class="lineNum">     876 </span>            :         u64 exec_start;
<span class="lineNum">     877 </span>            :         int instp_mode;
<span class="lineNum">     878 </span>            :         u32 instp_mask;
<span class="lineNum">     879 </span>            :         int ret;
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         instp_mode = args-&gt;flags &amp; I915_EXEC_CONSTANTS_MASK;</span>
<span class="lineNum">     882 </span>            :         instp_mask = I915_EXEC_CONSTANTS_MASK;
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :         switch (instp_mode) {</span>
<span class="lineNum">     884 </span>            :         case I915_EXEC_CONSTANTS_REL_GENERAL:
<span class="lineNum">     885 </span>            :         case I915_EXEC_CONSTANTS_ABSOLUTE:
<span class="lineNum">     886 </span>            :         case I915_EXEC_CONSTANTS_REL_SURFACE:
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                 if (instp_mode != 0 &amp;&amp; ring != &amp;dev_priv-&gt;ring[RCS]) {</span>
<span class="lineNum">     888 </span>            :                         DRM_DEBUG(&quot;non-0 rel constants mode on non-RCS\n&quot;);
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :                         return -EINVAL;</span>
<span class="lineNum">     890 </span>            :                 }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                 if (instp_mode != dev_priv-&gt;relative_constants_mode) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :                         if (instp_mode == I915_EXEC_CONSTANTS_REL_SURFACE) {</span>
<span class="lineNum">     894 </span>            :                                 DRM_DEBUG(&quot;rel surface constants mode invalid on gen5+\n&quot;);
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                                 return -EINVAL;</span>
<span class="lineNum">     896 </span>            :                         }
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            :                         /* The HW changed the meaning on this bit on gen6 */
<span class="lineNum">     899 </span>            :                         instp_mask &amp;= ~I915_EXEC_CONSTANTS_REL_SURFACE;
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     901 </span>            :                 break;
<span class="lineNum">     902 </span>            :         default:
<span class="lineNum">     903 </span>            :                 DRM_DEBUG(&quot;execbuf with unknown constants: %d\n&quot;, instp_mode);
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                 return -EINVAL;</span>
<span class="lineNum">     905 </span>            :         }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :         if (args-&gt;flags &amp; I915_EXEC_GEN7_SOL_RESET) {</span>
<span class="lineNum">     908 </span>            :                 DRM_DEBUG(&quot;sol reset is gen7 only\n&quot;);
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                 return -EINVAL;</span>
<span class="lineNum">     910 </span>            :         }
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :         ret = execlists_move_to_gpu(params-&gt;request, vmas);</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         if (ring == &amp;dev_priv-&gt;ring[RCS] &amp;&amp;</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :             instp_mode != dev_priv-&gt;relative_constants_mode) {</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                 ret = intel_logical_ring_begin(params-&gt;request, 4);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                         return ret;</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, MI_LOAD_REGISTER_IMM(1));</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, INSTPM);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, instp_mask &lt;&lt; 16 | instp_mode);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                 intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;relative_constants_mode = instp_mode;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         exec_start = params-&gt;batch_obj_vm_offset +</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :                      args-&gt;batch_start_offset;</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         ret = ring-&gt;emit_bb_start(params-&gt;request, exec_start, params-&gt;dispatch_flags);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :         trace_i915_gem_ring_dispatch(params-&gt;request, params-&gt;dispatch_flags);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         i915_gem_execbuffer_move_to_active(vmas, params-&gt;request);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         i915_gem_execbuffer_retire_commands(params);</span>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="944"><span class="lineNum">     944 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 : void intel_execlists_retire_requests(struct intel_engine_cs *ring)</span>
<span class="lineNum">     947 </span>            : {
<span class="lineNum">     948 </span>            :         struct drm_i915_gem_request *req, *tmp;
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :         struct list_head retired_list;</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :         WARN_ON(!mutex_is_locked(&amp;ring-&gt;dev-&gt;struct_mutex));</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         if (list_empty(&amp;ring-&gt;execlist_retired_req_list))</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         INIT_LIST_HEAD(&amp;retired_list);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         spin_lock_irq(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         list_replace_init(&amp;ring-&gt;execlist_retired_req_list, &amp;retired_list);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         spin_unlock_irq(&amp;ring-&gt;execlist_lock);</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         list_for_each_entry_safe(req, tmp, &amp;retired_list, execlist_link) {</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                 struct intel_context *ctx = req-&gt;ctx;</span>
<span class="lineNum">     962 </span>            :                 struct drm_i915_gem_object *ctx_obj =
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                                 ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                 if (ctx_obj &amp;&amp; (ctx != ring-&gt;default_context))</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :                         intel_lr_context_unpin(req);</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :                 list_del(&amp;req-&gt;execlist_link);</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :                 i915_gem_request_unreference(req);</span>
<span class="lineNum">     969 </span>            :         }
<a name="970"><span class="lineNum">     970 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineNoCov">          0 : void intel_logical_ring_stop(struct intel_engine_cs *ring)</span>
<span class="lineNum">     973 </span>            : {
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = ring-&gt;dev-&gt;dev_private;</span>
<span class="lineNum">     975 </span>            :         int ret;
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         if (!intel_ring_initialized(ring))</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         ret = intel_ring_idle(ring);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         if (ret &amp;&amp; !i915_reset_in_progress(&amp;to_i915(ring-&gt;dev)-&gt;gpu_error))</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;failed to quiesce %s whilst cleaning up: %d\n&quot;,</span>
<span class="lineNum">     983 </span>            :                           ring-&gt;name, ret);
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :         /* TODO: Is this correct with Execlists enabled? */
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :         I915_WRITE_MODE(ring, _MASKED_BIT_ENABLE(STOP_RING));</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :         if (wait_for_atomic((I915_READ_MODE(ring) &amp; MODE_IDLE) != 0, 1000)) {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;%s :timed out trying to stop ring\n&quot;, ring-&gt;name);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     990 </span>            :         }
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :         I915_WRITE_MODE(ring, _MASKED_BIT_DISABLE(STOP_RING));</span>
<a name="992"><span class="lineNum">     992 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineNoCov">          0 : int logical_ring_flush_all_caches(struct drm_i915_gem_request *req)</span>
<span class="lineNum">     995 </span>            : {
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = req-&gt;ring;</span>
<span class="lineNum">     997 </span>            :         int ret;
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :         if (!ring-&gt;gpu_caches_dirty)</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         ret = ring-&gt;emit_flush(req, 0, I915_GEM_GPU_DOMAINS);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         ring-&gt;gpu_caches_dirty = false;</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 : static int intel_lr_context_do_pin(struct intel_engine_cs *ring,</span>
<span class="lineNum">    1011 </span>            :                 struct drm_i915_gem_object *ctx_obj,
<span class="lineNum">    1012 </span>            :                 struct intel_ringbuffer *ringbuf)
<span class="lineNum">    1013 </span>            : {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1016 </span>            :         int ret = 0;
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         WARN_ON(!mutex_is_locked(&amp;ring-&gt;dev-&gt;struct_mutex));</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         ret = i915_gem_obj_ggtt_pin(ctx_obj, GEN8_LR_CONTEXT_ALIGN,</span>
<span class="lineNum">    1020 </span>            :                         PIN_OFFSET_BIAS | GUC_WOPCM_TOP);
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :         ret = intel_pin_and_map_ringbuffer_obj(ring-&gt;dev, ringbuf);</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1026 </span>            :                 goto unpin_ctx_obj;
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         ctx_obj-&gt;dirty = true;</span>
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :         /* Invalidate GuC TLB. */
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :         if (i915.enable_guc_submission)</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                 I915_WRITE(GEN8_GTCR, GEN8_GTCR_INVALIDATE);</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            : unpin_ctx_obj:
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :         i915_gem_object_ggtt_unpin(ctx_obj);</span>
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="1040"><span class="lineNum">    1040 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 : static int intel_lr_context_pin(struct drm_i915_gem_request *rq)</span>
<span class="lineNum">    1043 </span>            : {
<span class="lineNum">    1044 </span>            :         int ret = 0;
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = rq-&gt;ring;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :         struct drm_i915_gem_object *ctx_obj = rq-&gt;ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = rq-&gt;ringbuf;</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         if (rq-&gt;ctx-&gt;engine[ring-&gt;id].pin_count++ == 0) {</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                 ret = intel_lr_context_do_pin(ring, ctx_obj, ringbuf);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    1052 </span>            :                         goto reset_pin_count;
<span class="lineNum">    1053 </span>            :         }
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            : reset_pin_count:
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         rq-&gt;ctx-&gt;engine[ring-&gt;id].pin_count = 0;</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="1059"><span class="lineNum">    1059 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 : void intel_lr_context_unpin(struct drm_i915_gem_request *rq)</span>
<span class="lineNum">    1062 </span>            : {
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = rq-&gt;ring;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         struct drm_i915_gem_object *ctx_obj = rq-&gt;ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = rq-&gt;ringbuf;</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :         if (ctx_obj) {</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                 WARN_ON(!mutex_is_locked(&amp;ring-&gt;dev-&gt;struct_mutex));</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                 if (--rq-&gt;ctx-&gt;engine[ring-&gt;id].pin_count == 0) {</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                         intel_unpin_ringbuffer_obj(ringbuf);</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                         i915_gem_object_ggtt_unpin(ctx_obj);</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1073 </span>            :         }
<a name="1074"><span class="lineNum">    1074 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 : static int intel_logical_ring_workarounds_emit(struct drm_i915_gem_request *req)</span>
<span class="lineNum">    1077 </span>            : {
<span class="lineNum">    1078 </span>            :         int ret, i;
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = req-&gt;ring;</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = req-&gt;ringbuf;</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         struct i915_workarounds *w = &amp;dev_priv-&gt;workarounds;</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         if (WARN_ON_ONCE(w-&gt;count == 0))</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         ring-&gt;gpu_caches_dirty = true;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         ret = logical_ring_flush_all_caches(req);</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_begin(req, w-&gt;count * 2 + 2);</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_LOAD_REGISTER_IMM(w-&gt;count));</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; w-&gt;count; i++) {</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, w-&gt;reg[i].addr);</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, w-&gt;reg[i].value);</span>
<span class="lineNum">    1101 </span>            :         }
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         ring-&gt;gpu_caches_dirty = true;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         ret = logical_ring_flush_all_caches(req);</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            : #define wa_ctx_emit(batch, index, cmd)                                  \
<span class="lineNum">    1115 </span>            :         do {                                                            \
<span class="lineNum">    1116 </span>            :                 int __index = (index)++;                                \
<span class="lineNum">    1117 </span>            :                 if (WARN_ON(__index &gt;= (PAGE_SIZE / sizeof(uint32_t)))) { \
<span class="lineNum">    1118 </span>            :                         return -ENOSPC;                                 \
<span class="lineNum">    1119 </span>            :                 }                                                       \
<span class="lineNum">    1120 </span>            :                 batch[__index] = (cmd);                                 \
<span class="lineNum">    1121 </span>            :         } while (0)
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            : /*
<span class="lineNum">    1125 </span>            :  * In this WA we need to set GEN8_L3SQCREG4[21:21] and reset it after
<span class="lineNum">    1126 </span>            :  * PIPE_CONTROL instruction. This is required for the flush to happen correctly
<span class="lineNum">    1127 </span>            :  * but there is a slight complication as this is applied in WA batch where the
<span class="lineNum">    1128 </span>            :  * values are only initialized once so we cannot take register value at the
<span class="lineNum">    1129 </span>            :  * beginning and reuse it further; hence we save its value to memory, upload a
<span class="lineNum">    1130 </span>            :  * constant value with bit21 set and then we restore it back with the saved value.
<span class="lineNum">    1131 </span>            :  * To simplify the WA, a constant value is formed by using the default value
<span class="lineNum">    1132 </span>            :  * of this register. This shouldn't be a problem because we are only modifying
<span class="lineNum">    1133 </span>            :  * it for a short period and this batch in non-premptible. We can ofcourse
<span class="lineNum">    1134 </span>            :  * use additional instructions that read the actual value of the register
<span class="lineNum">    1135 </span>            :  * at that time and set our bit of interest but it makes the WA complicated.
<span class="lineNum">    1136 </span>            :  *
<span class="lineNum">    1137 </span>            :  * This WA is also required for Gen9 so extracting as a function avoids
<a name="1138"><span class="lineNum">    1138 </span>            :  * code duplication.</a>
<span class="lineNum">    1139 </span>            :  */
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 : static inline int gen8_emit_flush_coherentl3_wa(struct intel_engine_cs *ring,</span>
<span class="lineNum">    1141 </span>            :                                                 uint32_t *const batch,
<span class="lineNum">    1142 </span>            :                                                 uint32_t index)
<span class="lineNum">    1143 </span>            : {
<span class="lineNum">    1144 </span>            :         uint32_t l3sqc4_flush = (0x40400000 | GEN8_LQSC_FLUSH_COHERENT_LINES);
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :         /*
<span class="lineNum">    1147 </span>            :          * WaDisableLSQCROPERFforOCL:skl,kbl
<span class="lineNum">    1148 </span>            :          * This WA is implemented in skl_init_clock_gating() but since
<span class="lineNum">    1149 </span>            :          * this batch updates GEN8_L3SQCREG4 with default value we need to
<span class="lineNum">    1150 </span>            :          * set this bit here to retain the WA during flush.
<span class="lineNum">    1151 </span>            :          */
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :         if (IS_SKL_REVID(ring-&gt;dev, 0, SKL_REVID_E0) ||</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :             IS_KBL_REVID(ring-&gt;dev, 0, KBL_REVID_E0))</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                 l3sqc4_flush |= GEN8_LQSC_RO_PERF_DIS;</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, (MI_STORE_REGISTER_MEM_GEN8 |</span>
<span class="lineNum">    1157 </span>            :                                    MI_SRM_LRM_GLOBAL_GTT));
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, GEN8_L3SQCREG4);</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, ring-&gt;scratch.gtt_offset + 256);</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, MI_LOAD_REGISTER_IMM(1));</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, GEN8_L3SQCREG4);</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, l3sqc4_flush);</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, GFX_OP_PIPE_CONTROL(6));</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, (PIPE_CONTROL_CS_STALL |</span>
<span class="lineNum">    1168 </span>            :                                    PIPE_CONTROL_DC_FLUSH_ENABLE));
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, (MI_LOAD_REGISTER_MEM_GEN8 |</span>
<span class="lineNum">    1175 </span>            :                                    MI_SRM_LRM_GLOBAL_GTT));
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, GEN8_L3SQCREG4);</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, ring-&gt;scratch.gtt_offset + 256);</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :         return index;</span>
<a name="1181"><span class="lineNum">    1181 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 : static inline uint32_t wa_ctx_start(struct i915_wa_ctx_bb *wa_ctx,</span>
<span class="lineNum">    1184 </span>            :                                     uint32_t offset,
<span class="lineNum">    1185 </span>            :                                     uint32_t start_alignment)
<span class="lineNum">    1186 </span>            : {
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         return wa_ctx-&gt;offset = roundup2(offset, start_alignment);</span>
<a name="1188"><span class="lineNum">    1188 </span>            : }</a>
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 : static inline int wa_ctx_end(struct i915_wa_ctx_bb *wa_ctx,</span>
<span class="lineNum">    1191 </span>            :                              uint32_t offset,
<span class="lineNum">    1192 </span>            :                              uint32_t size_alignment)
<span class="lineNum">    1193 </span>            : {
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         wa_ctx-&gt;size = offset - wa_ctx-&gt;offset;</span>
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :         WARN(wa_ctx-&gt;size % size_alignment,</span>
<span class="lineNum">    1197 </span>            :              &quot;wa_ctx_bb failed sanity checks: size %d is not aligned to %d\n&quot;,
<span class="lineNum">    1198 </span>            :              wa_ctx-&gt;size, size_alignment);
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1200 </span>            : }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            : /**
<span class="lineNum">    1203 </span>            :  * gen8_init_indirectctx_bb() - initialize indirect ctx batch with WA
<span class="lineNum">    1204 </span>            :  *
<span class="lineNum">    1205 </span>            :  * @ring: only applicable for RCS
<span class="lineNum">    1206 </span>            :  * @wa_ctx: structure representing wa_ctx
<span class="lineNum">    1207 </span>            :  *  offset: specifies start of the batch, should be cache-aligned. This is updated
<span class="lineNum">    1208 </span>            :  *    with the offset value received as input.
<span class="lineNum">    1209 </span>            :  *  size: size of the batch in DWORDS but HW expects in terms of cachelines
<span class="lineNum">    1210 </span>            :  * @batch: page in which WA are loaded
<span class="lineNum">    1211 </span>            :  * @offset: This field specifies the start of the batch, it should be
<span class="lineNum">    1212 </span>            :  *  cache-aligned otherwise it is adjusted accordingly.
<span class="lineNum">    1213 </span>            :  *  Typically we only have one indirect_ctx and per_ctx batch buffer which are
<span class="lineNum">    1214 </span>            :  *  initialized at the beginning and shared across all contexts but this field
<span class="lineNum">    1215 </span>            :  *  helps us to have multiple batches at different offsets and select them based
<span class="lineNum">    1216 </span>            :  *  on a criteria. At the moment this batch always start at the beginning of the page
<span class="lineNum">    1217 </span>            :  *  and at this point we don't have multiple wa_ctx batch buffers.
<span class="lineNum">    1218 </span>            :  *
<span class="lineNum">    1219 </span>            :  *  The number of WA applied are not known at the beginning; we use this field
<span class="lineNum">    1220 </span>            :  *  to return the no of DWORDS written.
<span class="lineNum">    1221 </span>            :  *
<span class="lineNum">    1222 </span>            :  *  It is to be noted that this batch does not contain MI_BATCH_BUFFER_END
<span class="lineNum">    1223 </span>            :  *  so it adds NOOPs as padding to make it cacheline aligned.
<span class="lineNum">    1224 </span>            :  *  MI_BATCH_BUFFER_END will be added to perctx batch and both of them together
<span class="lineNum">    1225 </span>            :  *  makes a complete batch buffer.
<span class="lineNum">    1226 </span>            :  *
<span class="lineNum">    1227 </span>            :  * Return: non-zero if we exceed the PAGE_SIZE limit.
<a name="1228"><span class="lineNum">    1228 </span>            :  */</a>
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 : static int gen8_init_indirectctx_bb(struct intel_engine_cs *ring,</span>
<span class="lineNum">    1231 </span>            :                                     struct i915_wa_ctx_bb *wa_ctx,
<span class="lineNum">    1232 </span>            :                                     uint32_t *const batch,
<span class="lineNum">    1233 </span>            :                                     uint32_t *offset)
<span class="lineNum">    1234 </span>            : {
<span class="lineNum">    1235 </span>            :         uint32_t scratch_addr;
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :         uint32_t index = wa_ctx_start(wa_ctx, *offset, CACHELINE_DWORDS);</span>
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            :         /* WaDisableCtxRestoreArbitration:bdw,chv */
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, MI_ARB_ON_OFF | MI_ARB_DISABLE);</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :         /* WaFlushCoherentL3CacheLinesAtContextSwitch:bdw */
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :         if (IS_BROADWELL(ring-&gt;dev)) {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                 int rc = gen8_emit_flush_coherentl3_wa(ring, batch, index);</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :                 if (rc &lt; 0)</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                         return rc;</span>
<span class="lineNum">    1246 </span>            :                 index = rc;
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :         /* WaClearSlmSpaceAtContextSwitch:bdw,chv */
<span class="lineNum">    1250 </span>            :         /* Actual scratch location is at 128 bytes offset */
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :         scratch_addr = ring-&gt;scratch.gtt_offset + 2*CACHELINE_BYTES;</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, GFX_OP_PIPE_CONTROL(6));</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, (PIPE_CONTROL_FLUSH_L3 |</span>
<span class="lineNum">    1255 </span>            :                                    PIPE_CONTROL_GLOBAL_GTT_IVB |
<span class="lineNum">    1256 </span>            :                                    PIPE_CONTROL_CS_STALL |
<span class="lineNum">    1257 </span>            :                                    PIPE_CONTROL_QW_WRITE));
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, scratch_addr);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, 0);</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            :         /* Pad to end of cacheline */
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :         while (index % CACHELINE_DWORDS)</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, MI_NOOP);</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            :         /*
<span class="lineNum">    1268 </span>            :          * MI_BATCH_BUFFER_END is not required in Indirect ctx BB because
<span class="lineNum">    1269 </span>            :          * execution depends on the length specified in terms of cache lines
<span class="lineNum">    1270 </span>            :          * in the register CTX_RCS_INDIRECT_CTX
<span class="lineNum">    1271 </span>            :          */
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :         return wa_ctx_end(wa_ctx, *offset = index, CACHELINE_DWORDS);</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            : /**
<span class="lineNum">    1277 </span>            :  * gen8_init_perctx_bb() - initialize per ctx batch with WA
<span class="lineNum">    1278 </span>            :  *
<span class="lineNum">    1279 </span>            :  * @ring: only applicable for RCS
<span class="lineNum">    1280 </span>            :  * @wa_ctx: structure representing wa_ctx
<span class="lineNum">    1281 </span>            :  *  offset: specifies start of the batch, should be cache-aligned.
<span class="lineNum">    1282 </span>            :  *  size: size of the batch in DWORDS but HW expects in terms of cachelines
<span class="lineNum">    1283 </span>            :  * @batch: page in which WA are loaded
<span class="lineNum">    1284 </span>            :  * @offset: This field specifies the start of this batch.
<span class="lineNum">    1285 </span>            :  *   This batch is started immediately after indirect_ctx batch. Since we ensure
<span class="lineNum">    1286 </span>            :  *   that indirect_ctx ends on a cacheline this batch is aligned automatically.
<span class="lineNum">    1287 </span>            :  *
<span class="lineNum">    1288 </span>            :  *   The number of DWORDS written are returned using this field.
<span class="lineNum">    1289 </span>            :  *
<span class="lineNum">    1290 </span>            :  *  This batch is terminated with MI_BATCH_BUFFER_END and so we need not add padding
<a name="1291"><span class="lineNum">    1291 </span>            :  *  to align it with cacheline as padding after MI_BATCH_BUFFER_END is redundant.</a>
<span class="lineNum">    1292 </span>            :  */
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 : static int gen8_init_perctx_bb(struct intel_engine_cs *ring,</span>
<span class="lineNum">    1294 </span>            :                                struct i915_wa_ctx_bb *wa_ctx,
<span class="lineNum">    1295 </span>            :                                uint32_t *const batch,
<span class="lineNum">    1296 </span>            :                                uint32_t *offset)
<span class="lineNum">    1297 </span>            : {
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :         uint32_t index = wa_ctx_start(wa_ctx, *offset, CACHELINE_DWORDS);</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            :         /* WaDisableCtxRestoreArbitration:bdw,chv */
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, MI_ARB_ON_OFF | MI_ARB_ENABLE);</span>
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, MI_BATCH_BUFFER_END);</span>
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :         return wa_ctx_end(wa_ctx, *offset = index, 1);</span>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 : static int gen9_init_indirectctx_bb(struct intel_engine_cs *ring,</span>
<span class="lineNum">    1309 </span>            :                                     struct i915_wa_ctx_bb *wa_ctx,
<span class="lineNum">    1310 </span>            :                                     uint32_t *const batch,
<span class="lineNum">    1311 </span>            :                                     uint32_t *offset)
<span class="lineNum">    1312 </span>            : {
<span class="lineNum">    1313 </span>            :         int ret;
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :         uint32_t index = wa_ctx_start(wa_ctx, *offset, CACHELINE_DWORDS);</span>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            :         /* WaDisableCtxRestoreArbitration:skl,bxt */
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :         if (IS_SKL_REVID(dev, 0, SKL_REVID_D0) ||</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :             IS_BXT_REVID(dev, 0, BXT_REVID_A0))</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, MI_ARB_ON_OFF | MI_ARB_DISABLE);</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :         /* WaFlushCoherentL3CacheLinesAtContextSwitch:skl,bxt */
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :         ret = gen8_emit_flush_coherentl3_wa(ring, batch, index);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :         if (ret &lt; 0)</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1326 </span>            :         index = ret;
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :         /* Pad to end of cacheline */
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :         while (index % CACHELINE_DWORDS)</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, MI_NOOP);</span>
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         return wa_ctx_end(wa_ctx, *offset = index, CACHELINE_DWORDS);</span>
<a name="1333"><span class="lineNum">    1333 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 : static int gen9_init_perctx_bb(struct intel_engine_cs *ring,</span>
<span class="lineNum">    1336 </span>            :                                struct i915_wa_ctx_bb *wa_ctx,
<span class="lineNum">    1337 </span>            :                                uint32_t *const batch,
<span class="lineNum">    1338 </span>            :                                uint32_t *offset)
<span class="lineNum">    1339 </span>            : {
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :         uint32_t index = wa_ctx_start(wa_ctx, *offset, CACHELINE_DWORDS);</span>
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            :         /* WaSetDisablePixMaskCammingAndRhwoInCommonSliceChicken:skl,bxt */
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :         if (IS_SKL_REVID(dev, 0, SKL_REVID_B0) ||</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :             IS_BXT_REVID(dev, 0, BXT_REVID_A0)) {</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, MI_LOAD_REGISTER_IMM(1));</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, GEN9_SLICE_COMMON_ECO_CHICKEN0);</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index,</span>
<span class="lineNum">    1349 </span>            :                             _MASKED_BIT_ENABLE(DISABLE_PIXEL_MASK_CAMMING));
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, MI_NOOP);</span>
<span class="lineNum">    1351 </span>            :         }
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :         /* WaDisableCtxRestoreArbitration:skl,bxt */
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :         if (IS_SKL_REVID(dev, 0, SKL_REVID_D0) ||</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :             IS_BXT_REVID(dev, 0, BXT_REVID_A0))</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :                 wa_ctx_emit(batch, index, MI_ARB_ON_OFF | MI_ARB_ENABLE);</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :         wa_ctx_emit(batch, index, MI_BATCH_BUFFER_END);</span>
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :         return wa_ctx_end(wa_ctx, *offset = index, 1);</span>
<a name="1361"><span class="lineNum">    1361 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 : static int lrc_setup_wa_ctx_obj(struct intel_engine_cs *ring, u32 size)</span>
<span class="lineNum">    1364 </span>            : {
<span class="lineNum">    1365 </span>            :         int ret;
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :         ring-&gt;wa_ctx.obj = i915_gem_alloc_object(ring-&gt;dev, PAGE_ALIGN(size));</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :         if (!ring-&gt;wa_ctx.obj) {</span>
<span class="lineNum">    1369 </span>            :                 DRM_DEBUG_DRIVER(&quot;alloc LRC WA ctx backing obj failed.\n&quot;);
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :                 return -ENOMEM;</span>
<span class="lineNum">    1371 </span>            :         }
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :         ret = i915_gem_obj_ggtt_pin(ring-&gt;wa_ctx.obj, PAGE_SIZE, 0);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    1375 </span>            :                 DRM_DEBUG_DRIVER(&quot;pin LRC WA ctx backing obj failed: %d\n&quot;,
<span class="lineNum">    1376 </span>            :                                  ret);
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :                 drm_gem_object_unreference(&amp;ring-&gt;wa_ctx.obj-&gt;base);</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1379 </span>            :         }
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1382"><span class="lineNum">    1382 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 : static void lrc_destroy_wa_ctx_obj(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1385 </span>            : {
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :         if (ring-&gt;wa_ctx.obj) {</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                 i915_gem_object_ggtt_unpin(ring-&gt;wa_ctx.obj);</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                 drm_gem_object_unreference(&amp;ring-&gt;wa_ctx.obj-&gt;base);</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :                 ring-&gt;wa_ctx.obj = NULL;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :         }</span>
<a name="1391"><span class="lineNum">    1391 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 : static int intel_init_workaround_bb(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1394 </span>            : {
<span class="lineNum">    1395 </span>            :         int ret;
<span class="lineNum">    1396 </span>            :         uint32_t *batch;
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         uint32_t offset;</span>
<span class="lineNum">    1398 </span>            :         struct vm_page *page;
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         struct i915_ctx_workarounds *wa_ctx = &amp;ring-&gt;wa_ctx;</span>
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         WARN_ON(ring-&gt;id != RCS);</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            :         /* update this when WA for higher Gen are added */
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(ring-&gt;dev)-&gt;gen &gt; 9) {</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;WA batch buffer is not initialized for Gen%d\n&quot;,</span>
<span class="lineNum">    1406 </span>            :                           INTEL_INFO(ring-&gt;dev)-&gt;gen);
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1408 </span>            :         }
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            :         /* some WA perform writes to scratch page, ensure it is valid */
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :         if (ring-&gt;scratch.obj == NULL) {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;scratch page not allocated for %s\n&quot;, ring-&gt;name);</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                 return -EINVAL;</span>
<span class="lineNum">    1414 </span>            :         }
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :         ret = lrc_setup_wa_ctx_obj(ring, PAGE_SIZE);</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    1418 </span>            :                 DRM_DEBUG_DRIVER(&quot;Failed to setup context WA page: %d\n&quot;, ret);
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1420 </span>            :         }
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         page = i915_gem_object_get_page(wa_ctx-&gt;obj, 0);</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :         batch = kmap_atomic(page);</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :         offset = 0;</span>
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(ring-&gt;dev)-&gt;gen == 8) {</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :                 ret = gen8_init_indirectctx_bb(ring,</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :                                                &amp;wa_ctx-&gt;indirect_ctx,</span>
<span class="lineNum">    1429 </span>            :                                                batch,
<span class="lineNum">    1430 </span>            :                                                &amp;offset);
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    1432 </span>            :                         goto out;
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :                 ret = gen8_init_perctx_bb(ring,</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                                           &amp;wa_ctx-&gt;per_ctx,</span>
<span class="lineNum">    1436 </span>            :                                           batch,
<span class="lineNum">    1437 </span>            :                                           &amp;offset);
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    1439 </span>            :                         goto out;
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :         } else if (INTEL_INFO(ring-&gt;dev)-&gt;gen == 9) {</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :                 ret = gen9_init_indirectctx_bb(ring,</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :                                                &amp;wa_ctx-&gt;indirect_ctx,</span>
<span class="lineNum">    1443 </span>            :                                                batch,
<span class="lineNum">    1444 </span>            :                                                &amp;offset);
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    1446 </span>            :                         goto out;
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                 ret = gen9_init_perctx_bb(ring,</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                                           &amp;wa_ctx-&gt;per_ctx,</span>
<span class="lineNum">    1450 </span>            :                                           batch,
<span class="lineNum">    1451 </span>            :                                           &amp;offset);
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    1453 </span>            :                         goto out;
<span class="lineNum">    1454 </span>            :         }
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            : out:
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :         kunmap_atomic(batch);</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                 lrc_destroy_wa_ctx_obj(ring);</span>
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="1462"><span class="lineNum">    1462 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 : static int gen8_init_common_ring(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1465 </span>            : {
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1468 </span>            :         u8 next_context_status_buffer_hw;
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :         lrc_setup_hardware_status_page(ring,</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :                                 ring-&gt;default_context-&gt;engine[ring-&gt;id].state);</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :         I915_WRITE_IMR(ring, ~(ring-&gt;irq_enable_mask | ring-&gt;irq_keep_mask));</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         I915_WRITE(RING_HWSTAM(ring-&gt;mmio_base), 0xffffffff);</span>
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :         if (ring-&gt;status_page.obj) {</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :                 I915_WRITE(RING_HWS_PGA(ring-&gt;mmio_base),</span>
<span class="lineNum">    1478 </span>            :                            (u32)ring-&gt;status_page.gfx_addr);
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :                 POSTING_READ(RING_HWS_PGA(ring-&gt;mmio_base));</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :         I915_WRITE(RING_MODE_GEN7(ring),</span>
<span class="lineNum">    1483 </span>            :                    _MASKED_BIT_DISABLE(GFX_REPLAY_MODE) |
<span class="lineNum">    1484 </span>            :                    _MASKED_BIT_ENABLE(GFX_RUN_LIST_ENABLE));
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :         POSTING_READ(RING_MODE_GEN7(ring));</span>
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            :         /*
<span class="lineNum">    1488 </span>            :          * Instead of resetting the Context Status Buffer (CSB) read pointer to
<span class="lineNum">    1489 </span>            :          * zero, we need to read the write pointer from hardware and use its
<span class="lineNum">    1490 </span>            :          * value because &quot;this register is power context save restored&quot;.
<span class="lineNum">    1491 </span>            :          * Effectively, these states have been observed:
<span class="lineNum">    1492 </span>            :          *
<span class="lineNum">    1493 </span>            :          *      | Suspend-to-idle (freeze) | Suspend-to-RAM (mem) |
<span class="lineNum">    1494 </span>            :          * BDW  | CSB regs not reset       | CSB regs reset       |
<span class="lineNum">    1495 </span>            :          * CHT  | CSB regs not reset       | CSB regs not reset   |
<span class="lineNum">    1496 </span>            :          */
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :         next_context_status_buffer_hw = (I915_READ(RING_CONTEXT_STATUS_PTR(ring))</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :                                                    &amp; GEN8_CSB_PTR_MASK);</span>
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :         /*
<span class="lineNum">    1501 </span>            :          * When the CSB registers are reset (also after power-up / gpu reset),
<span class="lineNum">    1502 </span>            :          * CSB write pointer is set to all 1's, which is not valid, use '5' in
<span class="lineNum">    1503 </span>            :          * this special case, so the first element read is CSB[0].
<span class="lineNum">    1504 </span>            :          */
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :         if (next_context_status_buffer_hw == GEN8_CSB_PTR_MASK)</span>
<span class="lineNum">    1506 </span>            :                 next_context_status_buffer_hw = (GEN8_CSB_ENTRIES - 1);
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :         ring-&gt;next_context_status_buffer = next_context_status_buffer_hw;</span>
<span class="lineNum">    1509 </span>            :         DRM_DEBUG_DRIVER(&quot;Execlists enabled for %s\n&quot;, ring-&gt;name);
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :         memset(&amp;ring-&gt;hangcheck, 0, sizeof(ring-&gt;hangcheck));</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1514"><span class="lineNum">    1514 </span>            : }</a>
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 : static int gen8_init_render_ring(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1517 </span>            : {
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1520 </span>            :         int ret;
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :         ret = gen8_init_common_ring(ring);</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :         /* We need to disable the AsyncFlip performance optimisations in order
<span class="lineNum">    1527 </span>            :          * to use MI_WAIT_FOR_EVENT within the CS. It should already be
<span class="lineNum">    1528 </span>            :          * programmed to '1' on all products.
<span class="lineNum">    1529 </span>            :          *
<span class="lineNum">    1530 </span>            :          * WaDisableAsyncFlipPerfMode:snb,ivb,hsw,vlv,bdw,chv
<span class="lineNum">    1531 </span>            :          */
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :         I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(ASYNC_FLIP_PERF_DISABLE));</span>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :         I915_WRITE(INSTPM, _MASKED_BIT_ENABLE(INSTPM_FORCE_ORDERING));</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :         return init_workarounds_ring(ring);</span>
<a name="1537"><span class="lineNum">    1537 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 : static int gen9_init_render_ring(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1540 </span>            : {
<span class="lineNum">    1541 </span>            :         int ret;
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :         ret = gen8_init_common_ring(ring);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :         return init_workarounds_ring(ring);</span>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 : static int intel_logical_ring_emit_pdps(struct drm_i915_gem_request *req)</span>
<span class="lineNum">    1551 </span>            : {
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :         struct i915_hw_ppgtt *ppgtt = req-&gt;ctx-&gt;ppgtt;</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = req-&gt;ring;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = req-&gt;ringbuf;</span>
<span class="lineNum">    1555 </span>            :         const int num_lri_cmds = GEN8_LEGACY_PDPES * 2;
<span class="lineNum">    1556 </span>            :         int i, ret;
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_begin(req, num_lri_cmds * 2 + 2);</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_LOAD_REGISTER_IMM(num_lri_cmds));</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :         for (i = GEN8_LEGACY_PDPES - 1; i &gt;= 0; i--) {</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :                 const dma_addr_t pd_daddr = i915_page_dir_dma_addr(ppgtt, i);</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, GEN8_RING_PDP_UDW(ring, i));</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, upper_32_bits(pd_daddr));</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, GEN8_RING_PDP_LDW(ring, i));</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, lower_32_bits(pd_daddr));</span>
<span class="lineNum">    1570 </span>            :         }
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 : static int gen8_emit_bb_start(struct drm_i915_gem_request *req,</span>
<span class="lineNum">    1579 </span>            :                               u64 offset, unsigned dispatch_flags)
<span class="lineNum">    1580 </span>            : {
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = req-&gt;ringbuf;</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :         bool ppgtt = !(dispatch_flags &amp; I915_DISPATCH_SECURE);</span>
<span class="lineNum">    1583 </span>            :         int ret;
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :         /* Don't rely in hw updating PDPs, specially in lite-restore.
<span class="lineNum">    1586 </span>            :          * Ideally, we should set Force PD Restore in ctx descriptor,
<span class="lineNum">    1587 </span>            :          * but we can't. Force Restore would be a second option, but
<span class="lineNum">    1588 </span>            :          * it is unsafe in case of lite-restore (because the ctx is
<span class="lineNum">    1589 </span>            :          * not idle). PML4 is allocated during ppgtt init so this is
<span class="lineNum">    1590 </span>            :          * not needed in 48-bit.*/
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :         if (req-&gt;ctx-&gt;ppgtt &amp;&amp;</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :             (intel_ring_flag(req-&gt;ring) &amp; req-&gt;ctx-&gt;ppgtt-&gt;pd_dirty_rings)) {</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                 if (!USES_FULL_48BIT_PPGTT(req-&gt;i915) &amp;&amp;</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :                     !intel_vgpu_active(req-&gt;i915-&gt;dev)) {</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :                         ret = intel_logical_ring_emit_pdps(req);</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :                         if (ret)</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                                 return ret;</span>
<span class="lineNum">    1598 </span>            :                 }
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :                 req-&gt;ctx-&gt;ppgtt-&gt;pd_dirty_rings &amp;= ~intel_ring_flag(req-&gt;ring);</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_begin(req, 4);</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span>            :         /* FIXME(BDW): Address space and security selectors. */
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_BATCH_BUFFER_START_GEN8 |</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :                                 (ppgtt&lt;&lt;8) |</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :                                 (dispatch_flags &amp; I915_DISPATCH_RS ?</span>
<span class="lineNum">    1611 </span>            :                                  MI_BATCH_RESOURCE_STREAMER : 0));
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, lower_32_bits(offset));</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, upper_32_bits(offset));</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1618"><span class="lineNum">    1618 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 : static bool gen8_logical_ring_get_irq(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1621 </span>            : {
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1624 </span>            :         unsigned long flags;
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :         if (WARN_ON(!intel_irqs_enabled(dev_priv)))</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :         spin_lock_irqsave(&amp;dev_priv-&gt;irq_lock, flags);</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :         if (ring-&gt;irq_refcount++ == 0) {</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :                 I915_WRITE_IMR(ring, ~(ring-&gt;irq_enable_mask | ring-&gt;irq_keep_mask));</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :                 POSTING_READ(RING_IMR(ring-&gt;mmio_base));</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :         spin_unlock_irqrestore(&amp;dev_priv-&gt;irq_lock, flags);</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :         return true;</span>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 : static void gen8_logical_ring_put_irq(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1640 </span>            : {
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1643 </span>            :         unsigned long flags;
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :         spin_lock_irqsave(&amp;dev_priv-&gt;irq_lock, flags);</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :         if (--ring-&gt;irq_refcount == 0) {</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :                 I915_WRITE_IMR(ring, ~ring-&gt;irq_keep_mask);</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :                 POSTING_READ(RING_IMR(ring-&gt;mmio_base));</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :         spin_unlock_irqrestore(&amp;dev_priv-&gt;irq_lock, flags);</span>
<a name="1651"><span class="lineNum">    1651 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 : static int gen8_emit_flush(struct drm_i915_gem_request *request,</span>
<span class="lineNum">    1654 </span>            :                            u32 invalidate_domains,
<span class="lineNum">    1655 </span>            :                            u32 unused)
<span class="lineNum">    1656 </span>            : {
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = request-&gt;ringbuf;</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = ringbuf-&gt;ring;</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1661 </span>            :         uint32_t cmd;
<span class="lineNum">    1662 </span>            :         int ret;
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_begin(request, 4);</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            :         cmd = MI_FLUSH_DW + 1;
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            :         /* We always require a command barrier so that subsequent
<span class="lineNum">    1671 </span>            :          * commands, such as breadcrumb interrupts, are strictly ordered
<span class="lineNum">    1672 </span>            :          * wrt the contents of the write cache being flushed to memory
<span class="lineNum">    1673 </span>            :          * (and thus being coherent from the CPU).
<span class="lineNum">    1674 </span>            :          */
<span class="lineNum">    1675 </span>            :         cmd |= MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :         if (invalidate_domains &amp; I915_GEM_GPU_DOMAINS) {</span>
<span class="lineNum">    1678 </span>            :                 cmd |= MI_INVALIDATE_TLB;
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :                 if (ring == &amp;dev_priv-&gt;ring[VCS])</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :                         cmd |= MI_INVALIDATE_BSD;</span>
<span class="lineNum">    1681 </span>            :         }
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, cmd);</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf,</span>
<span class="lineNum">    1685 </span>            :                                 I915_GEM_HWS_SCRATCH_ADDR |
<span class="lineNum">    1686 </span>            :                                 MI_FLUSH_DW_USE_GTT);
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, 0); /* upper addr */</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, 0); /* value */</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1692"><span class="lineNum">    1692 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1693 </span>            : 
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 : static int gen8_emit_flush_render(struct drm_i915_gem_request *request,</span>
<span class="lineNum">    1695 </span>            :                                   u32 invalidate_domains,
<span class="lineNum">    1696 </span>            :                                   u32 flush_domains)
<span class="lineNum">    1697 </span>            : {
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = request-&gt;ringbuf;</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = ringbuf-&gt;ring;</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :         u32 scratch_addr = ring-&gt;scratch.gtt_offset + 2 * CACHELINE_BYTES;</span>
<span class="lineNum">    1701 </span>            :         bool vf_flush_wa;
<span class="lineNum">    1702 </span>            :         u32 flags = 0;
<span class="lineNum">    1703 </span>            :         int ret;
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span>            :         flags |= PIPE_CONTROL_CS_STALL;
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :         if (flush_domains) {</span>
<span class="lineNum">    1708 </span>            :                 flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
<span class="lineNum">    1709 </span>            :                 flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="lineNum">    1710 </span>            :                 flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
<span class="lineNum">    1711 </span>            :                 flags |= PIPE_CONTROL_FLUSH_ENABLE;
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :         if (invalidate_domains) {</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_TLB_INVALIDATE;</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_QW_WRITE;</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :                 flags |= PIPE_CONTROL_GLOBAL_GTT_IVB;</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            :         /*
<span class="lineNum">    1726 </span>            :          * On GEN9+ Before VF_CACHE_INVALIDATE we need to emit a NULL pipe
<span class="lineNum">    1727 </span>            :          * control.
<span class="lineNum">    1728 </span>            :          */
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :         vf_flush_wa = INTEL_INFO(ring-&gt;dev)-&gt;gen &gt;= 9 &amp;&amp;</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :                       flags &amp; PIPE_CONTROL_VF_CACHE_INVALIDATE;</span>
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_begin(request, vf_flush_wa ? 12 : 6);</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :         if (vf_flush_wa) {</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, GFX_OP_PIPE_CONTROL(6));</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :                 intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, GFX_OP_PIPE_CONTROL(6));</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, flags);</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, scratch_addr);</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1754"><span class="lineNum">    1754 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 : static u32 gen8_get_seqno(struct intel_engine_cs *ring, bool lazy_coherency)</span>
<span class="lineNum">    1757 </span>            : {
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :         return intel_read_status_page(ring, I915_GEM_HWS_INDEX);</span>
<a name="1759"><span class="lineNum">    1759 </span>            : }</a>
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 : static void gen8_set_seqno(struct intel_engine_cs *ring, u32 seqno)</span>
<span class="lineNum">    1762 </span>            : {
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         intel_write_status_page(ring, I915_GEM_HWS_INDEX, seqno);</span>
<a name="1764"><span class="lineNum">    1764 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 : static u32 bxt_a_get_seqno(struct intel_engine_cs *ring, bool lazy_coherency)</span>
<span class="lineNum">    1767 </span>            : {
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            :         /*
<span class="lineNum">    1770 </span>            :          * On BXT A steppings there is a HW coherency issue whereby the
<span class="lineNum">    1771 </span>            :          * MI_STORE_DATA_IMM storing the completed request's seqno
<span class="lineNum">    1772 </span>            :          * occasionally doesn't invalidate the CPU cache. Work around this by
<span class="lineNum">    1773 </span>            :          * clflushing the corresponding cacheline whenever the caller wants
<span class="lineNum">    1774 </span>            :          * the coherency to be guaranteed. Note that this cacheline is known
<span class="lineNum">    1775 </span>            :          * to be clean at this point, since we only write it in
<span class="lineNum">    1776 </span>            :          * bxt_a_set_seqno(), where we also do a clflush after the write. So
<span class="lineNum">    1777 </span>            :          * this clflush in practice becomes an invalidate operation.
<span class="lineNum">    1778 </span>            :          */
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :         if (!lazy_coherency)</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :                 intel_flush_status_page(ring, I915_GEM_HWS_INDEX);</span>
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :         return intel_read_status_page(ring, I915_GEM_HWS_INDEX);</span>
<a name="1784"><span class="lineNum">    1784 </span>            : }</a>
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 : static void bxt_a_set_seqno(struct intel_engine_cs *ring, u32 seqno)</span>
<span class="lineNum">    1787 </span>            : {
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :         intel_write_status_page(ring, I915_GEM_HWS_INDEX, seqno);</span>
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            :         /* See bxt_a_get_seqno() explaining the reason for the clflush. */
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :         intel_flush_status_page(ring, I915_GEM_HWS_INDEX);</span>
<a name="1792"><span class="lineNum">    1792 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 : static int gen8_emit_request(struct drm_i915_gem_request *request)</span>
<span class="lineNum">    1795 </span>            : {
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :         struct intel_ringbuffer *ringbuf = request-&gt;ringbuf;</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = ringbuf-&gt;ring;</span>
<span class="lineNum">    1798 </span>            :         u32 cmd;
<span class="lineNum">    1799 </span>            :         int ret;
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            :         /*
<span class="lineNum">    1802 </span>            :          * Reserve space for 2 NOOPs at the end of each request to be
<span class="lineNum">    1803 </span>            :          * used as a workaround for not being allowed to do lite
<span class="lineNum">    1804 </span>            :          * restore with HEAD==TAIL (WaIdleLiteRestore).
<span class="lineNum">    1805 </span>            :          */
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_begin(request, 8);</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :         cmd = MI_STORE_DWORD_IMM_GEN4;
<span class="lineNum">    1811 </span>            :         cmd |= MI_GLOBAL_GTT;
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, cmd);</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf,</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :                                 (ring-&gt;status_page.gfx_addr +</span>
<span class="lineNum">    1816 </span>            :                                 (I915_GEM_HWS_INDEX &lt;&lt; MI_STORE_DWORD_INDEX_SHIFT)));
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, 0);</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, i915_gem_request_get_seqno(request));</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_USER_INTERRUPT);</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance_and_submit(request);</span>
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :         /*
<span class="lineNum">    1824 </span>            :          * Here we add two extra NOOPs as padding to avoid
<span class="lineNum">    1825 </span>            :          * lite restore of a context with HEAD==TAIL.
<span class="lineNum">    1826 </span>            :          */
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :         intel_logical_ring_emit(ringbuf, MI_NOOP);</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :         intel_logical_ring_advance(ringbuf);</span>
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1832"><span class="lineNum">    1832 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 : static int intel_lr_context_render_state_init(struct drm_i915_gem_request *req)</span>
<span class="lineNum">    1835 </span>            : {
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :         struct render_state so;</span>
<span class="lineNum">    1837 </span>            :         int ret;
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :         ret = i915_gem_render_state_prepare(req-&gt;ring, &amp;so);</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :         if (so.rodata == NULL)</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :         ret = req-&gt;ring-&gt;emit_bb_start(req, so.ggtt_offset,</span>
<span class="lineNum">    1847 </span>            :                                        I915_DISPATCH_SECURE);
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1849 </span>            :                 goto out;
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :         ret = req-&gt;ring-&gt;emit_bb_start(req,</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :                                        (so.ggtt_offset + so.aux_batch_offset),</span>
<span class="lineNum">    1853 </span>            :                                        I915_DISPATCH_SECURE);
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1855 </span>            :                 goto out;
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :         i915_vma_move_to_active(i915_gem_obj_to_ggtt(so.obj), req);</span>
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            : out:
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :         i915_gem_render_state_fini(&amp;so);</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="1862"><span class="lineNum">    1862 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 : static int gen8_init_rcs_context(struct drm_i915_gem_request *req)</span>
<span class="lineNum">    1865 </span>            : {
<span class="lineNum">    1866 </span>            :         int ret;
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :         ret = intel_logical_ring_workarounds_emit(req);</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :         ret = intel_rcs_context_init_mocs(req);</span>
<span class="lineNum">    1873 </span>            :         /*
<span class="lineNum">    1874 </span>            :          * Failing to program the MOCS is non-fatal.The system will not
<span class="lineNum">    1875 </span>            :          * run at peak performance. So generate an error and carry on.
<span class="lineNum">    1876 </span>            :          */
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;MOCS failed to program: expect performance issues.\n&quot;);</span>
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :         return intel_lr_context_render_state_init(req);</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            : /**
<span class="lineNum">    1884 </span>            :  * intel_logical_ring_cleanup() - deallocate the Engine Command Streamer
<span class="lineNum">    1885 </span>            :  *
<span class="lineNum">    1886 </span>            :  * @ring: Engine Command Streamer.
<a name="1887"><span class="lineNum">    1887 </span>            :  *</a>
<span class="lineNum">    1888 </span>            :  */
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 : void intel_logical_ring_cleanup(struct intel_engine_cs *ring)</span>
<span class="lineNum">    1890 </span>            : {
<span class="lineNum">    1891 </span>            :         struct drm_i915_private *dev_priv;
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :         if (!intel_ring_initialized(ring))</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :         dev_priv = ring-&gt;dev-&gt;dev_private;</span>
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :         intel_logical_ring_stop(ring);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :         WARN_ON((I915_READ_MODE(ring) &amp; MODE_IDLE) == 0);</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :         if (ring-&gt;cleanup)</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :                 ring-&gt;cleanup(ring);</span>
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :         i915_cmd_parser_fini_ring(ring);</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :         i915_gem_batch_pool_fini(&amp;ring-&gt;batch_pool);</span>
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :         if (ring-&gt;status_page.obj) {</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                 kunmap(sg_page(ring-&gt;status_page.obj-&gt;pages-&gt;sgl));</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                 ring-&gt;status_page.obj = NULL;</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :         lrc_destroy_wa_ctx_obj(ring);</span>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 : static int logical_ring_init(struct drm_device *dev, struct intel_engine_cs *ring)</span>
<span class="lineNum">    1916 </span>            : {
<span class="lineNum">    1917 </span>            :         int ret;
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            :         /* Intentionally left blank. */
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :         ring-&gt;buffer = NULL;</span>
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :         ring-&gt;dev = dev;</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :         INIT_LIST_HEAD(&amp;ring-&gt;active_list);</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :         INIT_LIST_HEAD(&amp;ring-&gt;request_list);</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :         i915_gem_batch_pool_init(dev, &amp;ring-&gt;batch_pool);</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :         init_waitqueue_head(&amp;ring-&gt;irq_queue);</span>
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :         INIT_LIST_HEAD(&amp;ring-&gt;execlist_queue);</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :         INIT_LIST_HEAD(&amp;ring-&gt;execlist_retired_req_list);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :         mtx_init(&amp;ring-&gt;execlist_lock, IPL_TTY);</span>
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :         ret = i915_cmd_parser_init_ring(ring);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :         ret = intel_lr_context_deferred_alloc(ring-&gt;default_context, ring);</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :         /* As this is the default context, always pin it */
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :         ret = intel_lr_context_do_pin(</span>
<span class="lineNum">    1942 </span>            :                         ring,
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :                         ring-&gt;default_context-&gt;engine[ring-&gt;id].state,</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :                         ring-&gt;default_context-&gt;engine[ring-&gt;id].ringbuf);</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :                 DRM_ERROR(</span>
<span class="lineNum">    1947 </span>            :                         &quot;Failed to pin and map ringbuffer %s: %d\n&quot;,
<span class="lineNum">    1948 </span>            :                         ring-&gt;name, ret);
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1950 </span>            :         }
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="1953"><span class="lineNum">    1953 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 : static int logical_render_ring_init(struct drm_device *dev)</span>
<span class="lineNum">    1956 </span>            : {
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = &amp;dev_priv-&gt;ring[RCS];</span>
<span class="lineNum">    1959 </span>            :         int ret;
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :         ring-&gt;name = &quot;render ring&quot;;</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :         ring-&gt;id = RCS;</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :         ring-&gt;mmio_base = RENDER_RING_BASE;</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :         ring-&gt;irq_enable_mask =</span>
<span class="lineNum">    1965 </span>            :                 GT_RENDER_USER_INTERRUPT &lt;&lt; GEN8_RCS_IRQ_SHIFT;
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         ring-&gt;irq_keep_mask =</span>
<span class="lineNum">    1967 </span>            :                 GT_CONTEXT_SWITCH_INTERRUPT &lt;&lt; GEN8_RCS_IRQ_SHIFT;
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :         if (HAS_L3_DPF(dev))</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :                 ring-&gt;irq_keep_mask |= GT_RENDER_L3_PARITY_ERROR_INTERRUPT;</span>
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(dev)-&gt;gen &gt;= 9)</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :                 ring-&gt;init_hw = gen9_init_render_ring;</span>
<span class="lineNum">    1973 </span>            :         else
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :                 ring-&gt;init_hw = gen8_init_render_ring;</span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :         ring-&gt;init_context = gen8_init_rcs_context;</span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :         ring-&gt;cleanup = intel_fini_pipe_control;</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :         if (IS_BXT_REVID(dev, 0, BXT_REVID_A1)) {</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = bxt_a_get_seqno;</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = bxt_a_set_seqno;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = gen8_get_seqno;</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = gen8_set_seqno;</span>
<span class="lineNum">    1983 </span>            :         }
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :         ring-&gt;emit_request = gen8_emit_request;</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         ring-&gt;emit_flush = gen8_emit_flush_render;</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :         ring-&gt;irq_get = gen8_logical_ring_get_irq;</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :         ring-&gt;irq_put = gen8_logical_ring_put_irq;</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :         ring-&gt;emit_bb_start = gen8_emit_bb_start;</span>
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         ring-&gt;dev = dev;</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :         ret = intel_init_pipe_control(ring);</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :         ret = intel_init_workaround_bb(ring);</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    1998 </span>            :                 /*
<span class="lineNum">    1999 </span>            :                  * We continue even if we fail to initialize WA batch
<span class="lineNum">    2000 </span>            :                  * because we only expect rare glitches but nothing
<span class="lineNum">    2001 </span>            :                  * critical to prevent us from using GPU
<span class="lineNum">    2002 </span>            :                  */
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;WA batch buffer initialization failed: %d\n&quot;,</span>
<span class="lineNum">    2004 </span>            :                           ret);
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :         ret = logical_ring_init(dev, ring);</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :                 lrc_destroy_wa_ctx_obj(ring);</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 : static int logical_bsd_ring_init(struct drm_device *dev)</span>
<span class="lineNum">    2016 </span>            : {
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = &amp;dev_priv-&gt;ring[VCS];</span>
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :         ring-&gt;name = &quot;bsd ring&quot;;</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :         ring-&gt;id = VCS;</span>
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :         ring-&gt;mmio_base = GEN6_BSD_RING_BASE;</span>
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :         ring-&gt;irq_enable_mask =</span>
<span class="lineNum">    2024 </span>            :                 GT_RENDER_USER_INTERRUPT &lt;&lt; GEN8_VCS1_IRQ_SHIFT;
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :         ring-&gt;irq_keep_mask =</span>
<span class="lineNum">    2026 </span>            :                 GT_CONTEXT_SWITCH_INTERRUPT &lt;&lt; GEN8_VCS1_IRQ_SHIFT;
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :         ring-&gt;init_hw = gen8_init_common_ring;</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :         if (IS_BXT_REVID(dev, 0, BXT_REVID_A1)) {</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = bxt_a_get_seqno;</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = bxt_a_set_seqno;</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = gen8_get_seqno;</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = gen8_set_seqno;</span>
<span class="lineNum">    2035 </span>            :         }
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :         ring-&gt;emit_request = gen8_emit_request;</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :         ring-&gt;emit_flush = gen8_emit_flush;</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :         ring-&gt;irq_get = gen8_logical_ring_get_irq;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :         ring-&gt;irq_put = gen8_logical_ring_put_irq;</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :         ring-&gt;emit_bb_start = gen8_emit_bb_start;</span>
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :         return logical_ring_init(dev, ring);</span>
<a name="2043"><span class="lineNum">    2043 </span>            : }</a>
<span class="lineNum">    2044 </span>            : 
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 : static int logical_bsd2_ring_init(struct drm_device *dev)</span>
<span class="lineNum">    2046 </span>            : {
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = &amp;dev_priv-&gt;ring[VCS2];</span>
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :         ring-&gt;name = &quot;bds2 ring&quot;;</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :         ring-&gt;id = VCS2;</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :         ring-&gt;mmio_base = GEN8_BSD2_RING_BASE;</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :         ring-&gt;irq_enable_mask =</span>
<span class="lineNum">    2054 </span>            :                 GT_RENDER_USER_INTERRUPT &lt;&lt; GEN8_VCS2_IRQ_SHIFT;
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :         ring-&gt;irq_keep_mask =</span>
<span class="lineNum">    2056 </span>            :                 GT_CONTEXT_SWITCH_INTERRUPT &lt;&lt; GEN8_VCS2_IRQ_SHIFT;
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :         ring-&gt;init_hw = gen8_init_common_ring;</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :         ring-&gt;get_seqno = gen8_get_seqno;</span>
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :         ring-&gt;set_seqno = gen8_set_seqno;</span>
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :         ring-&gt;emit_request = gen8_emit_request;</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :         ring-&gt;emit_flush = gen8_emit_flush;</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :         ring-&gt;irq_get = gen8_logical_ring_get_irq;</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :         ring-&gt;irq_put = gen8_logical_ring_put_irq;</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :         ring-&gt;emit_bb_start = gen8_emit_bb_start;</span>
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :         return logical_ring_init(dev, ring);</span>
<a name="2068"><span class="lineNum">    2068 </span>            : }</a>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 : static int logical_blt_ring_init(struct drm_device *dev)</span>
<span class="lineNum">    2071 </span>            : {
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = &amp;dev_priv-&gt;ring[BCS];</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         ring-&gt;name = &quot;blitter ring&quot;;</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :         ring-&gt;id = BCS;</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :         ring-&gt;mmio_base = BLT_RING_BASE;</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :         ring-&gt;irq_enable_mask =</span>
<span class="lineNum">    2079 </span>            :                 GT_RENDER_USER_INTERRUPT &lt;&lt; GEN8_BCS_IRQ_SHIFT;
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :         ring-&gt;irq_keep_mask =</span>
<span class="lineNum">    2081 </span>            :                 GT_CONTEXT_SWITCH_INTERRUPT &lt;&lt; GEN8_BCS_IRQ_SHIFT;
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :         ring-&gt;init_hw = gen8_init_common_ring;</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         if (IS_BXT_REVID(dev, 0, BXT_REVID_A1)) {</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = bxt_a_get_seqno;</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = bxt_a_set_seqno;</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = gen8_get_seqno;</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = gen8_set_seqno;</span>
<span class="lineNum">    2090 </span>            :         }
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :         ring-&gt;emit_request = gen8_emit_request;</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :         ring-&gt;emit_flush = gen8_emit_flush;</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :         ring-&gt;irq_get = gen8_logical_ring_get_irq;</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :         ring-&gt;irq_put = gen8_logical_ring_put_irq;</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :         ring-&gt;emit_bb_start = gen8_emit_bb_start;</span>
<span class="lineNum">    2096 </span>            : 
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :         return logical_ring_init(dev, ring);</span>
<a name="2098"><span class="lineNum">    2098 </span>            : }</a>
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 : static int logical_vebox_ring_init(struct drm_device *dev)</span>
<span class="lineNum">    2101 </span>            : {
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         struct intel_engine_cs *ring = &amp;dev_priv-&gt;ring[VECS];</span>
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :         ring-&gt;name = &quot;video enhancement ring&quot;;</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :         ring-&gt;id = VECS;</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :         ring-&gt;mmio_base = VEBOX_RING_BASE;</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :         ring-&gt;irq_enable_mask =</span>
<span class="lineNum">    2109 </span>            :                 GT_RENDER_USER_INTERRUPT &lt;&lt; GEN8_VECS_IRQ_SHIFT;
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :         ring-&gt;irq_keep_mask =</span>
<span class="lineNum">    2111 </span>            :                 GT_CONTEXT_SWITCH_INTERRUPT &lt;&lt; GEN8_VECS_IRQ_SHIFT;
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :         ring-&gt;init_hw = gen8_init_common_ring;</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :         if (IS_BXT_REVID(dev, 0, BXT_REVID_A1)) {</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = bxt_a_get_seqno;</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = bxt_a_set_seqno;</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :                 ring-&gt;get_seqno = gen8_get_seqno;</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :                 ring-&gt;set_seqno = gen8_set_seqno;</span>
<span class="lineNum">    2120 </span>            :         }
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :         ring-&gt;emit_request = gen8_emit_request;</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :         ring-&gt;emit_flush = gen8_emit_flush;</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :         ring-&gt;irq_get = gen8_logical_ring_get_irq;</span>
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :         ring-&gt;irq_put = gen8_logical_ring_put_irq;</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :         ring-&gt;emit_bb_start = gen8_emit_bb_start;</span>
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :         return logical_ring_init(dev, ring);</span>
<span class="lineNum">    2128 </span>            : }
<span class="lineNum">    2129 </span>            : 
<span class="lineNum">    2130 </span>            : /**
<span class="lineNum">    2131 </span>            :  * intel_logical_rings_init() - allocate, populate and init the Engine Command Streamers
<span class="lineNum">    2132 </span>            :  * @dev: DRM device.
<span class="lineNum">    2133 </span>            :  *
<span class="lineNum">    2134 </span>            :  * This function inits the engines for an Execlists submission style (the equivalent in the
<span class="lineNum">    2135 </span>            :  * legacy ringbuffer submission world would be i915_gem_init_rings). It does it only for
<span class="lineNum">    2136 </span>            :  * those engines that are present in the hardware.
<span class="lineNum">    2137 </span>            :  *
<a name="2138"><span class="lineNum">    2138 </span>            :  * Return: non-zero if the initialization failed.</a>
<span class="lineNum">    2139 </span>            :  */
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 : int intel_logical_rings_init(struct drm_device *dev)</span>
<span class="lineNum">    2141 </span>            : {
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2143 </span>            :         int ret;
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :         ret = logical_render_ring_init(dev);</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         if (HAS_BSD(dev)) {</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                 ret = logical_bsd_ring_init(dev);</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    2152 </span>            :                         goto cleanup_render_ring;
<span class="lineNum">    2153 </span>            :         }
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :         if (HAS_BLT(dev)) {</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :                 ret = logical_blt_ring_init(dev);</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    2158 </span>            :                         goto cleanup_bsd_ring;
<span class="lineNum">    2159 </span>            :         }
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :         if (HAS_VEBOX(dev)) {</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :                 ret = logical_vebox_ring_init(dev);</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    2164 </span>            :                         goto cleanup_blt_ring;
<span class="lineNum">    2165 </span>            :         }
<span class="lineNum">    2166 </span>            : 
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :         if (HAS_BSD2(dev)) {</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :                 ret = logical_bsd2_ring_init(dev);</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :                 if (ret)</span>
<span class="lineNum">    2170 </span>            :                         goto cleanup_vebox_ring;
<span class="lineNum">    2171 </span>            :         }
<span class="lineNum">    2172 </span>            : 
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span>            : cleanup_vebox_ring:
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :         intel_logical_ring_cleanup(&amp;dev_priv-&gt;ring[VECS]);</span>
<span class="lineNum">    2177 </span>            : cleanup_blt_ring:
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :         intel_logical_ring_cleanup(&amp;dev_priv-&gt;ring[BCS]);</span>
<span class="lineNum">    2179 </span>            : cleanup_bsd_ring:
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :         intel_logical_ring_cleanup(&amp;dev_priv-&gt;ring[VCS]);</span>
<span class="lineNum">    2181 </span>            : cleanup_render_ring:
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :         intel_logical_ring_cleanup(&amp;dev_priv-&gt;ring[RCS]);</span>
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 : }</span>
<a name="2186"><span class="lineNum">    2186 </span>            : </a>
<span class="lineNum">    2187 </span>            : static u32
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 : make_rpcs(struct drm_device *dev)</span>
<span class="lineNum">    2189 </span>            : {
<span class="lineNum">    2190 </span>            :         u32 rpcs = 0;
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span>            :         /*
<span class="lineNum">    2193 </span>            :          * No explicit RPCS request is needed to ensure full
<span class="lineNum">    2194 </span>            :          * slice/subslice/EU enablement prior to Gen9.
<span class="lineNum">    2195 </span>            :         */
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(dev)-&gt;gen &lt; 9)</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span>            :         /*
<span class="lineNum">    2200 </span>            :          * Starting in Gen9, render power gating can leave
<span class="lineNum">    2201 </span>            :          * slice/subslice/EU in a partially enabled state. We
<span class="lineNum">    2202 </span>            :          * must make an explicit request through RPCS for full
<span class="lineNum">    2203 </span>            :          * enablement.
<span class="lineNum">    2204 </span>            :         */
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(dev)-&gt;has_slice_pg) {</span>
<span class="lineNum">    2206 </span>            :                 rpcs |= GEN8_RPCS_S_CNT_ENABLE;
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :                 rpcs |= INTEL_INFO(dev)-&gt;slice_total &lt;&lt;</span>
<span class="lineNum">    2208 </span>            :                         GEN8_RPCS_S_CNT_SHIFT;
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :                 rpcs |= GEN8_RPCS_ENABLE;</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(dev)-&gt;has_subslice_pg) {</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :                 rpcs |= GEN8_RPCS_SS_CNT_ENABLE;</span>
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :                 rpcs |= INTEL_INFO(dev)-&gt;subslice_per_slice &lt;&lt;</span>
<span class="lineNum">    2215 </span>            :                         GEN8_RPCS_SS_CNT_SHIFT;
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :                 rpcs |= GEN8_RPCS_ENABLE;</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :         if (INTEL_INFO(dev)-&gt;has_eu_pg) {</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :                 rpcs |= INTEL_INFO(dev)-&gt;eu_per_subslice &lt;&lt;</span>
<span class="lineNum">    2221 </span>            :                         GEN8_RPCS_EU_MIN_SHIFT;
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :                 rpcs |= INTEL_INFO(dev)-&gt;eu_per_subslice &lt;&lt;</span>
<span class="lineNum">    2223 </span>            :                         GEN8_RPCS_EU_MAX_SHIFT;
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :                 rpcs |= GEN8_RPCS_ENABLE;</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :         return rpcs;</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 : }</span>
<a name="2229"><span class="lineNum">    2229 </span>            : </a>
<span class="lineNum">    2230 </span>            : static int
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 : populate_lr_context(struct intel_context *ctx, struct drm_i915_gem_object *ctx_obj,</span>
<span class="lineNum">    2232 </span>            :                     struct intel_engine_cs *ring, struct intel_ringbuffer *ringbuf)
<span class="lineNum">    2233 </span>            : {
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :         struct i915_hw_ppgtt *ppgtt = ctx-&gt;ppgtt;</span>
<span class="lineNum">    2237 </span>            :         struct vm_page *page;
<span class="lineNum">    2238 </span>            :         uint32_t *reg_state;
<span class="lineNum">    2239 </span>            :         int ret;
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :         if (!ppgtt)</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :                 ppgtt = dev_priv-&gt;mm.aliasing_ppgtt;</span>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :         ret = i915_gem_object_set_to_cpu_domain(ctx_obj, true);</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    2246 </span>            :                 DRM_DEBUG_DRIVER(&quot;Could not set to CPU domain\n&quot;);
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    2248 </span>            :         }
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :         ret = i915_gem_object_get_pages(ctx_obj);</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    2252 </span>            :                 DRM_DEBUG_DRIVER(&quot;Could not get object pages\n&quot;);
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    2254 </span>            :         }
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :         i915_gem_object_pin_pages(ctx_obj);</span>
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span>            :         /* The second page of the context object contains some fields which must
<span class="lineNum">    2259 </span>            :          * be set up prior to the first execution. */
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :         page = i915_gem_object_get_page(ctx_obj, LRC_STATE_PN);</span>
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :         reg_state = kmap_atomic(page);</span>
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span>            :         /* A context is actually a big batch buffer with several MI_LOAD_REGISTER_IMM
<span class="lineNum">    2264 </span>            :          * commands followed by (reg, value) pairs. The values we are setting here are
<span class="lineNum">    2265 </span>            :          * only for the first context restore: on a subsequent save, the GPU will
<span class="lineNum">    2266 </span>            :          * recreate this batchbuffer with new values (including all the missing
<span class="lineNum">    2267 </span>            :          * MI_LOAD_REGISTER_IMM commands that we are not initializing here). */
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         if (ring-&gt;id == RCS)</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :                 reg_state[CTX_LRI_HEADER_0] = MI_LOAD_REGISTER_IMM(14);</span>
<span class="lineNum">    2270 </span>            :         else
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :                 reg_state[CTX_LRI_HEADER_0] = MI_LOAD_REGISTER_IMM(11);</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         reg_state[CTX_LRI_HEADER_0] |= MI_LRI_FORCE_POSTED;</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         reg_state[CTX_CONTEXT_CONTROL] = RING_CONTEXT_CONTROL(ring);</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :         reg_state[CTX_CONTEXT_CONTROL+1] =</span>
<span class="lineNum">    2275 </span>            :                 _MASKED_BIT_ENABLE(CTX_CTRL_INHIBIT_SYN_CTX_SWITCH |
<span class="lineNum">    2276 </span>            :                                    CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT |
<span class="lineNum">    2277 </span>            :                                    CTX_CTRL_RS_CTX_ENABLE);
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_HEAD] = RING_HEAD(ring-&gt;mmio_base);</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_HEAD+1] = 0;</span>
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_TAIL] = RING_TAIL(ring-&gt;mmio_base);</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_TAIL+1] = 0;</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_BUFFER_START] = RING_START(ring-&gt;mmio_base);</span>
<span class="lineNum">    2283 </span>            :         /* Ring buffer start address is not known until the buffer is pinned.
<span class="lineNum">    2284 </span>            :          * It is written to the context image in execlists_update_context()
<span class="lineNum">    2285 </span>            :          */
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_BUFFER_CONTROL] = RING_CTL(ring-&gt;mmio_base);</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :         reg_state[CTX_RING_BUFFER_CONTROL+1] =</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :                         ((ringbuf-&gt;size - PAGE_SIZE) &amp; RING_NR_PAGES) | RING_VALID;</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :         reg_state[CTX_BB_HEAD_U] = ring-&gt;mmio_base + 0x168;</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         reg_state[CTX_BB_HEAD_U+1] = 0;</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :         reg_state[CTX_BB_HEAD_L] = ring-&gt;mmio_base + 0x140;</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :         reg_state[CTX_BB_HEAD_L+1] = 0;</span>
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         reg_state[CTX_BB_STATE] = ring-&gt;mmio_base + 0x110;</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :         reg_state[CTX_BB_STATE+1] = (1&lt;&lt;5);</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :         reg_state[CTX_SECOND_BB_HEAD_U] = ring-&gt;mmio_base + 0x11c;</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :         reg_state[CTX_SECOND_BB_HEAD_U+1] = 0;</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :         reg_state[CTX_SECOND_BB_HEAD_L] = ring-&gt;mmio_base + 0x114;</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :         reg_state[CTX_SECOND_BB_HEAD_L+1] = 0;</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :         reg_state[CTX_SECOND_BB_STATE] = ring-&gt;mmio_base + 0x118;</span>
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :         reg_state[CTX_SECOND_BB_STATE+1] = 0;</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :         if (ring-&gt;id == RCS) {</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :                 reg_state[CTX_BB_PER_CTX_PTR] = ring-&gt;mmio_base + 0x1c0;</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :                 reg_state[CTX_BB_PER_CTX_PTR+1] = 0;</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :                 reg_state[CTX_RCS_INDIRECT_CTX] = ring-&gt;mmio_base + 0x1c4;</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :                 reg_state[CTX_RCS_INDIRECT_CTX+1] = 0;</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :                 reg_state[CTX_RCS_INDIRECT_CTX_OFFSET] = ring-&gt;mmio_base + 0x1c8;</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :                 reg_state[CTX_RCS_INDIRECT_CTX_OFFSET+1] = 0;</span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :                 if (ring-&gt;wa_ctx.obj) {</span>
<span class="lineNum">    2309 </span>            :                         struct i915_ctx_workarounds *wa_ctx = &amp;ring-&gt;wa_ctx;
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :                         uint32_t ggtt_offset = i915_gem_obj_ggtt_offset(wa_ctx-&gt;obj);</span>
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :                         reg_state[CTX_RCS_INDIRECT_CTX+1] =</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :                                 (ggtt_offset + wa_ctx-&gt;indirect_ctx.offset * sizeof(uint32_t)) |</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :                                 (wa_ctx-&gt;indirect_ctx.size / CACHELINE_DWORDS);</span>
<span class="lineNum">    2315 </span>            : 
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :                         reg_state[CTX_RCS_INDIRECT_CTX_OFFSET+1] =</span>
<span class="lineNum">    2317 </span>            :                                 CTX_RCS_INDIRECT_CTX_OFFSET_DEFAULT &lt;&lt; 6;
<span class="lineNum">    2318 </span>            : 
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :                         reg_state[CTX_BB_PER_CTX_PTR+1] =</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :                                 (ggtt_offset + wa_ctx-&gt;per_ctx.offset * sizeof(uint32_t)) |</span>
<span class="lineNum">    2321 </span>            :                                 0x01;
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    2323 </span>            :         }
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :         reg_state[CTX_LRI_HEADER_1] = MI_LOAD_REGISTER_IMM(9);</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :         reg_state[CTX_LRI_HEADER_1] |= MI_LRI_FORCE_POSTED;</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :         reg_state[CTX_CTX_TIMESTAMP] = ring-&gt;mmio_base + 0x3a8;</span>
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :         reg_state[CTX_CTX_TIMESTAMP+1] = 0;</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP3_UDW] = GEN8_RING_PDP_UDW(ring, 3);</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP3_LDW] = GEN8_RING_PDP_LDW(ring, 3);</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP2_UDW] = GEN8_RING_PDP_UDW(ring, 2);</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP2_LDW] = GEN8_RING_PDP_LDW(ring, 2);</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP1_UDW] = GEN8_RING_PDP_UDW(ring, 1);</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP1_LDW] = GEN8_RING_PDP_LDW(ring, 1);</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP0_UDW] = GEN8_RING_PDP_UDW(ring, 0);</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :         reg_state[CTX_PDP0_LDW] = GEN8_RING_PDP_LDW(ring, 0);</span>
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :         if (USES_FULL_48BIT_PPGTT(ppgtt-&gt;base.dev)) {</span>
<span class="lineNum">    2338 </span>            :                 /* 64b PPGTT (48bit canonical)
<span class="lineNum">    2339 </span>            :                  * PDP0_DESCRIPTOR contains the base address to PML4 and
<span class="lineNum">    2340 </span>            :                  * other PDP Descriptors are ignored.
<span class="lineNum">    2341 </span>            :                  */
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PML4(ppgtt, reg_state);</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    2344 </span>            :                 /* 32b PPGTT
<span class="lineNum">    2345 </span>            :                  * PDP*_DESCRIPTOR contains the base address of space supported.
<span class="lineNum">    2346 </span>            :                  * With dynamic page allocation, PDPs may not be allocated at
<span class="lineNum">    2347 </span>            :                  * this point. Point the unallocated PDPs to the scratch page
<span class="lineNum">    2348 </span>            :                  */
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 3);</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 2);</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 1);</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :                 ASSIGN_CTX_PDP(ppgtt, reg_state, 0);</span>
<span class="lineNum">    2353 </span>            :         }
<span class="lineNum">    2354 </span>            : 
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :         if (ring-&gt;id == RCS) {</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :                 reg_state[CTX_LRI_HEADER_2] = MI_LOAD_REGISTER_IMM(1);</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :                 reg_state[CTX_R_PWR_CLK_STATE] = GEN8_R_PWR_CLK_STATE;</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :                 reg_state[CTX_R_PWR_CLK_STATE+1] = make_rpcs(dev);</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :         kunmap_atomic(reg_state);</span>
<span class="lineNum">    2362 </span>            : 
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :         ctx_obj-&gt;dirty = 1;</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :         set_page_dirty(page);</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :         i915_gem_object_unpin_pages(ctx_obj);</span>
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span>            : /**
<span class="lineNum">    2371 </span>            :  * intel_lr_context_free() - free the LRC specific bits of a context
<span class="lineNum">    2372 </span>            :  * @ctx: the LR context to free.
<span class="lineNum">    2373 </span>            :  *
<span class="lineNum">    2374 </span>            :  * The real context freeing is done in i915_gem_context_free: this only
<span class="lineNum">    2375 </span>            :  * takes care of the bits that are LRC related: the per-engine backing
<a name="2376"><span class="lineNum">    2376 </span>            :  * objects and the logical ringbuffer.</a>
<span class="lineNum">    2377 </span>            :  */
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 : void intel_lr_context_free(struct intel_context *ctx)</span>
<span class="lineNum">    2379 </span>            : {
<span class="lineNum">    2380 </span>            :         int i;
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; I915_NUM_RINGS; i++) {</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :                 struct drm_i915_gem_object *ctx_obj = ctx-&gt;engine[i].state;</span>
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :                 if (ctx_obj) {</span>
<span class="lineNum">    2386 </span>            :                         struct intel_ringbuffer *ringbuf =
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :                                         ctx-&gt;engine[i].ringbuf;</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :                         struct intel_engine_cs *ring = ringbuf-&gt;ring;</span>
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :                         if (ctx == ring-&gt;default_context) {</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :                                 intel_unpin_ringbuffer_obj(ringbuf);</span>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :                                 i915_gem_object_ggtt_unpin(ctx_obj);</span>
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :                         WARN_ON(ctx-&gt;engine[ring-&gt;id].pin_count);</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :                         intel_ringbuffer_free(ringbuf);</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :                         drm_gem_object_unreference(&amp;ctx_obj-&gt;base);</span>
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    2398 </span>            :         }
<a name="2399"><span class="lineNum">    2399 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 : static uint32_t get_lr_context_size(struct intel_engine_cs *ring)</span>
<span class="lineNum">    2402 </span>            : {
<span class="lineNum">    2403 </span>            :         int ret = 0;
<span class="lineNum">    2404 </span>            : 
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :         WARN_ON(INTEL_INFO(ring-&gt;dev)-&gt;gen &lt; 8);</span>
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :         switch (ring-&gt;id) {</span>
<span class="lineNum">    2408 </span>            :         case RCS:
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :                 if (INTEL_INFO(ring-&gt;dev)-&gt;gen &gt;= 9)</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :                         ret = GEN9_LR_CONTEXT_RENDER_SIZE;</span>
<span class="lineNum">    2411 </span>            :                 else
<span class="lineNum">    2412 </span>            :                         ret = GEN8_LR_CONTEXT_RENDER_SIZE;
<span class="lineNum">    2413 </span>            :                 break;
<span class="lineNum">    2414 </span>            :         case VCS:
<span class="lineNum">    2415 </span>            :         case BCS:
<span class="lineNum">    2416 </span>            :         case VECS:
<span class="lineNum">    2417 </span>            :         case VCS2:
<span class="lineNum">    2418 </span>            :                 ret = GEN8_LR_CONTEXT_OTHER_SIZE;
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2420 </span>            :         }
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="2423"><span class="lineNum">    2423 </span>            : }</a>
<span class="lineNum">    2424 </span>            : 
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 : static void lrc_setup_hardware_status_page(struct intel_engine_cs *ring,</span>
<span class="lineNum">    2426 </span>            :                 struct drm_i915_gem_object *default_ctx_obj)
<span class="lineNum">    2427 </span>            : {
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = ring-&gt;dev-&gt;dev_private;</span>
<span class="lineNum">    2429 </span>            :         struct vm_page *page;
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span>            :         /* The HWSP is part of the default context object in LRC mode. */
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :         ring-&gt;status_page.gfx_addr = i915_gem_obj_ggtt_offset(default_ctx_obj)</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :                         + LRC_PPHWSP_PN * PAGE_SIZE;</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :         page = i915_gem_object_get_page(default_ctx_obj, LRC_PPHWSP_PN);</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :         ring-&gt;status_page.page_addr = kmap(page);</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :         ring-&gt;status_page.obj = default_ctx_obj;</span>
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :         I915_WRITE(RING_HWS_PGA(ring-&gt;mmio_base),</span>
<span class="lineNum">    2439 </span>            :                         (u32)ring-&gt;status_page.gfx_addr);
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :         POSTING_READ(RING_HWS_PGA(ring-&gt;mmio_base));</span>
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span>            : /**
<span class="lineNum">    2444 </span>            :  * intel_lr_context_deferred_alloc() - create the LRC specific bits of a context
<span class="lineNum">    2445 </span>            :  * @ctx: LR context to create.
<span class="lineNum">    2446 </span>            :  * @ring: engine to be used with the context.
<span class="lineNum">    2447 </span>            :  *
<span class="lineNum">    2448 </span>            :  * This function can be called more than once, with different engines, if we plan
<span class="lineNum">    2449 </span>            :  * to use the context with them. The context backing objects and the ringbuffers
<span class="lineNum">    2450 </span>            :  * (specially the ringbuffer backing objects) suck a lot of memory up, and that's why
<span class="lineNum">    2451 </span>            :  * the creation is a deferred call: it's better to make sure first that we need to use
<span class="lineNum">    2452 </span>            :  * a given ring with the context.
<span class="lineNum">    2453 </span>            :  *
<span class="lineNum">    2454 </span>            :  * Return: non-zero on error.
<a name="2455"><span class="lineNum">    2455 </span>            :  */</a>
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 : int intel_lr_context_deferred_alloc(struct intel_context *ctx,</span>
<span class="lineNum">    2458 </span>            :                                      struct intel_engine_cs *ring)
<span class="lineNum">    2459 </span>            : {
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :         struct drm_device *dev = ring-&gt;dev;</span>
<span class="lineNum">    2461 </span>            :         struct drm_i915_gem_object *ctx_obj;
<span class="lineNum">    2462 </span>            :         uint32_t context_size;
<span class="lineNum">    2463 </span>            :         struct intel_ringbuffer *ringbuf;
<span class="lineNum">    2464 </span>            :         int ret;
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :         WARN_ON(ctx-&gt;legacy_hw_ctx.rcs_state != NULL);</span>
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :         WARN_ON(ctx-&gt;engine[ring-&gt;id].state);</span>
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :         context_size = round_up(get_lr_context_size(ring), 4096);</span>
<span class="lineNum">    2470 </span>            : 
<span class="lineNum">    2471 </span>            :         /* One extra page as the sharing data between driver and GuC */
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :         context_size += PAGE_SIZE * LRC_PPHWSP_PN;</span>
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :         ctx_obj = i915_gem_alloc_object(dev, context_size);</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :         if (!ctx_obj) {</span>
<span class="lineNum">    2476 </span>            :                 DRM_DEBUG_DRIVER(&quot;Alloc LRC backing obj failed.\n&quot;);
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :                 return -ENOMEM;</span>
<span class="lineNum">    2478 </span>            :         }
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :         ringbuf = intel_engine_create_ringbuffer(ring, 4 * PAGE_SIZE);</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :         if (IS_ERR(ringbuf)) {</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :                 ret = PTR_ERR(ringbuf);</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :                 goto error_deref_obj;</span>
<span class="lineNum">    2484 </span>            :         }
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :         ret = populate_lr_context(ctx, ctx_obj, ring, ringbuf);</span>
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">    2488 </span>            :                 DRM_DEBUG_DRIVER(&quot;Failed to populate LRC: %d\n&quot;, ret);
<span class="lineNum">    2489 </span>            :                 goto error_ringbuf;
<span class="lineNum">    2490 </span>            :         }
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :         ctx-&gt;engine[ring-&gt;id].ringbuf = ringbuf;</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :         ctx-&gt;engine[ring-&gt;id].state = ctx_obj;</span>
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :         if (ctx != ring-&gt;default_context &amp;&amp; ring-&gt;init_context) {</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :                 struct drm_i915_gem_request *req;</span>
<span class="lineNum">    2497 </span>            : 
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :                 ret = i915_gem_request_alloc(ring,</span>
<span class="lineNum">    2499 </span>            :                         ctx, &amp;req);
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :                 if (ret) {</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;ring create req: %d\n&quot;,</span>
<span class="lineNum">    2502 </span>            :                                 ret);
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :                         goto error_ringbuf;</span>
<span class="lineNum">    2504 </span>            :                 }
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :                 ret = ring-&gt;init_context(req);</span>
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :                 if (ret) {</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;ring init context: %d\n&quot;,</span>
<span class="lineNum">    2509 </span>            :                                 ret);
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :                         i915_gem_request_cancel(req);</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :                         goto error_ringbuf;</span>
<span class="lineNum">    2512 </span>            :                 }
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :                 i915_add_request_no_flush(req);</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span>            : error_ringbuf:
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :         intel_ringbuffer_free(ringbuf);</span>
<span class="lineNum">    2519 </span>            : error_deref_obj:
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :         drm_gem_object_unreference(&amp;ctx_obj-&gt;base);</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :         ctx-&gt;engine[ring-&gt;id].ringbuf = NULL;</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :         ctx-&gt;engine[ring-&gt;id].state = NULL;</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="2524"><span class="lineNum">    2524 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 : void intel_lr_context_reset(struct drm_device *dev,</span>
<span class="lineNum">    2527 </span>            :                         struct intel_context *ctx)
<span class="lineNum">    2528 </span>            : {
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    2530 </span>            :         struct intel_engine_cs *ring;
<span class="lineNum">    2531 </span>            :         int i;
<span class="lineNum">    2532 </span>            : 
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :         for_each_ring(ring, dev_priv, i) {</span>
<span class="lineNum">    2534 </span>            :                 struct drm_i915_gem_object *ctx_obj =
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :                                 ctx-&gt;engine[ring-&gt;id].state;</span>
<span class="lineNum">    2536 </span>            :                 struct intel_ringbuffer *ringbuf =
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :                                 ctx-&gt;engine[ring-&gt;id].ringbuf;</span>
<span class="lineNum">    2538 </span>            :                 uint32_t *reg_state;
<span class="lineNum">    2539 </span>            :                 struct vm_page *page;
<span class="lineNum">    2540 </span>            : 
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :                 if (!ctx_obj)</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2543 </span>            : 
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :                 if (i915_gem_object_get_pages(ctx_obj)) {</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :                         WARN(1, &quot;Failed get_pages for context obj\n&quot;);</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2547 </span>            :                 }
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :                 page = i915_gem_object_get_page(ctx_obj, LRC_STATE_PN);</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :                 reg_state = kmap_atomic(page);</span>
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :                 reg_state[CTX_RING_HEAD+1] = 0;</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :                 reg_state[CTX_RING_TAIL+1] = 0;</span>
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :                 kunmap_atomic(reg_state);</span>
<span class="lineNum">    2555 </span>            : 
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :                 ringbuf-&gt;head = 0;</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :                 ringbuf-&gt;tail = 0;</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
