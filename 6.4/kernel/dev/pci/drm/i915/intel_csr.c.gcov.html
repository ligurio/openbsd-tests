<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/i915/intel_csr.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/i915</a> - intel_csr.c<span style="font-size: 80%;"> (source / <a href="intel_csr.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">60</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright Â© 2014 Intel Corporation
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       5 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">       6 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">       7 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">       8 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">       9 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      12 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      13 </span>            :  * Software.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      16 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      17 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      18 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      19 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      20 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
<span class="lineNum">      21 </span>            :  * IN THE SOFTWARE.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  */
<span class="lineNum">      24 </span>            : #ifdef __linux__
<span class="lineNum">      25 </span>            : #include &lt;linux/firmware.h&gt;
<span class="lineNum">      26 </span>            : #endif
<span class="lineNum">      27 </span>            : #include &quot;i915_drv.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;i915_reg.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : /**
<span class="lineNum">      31 </span>            :  * DOC: csr support for dmc
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * Display Context Save and Restore (CSR) firmware support added from gen9
<span class="lineNum">      34 </span>            :  * onwards to drive newly added DMC (Display microcontroller) in display
<span class="lineNum">      35 </span>            :  * engine to save and restore the state of display engine when it enter into
<span class="lineNum">      36 </span>            :  * low-power state and comes back to normal.
<span class="lineNum">      37 </span>            :  *
<span class="lineNum">      38 </span>            :  * Firmware loading status will be one of the below states: FW_UNINITIALIZED,
<span class="lineNum">      39 </span>            :  * FW_LOADED, FW_FAILED.
<span class="lineNum">      40 </span>            :  *
<span class="lineNum">      41 </span>            :  * Once the firmware is written into the registers status will be moved from
<span class="lineNum">      42 </span>            :  * FW_UNINITIALIZED to FW_LOADED and for any erroneous condition status will
<span class="lineNum">      43 </span>            :  * be moved to FW_FAILED.
<span class="lineNum">      44 </span>            :  */
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #define I915_CSR_KBL &quot;i915/kbl_dmc_ver1.bin&quot;
<span class="lineNum">      47 </span>            : #define I915_CSR_SKL &quot;i915/skl_dmc_ver1.bin&quot;
<span class="lineNum">      48 </span>            : #define I915_CSR_BXT &quot;i915/bxt_dmc_ver1.bin&quot;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : MODULE_FIRMWARE(I915_CSR_KBL);
<span class="lineNum">      51 </span>            : MODULE_FIRMWARE(I915_CSR_SKL);
<span class="lineNum">      52 </span>            : MODULE_FIRMWARE(I915_CSR_BXT);
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /*
<span class="lineNum">      55 </span>            : * SKL CSR registers for DC5 and DC6
<span class="lineNum">      56 </span>            : */
<span class="lineNum">      57 </span>            : #define CSR_PROGRAM(i)                  (0x80000 + (i) * 4)
<span class="lineNum">      58 </span>            : #define CSR_SSP_BASE_ADDR_GEN9          0x00002FC0
<span class="lineNum">      59 </span>            : #define CSR_HTP_ADDR_SKL                0x00500034
<span class="lineNum">      60 </span>            : #define CSR_SSP_BASE                    0x8F074
<span class="lineNum">      61 </span>            : #define CSR_HTP_SKL                     0x8F004
<span class="lineNum">      62 </span>            : #define CSR_LAST_WRITE                  0x8F034
<span class="lineNum">      63 </span>            : #define CSR_LAST_WRITE_VALUE            0xc003b400
<span class="lineNum">      64 </span>            : /* MMIO address range for CSR program (0x80000 - 0x82FFF) */
<span class="lineNum">      65 </span>            : #define CSR_MAX_FW_SIZE                 0x2FFF
<span class="lineNum">      66 </span>            : #define CSR_DEFAULT_FW_OFFSET           0xFFFFFFFF
<span class="lineNum">      67 </span>            : #define CSR_MMIO_START_RANGE    0x80000
<span class="lineNum">      68 </span>            : #define CSR_MMIO_END_RANGE              0x8FFFF
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : struct intel_css_header {
<span class="lineNum">      71 </span>            :         /* 0x09 for DMC */
<span class="lineNum">      72 </span>            :         uint32_t module_type;
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :         /* Includes the DMC specific header in dwords */
<span class="lineNum">      75 </span>            :         uint32_t header_len;
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :         /* always value would be 0x10000 */
<span class="lineNum">      78 </span>            :         uint32_t header_ver;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :         /* Not used */
<span class="lineNum">      81 </span>            :         uint32_t module_id;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :         /* Not used */
<span class="lineNum">      84 </span>            :         uint32_t module_vendor;
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :         /* in YYYYMMDD format */
<span class="lineNum">      87 </span>            :         uint32_t date;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :         /* Size in dwords (CSS_Headerlen + PackageHeaderLen + dmc FWsLen)/4 */
<span class="lineNum">      90 </span>            :         uint32_t size;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :         /* Not used */
<span class="lineNum">      93 </span>            :         uint32_t key_size;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :         /* Not used */
<span class="lineNum">      96 </span>            :         uint32_t modulus_size;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :         /* Not used */
<span class="lineNum">      99 </span>            :         uint32_t exponent_size;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :         /* Not used */
<span class="lineNum">     102 </span>            :         uint32_t reserved1[12];
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :         /* Major Minor */
<span class="lineNum">     105 </span>            :         uint32_t version;
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :         /* Not used */
<span class="lineNum">     108 </span>            :         uint32_t reserved2[8];
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :         /* Not used */
<span class="lineNum">     111 </span>            :         uint32_t kernel_header_info;
<span class="lineNum">     112 </span>            : } __packed;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : struct intel_fw_info {
<span class="lineNum">     115 </span>            :         uint16_t reserved1;
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :         /* Stepping (A, B, C, ..., *). * is a wildcard */
<span class="lineNum">     118 </span>            :         char stepping;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :         /* Sub-stepping (0, 1, ..., *). * is a wildcard */
<span class="lineNum">     121 </span>            :         char substepping;
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            :         uint32_t offset;
<span class="lineNum">     124 </span>            :         uint32_t reserved2;
<span class="lineNum">     125 </span>            : } __packed;
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : struct intel_package_header {
<span class="lineNum">     128 </span>            :         /* DMC container header length in dwords */
<span class="lineNum">     129 </span>            :         unsigned char header_len;
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :         /* always value would be 0x01 */
<span class="lineNum">     132 </span>            :         unsigned char header_ver;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :         unsigned char reserved[10];
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :         /* Number of valid entries in the FWInfo array below */
<span class="lineNum">     137 </span>            :         uint32_t num_entries;
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :         struct intel_fw_info fw_info[20];
<span class="lineNum">     140 </span>            : } __packed;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : struct intel_dmc_header {
<span class="lineNum">     143 </span>            :         /* always value would be 0x40403E3E */
<span class="lineNum">     144 </span>            :         uint32_t signature;
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :         /* DMC binary header length */
<span class="lineNum">     147 </span>            :         unsigned char header_len;
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :         /* 0x01 */
<span class="lineNum">     150 </span>            :         unsigned char header_ver;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :         /* Reserved */
<span class="lineNum">     153 </span>            :         uint16_t dmcc_ver;
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :         /* Major, Minor */
<span class="lineNum">     156 </span>            :         uint32_t        project;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :         /* Firmware program size (excluding header) in dwords */
<span class="lineNum">     159 </span>            :         uint32_t        fw_size;
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :         /* Major Minor version */
<span class="lineNum">     162 </span>            :         uint32_t fw_version;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :         /* Number of valid MMIO cycles present. */
<span class="lineNum">     165 </span>            :         uint32_t mmio_count;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :         /* MMIO address */
<span class="lineNum">     168 </span>            :         uint32_t mmioaddr[8];
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :         /* MMIO data */
<span class="lineNum">     171 </span>            :         uint32_t mmiodata[8];
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :         /* FW filename  */
<span class="lineNum">     174 </span>            :         unsigned char dfile[32];
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :         uint32_t reserved1[2];
<span class="lineNum">     177 </span>            : } __packed;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : #ifdef __linux__
<span class="lineNum">     180 </span>            : struct stepping_info {
<span class="lineNum">     181 </span>            :         char stepping;
<span class="lineNum">     182 </span>            :         char substepping;
<span class="lineNum">     183 </span>            : };
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /*
<span class="lineNum">     186 </span>            :  * Kabylake derivated from Skylake H0, so SKL H0
<span class="lineNum">     187 </span>            :  * is the right firmware for KBL A0 (revid 0).
<span class="lineNum">     188 </span>            :  */
<span class="lineNum">     189 </span>            : static const struct stepping_info kbl_stepping_info[] = {
<span class="lineNum">     190 </span>            :         {'H', '0'}, {'I', '0'}
<span class="lineNum">     191 </span>            : };
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : static const struct stepping_info skl_stepping_info[] = {
<span class="lineNum">     194 </span>            :                 {'A', '0'}, {'B', '0'}, {'C', '0'},
<span class="lineNum">     195 </span>            :                 {'D', '0'}, {'E', '0'}, {'F', '0'},
<span class="lineNum">     196 </span>            :                 {'G', '0'}, {'H', '0'}, {'I', '0'},
<span class="lineNum">     197 </span>            :                 {'J', '0'}, {'K', '0'}
<span class="lineNum">     198 </span>            : };
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : static struct stepping_info bxt_stepping_info[] = {
<span class="lineNum">     201 </span>            :         {'A', '0'}, {'A', '1'}, {'A', '2'},
<span class="lineNum">     202 </span>            :         {'B', '0'}, {'B', '1'}, {'B', '2'}
<span class="lineNum">     203 </span>            : };
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            : static char intel_get_stepping(struct drm_device *dev)
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span>            :         if (IS_KABYLAKE(dev) &amp;&amp; (dev-&gt;pdev-&gt;revision &lt;
<span class="lineNum">     208 </span>            :                         ARRAY_SIZE(kbl_stepping_info)))
<span class="lineNum">     209 </span>            :                 return kbl_stepping_info[dev-&gt;pdev-&gt;revision].stepping;
<span class="lineNum">     210 </span>            :         else if (IS_SKYLAKE(dev) &amp;&amp; (dev-&gt;pdev-&gt;revision &lt;
<span class="lineNum">     211 </span>            :                         ARRAY_SIZE(skl_stepping_info)))
<span class="lineNum">     212 </span>            :                 return skl_stepping_info[dev-&gt;pdev-&gt;revision].stepping;
<span class="lineNum">     213 </span>            :         else if (IS_BROXTON(dev) &amp;&amp; (dev-&gt;pdev-&gt;revision &lt;
<span class="lineNum">     214 </span>            :                                 ARRAY_SIZE(bxt_stepping_info)))
<span class="lineNum">     215 </span>            :                 return bxt_stepping_info[dev-&gt;pdev-&gt;revision].stepping;
<span class="lineNum">     216 </span>            :         else
<span class="lineNum">     217 </span>            :                 return -ENODATA;
<span class="lineNum">     218 </span>            : }
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : static char intel_get_substepping(struct drm_device *dev)
<span class="lineNum">     221 </span>            : {
<span class="lineNum">     222 </span>            :         if (IS_KABYLAKE(dev) &amp;&amp; (dev-&gt;pdev-&gt;revision &lt;
<span class="lineNum">     223 </span>            :                         ARRAY_SIZE(kbl_stepping_info)))
<span class="lineNum">     224 </span>            :                 return kbl_stepping_info[dev-&gt;pdev-&gt;revision].substepping;
<span class="lineNum">     225 </span>            :         else if (IS_SKYLAKE(dev) &amp;&amp; (dev-&gt;pdev-&gt;revision &lt;
<span class="lineNum">     226 </span>            :                         ARRAY_SIZE(skl_stepping_info)))
<span class="lineNum">     227 </span>            :                 return skl_stepping_info[dev-&gt;pdev-&gt;revision].substepping;
<span class="lineNum">     228 </span>            :         else if (IS_BROXTON(dev) &amp;&amp; (dev-&gt;pdev-&gt;revision &lt;
<span class="lineNum">     229 </span>            :                         ARRAY_SIZE(bxt_stepping_info)))
<span class="lineNum">     230 </span>            :                 return bxt_stepping_info[dev-&gt;pdev-&gt;revision].substepping;
<span class="lineNum">     231 </span>            :         else
<span class="lineNum">     232 </span>            :                 return -ENODATA;
<span class="lineNum">     233 </span>            : }
<span class="lineNum">     234 </span>            : #endif
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /**
<span class="lineNum">     237 </span>            :  * intel_csr_load_status_get() - to get firmware loading status.
<span class="lineNum">     238 </span>            :  * @dev_priv: i915 device.
<span class="lineNum">     239 </span>            :  *
<span class="lineNum">     240 </span>            :  * This function helps to get the firmware loading status.
<span class="lineNum">     241 </span>            :  *
<a name="242"><span class="lineNum">     242 </span>            :  * Return: Firmware loading status.</a>
<span class="lineNum">     243 </span>            :  */
<span class="lineNum">     244 </span><span class="lineNoCov">          0 : enum csr_state intel_csr_load_status_get(struct drm_i915_private *dev_priv)</span>
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span>            :         enum csr_state state;
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         mutex_lock(&amp;dev_priv-&gt;csr_lock);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         state = dev_priv-&gt;csr.state;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         mutex_unlock(&amp;dev_priv-&gt;csr_lock);</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         return state;</span>
<span class="lineNum">     253 </span>            : }
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : /**
<span class="lineNum">     256 </span>            :  * intel_csr_load_status_set() - help to set firmware loading status.
<span class="lineNum">     257 </span>            :  * @dev_priv: i915 device.
<span class="lineNum">     258 </span>            :  * @state: enumeration of firmware loading status.
<span class="lineNum">     259 </span>            :  *
<a name="260"><span class="lineNum">     260 </span>            :  * Set the firmware loading status.</a>
<span class="lineNum">     261 </span>            :  */
<span class="lineNum">     262 </span><span class="lineNoCov">          0 : void intel_csr_load_status_set(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     263 </span>            :                         enum csr_state state)
<span class="lineNum">     264 </span>            : {
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         mutex_lock(&amp;dev_priv-&gt;csr_lock);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         dev_priv-&gt;csr.state = state;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         mutex_unlock(&amp;dev_priv-&gt;csr_lock);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : /**
<span class="lineNum">     271 </span>            :  * intel_csr_load_program() - write the firmware from memory to register.
<span class="lineNum">     272 </span>            :  * @dev: drm device.
<span class="lineNum">     273 </span>            :  *
<span class="lineNum">     274 </span>            :  * CSR firmware is read from a .bin file and kept in internal memory one time.
<span class="lineNum">     275 </span>            :  * Everytime display comes back from low power state this function is called to
<a name="276"><span class="lineNum">     276 </span>            :  * copy the firmware from internal memory to registers.</a>
<span class="lineNum">     277 </span>            :  */
<span class="lineNum">     278 </span><span class="lineNoCov">          0 : void intel_csr_load_program(struct drm_device *dev)</span>
<span class="lineNum">     279 </span>            : {
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         u32 *payload = dev_priv-&gt;csr.dmc_payload;</span>
<span class="lineNum">     282 </span>            :         uint32_t i, fw_size;
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         if (!IS_GEN9(dev)) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;No CSR support available for this platform\n&quot;);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     287 </span>            :         }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :         /*
<span class="lineNum">     290 </span>            :          * FIXME: Firmware gets lost on S3/S4, but not when entering system
<span class="lineNum">     291 </span>            :          * standby or suspend-to-idle (which is just like forced runtime pm).
<span class="lineNum">     292 </span>            :          * Unfortunately the ACPI subsystem doesn't yet give us a way to
<span class="lineNum">     293 </span>            :          * differentiate this, hence figure it out with this hack.
<span class="lineNum">     294 </span>            :          */
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         if (I915_READ(CSR_PROGRAM(0)))</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         mutex_lock(&amp;dev_priv-&gt;csr_lock);</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         fw_size = dev_priv-&gt;csr.dmc_fw_size;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; fw_size; i++)</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :                 I915_WRITE(CSR_PROGRAM(i), payload[i]);</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; dev_priv-&gt;csr.mmio_count; i++) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :                 I915_WRITE(dev_priv-&gt;csr.mmioaddr[i],</span>
<span class="lineNum">     305 </span>            :                         dev_priv-&gt;csr.mmiodata[i]);
<span class="lineNum">     306 </span>            :         }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         dev_priv-&gt;csr.state = FW_LOADED;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         mutex_unlock(&amp;dev_priv-&gt;csr_lock);</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : #ifdef __linux__
<span class="lineNum">     313 </span>            : static void finish_csr_load(const struct firmware *fw, void *context)
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :         struct drm_i915_private *dev_priv = context;
<span class="lineNum">     316 </span>            :         struct drm_device *dev = dev_priv-&gt;dev;
<span class="lineNum">     317 </span>            :         struct intel_css_header *css_header;
<span class="lineNum">     318 </span>            :         struct intel_package_header *package_header;
<span class="lineNum">     319 </span>            :         struct intel_dmc_header *dmc_header;
<span class="lineNum">     320 </span>            :         struct intel_csr *csr = &amp;dev_priv-&gt;csr;
<span class="lineNum">     321 </span>            :         char stepping = intel_get_stepping(dev);
<span class="lineNum">     322 </span>            :         char substepping = intel_get_substepping(dev);
<span class="lineNum">     323 </span>            :         uint32_t dmc_offset = CSR_DEFAULT_FW_OFFSET, readcount = 0, nbytes;
<span class="lineNum">     324 </span>            :         uint32_t i;
<span class="lineNum">     325 </span>            :         uint32_t *dmc_payload;
<span class="lineNum">     326 </span>            :         bool fw_loaded = false;
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :         if (!fw) {
<span class="lineNum">     329 </span>            :                 i915_firmware_load_error_print(csr-&gt;fw_path, 0);
<span class="lineNum">     330 </span>            :                 goto out;
<span class="lineNum">     331 </span>            :         }
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :         if ((stepping == -ENODATA) || (substepping == -ENODATA)) {
<span class="lineNum">     334 </span>            :                 DRM_ERROR(&quot;Unknown stepping info, firmware loading failed\n&quot;);
<span class="lineNum">     335 </span>            :                 goto out;
<span class="lineNum">     336 </span>            :         }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :         /* Extract CSS Header information*/
<span class="lineNum">     339 </span>            :         css_header = (struct intel_css_header *)fw-&gt;data;
<span class="lineNum">     340 </span>            :         if (sizeof(struct intel_css_header) !=
<span class="lineNum">     341 </span>            :                 (css_header-&gt;header_len * 4)) {
<span class="lineNum">     342 </span>            :                 DRM_ERROR(&quot;Firmware has wrong CSS header length %u bytes\n&quot;,
<span class="lineNum">     343 </span>            :                         (css_header-&gt;header_len * 4));
<span class="lineNum">     344 </span>            :                 goto out;
<span class="lineNum">     345 </span>            :         }
<span class="lineNum">     346 </span>            :         readcount += sizeof(struct intel_css_header);
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :         /* Extract Package Header information*/
<span class="lineNum">     349 </span>            :         package_header = (struct intel_package_header *)
<span class="lineNum">     350 </span>            :                                         &amp;fw-&gt;data[readcount];
<span class="lineNum">     351 </span>            :         if (sizeof(struct intel_package_header) !=
<span class="lineNum">     352 </span>            :                 (package_header-&gt;header_len * 4)) {
<span class="lineNum">     353 </span>            :                 DRM_ERROR(&quot;Firmware has wrong package header length %u bytes\n&quot;,
<span class="lineNum">     354 </span>            :                         (package_header-&gt;header_len * 4));
<span class="lineNum">     355 </span>            :                 goto out;
<span class="lineNum">     356 </span>            :         }
<span class="lineNum">     357 </span>            :         readcount += sizeof(struct intel_package_header);
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :         /* Search for dmc_offset to find firware binary. */
<span class="lineNum">     360 </span>            :         for (i = 0; i &lt; package_header-&gt;num_entries; i++) {
<span class="lineNum">     361 </span>            :                 if (package_header-&gt;fw_info[i].substepping == '*' &amp;&amp;
<span class="lineNum">     362 </span>            :                         stepping == package_header-&gt;fw_info[i].stepping) {
<span class="lineNum">     363 </span>            :                         dmc_offset = package_header-&gt;fw_info[i].offset;
<span class="lineNum">     364 </span>            :                         break;
<span class="lineNum">     365 </span>            :                 } else if (stepping == package_header-&gt;fw_info[i].stepping &amp;&amp;
<span class="lineNum">     366 </span>            :                         substepping == package_header-&gt;fw_info[i].substepping) {
<span class="lineNum">     367 </span>            :                         dmc_offset = package_header-&gt;fw_info[i].offset;
<span class="lineNum">     368 </span>            :                         break;
<span class="lineNum">     369 </span>            :                 } else if (package_header-&gt;fw_info[i].stepping == '*' &amp;&amp;
<span class="lineNum">     370 </span>            :                         package_header-&gt;fw_info[i].substepping == '*')
<span class="lineNum">     371 </span>            :                         dmc_offset = package_header-&gt;fw_info[i].offset;
<span class="lineNum">     372 </span>            :         }
<span class="lineNum">     373 </span>            :         if (dmc_offset == CSR_DEFAULT_FW_OFFSET) {
<span class="lineNum">     374 </span>            :                 DRM_ERROR(&quot;Firmware not supported for %c stepping\n&quot;, stepping);
<span class="lineNum">     375 </span>            :                 goto out;
<span class="lineNum">     376 </span>            :         }
<span class="lineNum">     377 </span>            :         readcount += dmc_offset;
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :         /* Extract dmc_header information. */
<span class="lineNum">     380 </span>            :         dmc_header = (struct intel_dmc_header *)&amp;fw-&gt;data[readcount];
<span class="lineNum">     381 </span>            :         if (sizeof(struct intel_dmc_header) != (dmc_header-&gt;header_len)) {
<span class="lineNum">     382 </span>            :                 DRM_ERROR(&quot;Firmware has wrong dmc header length %u bytes\n&quot;,
<span class="lineNum">     383 </span>            :                                 (dmc_header-&gt;header_len));
<span class="lineNum">     384 </span>            :                 goto out;
<span class="lineNum">     385 </span>            :         }
<span class="lineNum">     386 </span>            :         readcount += sizeof(struct intel_dmc_header);
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :         /* Cache the dmc header info. */
<span class="lineNum">     389 </span>            :         if (dmc_header-&gt;mmio_count &gt; ARRAY_SIZE(csr-&gt;mmioaddr)) {
<span class="lineNum">     390 </span>            :                 DRM_ERROR(&quot;Firmware has wrong mmio count %u\n&quot;,
<span class="lineNum">     391 </span>            :                                                 dmc_header-&gt;mmio_count);
<span class="lineNum">     392 </span>            :                 goto out;
<span class="lineNum">     393 </span>            :         }
<span class="lineNum">     394 </span>            :         csr-&gt;mmio_count = dmc_header-&gt;mmio_count;
<span class="lineNum">     395 </span>            :         for (i = 0; i &lt; dmc_header-&gt;mmio_count; i++) {
<span class="lineNum">     396 </span>            :                 if (dmc_header-&gt;mmioaddr[i] &lt; CSR_MMIO_START_RANGE ||
<span class="lineNum">     397 </span>            :                         dmc_header-&gt;mmioaddr[i] &gt; CSR_MMIO_END_RANGE) {
<span class="lineNum">     398 </span>            :                         DRM_ERROR(&quot; Firmware has wrong mmio address 0x%x\n&quot;,
<span class="lineNum">     399 </span>            :                                                 dmc_header-&gt;mmioaddr[i]);
<span class="lineNum">     400 </span>            :                         goto out;
<span class="lineNum">     401 </span>            :                 }
<span class="lineNum">     402 </span>            :                 csr-&gt;mmioaddr[i] = dmc_header-&gt;mmioaddr[i];
<span class="lineNum">     403 </span>            :                 csr-&gt;mmiodata[i] = dmc_header-&gt;mmiodata[i];
<span class="lineNum">     404 </span>            :         }
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :         /* fw_size is in dwords, so multiplied by 4 to convert into bytes. */
<span class="lineNum">     407 </span>            :         nbytes = dmc_header-&gt;fw_size * 4;
<span class="lineNum">     408 </span>            :         if (nbytes &gt; CSR_MAX_FW_SIZE) {
<span class="lineNum">     409 </span>            :                 DRM_ERROR(&quot;CSR firmware too big (%u) bytes\n&quot;, nbytes);
<span class="lineNum">     410 </span>            :                 goto out;
<span class="lineNum">     411 </span>            :         }
<span class="lineNum">     412 </span>            :         csr-&gt;dmc_fw_size = dmc_header-&gt;fw_size;
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :         csr-&gt;dmc_payload = kmalloc(nbytes, GFP_KERNEL);
<span class="lineNum">     415 </span>            :         if (!csr-&gt;dmc_payload) {
<span class="lineNum">     416 </span>            :                 DRM_ERROR(&quot;Memory allocation failed for dmc payload\n&quot;);
<span class="lineNum">     417 </span>            :                 goto out;
<span class="lineNum">     418 </span>            :         }
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :         dmc_payload = csr-&gt;dmc_payload;
<span class="lineNum">     421 </span>            :         memcpy(dmc_payload, &amp;fw-&gt;data[readcount], nbytes);
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            :         /* load csr program during system boot, as needed for DC states */
<span class="lineNum">     424 </span>            :         intel_csr_load_program(dev);
<span class="lineNum">     425 </span>            :         fw_loaded = true;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :         DRM_DEBUG_KMS(&quot;Finished loading %s\n&quot;, dev_priv-&gt;csr.fw_path);
<span class="lineNum">     428 </span>            : out:
<span class="lineNum">     429 </span>            :         if (fw_loaded)
<span class="lineNum">     430 </span>            :                 intel_runtime_pm_put(dev_priv);
<span class="lineNum">     431 </span>            :         else
<span class="lineNum">     432 </span>            :                 intel_csr_load_status_set(dev_priv, FW_FAILED);
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :         release_firmware(fw);
<span class="lineNum">     435 </span>            : }
<span class="lineNum">     436 </span>            : #endif
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : /**
<span class="lineNum">     439 </span>            :  * intel_csr_ucode_init() - initialize the firmware loading.
<span class="lineNum">     440 </span>            :  * @dev: drm device.
<span class="lineNum">     441 </span>            :  *
<span class="lineNum">     442 </span>            :  * This function is called at the time of loading the display driver to read
<a name="443"><span class="lineNum">     443 </span>            :  * firmware from a .bin file and copied into a internal memory.</a>
<span class="lineNum">     444 </span>            :  */
<span class="lineNum">     445 </span><span class="lineNoCov">          0 : void intel_csr_ucode_init(struct drm_device *dev)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         struct intel_csr *csr = &amp;dev_priv-&gt;csr;</span>
<span class="lineNum">     449 </span>            :         int ret;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         if (!HAS_CSR(dev))</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         if (IS_KABYLAKE(dev))</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 csr-&gt;fw_path = I915_CSR_KBL;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         else if (IS_SKYLAKE(dev))</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                 csr-&gt;fw_path = I915_CSR_SKL;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         else if (IS_BROXTON(dev_priv))</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                 csr-&gt;fw_path = I915_CSR_BXT;</span>
<span class="lineNum">     460 </span>            :         else {
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;Unexpected: no known CSR firmware for platform\n&quot;);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                 intel_csr_load_status_set(dev_priv, FW_FAILED);</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     464 </span>            :         }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :         DRM_DEBUG_KMS(&quot;Loading %s\n&quot;, csr-&gt;fw_path);
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :         /*
<span class="lineNum">     469 </span>            :          * Obtain a runtime pm reference, until CSR is loaded,
<span class="lineNum">     470 </span>            :          * to avoid entering runtime-suspend.
<span class="lineNum">     471 </span>            :          */
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :         intel_runtime_pm_get(dev_priv);</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :         /* CSR supported for platform, load firmware */
<span class="lineNum">     475 </span>            :         ret = request_firmware_nowait(THIS_MODULE, true, csr-&gt;fw_path,
<span class="lineNum">     476 </span>            :                                 &amp;dev_priv-&gt;dev-&gt;pdev-&gt;dev,
<span class="lineNum">     477 </span>            :                                 GFP_KERNEL, dev_priv,
<span class="lineNum">     478 </span>            :                                 finish_csr_load);
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         if (ret) {</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                 i915_firmware_load_error_print(csr-&gt;fw_path, ret);</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                 intel_csr_load_status_set(dev_priv, FW_FAILED);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : /**
<span class="lineNum">     486 </span>            :  * intel_csr_ucode_fini() - unload the CSR firmware.
<span class="lineNum">     487 </span>            :  * @dev: drm device.
<span class="lineNum">     488 </span>            :  *
<span class="lineNum">     489 </span>            :  * Firmmware unloading includes freeing the internal momory and reset the
<a name="490"><span class="lineNum">     490 </span>            :  * firmware loading status.</a>
<span class="lineNum">     491 </span>            :  */
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : void intel_csr_ucode_fini(struct drm_device *dev)</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         if (!HAS_CSR(dev))</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         intel_csr_load_status_set(dev_priv, FW_FAILED);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         kfree(dev_priv-&gt;csr.dmc_payload);</span>
<a name="501"><span class="lineNum">     501 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 : void assert_csr_loaded(struct drm_i915_private *dev_priv)</span>
<span class="lineNum">     504 </span>            : {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         WARN_ONCE(intel_csr_load_status_get(dev_priv) != FW_LOADED,</span>
<span class="lineNum">     506 </span>            :                   &quot;CSR is not loaded.\n&quot;);
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         WARN_ONCE(!I915_READ(CSR_PROGRAM(0)),</span>
<span class="lineNum">     508 </span>            :                   &quot;CSR program storage start is NULL\n&quot;);
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         WARN_ONCE(!I915_READ(CSR_SSP_BASE), &quot;CSR SSP Base Not fine\n&quot;);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         WARN_ONCE(!I915_READ(CSR_HTP_SKL), &quot;CSR HTP Not fine\n&quot;);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
