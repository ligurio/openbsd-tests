<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/i915/intel_dsi_panel_vbt.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/i915</a> - intel_dsi_panel_vbt.c<span style="font-size: 80%;"> (source / <a href="intel_dsi_panel_vbt.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">229</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright Â© 2014 Intel Corporation
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       5 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">       6 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">       7 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">       8 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">       9 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      12 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      13 </span>            :  * Software.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      16 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      17 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      18 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      19 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      20 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
<span class="lineNum">      21 </span>            :  * DEALINGS IN THE SOFTWARE.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * Author: Shobhit Kumar &lt;shobhit.kumar@intel.com&gt;
<span class="lineNum">      24 </span>            :  *
<span class="lineNum">      25 </span>            :  */
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &lt;dev/pci/drm/drmP.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;dev/pci/drm/drm_crtc.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;dev/pci/drm/drm_edid.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;dev/pci/drm/i915_drm.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;dev/pci/drm/drm_panel.h&gt;
<span class="lineNum">      32 </span>            : #ifdef __linux__
<span class="lineNum">      33 </span>            : #include &lt;linux/slab.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;video/mipi_display.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;asm/intel-mid.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;video/mipi_display.h&gt;
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : #include &quot;i915_drv.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;intel_drv.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;intel_dsi.h&quot;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : struct vbt_panel {
<span class="lineNum">      43 </span>            :         struct drm_panel panel;
<span class="lineNum">      44 </span>            :         struct intel_dsi *intel_dsi;
<a name="45"><span class="lineNum">      45 </span>            : };</a>
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span><span class="lineNoCov">          0 : static inline struct vbt_panel *to_vbt_panel(struct drm_panel *panel)</span>
<span class="lineNum">      48 </span>            : {
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :         return container_of(panel, struct vbt_panel, panel);</span>
<span class="lineNum">      50 </span>            : }
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #define MIPI_TRANSFER_MODE_SHIFT        0
<span class="lineNum">      53 </span>            : #define MIPI_VIRTUAL_CHANNEL_SHIFT      1
<span class="lineNum">      54 </span>            : #define MIPI_PORT_SHIFT                 3
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : #define PREPARE_CNT_MAX         0x3F
<span class="lineNum">      57 </span>            : #define EXIT_ZERO_CNT_MAX       0x3F
<span class="lineNum">      58 </span>            : #define CLK_ZERO_CNT_MAX        0xFF
<span class="lineNum">      59 </span>            : #define TRAIL_CNT_MAX           0x1F
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : #define NS_KHZ_RATIO 1000000
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : #define GPI0_NC_0_HV_DDI0_HPD           0x4130
<span class="lineNum">      64 </span>            : #define GPIO_NC_0_HV_DDI0_PAD           0x4138
<span class="lineNum">      65 </span>            : #define GPIO_NC_1_HV_DDI0_DDC_SDA       0x4120
<span class="lineNum">      66 </span>            : #define GPIO_NC_1_HV_DDI0_DDC_SDA_PAD   0x4128
<span class="lineNum">      67 </span>            : #define GPIO_NC_2_HV_DDI0_DDC_SCL       0x4110
<span class="lineNum">      68 </span>            : #define GPIO_NC_2_HV_DDI0_DDC_SCL_PAD   0x4118
<span class="lineNum">      69 </span>            : #define GPIO_NC_3_PANEL0_VDDEN          0x4140
<span class="lineNum">      70 </span>            : #define GPIO_NC_3_PANEL0_VDDEN_PAD      0x4148
<span class="lineNum">      71 </span>            : #define GPIO_NC_4_PANEL0_BLKEN          0x4150
<span class="lineNum">      72 </span>            : #define GPIO_NC_4_PANEL0_BLKEN_PAD      0x4158
<span class="lineNum">      73 </span>            : #define GPIO_NC_5_PANEL0_BLKCTL         0x4160
<span class="lineNum">      74 </span>            : #define GPIO_NC_5_PANEL0_BLKCTL_PAD     0x4168
<span class="lineNum">      75 </span>            : #define GPIO_NC_6_PCONF0                0x4180
<span class="lineNum">      76 </span>            : #define GPIO_NC_6_PAD                   0x4188
<span class="lineNum">      77 </span>            : #define GPIO_NC_7_PCONF0                0x4190
<span class="lineNum">      78 </span>            : #define GPIO_NC_7_PAD                   0x4198
<span class="lineNum">      79 </span>            : #define GPIO_NC_8_PCONF0                0x4170
<span class="lineNum">      80 </span>            : #define GPIO_NC_8_PAD                   0x4178
<span class="lineNum">      81 </span>            : #define GPIO_NC_9_PCONF0                0x4100
<span class="lineNum">      82 </span>            : #define GPIO_NC_9_PAD                   0x4108
<span class="lineNum">      83 </span>            : #define GPIO_NC_10_PCONF0               0x40E0
<span class="lineNum">      84 </span>            : #define GPIO_NC_10_PAD                  0x40E8
<span class="lineNum">      85 </span>            : #define GPIO_NC_11_PCONF0               0x40F0
<span class="lineNum">      86 </span>            : #define GPIO_NC_11_PAD                  0x40F8
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : struct gpio_table {
<span class="lineNum">      89 </span>            :         u16 function_reg;
<span class="lineNum">      90 </span>            :         u16 pad_reg;
<span class="lineNum">      91 </span>            :         u8 init;
<span class="lineNum">      92 </span>            : };
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : static struct gpio_table gtable[] = {
<span class="lineNum">      95 </span>            :         { GPI0_NC_0_HV_DDI0_HPD, GPIO_NC_0_HV_DDI0_PAD, 0 },
<span class="lineNum">      96 </span>            :         { GPIO_NC_1_HV_DDI0_DDC_SDA, GPIO_NC_1_HV_DDI0_DDC_SDA_PAD, 0 },
<span class="lineNum">      97 </span>            :         { GPIO_NC_2_HV_DDI0_DDC_SCL, GPIO_NC_2_HV_DDI0_DDC_SCL_PAD, 0 },
<span class="lineNum">      98 </span>            :         { GPIO_NC_3_PANEL0_VDDEN, GPIO_NC_3_PANEL0_VDDEN_PAD, 0 },
<span class="lineNum">      99 </span>            :         { GPIO_NC_4_PANEL0_BLKEN, GPIO_NC_4_PANEL0_BLKEN_PAD, 0 },
<span class="lineNum">     100 </span>            :         { GPIO_NC_5_PANEL0_BLKCTL, GPIO_NC_5_PANEL0_BLKCTL_PAD, 0 },
<span class="lineNum">     101 </span>            :         { GPIO_NC_6_PCONF0, GPIO_NC_6_PAD, 0 },
<span class="lineNum">     102 </span>            :         { GPIO_NC_7_PCONF0, GPIO_NC_7_PAD, 0 },
<span class="lineNum">     103 </span>            :         { GPIO_NC_8_PCONF0, GPIO_NC_8_PAD, 0 },
<span class="lineNum">     104 </span>            :         { GPIO_NC_9_PCONF0, GPIO_NC_9_PAD, 0 },
<span class="lineNum">     105 </span>            :         { GPIO_NC_10_PCONF0, GPIO_NC_10_PAD, 0},
<span class="lineNum">     106 </span>            :         { GPIO_NC_11_PCONF0, GPIO_NC_11_PAD, 0}
<a name="107"><span class="lineNum">     107 </span>            : };</a>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 : static inline enum port intel_dsi_seq_port_to_port(u8 port)</span>
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         return port ? PORT_C : PORT_A;</span>
<a name="112"><span class="lineNum">     112 </span>            : }</a>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 : static const u8 *mipi_exec_send_packet(struct intel_dsi *intel_dsi,</span>
<span class="lineNum">     115 </span>            :                                        const u8 *data)
<span class="lineNum">     116 </span>            : {
<span class="lineNum">     117 </span>            :         struct mipi_dsi_device *dsi_device;
<span class="lineNum">     118 </span>            :         u8 type, flags, seq_port;
<span class="lineNum">     119 </span>            :         u16 len;
<span class="lineNum">     120 </span>            :         enum port port;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :         flags = *data++;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :         type = *data++;</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :         len = *((u16 *) data);</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :         data += 2;</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         seq_port = (flags &gt;&gt; MIPI_PORT_SHIFT) &amp; 3;</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :         /* For DSI single link on Port A &amp; C, the seq_port value which is
<span class="lineNum">     131 </span>            :          * parsed from Sequence Block#53 of VBT has been set to 0
<span class="lineNum">     132 </span>            :          * Now, read/write of packets for the DSI single link on Port A and
<span class="lineNum">     133 </span>            :          * Port C will based on the DVO port from VBT block 2.
<span class="lineNum">     134 </span>            :          */
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         if (intel_dsi-&gt;ports == (1 &lt;&lt; PORT_C))</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :                 port = PORT_C;</span>
<span class="lineNum">     137 </span>            :         else
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :                 port = intel_dsi_seq_port_to_port(seq_port);</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :         dsi_device = intel_dsi-&gt;dsi_hosts[port]-&gt;device;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         if (!dsi_device) {</span>
<span class="lineNum">     142 </span>            :                 DRM_DEBUG_KMS(&quot;no dsi device for port %c\n&quot;, port_name(port));
<span class="lineNum">     143 </span>            :                 goto out;
<span class="lineNum">     144 </span>            :         }
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         if ((flags &gt;&gt; MIPI_TRANSFER_MODE_SHIFT) &amp; 1)</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                 dsi_device-&gt;mode_flags &amp;= ~MIPI_DSI_MODE_LPM;</span>
<span class="lineNum">     148 </span>            :         else
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 dsi_device-&gt;mode_flags |= MIPI_DSI_MODE_LPM;</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         dsi_device-&gt;channel = (flags &gt;&gt; MIPI_VIRTUAL_CHANNEL_SHIFT) &amp; 3;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         switch (type) {</span>
<span class="lineNum">     154 </span>            :         case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :                 mipi_dsi_generic_write(dsi_device, NULL, 0);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     157 </span>            :         case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :                 mipi_dsi_generic_write(dsi_device, data, 1);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     160 </span>            :         case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :                 mipi_dsi_generic_write(dsi_device, data, 2);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     163 </span>            :         case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
<span class="lineNum">     164 </span>            :         case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
<span class="lineNum">     165 </span>            :         case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
<span class="lineNum">     166 </span>            :                 DRM_DEBUG_DRIVER(&quot;Generic Read not yet implemented or used\n&quot;);
<span class="lineNum">     167 </span>            :                 break;
<span class="lineNum">     168 </span>            :         case MIPI_DSI_GENERIC_LONG_WRITE:
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :                 mipi_dsi_generic_write(dsi_device, data, len);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     171 </span>            :         case MIPI_DSI_DCS_SHORT_WRITE:
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                 mipi_dsi_dcs_write_buffer(dsi_device, data, 1);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     174 </span>            :         case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :                 mipi_dsi_dcs_write_buffer(dsi_device, data, 2);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     177 </span>            :         case MIPI_DSI_DCS_READ:
<span class="lineNum">     178 </span>            :                 DRM_DEBUG_DRIVER(&quot;DCS Read not yet implemented or used\n&quot;);
<span class="lineNum">     179 </span>            :                 break;
<span class="lineNum">     180 </span>            :         case MIPI_DSI_DCS_LONG_WRITE:
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :                 mipi_dsi_dcs_write_buffer(dsi_device, data, len);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     183 </span>            :         }
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : out:
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         data += len;</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         return data;</span>
<a name="189"><span class="lineNum">     189 </span>            : }</a>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 : static const u8 *mipi_exec_delay(struct intel_dsi *intel_dsi, const u8 *data)</span>
<span class="lineNum">     192 </span>            : {
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         u32 delay = *((const u32 *) data);</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         usleep_range(delay, delay + 10);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         data += 4;</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :         return data;</span>
<a name="199"><span class="lineNum">     199 </span>            : }</a>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : static const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)</span>
<span class="lineNum">     202 </span>            : {
<span class="lineNum">     203 </span>            :         u8 gpio, action;
<span class="lineNum">     204 </span>            :         u16 function, pad;
<span class="lineNum">     205 </span>            :         u32 val;
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         gpio = *data++;</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :         /* pull up/down */
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         action = *data++ &amp; 1;</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         if (gpio &gt;= ARRAY_SIZE(gtable)) {</span>
<span class="lineNum">     215 </span>            :                 DRM_DEBUG_KMS(&quot;unknown gpio %u\n&quot;, gpio);
<span class="lineNum">     216 </span>            :                 goto out;
<span class="lineNum">     217 </span>            :         }
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         function = gtable[gpio].function_reg;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         pad = gtable[gpio].pad_reg;</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         mutex_lock(&amp;dev_priv-&gt;sb_lock);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         if (!gtable[gpio].init) {</span>
<span class="lineNum">     224 </span>            :                 /* program the function */
<span class="lineNum">     225 </span>            :                 /* FIXME: remove constant below */
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                 vlv_gpio_nc_write(dev_priv, function, 0x2000CC00);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 gtable[gpio].init = 1;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :         val = 0x4 | action;</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :         /* pull up/down */
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         vlv_gpio_nc_write(dev_priv, pad, val);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         mutex_unlock(&amp;dev_priv-&gt;sb_lock);</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : out:
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         return data;</span>
<span class="lineNum">     238 </span>            : }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : typedef const u8 * (*fn_mipi_elem_exec)(struct intel_dsi *intel_dsi,
<span class="lineNum">     241 </span>            :                                         const u8 *data);
<span class="lineNum">     242 </span>            : static const fn_mipi_elem_exec exec_elem[] = {
<span class="lineNum">     243 </span>            :         NULL, /* reserved */
<span class="lineNum">     244 </span>            :         mipi_exec_send_packet,
<span class="lineNum">     245 </span>            :         mipi_exec_delay,
<span class="lineNum">     246 </span>            :         mipi_exec_gpio,
<span class="lineNum">     247 </span>            :         NULL, /* status read; later */
<span class="lineNum">     248 </span>            : };
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : /*
<span class="lineNum">     251 </span>            :  * MIPI Sequence from VBT #53 parsing logic
<span class="lineNum">     252 </span>            :  * We have already separated each seqence during bios parsing
<span class="lineNum">     253 </span>            :  * Following is generic execution function for any sequence
<span class="lineNum">     254 </span>            :  */
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : static const char * const seq_name[] = {
<span class="lineNum">     257 </span>            :         &quot;UNDEFINED&quot;,
<span class="lineNum">     258 </span>            :         &quot;MIPI_SEQ_ASSERT_RESET&quot;,
<span class="lineNum">     259 </span>            :         &quot;MIPI_SEQ_INIT_OTP&quot;,
<span class="lineNum">     260 </span>            :         &quot;MIPI_SEQ_DISPLAY_ON&quot;,
<span class="lineNum">     261 </span>            :         &quot;MIPI_SEQ_DISPLAY_OFF&quot;,
<span class="lineNum">     262 </span>            :         &quot;MIPI_SEQ_DEASSERT_RESET&quot;
<a name="263"><span class="lineNum">     263 </span>            : };</a>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 : static void generic_exec_sequence(struct intel_dsi *intel_dsi, const u8 *data)</span>
<span class="lineNum">     266 </span>            : {
<span class="lineNum">     267 </span>            :         fn_mipi_elem_exec mipi_elem_exec;
<span class="lineNum">     268 </span>            :         int index;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         if (!data)</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :         DRM_DEBUG_DRIVER(&quot;Starting MIPI sequence - %s\n&quot;, seq_name[*data]);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :         /* go to the first element of the sequence */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         data++;</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :         /* parse each byte till we reach end of sequence byte - 0x00 */
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         while (1) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                 index = *data;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                 mipi_elem_exec = exec_elem[index];</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 if (!mipi_elem_exec) {</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;Unsupported MIPI element, skipping sequence execution\n&quot;);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     285 </span>            :                 }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :                 /* goto element payload */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 data++;</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :                 /* execute the element specific rotines */
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :                 data = mipi_elem_exec(intel_dsi, data);</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :                 /*
<span class="lineNum">     294 </span>            :                  * After processing the element, data should point to
<span class="lineNum">     295 </span>            :                  * next element or end of sequence
<span class="lineNum">     296 </span>            :                  * check if have we reached end of sequence
<span class="lineNum">     297 </span>            :                  */
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                 if (*data == 0x00)</span>
<span class="lineNum">     299 </span>            :                         break;
<span class="lineNum">     300 </span>            :         }
<a name="301"><span class="lineNum">     301 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 : static int vbt_panel_prepare(struct drm_panel *panel)</span>
<span class="lineNum">     304 </span>            : {
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         struct vbt_panel *vbt_panel = to_vbt_panel(panel);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         struct intel_dsi *intel_dsi = vbt_panel-&gt;intel_dsi;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     309 </span>            :         const u8 *sequence;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         sequence = dev_priv-&gt;vbt.dsi.sequence[MIPI_SEQ_ASSERT_RESET];</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         generic_exec_sequence(intel_dsi, sequence);</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         sequence = dev_priv-&gt;vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         generic_exec_sequence(intel_dsi, sequence);</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="318"><span class="lineNum">     318 </span>            : }</a>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 : static int vbt_panel_unprepare(struct drm_panel *panel)</span>
<span class="lineNum">     321 </span>            : {
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         struct vbt_panel *vbt_panel = to_vbt_panel(panel);</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         struct intel_dsi *intel_dsi = vbt_panel-&gt;intel_dsi;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     326 </span>            :         const u8 *sequence;
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         sequence = dev_priv-&gt;vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET];</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         generic_exec_sequence(intel_dsi, sequence);</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="332"><span class="lineNum">     332 </span>            : }</a>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineNoCov">          0 : static int vbt_panel_enable(struct drm_panel *panel)</span>
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         struct vbt_panel *vbt_panel = to_vbt_panel(panel);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :         struct intel_dsi *intel_dsi = vbt_panel-&gt;intel_dsi;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     340 </span>            :         const u8 *sequence;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         sequence = dev_priv-&gt;vbt.dsi.sequence[MIPI_SEQ_DISPLAY_ON];</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         generic_exec_sequence(intel_dsi, sequence);</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="346"><span class="lineNum">     346 </span>            : }</a>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : static int vbt_panel_disable(struct drm_panel *panel)</span>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         struct vbt_panel *vbt_panel = to_vbt_panel(panel);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         struct intel_dsi *intel_dsi = vbt_panel-&gt;intel_dsi;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     354 </span>            :         const u8 *sequence;
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         sequence = dev_priv-&gt;vbt.dsi.sequence[MIPI_SEQ_DISPLAY_OFF];</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         generic_exec_sequence(intel_dsi, sequence);</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="360"><span class="lineNum">     360 </span>            : }</a>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 : static int vbt_panel_get_modes(struct drm_panel *panel)</span>
<span class="lineNum">     363 </span>            : {
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         struct vbt_panel *vbt_panel = to_vbt_panel(panel);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         struct intel_dsi *intel_dsi = vbt_panel-&gt;intel_dsi;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     368 </span>            :         struct drm_display_mode *mode;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         if (!panel-&gt;connector)</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         mode = drm_mode_duplicate(dev, dev_priv-&gt;vbt.lfp_lvds_vbt_mode);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         if (!mode)</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         mode-&gt;type |= DRM_MODE_TYPE_PREFERRED;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         drm_mode_probed_add(panel-&gt;connector, mode);</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : static const struct drm_panel_funcs vbt_panel_funcs = {
<span class="lineNum">     385 </span>            :         .disable = vbt_panel_disable,
<span class="lineNum">     386 </span>            :         .unprepare = vbt_panel_unprepare,
<span class="lineNum">     387 </span>            :         .prepare = vbt_panel_prepare,
<span class="lineNum">     388 </span>            :         .enable = vbt_panel_enable,
<span class="lineNum">     389 </span>            :         .get_modes = vbt_panel_get_modes,
<a name="390"><span class="lineNum">     390 </span>            : };</a>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : struct drm_panel *vbt_panel_init(struct intel_dsi *intel_dsi, u16 panel_id)</span>
<span class="lineNum">     393 </span>            : {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         struct drm_device *dev = intel_dsi-&gt;base.base.dev;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         struct mipi_config *mipi_config = dev_priv-&gt;vbt.dsi.config;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         struct mipi_pps_data *pps = dev_priv-&gt;vbt.dsi.pps;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         struct drm_display_mode *mode = dev_priv-&gt;vbt.lfp_lvds_vbt_mode;</span>
<span class="lineNum">     399 </span>            :         struct vbt_panel *vbt_panel;
<span class="lineNum">     400 </span>            :         u32 bits_per_pixel = 24;
<span class="lineNum">     401 </span>            :         u32 tlpx_ns, extra_byte_count, bitrate, tlpx_ui;
<span class="lineNum">     402 </span>            :         u32 ui_num, ui_den;
<span class="lineNum">     403 </span>            :         u32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;
<span class="lineNum">     404 </span>            :         u32 ths_prepare_ns, tclk_trail_ns;
<span class="lineNum">     405 </span>            :         u32 tclk_prepare_clkzero, ths_prepare_hszero;
<span class="lineNum">     406 </span>            :         u32 lp_to_hs_switch, hs_to_lp_switch;
<span class="lineNum">     407 </span>            :         u32 pclk, computed_ddr;
<span class="lineNum">     408 </span>            :         u16 burst_mode_ratio;
<span class="lineNum">     409 </span>            :         enum port port;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :         DRM_DEBUG_KMS(&quot;\n&quot;);
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;eotp_pkt = mipi_config-&gt;eot_pkt_disabled ? 0 : 1;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;clock_stop = mipi_config-&gt;enable_clk_stop ? 1 : 0;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;lane_count = mipi_config-&gt;lane_cnt + 1;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;pixel_format = mipi_config-&gt;videomode_color_format &lt;&lt; 7;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;dual_link = mipi_config-&gt;dual_link;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;pixel_overlap = mipi_config-&gt;pixel_overlap;</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         if (intel_dsi-&gt;pixel_format == VID_MODE_FORMAT_RGB666)</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :                 bits_per_pixel = 18;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         else if (intel_dsi-&gt;pixel_format == VID_MODE_FORMAT_RGB565)</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                 bits_per_pixel = 16;</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;operation_mode = mipi_config-&gt;is_cmd_mode;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;video_mode_format = mipi_config-&gt;video_transfer_mode;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;escape_clk_div = mipi_config-&gt;byte_clk_sel;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;lp_rx_timeout = mipi_config-&gt;lp_rx_timeout;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;turn_arnd_val = mipi_config-&gt;turn_around_timeout;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;rst_timer_val = mipi_config-&gt;device_reset_timer;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;init_count = mipi_config-&gt;master_init_timer;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;bw_timer = mipi_config-&gt;dbi_bw_timer;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;video_frmt_cfg_bits =</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                 mipi_config-&gt;bta_enabled ? DISABLE_VIDEO_BTA : 0;</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         pclk = mode-&gt;clock;</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :         /* In dual link mode each port needs half of pixel clock */
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         if (intel_dsi-&gt;dual_link) {</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                 pclk = pclk / 2;</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :                 /* we can enable pixel_overlap if needed by panel. In this
<span class="lineNum">     443 </span>            :                  * case we need to increase the pixelclock for extra pixels
<span class="lineNum">     444 </span>            :                  */
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                 if (intel_dsi-&gt;dual_link == DSI_DUAL_LINK_FRONT_BACK) {</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                         pclk += DIV_ROUND_UP(mode-&gt;vtotal *</span>
<span class="lineNum">     447 </span>            :                                                 intel_dsi-&gt;pixel_overlap *
<span class="lineNum">     448 </span>            :                                                 60, 1000);
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     450 </span>            :         }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :         /* Burst Mode Ratio
<span class="lineNum">     453 </span>            :          * Target ddr frequency from VBT / non burst ddr freq
<span class="lineNum">     454 </span>            :          * multiply by 100 to preserve remainder
<span class="lineNum">     455 </span>            :          */
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         if (intel_dsi-&gt;video_mode_format == VIDEO_MODE_BURST) {</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                 if (mipi_config-&gt;target_burst_mode_freq) {</span>
<span class="lineNum">     458 </span>            :                         computed_ddr =
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                                 (pclk * bits_per_pixel) / intel_dsi-&gt;lane_count;</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                         if (mipi_config-&gt;target_burst_mode_freq &lt;</span>
<span class="lineNum">     462 </span>            :                                                                 computed_ddr) {
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :                                 DRM_ERROR(&quot;Burst mode freq is less than computed\n&quot;);</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">     465 </span>            :                         }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         burst_mode_ratio = DIV_ROUND_UP(</span>
<span class="lineNum">     468 </span>            :                                 mipi_config-&gt;target_burst_mode_freq * 100,
<span class="lineNum">     469 </span>            :                                 computed_ddr);
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                         pclk = DIV_ROUND_UP(pclk * burst_mode_ratio, 100);</span>
<span class="lineNum">     472 </span>            :                 } else {
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;Burst mode target is not set\n&quot;);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     475 </span>            :                 }
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         } else</span>
<span class="lineNum">     477 </span>            :                 burst_mode_ratio = 100;
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;burst_mode_ratio = burst_mode_ratio;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;pclk = pclk;</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         bitrate = (pclk * bits_per_pixel) / intel_dsi-&gt;lane_count;</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         switch (intel_dsi-&gt;escape_clk_div) {</span>
<span class="lineNum">     485 </span>            :         case 0:
<span class="lineNum">     486 </span>            :                 tlpx_ns = 50;
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     488 </span>            :         case 1:
<span class="lineNum">     489 </span>            :                 tlpx_ns = 100;
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :         case 2:
<span class="lineNum">     493 </span>            :                 tlpx_ns = 200;
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     495 </span>            :         default:
<span class="lineNum">     496 </span>            :                 tlpx_ns = 50;
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     498 </span>            :         }
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         switch (intel_dsi-&gt;lane_count) {</span>
<span class="lineNum">     501 </span>            :         case 1:
<span class="lineNum">     502 </span>            :         case 2:
<span class="lineNum">     503 </span>            :                 extra_byte_count = 2;
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     505 </span>            :         case 3:
<span class="lineNum">     506 </span>            :                 extra_byte_count = 4;
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     508 </span>            :         case 4:
<span class="lineNum">     509 </span>            :         default:
<span class="lineNum">     510 </span>            :                 extra_byte_count = 3;
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     512 </span>            :         }
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :         /*
<span class="lineNum">     515 </span>            :          * ui(s) = 1/f [f in hz]
<span class="lineNum">     516 </span>            :          * ui(ns) = 10^9 / (f*10^6) [f in Mhz] -&gt; 10^3/f(Mhz)
<span class="lineNum">     517 </span>            :          */
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :         /* in Kbps */
<span class="lineNum">     520 </span>            :         ui_num = NS_KHZ_RATIO;
<span class="lineNum">     521 </span>            :         ui_den = bitrate;
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         tclk_prepare_clkzero = mipi_config-&gt;tclk_prepare_clkzero;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         ths_prepare_hszero = mipi_config-&gt;ths_prepare_hszero;</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :         /*
<span class="lineNum">     527 </span>            :          * B060
<span class="lineNum">     528 </span>            :          * LP byte clock = TLPX/ (8UI)
<span class="lineNum">     529 </span>            :          */
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;lp_byte_clk = DIV_ROUND_UP(tlpx_ns * ui_den, 8 * ui_num);</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :         /* count values in UI = (ns value) * (bitrate / (2 * 10^6))
<span class="lineNum">     533 </span>            :          *
<span class="lineNum">     534 </span>            :          * Since txddrclkhs_i is 2xUI, all the count values programmed in
<span class="lineNum">     535 </span>            :          * DPHY param register are divided by 2
<span class="lineNum">     536 </span>            :          *
<span class="lineNum">     537 </span>            :          * prepare count
<span class="lineNum">     538 </span>            :          */
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         ths_prepare_ns = max(mipi_config-&gt;ths_prepare,</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                              mipi_config-&gt;tclk_prepare);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         prepare_cnt = DIV_ROUND_UP(ths_prepare_ns * ui_den, ui_num * 2);</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :         /* exit zero count */
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         exit_zero_cnt = DIV_ROUND_UP(</span>
<span class="lineNum">     545 </span>            :                                 (ths_prepare_hszero - ths_prepare_ns) * ui_den,
<span class="lineNum">     546 </span>            :                                 ui_num * 2
<span class="lineNum">     547 </span>            :                                 );
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :         /*
<span class="lineNum">     550 </span>            :          * Exit zero  is unified val ths_zero and ths_exit
<span class="lineNum">     551 </span>            :          * minimum value for ths_exit = 110ns
<span class="lineNum">     552 </span>            :          * min (exit_zero_cnt * 2) = 110/UI
<span class="lineNum">     553 </span>            :          * exit_zero_cnt = 55/UI
<span class="lineNum">     554 </span>            :          */
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :          if (exit_zero_cnt &lt; (55 * ui_den / ui_num))</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                 if ((55 * ui_den) % ui_num)</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                         exit_zero_cnt += 1;</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :         /* clk zero count */
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         clk_zero_cnt = DIV_ROUND_UP(</span>
<span class="lineNum">     561 </span>            :                         (tclk_prepare_clkzero - ths_prepare_ns)
<span class="lineNum">     562 </span>            :                         * ui_den, 2 * ui_num);
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :         /* trail count */
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         tclk_trail_ns = max(mipi_config-&gt;tclk_trail, mipi_config-&gt;ths_trail);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :         trail_cnt = DIV_ROUND_UP(tclk_trail_ns * ui_den, 2 * ui_num);</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         if (prepare_cnt &gt; PREPARE_CNT_MAX ||</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                 exit_zero_cnt &gt; EXIT_ZERO_CNT_MAX ||</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                 clk_zero_cnt &gt; CLK_ZERO_CNT_MAX ||</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :                 trail_cnt &gt; TRAIL_CNT_MAX)</span>
<span class="lineNum">     572 </span>            :                 DRM_DEBUG_DRIVER(&quot;Values crossing maximum limits, restricting to max values\n&quot;);
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         if (prepare_cnt &gt; PREPARE_CNT_MAX)</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                 prepare_cnt = PREPARE_CNT_MAX;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         if (exit_zero_cnt &gt; EXIT_ZERO_CNT_MAX)</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :                 exit_zero_cnt = EXIT_ZERO_CNT_MAX;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         if (clk_zero_cnt &gt; CLK_ZERO_CNT_MAX)</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 clk_zero_cnt = CLK_ZERO_CNT_MAX;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         if (trail_cnt &gt; TRAIL_CNT_MAX)</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :                 trail_cnt = TRAIL_CNT_MAX;</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :         /* B080 */
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;dphy_reg = exit_zero_cnt &lt;&lt; 24 | trail_cnt &lt;&lt; 16 |</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                                                 clk_zero_cnt &lt;&lt; 8 | prepare_cnt;</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :         /*
<span class="lineNum">     591 </span>            :          * LP to HS switch count = 4TLPX + PREP_COUNT * 2 + EXIT_ZERO_COUNT * 2
<span class="lineNum">     592 </span>            :          *                                      + 10UI + Extra Byte Count
<span class="lineNum">     593 </span>            :          *
<span class="lineNum">     594 </span>            :          * HS to LP switch count = THS-TRAIL + 2TLPX + Extra Byte Count
<span class="lineNum">     595 </span>            :          * Extra Byte Count is calculated according to number of lanes.
<span class="lineNum">     596 </span>            :          * High Low Switch Count is the Max of LP to HS and
<span class="lineNum">     597 </span>            :          * HS to LP switch count
<span class="lineNum">     598 </span>            :          *
<span class="lineNum">     599 </span>            :          */
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         tlpx_ui = DIV_ROUND_UP(tlpx_ns * ui_den, ui_num);</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :         /* B044 */
<span class="lineNum">     603 </span>            :         /* FIXME:
<span class="lineNum">     604 </span>            :          * The comment above does not match with the code */
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         lp_to_hs_switch = DIV_ROUND_UP(4 * tlpx_ui + prepare_cnt * 2 +</span>
<span class="lineNum">     606 </span>            :                                                 exit_zero_cnt * 2 + 10, 8);
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         hs_to_lp_switch = DIV_ROUND_UP(mipi_config-&gt;ths_trail + 2 * tlpx_ui, 8);</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;hs_to_lp_count = max(lp_to_hs_switch, hs_to_lp_switch);</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;hs_to_lp_count += extra_byte_count;</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :         /* B088 */
<span class="lineNum">     614 </span>            :         /* LP -&gt; HS for clock lanes
<span class="lineNum">     615 </span>            :          * LP clk sync + LP11 + LP01 + tclk_prepare + tclk_zero +
<span class="lineNum">     616 </span>            :          *                                              extra byte count
<span class="lineNum">     617 </span>            :          * 2TPLX + 1TLPX + 1 TPLX(in ns) + prepare_cnt * 2 + clk_zero_cnt *
<span class="lineNum">     618 </span>            :          *                                      2(in UI) + extra byte count
<span class="lineNum">     619 </span>            :          * In byteclks = (4TLPX + prepare_cnt * 2 + clk_zero_cnt *2 (in UI)) /
<span class="lineNum">     620 </span>            :          *                                      8 + extra byte count
<span class="lineNum">     621 </span>            :          */
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;clk_lp_to_hs_count =</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                 DIV_ROUND_UP(</span>
<span class="lineNum">     624 </span>            :                         4 * tlpx_ui + prepare_cnt * 2 +
<span class="lineNum">     625 </span>            :                         clk_zero_cnt * 2,
<span class="lineNum">     626 </span>            :                         8);
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;clk_lp_to_hs_count += extra_byte_count;</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :         /* HS-&gt;LP for Clock Lanes
<span class="lineNum">     631 </span>            :          * Low Power clock synchronisations + 1Tx byteclk + tclk_trail +
<span class="lineNum">     632 </span>            :          *                                              Extra byte count
<span class="lineNum">     633 </span>            :          * 2TLPX + 8UI + (trail_count*2)(in UI) + Extra byte count
<span class="lineNum">     634 </span>            :          * In byteclks = (2*TLpx(in UI) + trail_count*2 +8)(in UI)/8 +
<span class="lineNum">     635 </span>            :          *                                              Extra byte count
<span class="lineNum">     636 </span>            :          */
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;clk_hs_to_lp_count =</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                 DIV_ROUND_UP(2 * tlpx_ui + trail_cnt * 2 + 8,</span>
<span class="lineNum">     639 </span>            :                         8);
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;clk_hs_to_lp_count += extra_byte_count;</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :         DRM_DEBUG_KMS(&quot;Eot %s\n&quot;, intel_dsi-&gt;eotp_pkt ? &quot;enabled&quot; : &quot;disabled&quot;);
<span class="lineNum">     643 </span>            :         DRM_DEBUG_KMS(&quot;Clockstop %s\n&quot;, intel_dsi-&gt;clock_stop ?
<span class="lineNum">     644 </span>            :                                                 &quot;disabled&quot; : &quot;enabled&quot;);
<span class="lineNum">     645 </span>            :         DRM_DEBUG_KMS(&quot;Mode %s\n&quot;, intel_dsi-&gt;operation_mode ? &quot;command&quot; : &quot;video&quot;);
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         if (intel_dsi-&gt;dual_link == DSI_DUAL_LINK_FRONT_BACK)</span>
<span class="lineNum">     647 </span>            :                 DRM_DEBUG_KMS(&quot;Dual link: DSI_DUAL_LINK_FRONT_BACK\n&quot;);
<span class="lineNum">     648 </span>            :         else if (intel_dsi-&gt;dual_link == DSI_DUAL_LINK_PIXEL_ALT)
<span class="lineNum">     649 </span>            :                 DRM_DEBUG_KMS(&quot;Dual link: DSI_DUAL_LINK_PIXEL_ALT\n&quot;);
<span class="lineNum">     650 </span>            :         else
<span class="lineNum">     651 </span>            :                 DRM_DEBUG_KMS(&quot;Dual link: NONE\n&quot;);
<span class="lineNum">     652 </span>            :         DRM_DEBUG_KMS(&quot;Pixel Format %d\n&quot;, intel_dsi-&gt;pixel_format);
<span class="lineNum">     653 </span>            :         DRM_DEBUG_KMS(&quot;TLPX %d\n&quot;, intel_dsi-&gt;escape_clk_div);
<span class="lineNum">     654 </span>            :         DRM_DEBUG_KMS(&quot;LP RX Timeout 0x%x\n&quot;, intel_dsi-&gt;lp_rx_timeout);
<span class="lineNum">     655 </span>            :         DRM_DEBUG_KMS(&quot;Turnaround Timeout 0x%x\n&quot;, intel_dsi-&gt;turn_arnd_val);
<span class="lineNum">     656 </span>            :         DRM_DEBUG_KMS(&quot;Init Count 0x%x\n&quot;, intel_dsi-&gt;init_count);
<span class="lineNum">     657 </span>            :         DRM_DEBUG_KMS(&quot;HS to LP Count 0x%x\n&quot;, intel_dsi-&gt;hs_to_lp_count);
<span class="lineNum">     658 </span>            :         DRM_DEBUG_KMS(&quot;LP Byte Clock %d\n&quot;, intel_dsi-&gt;lp_byte_clk);
<span class="lineNum">     659 </span>            :         DRM_DEBUG_KMS(&quot;DBI BW Timer 0x%x\n&quot;, intel_dsi-&gt;bw_timer);
<span class="lineNum">     660 </span>            :         DRM_DEBUG_KMS(&quot;LP to HS Clock Count 0x%x\n&quot;, intel_dsi-&gt;clk_lp_to_hs_count);
<span class="lineNum">     661 </span>            :         DRM_DEBUG_KMS(&quot;HS to LP Clock Count 0x%x\n&quot;, intel_dsi-&gt;clk_hs_to_lp_count);
<span class="lineNum">     662 </span>            :         DRM_DEBUG_KMS(&quot;BTA %s\n&quot;,
<span class="lineNum">     663 </span>            :                         intel_dsi-&gt;video_frmt_cfg_bits &amp; DISABLE_VIDEO_BTA ?
<span class="lineNum">     664 </span>            :                         &quot;disabled&quot; : &quot;enabled&quot;);
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :         /* delays in VBT are in unit of 100us, so need to convert
<span class="lineNum">     667 </span>            :          * here in ms
<span class="lineNum">     668 </span>            :          * Delay (100us) * 100 /1000 = Delay / 10 (ms) */
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;backlight_off_delay = pps-&gt;bl_disable_delay / 10;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;backlight_on_delay = pps-&gt;bl_enable_delay / 10;</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;panel_on_delay = pps-&gt;panel_on_delay / 10;</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;panel_off_delay = pps-&gt;panel_off_delay / 10;</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :         intel_dsi-&gt;panel_pwr_cycle_delay = pps-&gt;panel_power_cycle_delay / 10;</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :         /* This is cheating a bit with the cleanup. */
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         vbt_panel = devm_kzalloc(dev-&gt;dev, sizeof(*vbt_panel), GFP_KERNEL);</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         vbt_panel-&gt;intel_dsi = intel_dsi;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         drm_panel_init(&amp;vbt_panel-&gt;panel);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         vbt_panel-&gt;panel.funcs = &amp;vbt_panel_funcs;</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         drm_panel_add(&amp;vbt_panel-&gt;panel);</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :         /* a regular driver would get the device in probe */
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         for_each_dsi_port(port, intel_dsi-&gt;ports) {</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :                 mipi_dsi_attach(intel_dsi-&gt;dsi_hosts[port]-&gt;device);</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         return &amp;vbt_panel-&gt;panel;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
