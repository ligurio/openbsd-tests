<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/i915/intel_bios.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/i915</a> - intel_bios.c<span style="font-size: 80%;"> (source / <a href="intel_bios.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">595</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright Â© 2006 Intel Corporation
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       5 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">       6 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">       7 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">       8 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">       9 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      12 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      13 </span>            :  * Software.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      16 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      17 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      18 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      19 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
<span class="lineNum">      20 </span>            :  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
<span class="lineNum">      21 </span>            :  * SOFTWARE.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * Authors:
<span class="lineNum">      24 </span>            :  *    Eric Anholt &lt;eric@anholt.net&gt;
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : #ifdef __linux__
<span class="lineNum">      28 </span>            : #include &lt;linux/dmi.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;drm/drm_dp_helper.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;drm/drmP.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;drm/i915_drm.h&gt;
<span class="lineNum">      32 </span>            : #else
<span class="lineNum">      33 </span>            : #include &lt;dev/pci/drm/drm_dp_helper.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;dev/pci/drm/drmP.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;dev/pci/drm/i915_drm.h&gt;
<span class="lineNum">      36 </span>            : #endif
<span class="lineNum">      37 </span>            : #include &quot;i915_drv.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;intel_bios.h&quot;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #define SLAVE_ADDR1     0x70
<span class="lineNum">      41 </span>            : #define SLAVE_ADDR2     0x72
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : static int panel_type;
<a name="44"><span class="lineNum">      44 </span>            : </a>
<span class="lineNum">      45 </span>            : static const void *
<span class="lineNum">      46 </span><span class="lineNoCov">          0 : find_section(const void *_bdb, int section_id)</span>
<span class="lineNum">      47 </span>            : {
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :         const struct bdb_header *bdb = _bdb;</span>
<span class="lineNum">      49 </span>            :         const u8 *base = _bdb;
<span class="lineNum">      50 </span>            :         int index = 0;
<span class="lineNum">      51 </span>            :         u32 total, current_size;
<span class="lineNum">      52 </span>            :         u8 current_id;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :         /* skip to first section */
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :         index += bdb-&gt;header_size;</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :         total = bdb-&gt;bdb_size;</span>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :         /* walk the sections looking for section_id */
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :         while (index + 3 &lt; total) {</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :                 current_id = *(base + index);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :                 index++;</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :                 current_size = *((const u16 *)(base + index));</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :                 index += 2;</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :                 /* The MIPI Sequence Block v3+ has a separate size field. */
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :                 if (current_id == BDB_MIPI_SEQUENCE &amp;&amp; *(base + index) &gt;= 3)</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :                         current_size = *((const u32 *)(base + index + 1));</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :                 if (index + current_size &gt; total)</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :                 if (current_id == section_id)</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :                         return base + index;</span>
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :                 index += current_size;
<span class="lineNum">      77 </span>            :         }
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 : }</span>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<span class="lineNum">      82 </span>            : static u16
<span class="lineNum">      83 </span><span class="lineNoCov">          0 : get_blocksize(const void *p)</span>
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span>            :         u16 *block_ptr, block_size;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         block_ptr = (u16 *)((char *)p - 2);</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :         block_size = *block_ptr;</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         return block_size;</span>
<span class="lineNum">      90 </span>            : }
<a name="91"><span class="lineNum">      91 </span>            : </a>
<span class="lineNum">      92 </span>            : static void
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode,</span>
<span class="lineNum">      94 </span>            :                         const struct lvds_dvo_timing *dvo_timing)
<span class="lineNum">      95 </span>            : {
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;hdisplay = (dvo_timing-&gt;hactive_hi &lt;&lt; 8) |</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                 dvo_timing-&gt;hactive_lo;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;hsync_start = panel_fixed_mode-&gt;hdisplay +</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                 ((dvo_timing-&gt;hsync_off_hi &lt;&lt; 8) | dvo_timing-&gt;hsync_off_lo);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;hsync_end = panel_fixed_mode-&gt;hsync_start +</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 dvo_timing-&gt;hsync_pulse_width;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;htotal = panel_fixed_mode-&gt;hdisplay +</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                 ((dvo_timing-&gt;hblank_hi &lt;&lt; 8) | dvo_timing-&gt;hblank_lo);</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;vdisplay = (dvo_timing-&gt;vactive_hi &lt;&lt; 8) |</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :                 dvo_timing-&gt;vactive_lo;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;vsync_start = panel_fixed_mode-&gt;vdisplay +</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 dvo_timing-&gt;vsync_off;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;vsync_end = panel_fixed_mode-&gt;vsync_start +</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :                 dvo_timing-&gt;vsync_pulse_width;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;vtotal = panel_fixed_mode-&gt;vdisplay +</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :                 ((dvo_timing-&gt;vblank_hi &lt;&lt; 8) | dvo_timing-&gt;vblank_lo);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;clock = dvo_timing-&gt;clock * 10;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :         panel_fixed_mode-&gt;type = DRM_MODE_TYPE_PREFERRED;</span>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         if (dvo_timing-&gt;hsync_positive)</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :                 panel_fixed_mode-&gt;flags |= DRM_MODE_FLAG_PHSYNC;</span>
<span class="lineNum">     118 </span>            :         else
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :                 panel_fixed_mode-&gt;flags |= DRM_MODE_FLAG_NHSYNC;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         if (dvo_timing-&gt;vsync_positive)</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :                 panel_fixed_mode-&gt;flags |= DRM_MODE_FLAG_PVSYNC;</span>
<span class="lineNum">     123 </span>            :         else
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                 panel_fixed_mode-&gt;flags |= DRM_MODE_FLAG_NVSYNC;</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :         /* Some VBTs have bogus h/vtotal values */
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         if (panel_fixed_mode-&gt;hsync_end &gt; panel_fixed_mode-&gt;htotal)</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :                 panel_fixed_mode-&gt;htotal = panel_fixed_mode-&gt;hsync_end + 1;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         if (panel_fixed_mode-&gt;vsync_end &gt; panel_fixed_mode-&gt;vtotal)</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                 panel_fixed_mode-&gt;vtotal = panel_fixed_mode-&gt;vsync_end + 1;</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         drm_mode_set_name(panel_fixed_mode);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 : }</span>
<a name="134"><span class="lineNum">     134 </span>            : </a>
<span class="lineNum">     135 </span>            : static const struct lvds_dvo_timing *
<span class="lineNum">     136 </span><span class="lineNoCov">          0 : get_lvds_dvo_timing(const struct bdb_lvds_lfp_data *lvds_lfp_data,</span>
<span class="lineNum">     137 </span>            :                     const struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs,
<span class="lineNum">     138 </span>            :                     int index)
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span>            :         /*
<span class="lineNum">     141 </span>            :          * the size of fp_timing varies on the different platform.
<span class="lineNum">     142 </span>            :          * So calculate the DVO timing relative offset in LVDS data
<span class="lineNum">     143 </span>            :          * entry to get the DVO timing entry
<span class="lineNum">     144 </span>            :          */
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :         int lfp_data_size =
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                 lvds_lfp_data_ptrs-&gt;ptr[1].dvo_timing_offset -</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :                 lvds_lfp_data_ptrs-&gt;ptr[0].dvo_timing_offset;</span>
<span class="lineNum">     149 </span>            :         int dvo_timing_offset =
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                 lvds_lfp_data_ptrs-&gt;ptr[0].dvo_timing_offset -</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :                 lvds_lfp_data_ptrs-&gt;ptr[0].fp_timing_offset;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         char *entry = (char *)lvds_lfp_data-&gt;data + lfp_data_size * index;</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         return (struct lvds_dvo_timing *)(entry + dvo_timing_offset);</span>
<span class="lineNum">     155 </span>            : }
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /* get lvds_fp_timing entry
<span class="lineNum">     158 </span>            :  * this function may return NULL if the corresponding entry is invalid
<a name="159"><span class="lineNum">     159 </span>            :  */</a>
<span class="lineNum">     160 </span>            : static const struct lvds_fp_timing *
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : get_lvds_fp_timing(const struct bdb_header *bdb,</span>
<span class="lineNum">     162 </span>            :                    const struct bdb_lvds_lfp_data *data,
<span class="lineNum">     163 </span>            :                    const struct bdb_lvds_lfp_data_ptrs *ptrs,
<span class="lineNum">     164 </span>            :                    int index)
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         size_t data_ofs = (const u8 *)data - (const u8 *)bdb;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         u16 data_size = ((const u16 *)data)[-1]; /* stored in header */</span>
<span class="lineNum">     168 </span>            :         size_t ofs;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         if (index &gt;= ARRAY_SIZE(ptrs-&gt;ptr))</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         ofs = ptrs-&gt;ptr[index].fp_timing_offset;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :         if (ofs &lt; data_ofs ||</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :             ofs + sizeof(struct lvds_fp_timing) &gt; data_ofs + data_size)</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         return (const struct lvds_fp_timing *)((const u8 *)bdb + ofs);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     178 </span>            : 
<a name="179"><span class="lineNum">     179 </span>            : /* Try to find integrated panel data */</a>
<span class="lineNum">     180 </span>            : static void
<span class="lineNum">     181 </span><span class="lineNoCov">          0 : parse_lfp_panel_data(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     182 </span>            :                      const struct bdb_header *bdb)
<span class="lineNum">     183 </span>            : {
<span class="lineNum">     184 </span>            :         const struct bdb_lvds_options *lvds_options;
<span class="lineNum">     185 </span>            :         const struct bdb_lvds_lfp_data *lvds_lfp_data;
<span class="lineNum">     186 </span>            :         const struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs;
<span class="lineNum">     187 </span>            :         const struct lvds_dvo_timing *panel_dvo_timing;
<span class="lineNum">     188 </span>            :         const struct lvds_fp_timing *fp_timing;
<span class="lineNum">     189 </span>            :         struct drm_display_mode *panel_fixed_mode;
<span class="lineNum">     190 </span>            :         int drrs_mode;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         lvds_options = find_section(bdb, BDB_LVDS_OPTIONS);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         if (!lvds_options)</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lvds_dither = lvds_options-&gt;pixel_dither;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         if (lvds_options-&gt;panel_type == 0xff)</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         panel_type = lvds_options-&gt;panel_type;</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         drrs_mode = (lvds_options-&gt;dps_panel_type_bits</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :                                 &gt;&gt; (panel_type * 2)) &amp; MODE_MASK;</span>
<span class="lineNum">     204 </span>            :         /*
<span class="lineNum">     205 </span>            :          * VBT has static DRRS = 0 and seamless DRRS = 2.
<span class="lineNum">     206 </span>            :          * The below piece of code is required to adjust vbt.drrs_type
<span class="lineNum">     207 </span>            :          * to match the enum drrs_support_type.
<span class="lineNum">     208 </span>            :          */
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         switch (drrs_mode) {</span>
<span class="lineNum">     210 </span>            :         case 0:
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.drrs_type = STATIC_DRRS_SUPPORT;</span>
<span class="lineNum">     212 </span>            :                 DRM_DEBUG_KMS(&quot;DRRS supported mode is static\n&quot;);
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     214 </span>            :         case 2:
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.drrs_type = SEAMLESS_DRRS_SUPPORT;</span>
<span class="lineNum">     216 </span>            :                 DRM_DEBUG_KMS(&quot;DRRS supported mode is seamless\n&quot;);
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     218 </span>            :         default:
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.drrs_type = DRRS_NOT_SUPPORTED;</span>
<span class="lineNum">     220 </span>            :                 DRM_DEBUG_KMS(&quot;DRRS not supported (VBT input)\n&quot;);
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     222 </span>            :         }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         lvds_lfp_data = find_section(bdb, BDB_LVDS_LFP_DATA);</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         if (!lvds_lfp_data)</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         lvds_lfp_data_ptrs = find_section(bdb, BDB_LVDS_LFP_DATA_PTRS);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         if (!lvds_lfp_data_ptrs)</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lvds_vbt = 1;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         panel_dvo_timing = get_lvds_dvo_timing(lvds_lfp_data,</span>
<span class="lineNum">     235 </span>            :                                                lvds_lfp_data_ptrs,
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                                                lvds_options-&gt;panel_type);</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         panel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         if (!panel_fixed_mode)</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         fill_detail_timing_data(panel_fixed_mode, panel_dvo_timing);</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lfp_lvds_vbt_mode = panel_fixed_mode;</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :         DRM_DEBUG_KMS(&quot;Found panel mode in BIOS VBT tables:\n&quot;);
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         drm_mode_debug_printmodeline(panel_fixed_mode);</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         fp_timing = get_lvds_fp_timing(bdb, lvds_lfp_data,</span>
<span class="lineNum">     250 </span>            :                                        lvds_lfp_data_ptrs,
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :                                        lvds_options-&gt;panel_type);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         if (fp_timing) {</span>
<span class="lineNum">     253 </span>            :                 /* check the resolution, just to be sure */
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                 if (fp_timing-&gt;x_res == panel_fixed_mode-&gt;hdisplay &amp;&amp;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                     fp_timing-&gt;y_res == panel_fixed_mode-&gt;vdisplay) {</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :                         dev_priv-&gt;vbt.bios_lvds_val = fp_timing-&gt;lvds_reg_val;</span>
<span class="lineNum">     257 </span>            :                         DRM_DEBUG_KMS(&quot;VBT initial LVDS value %x\n&quot;,
<span class="lineNum">     258 </span>            :                                       dev_priv-&gt;vbt.bios_lvds_val);
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     260 </span>            :         }
<span class="lineNum">     261 </span><span class="lineNoCov">          0 : }</span>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<span class="lineNum">     263 </span>            : static void
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : parse_lfp_backlight(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     265 </span>            :                     const struct bdb_header *bdb)
<span class="lineNum">     266 </span>            : {
<span class="lineNum">     267 </span>            :         const struct bdb_lfp_backlight_data *backlight_data;
<span class="lineNum">     268 </span>            :         const struct bdb_lfp_backlight_data_entry *entry;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         backlight_data = find_section(bdb, BDB_LVDS_BACKLIGHT);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         if (!backlight_data)</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         if (backlight_data-&gt;entry_size != sizeof(backlight_data-&gt;data[0])) {</span>
<span class="lineNum">     275 </span>            :                 DRM_DEBUG_KMS(&quot;Unsupported backlight data entry size %u\n&quot;,
<span class="lineNum">     276 </span>            :                               backlight_data-&gt;entry_size);
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     278 </span>            :         }
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         entry = &amp;backlight_data-&gt;data[panel_type];</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.backlight.present = entry-&gt;type == BDB_BACKLIGHT_TYPE_PWM;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.backlight.present) {</span>
<span class="lineNum">     284 </span>            :                 DRM_DEBUG_KMS(&quot;PWM backlight not present in VBT (type %u)\n&quot;,
<span class="lineNum">     285 </span>            :                               entry-&gt;type);
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     287 </span>            :         }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.backlight.pwm_freq_hz = entry-&gt;pwm_freq_hz;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.backlight.active_low_pwm = entry-&gt;active_low_pwm;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.backlight.min_brightness = entry-&gt;min_brightness;</span>
<span class="lineNum">     292 </span>            :         DRM_DEBUG_KMS(&quot;VBT backlight PWM modulation frequency %u Hz, &quot;
<span class="lineNum">     293 </span>            :                       &quot;active %s, min brightness %u, level %u\n&quot;,
<span class="lineNum">     294 </span>            :                       dev_priv-&gt;vbt.backlight.pwm_freq_hz,
<span class="lineNum">     295 </span>            :                       dev_priv-&gt;vbt.backlight.active_low_pwm ? &quot;low&quot; : &quot;high&quot;,
<span class="lineNum">     296 </span>            :                       dev_priv-&gt;vbt.backlight.min_brightness,
<span class="lineNum">     297 </span>            :                       backlight_data-&gt;level[panel_type]);
<span class="lineNum">     298 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     299 </span>            : 
<a name="300"><span class="lineNum">     300 </span>            : /* Try to find sdvo panel data */</a>
<span class="lineNum">     301 </span>            : static void
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : parse_sdvo_panel_data(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     303 </span>            :                       const struct bdb_header *bdb)
<span class="lineNum">     304 </span>            : {
<span class="lineNum">     305 </span>            :         const struct lvds_dvo_timing *dvo_timing;
<span class="lineNum">     306 </span>            :         struct drm_display_mode *panel_fixed_mode;
<span class="lineNum">     307 </span>            :         int index;
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         index = i915.vbt_sdvo_panel_type;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         if (index == -2) {</span>
<span class="lineNum">     311 </span>            :                 DRM_DEBUG_KMS(&quot;Ignore SDVO panel mode from BIOS VBT tables.\n&quot;);
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     313 </span>            :         }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         if (index == -1) {</span>
<span class="lineNum">     316 </span>            :                 const struct bdb_sdvo_lvds_options *sdvo_lvds_options;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 sdvo_lvds_options = find_section(bdb, BDB_SDVO_LVDS_OPTIONS);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                 if (!sdvo_lvds_options)</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :                 index = sdvo_lvds_options-&gt;panel_type;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         dvo_timing = find_section(bdb, BDB_SDVO_PANEL_DTDS);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         if (!dvo_timing)</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         panel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         if (!panel_fixed_mode)</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         fill_detail_timing_data(panel_fixed_mode, dvo_timing + index);</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.sdvo_lvds_vbt_mode = panel_fixed_mode;</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :         DRM_DEBUG_KMS(&quot;Found SDVO panel mode in BIOS VBT tables:\n&quot;);
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         drm_mode_debug_printmodeline(panel_fixed_mode);</span>
<a name="339"><span class="lineNum">     339 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span><span class="lineNoCov">          0 : static int intel_bios_ssc_frequency(struct drm_device *dev,</span>
<span class="lineNum">     342 </span>            :                                     bool alternate)
<span class="lineNum">     343 </span>            : {
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         switch (INTEL_INFO(dev)-&gt;gen) {</span>
<span class="lineNum">     345 </span>            :         case 2:
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                 return alternate ? 66667 : 48000;</span>
<span class="lineNum">     347 </span>            :         case 3:
<span class="lineNum">     348 </span>            :         case 4:
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :                 return alternate ? 100000 : 96000;</span>
<span class="lineNum">     350 </span>            :         default:
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                 return alternate ? 100000 : 120000;</span>
<span class="lineNum">     352 </span>            :         }
<span class="lineNum">     353 </span><span class="lineNoCov">          0 : }</span>
<a name="354"><span class="lineNum">     354 </span>            : </a>
<span class="lineNum">     355 </span>            : static void
<span class="lineNum">     356 </span><span class="lineNoCov">          0 : parse_general_features(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     357 </span>            :                        const struct bdb_header *bdb)
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         struct drm_device *dev = dev_priv-&gt;dev;</span>
<span class="lineNum">     360 </span>            :         const struct bdb_general_features *general;
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         general = find_section(bdb, BDB_GENERAL_FEATURES);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         if (general) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.int_tv_support = general-&gt;int_tv_support;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.int_crt_support = general-&gt;int_crt_support;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.lvds_use_ssc = general-&gt;enable_ssc;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.lvds_ssc_freq =</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                         intel_bios_ssc_frequency(dev, general-&gt;ssc_freq);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.display_clock_mode = general-&gt;display_clock_mode;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.fdi_rx_polarity_inverted = general-&gt;fdi_rx_polarity_inverted;</span>
<span class="lineNum">     371 </span>            :                 DRM_DEBUG_KMS(&quot;BDB_GENERAL_FEATURES int_tv_support %d int_crt_support %d lvds_use_ssc %d lvds_ssc_freq %d display_clock_mode %d fdi_rx_polarity_inverted %d\n&quot;,
<span class="lineNum">     372 </span>            :                               dev_priv-&gt;vbt.int_tv_support,
<span class="lineNum">     373 </span>            :                               dev_priv-&gt;vbt.int_crt_support,
<span class="lineNum">     374 </span>            :                               dev_priv-&gt;vbt.lvds_use_ssc,
<span class="lineNum">     375 </span>            :                               dev_priv-&gt;vbt.lvds_ssc_freq,
<span class="lineNum">     376 </span>            :                               dev_priv-&gt;vbt.display_clock_mode,
<span class="lineNum">     377 </span>            :                               dev_priv-&gt;vbt.fdi_rx_polarity_inverted);
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 : }</span>
<a name="380"><span class="lineNum">     380 </span>            : </a>
<span class="lineNum">     381 </span>            : static void
<span class="lineNum">     382 </span><span class="lineNoCov">          0 : parse_general_definitions(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     383 </span>            :                           const struct bdb_header *bdb)
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span>            :         const struct bdb_general_definitions *general;
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         general = find_section(bdb, BDB_GENERAL_DEFINITIONS);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         if (general) {</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :                 u16 block_size = get_blocksize(general);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 if (block_size &gt;= sizeof(*general)) {</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :                         int bus_pin = general-&gt;crt_ddc_gmbus_pin;</span>
<span class="lineNum">     392 </span>            :                         DRM_DEBUG_KMS(&quot;crt_ddc_bus_pin: %d\n&quot;, bus_pin);
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :                         if (intel_gmbus_is_valid_pin(dev_priv, bus_pin))</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.crt_ddc_pin = bus_pin;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">     396 </span>            :                         DRM_DEBUG_KMS(&quot;BDB_GD too small (%d). Invalid.\n&quot;,
<span class="lineNum">     397 </span>            :                                       block_size);
<span class="lineNum">     398 </span>            :                 }
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 : }</span>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<span class="lineNum">     402 </span>            : static const union child_device_config *
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : child_device_ptr(const struct bdb_general_definitions *p_defs, int i)</span>
<span class="lineNum">     404 </span>            : {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         return (const void *) &amp;p_defs-&gt;devices[i * p_defs-&gt;child_dev_size];</span>
<span class="lineNum">     406 </span>            : }
<a name="407"><span class="lineNum">     407 </span>            : </a>
<span class="lineNum">     408 </span>            : static void
<span class="lineNum">     409 </span><span class="lineNoCov">          0 : parse_sdvo_device_mapping(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     410 </span>            :                           const struct bdb_header *bdb)
<span class="lineNum">     411 </span>            : {
<span class="lineNum">     412 </span>            :         struct sdvo_device_mapping *p_mapping;
<span class="lineNum">     413 </span>            :         const struct bdb_general_definitions *p_defs;
<span class="lineNum">     414 </span>            :         const struct old_child_dev_config *child; /* legacy */
<span class="lineNum">     415 </span>            :         int i, child_device_num, count;
<span class="lineNum">     416 </span>            :         u16     block_size;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         p_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         if (!p_defs) {</span>
<span class="lineNum">     420 </span>            :                 DRM_DEBUG_KMS(&quot;No general definition block is found, unable to construct sdvo mapping.\n&quot;);
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     422 </span>            :         }
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :         /*
<span class="lineNum">     425 </span>            :          * Only parse SDVO mappings when the general definitions block child
<span class="lineNum">     426 </span>            :          * device size matches that of the *legacy* child device config
<span class="lineNum">     427 </span>            :          * struct. Thus, SDVO mapping will be skipped for newer VBT.
<span class="lineNum">     428 </span>            :          */
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         if (p_defs-&gt;child_dev_size != sizeof(*child)) {</span>
<span class="lineNum">     430 </span>            :                 DRM_DEBUG_KMS(&quot;Unsupported child device size for SDVO mapping.\n&quot;);
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     432 </span>            :         }
<span class="lineNum">     433 </span>            :         /* get the block size of general definitions */
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         block_size = get_blocksize(p_defs);</span>
<span class="lineNum">     435 </span>            :         /* get the number of child device */
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         child_device_num = (block_size - sizeof(*p_defs)) /</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                 p_defs-&gt;child_dev_size;</span>
<span class="lineNum">     438 </span>            :         count = 0;
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; child_device_num; i++) {</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                 child = &amp;child_device_ptr(p_defs, i)-&gt;old;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                 if (!child-&gt;device_type) {</span>
<span class="lineNum">     442 </span>            :                         /* skip the device block if device type is invalid */
<span class="lineNum">     443 </span>            :                         continue;
<span class="lineNum">     444 </span>            :                 }
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                 if (child-&gt;slave_addr != SLAVE_ADDR1 &amp;&amp;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                     child-&gt;slave_addr != SLAVE_ADDR2) {</span>
<span class="lineNum">     447 </span>            :                         /*
<span class="lineNum">     448 </span>            :                          * If the slave address is neither 0x70 nor 0x72,
<span class="lineNum">     449 </span>            :                          * it is not a SDVO device. Skip it.
<span class="lineNum">     450 </span>            :                          */
<span class="lineNum">     451 </span>            :                         continue;
<span class="lineNum">     452 </span>            :                 }
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 if (child-&gt;dvo_port != DEVICE_PORT_DVOB &amp;&amp;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                     child-&gt;dvo_port != DEVICE_PORT_DVOC) {</span>
<span class="lineNum">     455 </span>            :                         /* skip the incorrect SDVO port */
<span class="lineNum">     456 </span>            :                         DRM_DEBUG_KMS(&quot;Incorrect SDVO port. Skip it\n&quot;);
<span class="lineNum">     457 </span>            :                         continue;
<span class="lineNum">     458 </span>            :                 }
<span class="lineNum">     459 </span>            :                 DRM_DEBUG_KMS(&quot;the SDVO device with slave addr %2x is found on&quot;
<span class="lineNum">     460 </span>            :                               &quot; %s port\n&quot;,
<span class="lineNum">     461 </span>            :                               child-&gt;slave_addr,
<span class="lineNum">     462 </span>            :                               (child-&gt;dvo_port == DEVICE_PORT_DVOB) ?
<span class="lineNum">     463 </span>            :                               &quot;SDVOB&quot; : &quot;SDVOC&quot;);
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                 p_mapping = &amp;(dev_priv-&gt;sdvo_mappings[child-&gt;dvo_port - 1]);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                 if (!p_mapping-&gt;initialized) {</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                         p_mapping-&gt;dvo_port = child-&gt;dvo_port;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         p_mapping-&gt;slave_addr = child-&gt;slave_addr;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                         p_mapping-&gt;dvo_wiring = child-&gt;dvo_wiring;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                         p_mapping-&gt;ddc_pin = child-&gt;ddc_pin;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :                         p_mapping-&gt;i2c_pin = child-&gt;i2c_pin;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                         p_mapping-&gt;initialized = 1;</span>
<span class="lineNum">     472 </span>            :                         DRM_DEBUG_KMS(&quot;SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n&quot;,
<span class="lineNum">     473 </span>            :                                       p_mapping-&gt;dvo_port,
<span class="lineNum">     474 </span>            :                                       p_mapping-&gt;slave_addr,
<span class="lineNum">     475 </span>            :                                       p_mapping-&gt;dvo_wiring,
<span class="lineNum">     476 </span>            :                                       p_mapping-&gt;ddc_pin,
<span class="lineNum">     477 </span>            :                                       p_mapping-&gt;i2c_pin);
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">     479 </span>            :                         DRM_DEBUG_KMS(&quot;Maybe one SDVO port is shared by &quot;
<span class="lineNum">     480 </span>            :                                          &quot;two SDVO device.\n&quot;);
<span class="lineNum">     481 </span>            :                 }
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                 if (child-&gt;slave2_addr) {</span>
<span class="lineNum">     483 </span>            :                         /* Maybe this is a SDVO device with multiple inputs */
<span class="lineNum">     484 </span>            :                         /* And the mapping info is not added */
<span class="lineNum">     485 </span>            :                         DRM_DEBUG_KMS(&quot;there exists the slave2_addr. Maybe this&quot;
<span class="lineNum">     486 </span>            :                                 &quot; is a SDVO device with multiple inputs.\n&quot;);
<span class="lineNum">     487 </span>            :                 }
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :                 count++;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :         if (!count) {
<span class="lineNum">     492 </span>            :                 /* No SDVO device info is found */
<span class="lineNum">     493 </span>            :                 DRM_DEBUG_KMS(&quot;No SDVO device info is found in VBT\n&quot;);
<span class="lineNum">     494 </span>            :         }
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 : }</span>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<span class="lineNum">     498 </span>            : static void
<span class="lineNum">     499 </span><span class="lineNoCov">          0 : parse_driver_features(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">     500 </span>            :                       const struct bdb_header *bdb)
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span>            :         const struct bdb_driver_features *driver;
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         driver = find_section(bdb, BDB_DRIVER_FEATURES);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         if (!driver)</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         if (driver-&gt;lvds_config == BDB_DRIVER_FEATURE_EDP)</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_support = 1;</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         if (driver-&gt;dual_frequency)</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;render_reclock_avail = true;</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :         DRM_DEBUG_KMS(&quot;DRRS State Enabled:%d\n&quot;, driver-&gt;drrs_enabled);
<span class="lineNum">     515 </span>            :         /*
<span class="lineNum">     516 </span>            :          * If DRRS is not supported, drrs_type has to be set to 0.
<span class="lineNum">     517 </span>            :          * This is because, VBT is configured in such a way that
<span class="lineNum">     518 </span>            :          * static DRRS is 0 and DRRS not supported is represented by
<span class="lineNum">     519 </span>            :          * driver-&gt;drrs_enabled=false
<span class="lineNum">     520 </span>            :          */
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         if (!driver-&gt;drrs_enabled)</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.drrs_type = DRRS_NOT_SUPPORTED;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : }</span>
<a name="524"><span class="lineNum">     524 </span>            : </a>
<span class="lineNum">     525 </span>            : static void
<span class="lineNum">     526 </span><span class="lineNoCov">          0 : parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)</span>
<span class="lineNum">     527 </span>            : {
<span class="lineNum">     528 </span>            :         const struct bdb_edp *edp;
<span class="lineNum">     529 </span>            :         const struct edp_power_seq *edp_pps;
<span class="lineNum">     530 </span>            :         const struct edp_link_params *edp_link_params;
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         edp = find_section(bdb, BDB_EDP);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         if (!edp) {</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                 if (dev_priv-&gt;vbt.edp_support)</span>
<span class="lineNum">     535 </span>            :                         DRM_DEBUG_KMS(&quot;No eDP BDB found but eDP panel supported.\n&quot;);
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     537 </span>            :         }
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         switch ((edp-&gt;color_depth &gt;&gt; (panel_type * 2)) &amp; 3) {</span>
<span class="lineNum">     540 </span>            :         case EDP_18BPP:
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_bpp = 18;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     543 </span>            :         case EDP_24BPP:
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_bpp = 24;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     546 </span>            :         case EDP_30BPP:
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_bpp = 30;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     549 </span>            :         }
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :         /* Get the eDP sequencing and link info */
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         edp_pps = &amp;edp-&gt;power_seqs[panel_type];</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         edp_link_params = &amp;edp-&gt;link_params[panel_type];</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.edp_pps = *edp_pps;</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         switch (edp_link_params-&gt;rate) {</span>
<span class="lineNum">     558 </span>            :         case EDP_RATE_1_62:
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_rate = DP_LINK_BW_1_62;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     561 </span>            :         case EDP_RATE_2_7:
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_rate = DP_LINK_BW_2_7;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     564 </span>            :         default:
<span class="lineNum">     565 </span>            :                 DRM_DEBUG_KMS(&quot;VBT has unknown eDP link rate value %u\n&quot;,
<span class="lineNum">     566 </span>            :                               edp_link_params-&gt;rate);
<span class="lineNum">     567 </span>            :                 break;
<span class="lineNum">     568 </span>            :         }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         switch (edp_link_params-&gt;lanes) {</span>
<span class="lineNum">     571 </span>            :         case EDP_LANE_1:
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_lanes = 1;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     574 </span>            :         case EDP_LANE_2:
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_lanes = 2;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     577 </span>            :         case EDP_LANE_4:
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_lanes = 4;</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     580 </span>            :         default:
<span class="lineNum">     581 </span>            :                 DRM_DEBUG_KMS(&quot;VBT has unknown eDP lane count value %u\n&quot;,
<span class="lineNum">     582 </span>            :                               edp_link_params-&gt;lanes);
<span class="lineNum">     583 </span>            :                 break;
<span class="lineNum">     584 </span>            :         }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         switch (edp_link_params-&gt;preemphasis) {</span>
<span class="lineNum">     587 </span>            :         case EDP_PREEMPHASIS_NONE:
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_0;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     590 </span>            :         case EDP_PREEMPHASIS_3_5dB:
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_1;</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     593 </span>            :         case EDP_PREEMPHASIS_6dB:
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_2;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     596 </span>            :         case EDP_PREEMPHASIS_9_5dB:
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_3;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     599 </span>            :         default:
<span class="lineNum">     600 </span>            :                 DRM_DEBUG_KMS(&quot;VBT has unknown eDP pre-emphasis value %u\n&quot;,
<span class="lineNum">     601 </span>            :                               edp_link_params-&gt;preemphasis);
<span class="lineNum">     602 </span>            :                 break;
<span class="lineNum">     603 </span>            :         }
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         switch (edp_link_params-&gt;vswing) {</span>
<span class="lineNum">     606 </span>            :         case EDP_VSWING_0_4V:
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_0;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     609 </span>            :         case EDP_VSWING_0_6V:
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_1;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     612 </span>            :         case EDP_VSWING_0_8V:
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_2;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     615 </span>            :         case EDP_VSWING_1_2V:
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_3;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     618 </span>            :         default:
<span class="lineNum">     619 </span>            :                 DRM_DEBUG_KMS(&quot;VBT has unknown eDP voltage swing value %u\n&quot;,
<span class="lineNum">     620 </span>            :                               edp_link_params-&gt;vswing);
<span class="lineNum">     621 </span>            :                 break;
<span class="lineNum">     622 </span>            :         }
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         if (bdb-&gt;version &gt;= 173) {</span>
<span class="lineNum">     625 </span>            :                 uint8_t vswing;
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :                 /* Don't read from VBT if module parameter has valid value*/
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                 if (i915.edp_vswing) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :                         dev_priv-&gt;edp_low_vswing = i915.edp_vswing == 1;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                         vswing = (edp-&gt;edp_vswing_preemph &gt;&gt; (panel_type * 4)) &amp; 0xF;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :                         dev_priv-&gt;edp_low_vswing = vswing == 0;</span>
<span class="lineNum">     633 </span>            :                 }
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 : }</span>
<a name="636"><span class="lineNum">     636 </span>            : </a>
<span class="lineNum">     637 </span>            : static void
<span class="lineNum">     638 </span><span class="lineNoCov">          0 : parse_psr(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)</span>
<span class="lineNum">     639 </span>            : {
<span class="lineNum">     640 </span>            :         const struct bdb_psr *psr;
<span class="lineNum">     641 </span>            :         const struct psr_table *psr_table;
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         psr = find_section(bdb, BDB_PSR);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         if (!psr) {</span>
<span class="lineNum">     645 </span>            :                 DRM_DEBUG_KMS(&quot;No PSR BDB found.\n&quot;);
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     647 </span>            :         }
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         psr_table = &amp;psr-&gt;psr_table[panel_type];</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.psr.full_link = psr_table-&gt;full_link;</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.psr.require_aux_wakeup = psr_table-&gt;require_aux_to_wakeup;</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :         /* Allowed VBT values goes from 0 to 15 */
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.psr.idle_frames = psr_table-&gt;idle_frames &lt; 0 ? 0 :</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                 psr_table-&gt;idle_frames &gt; 15 ? 15 : psr_table-&gt;idle_frames;</span>
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         switch (psr_table-&gt;lines_to_wait) {</span>
<span class="lineNum">     659 </span>            :         case 0:
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.psr.lines_to_wait = PSR_0_LINES_TO_WAIT;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     662 </span>            :         case 1:
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.psr.lines_to_wait = PSR_1_LINE_TO_WAIT;</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     665 </span>            :         case 2:
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.psr.lines_to_wait = PSR_4_LINES_TO_WAIT;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     668 </span>            :         case 3:
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                 dev_priv-&gt;vbt.psr.lines_to_wait = PSR_8_LINES_TO_WAIT;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     671 </span>            :         default:
<span class="lineNum">     672 </span>            :                 DRM_DEBUG_KMS(&quot;VBT has unknown PSR lines to wait %u\n&quot;,
<span class="lineNum">     673 </span>            :                               psr_table-&gt;lines_to_wait);
<span class="lineNum">     674 </span>            :                 break;
<span class="lineNum">     675 </span>            :         }
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.psr.tp1_wakeup_time = psr_table-&gt;tp1_wakeup_time;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.psr.tp2_tp3_wakeup_time = psr_table-&gt;tp2_tp3_wakeup_time;</span>
<a name="679"><span class="lineNum">     679 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 : static u8 *goto_next_sequence(u8 *data, int *size)</span>
<span class="lineNum">     682 </span>            : {
<span class="lineNum">     683 </span>            :         u16 len;
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         int tmp = *size;</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         if (--tmp &lt; 0)</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :         /* goto first element */
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         data++;</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         while (1) {</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :                 switch (*data) {</span>
<span class="lineNum">     693 </span>            :                 case MIPI_SEQ_ELEM_SEND_PKT:
<span class="lineNum">     694 </span>            :                         /*
<span class="lineNum">     695 </span>            :                          * skip by this element payload size
<span class="lineNum">     696 </span>            :                          * skip elem id, command flag and data type
<span class="lineNum">     697 </span>            :                          */
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                         tmp -= 5;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :                         if (tmp &lt; 0)</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                         data += 3;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                         len = *((u16 *)data);</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                         tmp -= len;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :                         if (tmp &lt; 0)</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :                         /* skip by len */
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                         data = data + 2 + len;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     712 </span>            :                 case MIPI_SEQ_ELEM_DELAY:
<span class="lineNum">     713 </span>            :                         /* skip by elem id, and delay is 4 bytes */
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :                         tmp -= 5;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :                         if (tmp &lt; 0)</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                         data += 5;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     720 </span>            :                 case MIPI_SEQ_ELEM_GPIO:
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :                         tmp -= 3;</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :                         if (tmp &lt; 0)</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :                         data += 3;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     727 </span>            :                 default:
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;Unknown element\n&quot;);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     730 </span>            :                 }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :                 /* end of sequence ? */
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                 if (*data == 0)</span>
<span class="lineNum">     734 </span>            :                         break;
<span class="lineNum">     735 </span>            :         }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :         /* goto next sequence or end of block byte */
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         if (--tmp &lt; 0)</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         data++;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :         /* update amount of data left for the sequence block to be parsed */
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :         *size = tmp;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         return data;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 : }</span>
<a name="747"><span class="lineNum">     747 </span>            : </a>
<span class="lineNum">     748 </span>            : static void
<span class="lineNum">     749 </span><span class="lineNoCov">          0 : parse_mipi(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)</span>
<span class="lineNum">     750 </span>            : {
<span class="lineNum">     751 </span>            :         const struct bdb_mipi_config *start;
<span class="lineNum">     752 </span>            :         const struct bdb_mipi_sequence *sequence;
<span class="lineNum">     753 </span>            :         const struct mipi_config *config;
<span class="lineNum">     754 </span>            :         const struct mipi_pps_data *pps;
<span class="lineNum">     755 </span>            :         u8 *data;
<span class="lineNum">     756 </span>            :         const u8 *seq_data;
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         int i, panel_id, seq_size;</span>
<span class="lineNum">     758 </span>            :         u16 block_size;
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :         /* parse MIPI blocks only if LFP type is MIPI */
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.has_mipi)</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :         /* Initialize this to undefined indicating no generic MIPI support */
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.panel_id = MIPI_DSI_UNDEFINED_PANEL_ID;</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :         /* Block #40 is already parsed and panel_fixed_mode is
<span class="lineNum">     768 </span>            :          * stored in dev_priv-&gt;lfp_lvds_vbt_mode
<span class="lineNum">     769 </span>            :          * resuse this when needed
<span class="lineNum">     770 </span>            :          */
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :         /* Parse #52 for panel index used from panel_type already
<span class="lineNum">     773 </span>            :          * parsed
<span class="lineNum">     774 </span>            :          */
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         start = find_section(bdb, BDB_MIPI_CONFIG);</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :         if (!start) {</span>
<span class="lineNum">     777 </span>            :                 DRM_DEBUG_KMS(&quot;No MIPI config BDB found&quot;);
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     779 </span>            :         }
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :         DRM_DEBUG_DRIVER(&quot;Found MIPI Config block, panel index = %d\n&quot;,
<span class="lineNum">     782 </span>            :                                                                 panel_type);
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :         /*
<span class="lineNum">     785 </span>            :          * get hold of the correct configuration block and pps data as per
<span class="lineNum">     786 </span>            :          * the panel_type as index
<span class="lineNum">     787 </span>            :          */
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         config = &amp;start-&gt;config[panel_type];</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         pps = &amp;start-&gt;pps[panel_type];</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :         /* store as of now full data. Trim when we realise all is not needed */
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.config = kmemdup(config, sizeof(struct mipi_config), GFP_KERNEL);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.dsi.config)</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.pps = kmemdup(pps, sizeof(struct mipi_pps_data), GFP_KERNEL);</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.dsi.pps) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                 kfree(dev_priv-&gt;vbt.dsi.config);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     800 </span>            :         }
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :         /* We have mandatory mipi config blocks. Initialize as generic panel */
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.panel_id = MIPI_DSI_GENERIC_PANEL_ID;</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :         /* Check if we have sequence block as well */
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         sequence = find_section(bdb, BDB_MIPI_SEQUENCE);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         if (!sequence) {</span>
<span class="lineNum">     808 </span>            :                 DRM_DEBUG_KMS(&quot;No MIPI Sequence found, parsing complete\n&quot;);
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     810 </span>            :         }
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :         /* Fail gracefully for forward incompatible sequence block. */
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (sequence-&gt;version &gt;= 3) {</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;Unable to parse MIPI Sequence Block v3+\n&quot;);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     816 </span>            :         }
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :         DRM_DEBUG_DRIVER(&quot;Found MIPI sequence block\n&quot;);
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         block_size = get_blocksize(sequence);</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :         /*
<span class="lineNum">     823 </span>            :          * parse the sequence block for individual sequences
<span class="lineNum">     824 </span>            :          */
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.seq_version = sequence-&gt;version;</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :         seq_data = &amp;sequence-&gt;data[0];</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :         /*
<span class="lineNum">     830 </span>            :          * sequence block is variable length and hence we need to parse and
<span class="lineNum">     831 </span>            :          * get the sequence data for specific panel id
<span class="lineNum">     832 </span>            :          */
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; MAX_MIPI_CONFIGURATIONS; i++) {</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                 panel_id = *seq_data;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                 seq_size = *((u16 *) (seq_data + 1));</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :                 if (panel_id == panel_type)</span>
<span class="lineNum">     837 </span>            :                         break;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :                 /* skip the sequence including seq header of 3 bytes */
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                 seq_data = seq_data + 3 + seq_size;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                 if ((seq_data - &amp;sequence-&gt;data[0]) &gt; block_size) {</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;Sequence start is beyond sequence block size, corrupted sequence block\n&quot;);</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     844 </span>            :                 }
<span class="lineNum">     845 </span>            :         }
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         if (i == MAX_MIPI_CONFIGURATIONS) {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;Sequence block detected but no valid configuration\n&quot;);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     850 </span>            :         }
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :         /* check if found sequence is completely within the sequence block
<span class="lineNum">     853 </span>            :          * just being paranoid */
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :         if (seq_size &gt; block_size) {</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;Corrupted sequence/size, bailing out\n&quot;);</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     857 </span>            :         }
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :         /* skip the panel id(1 byte) and seq size(2 bytes) */
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.data = kmemdup(seq_data + 3, seq_size, GFP_KERNEL);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.dsi.data)</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :         /*
<span class="lineNum">     865 </span>            :          * loop into the sequence data and split into multiple sequneces
<span class="lineNum">     866 </span>            :          * There are only 5 types of sequences as of now
<span class="lineNum">     867 </span>            :          */
<span class="lineNum">     868 </span>            :         data = dev_priv-&gt;vbt.dsi.data;
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.size = seq_size;</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :         /* two consecutive 0x00 indicate end of all sequences */
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         while (1) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :                 int seq_id = *data;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :                 if (MIPI_SEQ_MAX &gt; seq_id &amp;&amp; seq_id &gt; MIPI_SEQ_UNDEFINED) {</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :                         dev_priv-&gt;vbt.dsi.sequence[seq_id] = data;</span>
<span class="lineNum">     876 </span>            :                         DRM_DEBUG_DRIVER(&quot;Found mipi sequence - %d\n&quot;, seq_id);
<span class="lineNum">     877 </span>            :                 } else {
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;undefined sequence\n&quot;);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :                         goto err;</span>
<span class="lineNum">     880 </span>            :                 }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            :                 /* partial parsing to skip elements */
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                 data = goto_next_sequence(data, &amp;seq_size);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :                 if (data == NULL) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :                         DRM_ERROR(&quot;Sequence elements going beyond block itself. Sequence block parsing failed\n&quot;);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                         goto err;</span>
<span class="lineNum">     888 </span>            :                 }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :                 if (*data == 0)</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :                         break; /* end of sequence reached */</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :         DRM_DEBUG_DRIVER(&quot;MIPI related vbt parsing complete\n&quot;);
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     896 </span>            : err:
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         kfree(dev_priv-&gt;vbt.dsi.data);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.dsi.data = NULL;</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :         /* error during parsing so set all pointers to null
<span class="lineNum">     901 </span>            :          * because of partial parsing */
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         memset(dev_priv-&gt;vbt.dsi.sequence, 0, sizeof(dev_priv-&gt;vbt.dsi.sequence));</span>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 : static u8 translate_iboost(u8 val)</span>
<span class="lineNum">     906 </span>            : {
<span class="lineNum">     907 </span>            :         static const u8 mapping[] = { 1, 3, 7 }; /* See VBT spec */
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :         if (val &gt;= ARRAY_SIZE(mapping)) {</span>
<span class="lineNum">     910 </span>            :                 DRM_DEBUG_KMS(&quot;Unsupported I_boost value found in VBT (%d), display may not work properly\n&quot;, val);
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     912 </span>            :         }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :         return mapping[val];</span>
<a name="914"><span class="lineNum">     914 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 : static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,</span>
<span class="lineNum">     917 </span>            :                            const struct bdb_header *bdb)
<span class="lineNum">     918 </span>            : {
<span class="lineNum">     919 </span>            :         union child_device_config *it, *child = NULL;
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         struct ddi_vbt_port_info *info = &amp;dev_priv-&gt;vbt.ddi_port_info[port];</span>
<span class="lineNum">     921 </span>            :         uint8_t hdmi_level_shift;
<span class="lineNum">     922 </span>            :         int i, j;
<span class="lineNum">     923 </span>            :         bool is_dvi, is_hdmi, is_dp, is_edp, is_crt;
<span class="lineNum">     924 </span>            :         uint8_t aux_channel, ddc_pin;
<span class="lineNum">     925 </span>            :         /* Each DDI port can have more than one value on the &quot;DVO Port&quot; field,
<span class="lineNum">     926 </span>            :          * so look for all the possible values for each port and abort if more
<span class="lineNum">     927 </span>            :          * than one is found. */
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         int dvo_ports[][3] = {</span>
<span class="lineNum">     929 </span>            :                 {DVO_PORT_HDMIA, DVO_PORT_DPA, -1},
<span class="lineNum">     930 </span>            :                 {DVO_PORT_HDMIB, DVO_PORT_DPB, -1},
<span class="lineNum">     931 </span>            :                 {DVO_PORT_HDMIC, DVO_PORT_DPC, -1},
<span class="lineNum">     932 </span>            :                 {DVO_PORT_HDMID, DVO_PORT_DPD, -1},
<span class="lineNum">     933 </span>            :                 {DVO_PORT_CRT, DVO_PORT_HDMIE, DVO_PORT_DPE},
<span class="lineNum">     934 </span>            :         };
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :         /* Find the child device to use, abort if more than one found. */
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; dev_priv-&gt;vbt.child_dev_num; i++) {</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :                 it = dev_priv-&gt;vbt.child_dev + i;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :                 for (j = 0; j &lt; 3; j++) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :                         if (dvo_ports[port][j] == -1)</span>
<span class="lineNum">     942 </span>            :                                 break;
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :                         if (it-&gt;common.dvo_port == dvo_ports[port][j]) {</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                                 if (child) {</span>
<span class="lineNum">     946 </span>            :                                         DRM_DEBUG_KMS(&quot;More than one child device for port %c in VBT.\n&quot;,
<span class="lineNum">     947 </span>            :                                                       port_name(port));
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :                                         return;</span>
<span class="lineNum">     949 </span>            :                                 }
<span class="lineNum">     950 </span>            :                                 child = it;
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">     952 </span>            :                 }
<span class="lineNum">     953 </span>            :         }
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         if (!child)</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         aux_channel = child-&gt;raw[25];</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         ddc_pin = child-&gt;common.ddc_pin;</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         is_dvi = child-&gt;common.device_type &amp; DEVICE_TYPE_TMDS_DVI_SIGNALING;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         is_dp = child-&gt;common.device_type &amp; DEVICE_TYPE_DISPLAYPORT_OUTPUT;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         is_crt = child-&gt;common.device_type &amp; DEVICE_TYPE_ANALOG_OUTPUT;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :         is_hdmi = is_dvi &amp;&amp; (child-&gt;common.device_type &amp; DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :         is_edp = is_dp &amp;&amp; (child-&gt;common.device_type &amp; DEVICE_TYPE_INTERNAL_CONNECTOR);</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         if (port == PORT_A &amp;&amp; is_dvi) {</span>
<span class="lineNum">     967 </span>            :                 DRM_DEBUG_KMS(&quot;VBT claims port A supports DVI%s, ignoring\n&quot;,
<span class="lineNum">     968 </span>            :                               is_hdmi ? &quot;/HDMI&quot; : &quot;&quot;);
<span class="lineNum">     969 </span>            :                 is_dvi = false;
<span class="lineNum">     970 </span>            :                 is_hdmi = false;
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         info-&gt;supports_dvi = is_dvi;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :         info-&gt;supports_hdmi = is_hdmi;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         info-&gt;supports_dp = is_dp;</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :         DRM_DEBUG_KMS(&quot;Port %c VBT info: DP:%d HDMI:%d DVI:%d EDP:%d CRT:%d\n&quot;,
<span class="lineNum">     978 </span>            :                       port_name(port), is_dp, is_hdmi, is_dvi, is_edp, is_crt);
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :         if (is_edp &amp;&amp; is_dvi)
<span class="lineNum">     981 </span>            :                 DRM_DEBUG_KMS(&quot;Internal DP port %c is TMDS compatible\n&quot;,
<span class="lineNum">     982 </span>            :                               port_name(port));
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         if (is_crt &amp;&amp; port != PORT_E)</span>
<span class="lineNum">     984 </span>            :                 DRM_DEBUG_KMS(&quot;Port %c is analog\n&quot;, port_name(port));
<span class="lineNum">     985 </span>            :         if (is_crt &amp;&amp; (is_dvi || is_dp))
<span class="lineNum">     986 </span>            :                 DRM_DEBUG_KMS(&quot;Analog port %c is also DP or TMDS compatible\n&quot;,
<span class="lineNum">     987 </span>            :                               port_name(port));
<span class="lineNum">     988 </span>            :         if (is_dvi &amp;&amp; (port == PORT_A || port == PORT_E))
<span class="lineNum">     989 </span>            :                 DRM_DEBUG_KMS(&quot;Port %c is TMDS compatible\n&quot;, port_name(port));
<span class="lineNum">     990 </span>            :         if (!is_dvi &amp;&amp; !is_dp &amp;&amp; !is_crt)
<span class="lineNum">     991 </span>            :                 DRM_DEBUG_KMS(&quot;Port %c is not DP/TMDS/CRT compatible\n&quot;,
<span class="lineNum">     992 </span>            :                               port_name(port));
<span class="lineNum">     993 </span>            :         if (is_edp &amp;&amp; (port == PORT_B || port == PORT_C || port == PORT_E))
<span class="lineNum">     994 </span>            :                 DRM_DEBUG_KMS(&quot;Port %c is internal DP\n&quot;, port_name(port));
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         if (is_dvi) {</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :                 if (port == PORT_E) {</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :                         info-&gt;alternate_ddc_pin = ddc_pin;</span>
<span class="lineNum">     999 </span>            :                         /* if DDIE share ddc pin with other port, then
<span class="lineNum">    1000 </span>            :                          * dvi/hdmi couldn't exist on the shared port.
<span class="lineNum">    1001 </span>            :                          * Otherwise they share the same ddc bin and system
<span class="lineNum">    1002 </span>            :                          * couldn't communicate with them seperately. */
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :                         if (ddc_pin == DDC_PIN_B) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_B].supports_dvi = 0;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_B].supports_hdmi = 0;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :                         } else if (ddc_pin == DDC_PIN_C) {</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_C].supports_dvi = 0;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_C].supports_hdmi = 0;</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :                         } else if (ddc_pin == DDC_PIN_D) {</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_D].supports_dvi = 0;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_D].supports_hdmi = 0;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                 } else if (ddc_pin == DDC_PIN_B &amp;&amp; port != PORT_B)</span>
<span class="lineNum">    1014 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected DDC pin for port B\n&quot;);
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                 else if (ddc_pin == DDC_PIN_C &amp;&amp; port != PORT_C)</span>
<span class="lineNum">    1016 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected DDC pin for port C\n&quot;);
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                 else if (ddc_pin == DDC_PIN_D &amp;&amp; port != PORT_D)</span>
<span class="lineNum">    1018 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected DDC pin for port D\n&quot;);
<span class="lineNum">    1019 </span>            :         }
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :         if (is_dp) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                 if (port == PORT_E) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :                         info-&gt;alternate_aux_channel = aux_channel;</span>
<span class="lineNum">    1024 </span>            :                         /* if DDIE share aux channel with other port, then
<span class="lineNum">    1025 </span>            :                          * DP couldn't exist on the shared port. Otherwise
<span class="lineNum">    1026 </span>            :                          * they share the same aux channel and system
<span class="lineNum">    1027 </span>            :                          * couldn't communicate with them seperately. */
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                         if (aux_channel == DP_AUX_A)</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_A].supports_dp = 0;</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                         else if (aux_channel == DP_AUX_B)</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_B].supports_dp = 0;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                         else if (aux_channel == DP_AUX_C)</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_C].supports_dp = 0;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                         else if (aux_channel == DP_AUX_D)</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                                 dev_priv-&gt;vbt.ddi_port_info[PORT_D].supports_dp = 0;</span>
<span class="lineNum">    1036 </span>            :                 }
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :                 else if (aux_channel == DP_AUX_A &amp;&amp; port != PORT_A)</span>
<span class="lineNum">    1038 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port A\n&quot;);
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                 else if (aux_channel == DP_AUX_B &amp;&amp; port != PORT_B)</span>
<span class="lineNum">    1040 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port B\n&quot;);
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :                 else if (aux_channel == DP_AUX_C &amp;&amp; port != PORT_C)</span>
<span class="lineNum">    1042 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port C\n&quot;);
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                 else if (aux_channel == DP_AUX_D &amp;&amp; port != PORT_D)</span>
<span class="lineNum">    1044 </span>            :                         DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port D\n&quot;);
<span class="lineNum">    1045 </span>            :         }
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         if (bdb-&gt;version &gt;= 158) {</span>
<span class="lineNum">    1048 </span>            :                 /* The VBT HDMI level shift values match the table we have. */
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                 hdmi_level_shift = child-&gt;raw[7] &amp; 0xF;</span>
<span class="lineNum">    1050 </span>            :                 DRM_DEBUG_KMS(&quot;VBT HDMI level shift for port %c: %d\n&quot;,
<span class="lineNum">    1051 </span>            :                               port_name(port),
<span class="lineNum">    1052 </span>            :                               hdmi_level_shift);
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :                 info-&gt;hdmi_level_shift = hdmi_level_shift;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :         /* Parse the I_boost config for SKL and above */
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         if (bdb-&gt;version &gt;= 196 &amp;&amp; (child-&gt;common.flags_1 &amp; IBOOST_ENABLE)) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                 info-&gt;dp_boost_level = translate_iboost(child-&gt;common.iboost_level &amp; 0xF);</span>
<span class="lineNum">    1059 </span>            :                 DRM_DEBUG_KMS(&quot;VBT (e)DP boost level for port %c: %d\n&quot;,
<span class="lineNum">    1060 </span>            :                               port_name(port), info-&gt;dp_boost_level);
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                 info-&gt;hdmi_boost_level = translate_iboost(child-&gt;common.iboost_level &gt;&gt; 4);</span>
<span class="lineNum">    1062 </span>            :                 DRM_DEBUG_KMS(&quot;VBT HDMI boost level for port %c: %d\n&quot;,
<span class="lineNum">    1063 </span>            :                               port_name(port), info-&gt;hdmi_boost_level);
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         }</span>
<a name="1065"><span class="lineNum">    1065 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 : static void parse_ddi_ports(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">    1068 </span>            :                             const struct bdb_header *bdb)
<span class="lineNum">    1069 </span>            : {
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :         struct drm_device *dev = dev_priv-&gt;dev;</span>
<span class="lineNum">    1071 </span>            :         enum port port;
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         if (!HAS_DDI(dev))</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.child_dev_num)</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         if (bdb-&gt;version &lt; 155)</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         for (port = PORT_A; port &lt; I915_MAX_PORTS; port++)</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :                 parse_ddi_port(dev_priv, port, bdb);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : }</span>
<a name="1085"><span class="lineNum">    1085 </span>            : </a>
<span class="lineNum">    1086 </span>            : static void
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 : parse_device_mapping(struct drm_i915_private *dev_priv,</span>
<span class="lineNum">    1088 </span>            :                      const struct bdb_header *bdb)
<span class="lineNum">    1089 </span>            : {
<span class="lineNum">    1090 </span>            :         const struct bdb_general_definitions *p_defs;
<span class="lineNum">    1091 </span>            :         const union child_device_config *p_child;
<span class="lineNum">    1092 </span>            :         union child_device_config *child_dev_ptr;
<span class="lineNum">    1093 </span>            :         int i, child_device_num, count;
<span class="lineNum">    1094 </span>            :         u8 expected_size;
<span class="lineNum">    1095 </span>            :         u16 block_size;
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         p_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         if (!p_defs) {</span>
<span class="lineNum">    1099 </span>            :                 DRM_DEBUG_KMS(&quot;No general definition block is found, no devices defined.\n&quot;);
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1101 </span>            :         }
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :         if (bdb-&gt;version &lt; 195) {</span>
<span class="lineNum">    1103 </span>            :                 expected_size = sizeof(struct old_child_dev_config);
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         } else if (bdb-&gt;version == 195) {</span>
<span class="lineNum">    1105 </span>            :                 expected_size = 37;
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         } else if (bdb-&gt;version &lt;= 197) {</span>
<span class="lineNum">    1107 </span>            :                 expected_size = 38;
<span class="lineNum">    1108 </span>            :         } else {
<span class="lineNum">    1109 </span>            :                 expected_size = 38;
<span class="lineNum">    1110 </span>            :                 BUILD_BUG_ON(sizeof(*p_child) &lt; 38);
<span class="lineNum">    1111 </span>            :                 DRM_DEBUG_DRIVER(&quot;Expected child device config size for VBT version %u not known; assuming %u\n&quot;,
<span class="lineNum">    1112 </span>            :                                  bdb-&gt;version, expected_size);
<span class="lineNum">    1113 </span>            :         }
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :         /* The legacy sized child device config is the minimum we need. */
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :         if (p_defs-&gt;child_dev_size &lt; sizeof(struct old_child_dev_config)) {</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;Child device config size %u is too small.\n&quot;,</span>
<span class="lineNum">    1118 </span>            :                           p_defs-&gt;child_dev_size);
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1120 </span>            :         }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :         /* Flag an error for unexpected size, but continue anyway. */
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :         if (p_defs-&gt;child_dev_size != expected_size)</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                 DRM_ERROR(&quot;Unexpected child device config size %u (expected %u for VBT version %u)\n&quot;,</span>
<span class="lineNum">    1125 </span>            :                           p_defs-&gt;child_dev_size, expected_size, bdb-&gt;version);
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            :         /* get the block size of general definitions */
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         block_size = get_blocksize(p_defs);</span>
<span class="lineNum">    1129 </span>            :         /* get the number of child device */
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         child_device_num = (block_size - sizeof(*p_defs)) /</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                                 p_defs-&gt;child_dev_size;</span>
<span class="lineNum">    1132 </span>            :         count = 0;
<span class="lineNum">    1133 </span>            :         /* get the number of child device that is present */
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; child_device_num; i++) {</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :                 p_child = child_device_ptr(p_defs, i);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                 if (!p_child-&gt;common.device_type) {</span>
<span class="lineNum">    1137 </span>            :                         /* skip the device block if device type is invalid */
<span class="lineNum">    1138 </span>            :                         continue;
<span class="lineNum">    1139 </span>            :                 }
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                 count++;</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :         if (!count) {</span>
<span class="lineNum">    1143 </span>            :                 DRM_DEBUG_KMS(&quot;no child dev is parsed from VBT\n&quot;);
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1145 </span>            :         }
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.child_dev = kcalloc(count, sizeof(*p_child), GFP_KERNEL);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.child_dev) {</span>
<span class="lineNum">    1148 </span>            :                 DRM_DEBUG_KMS(&quot;No memory space for child device\n&quot;);
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1150 </span>            :         }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.child_dev_num = count;</span>
<span class="lineNum">    1153 </span>            :         count = 0;
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; child_device_num; i++) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                 p_child = child_device_ptr(p_defs, i);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                 if (!p_child-&gt;common.device_type) {</span>
<span class="lineNum">    1157 </span>            :                         /* skip the device block if device type is invalid */
<span class="lineNum">    1158 </span>            :                         continue;
<span class="lineNum">    1159 </span>            :                 }
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                 if (p_child-&gt;common.dvo_port &gt;= DVO_PORT_MIPIA</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :                     &amp;&amp; p_child-&gt;common.dvo_port &lt;= DVO_PORT_MIPID</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                     &amp;&amp;p_child-&gt;common.device_type &amp; DEVICE_TYPE_MIPI_OUTPUT) {</span>
<span class="lineNum">    1164 </span>            :                         DRM_DEBUG_KMS(&quot;Found MIPI as LFP\n&quot;);
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                         dev_priv-&gt;vbt.has_mipi = 1;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :                         dev_priv-&gt;vbt.dsi.port = p_child-&gt;common.dvo_port;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :                 child_dev_ptr = dev_priv-&gt;vbt.child_dev + count;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :                 count++;</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            :                 /*
<span class="lineNum">    1173 </span>            :                  * Copy as much as we know (sizeof) and is available
<span class="lineNum">    1174 </span>            :                  * (child_dev_size) of the child device. Accessing the data must
<span class="lineNum">    1175 </span>            :                  * depend on VBT version.
<span class="lineNum">    1176 </span>            :                  */
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :                 memcpy(child_dev_ptr, p_child,</span>
<span class="lineNum">    1178 </span>            :                        min_t(size_t, p_defs-&gt;child_dev_size, sizeof(*p_child)));
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : }</span>
<a name="1182"><span class="lineNum">    1182 </span>            : </a>
<span class="lineNum">    1183 </span>            : static void
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 : init_vbt_defaults(struct drm_i915_private *dev_priv)</span>
<span class="lineNum">    1185 </span>            : {
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         struct drm_device *dev = dev_priv-&gt;dev;</span>
<span class="lineNum">    1187 </span>            :         enum port port;
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.crt_ddc_pin = GMBUS_PIN_VGADDC;</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            :         /* Default to having backlight */
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.backlight.present = true;</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            :         /* LFP panel data */
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lvds_dither = 1;</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lvds_vbt = 0;</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :         /* SDVO panel data */
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.sdvo_lvds_vbt_mode = NULL;</span>
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span>            :         /* general features */
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.int_tv_support = 1;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.int_crt_support = 1;</span>
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :         /* Default to using SSC */
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lvds_use_ssc = 1;</span>
<span class="lineNum">    1207 </span>            :         /*
<span class="lineNum">    1208 </span>            :          * Core/SandyBridge/IvyBridge use alternative (120MHz) reference
<span class="lineNum">    1209 </span>            :          * clock for LVDS.
<span class="lineNum">    1210 </span>            :          */
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :         dev_priv-&gt;vbt.lvds_ssc_freq = intel_bios_ssc_frequency(dev,</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :                         !HAS_PCH_SPLIT(dev));</span>
<span class="lineNum">    1213 </span>            :         DRM_DEBUG_KMS(&quot;Set default to SSC at %d kHz\n&quot;, dev_priv-&gt;vbt.lvds_ssc_freq);
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :         for (port = PORT_A; port &lt; I915_MAX_PORTS; port++) {</span>
<span class="lineNum">    1216 </span>            :                 struct ddi_vbt_port_info *info =
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                         &amp;dev_priv-&gt;vbt.ddi_port_info[port];</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                 info-&gt;hdmi_level_shift = HDMI_LEVEL_SHIFT_UNKNOWN;</span>
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                 info-&gt;supports_dvi = (port != PORT_A &amp;&amp; port != PORT_E);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                 info-&gt;supports_hdmi = info-&gt;supports_dvi;</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :                 info-&gt;supports_dp = (port != PORT_E);</span>
<span class="lineNum">    1224 </span>            :         }
<a name="1225"><span class="lineNum">    1225 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 : static int intel_no_opregion_vbt_callback(const struct dmi_system_id *id)</span>
<span class="lineNum">    1228 </span>            : {
<span class="lineNum">    1229 </span>            :         DRM_DEBUG_KMS(&quot;Falling back to manually reading VBT from &quot;
<span class="lineNum">    1230 </span>            :                       &quot;VBIOS ROM for %s\n&quot;,
<span class="lineNum">    1231 </span>            :                       id-&gt;ident);
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    1233 </span>            : }
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            : static const struct dmi_system_id intel_no_opregion_vbt[] = {
<span class="lineNum">    1236 </span>            :         {
<span class="lineNum">    1237 </span>            :                 .callback = intel_no_opregion_vbt_callback,
<span class="lineNum">    1238 </span>            :                 .ident = &quot;ThinkCentre A57&quot;,
<span class="lineNum">    1239 </span>            :                 .matches = {
<span class="lineNum">    1240 </span>            :                         DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="lineNum">    1241 </span>            :                         DMI_MATCH(DMI_PRODUCT_NAME, &quot;97027RG&quot;),
<span class="lineNum">    1242 </span>            :                 },
<span class="lineNum">    1243 </span>            :         },
<span class="lineNum">    1244 </span>            :         { }
<a name="1245"><span class="lineNum">    1245 </span>            : };</a>
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 : static const struct bdb_header *validate_vbt(const void *base,</span>
<span class="lineNum">    1248 </span>            :                                              size_t size,
<span class="lineNum">    1249 </span>            :                                              const void *_vbt,
<span class="lineNum">    1250 </span>            :                                              const char *source)
<span class="lineNum">    1251 </span>            : {
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :         size_t offset = _vbt - base;</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :         const struct vbt_header *vbt = _vbt;</span>
<span class="lineNum">    1254 </span>            :         const struct bdb_header *bdb;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :         if (offset + sizeof(struct vbt_header) &gt; size) {</span>
<span class="lineNum">    1257 </span>            :                 DRM_DEBUG_DRIVER(&quot;VBT header incomplete\n&quot;);
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1259 </span>            :         }
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :         if (memcmp(vbt-&gt;signature, &quot;$VBT&quot;, 4)) {</span>
<span class="lineNum">    1262 </span>            :                 DRM_DEBUG_DRIVER(&quot;VBT invalid signature\n&quot;);
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1264 </span>            :         }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :         offset += vbt-&gt;bdb_offset;</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :         if (offset + sizeof(struct bdb_header) &gt; size) {</span>
<span class="lineNum">    1268 </span>            :                 DRM_DEBUG_DRIVER(&quot;BDB header incomplete\n&quot;);
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1270 </span>            :         }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :         bdb = base + offset;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :         if (offset + bdb-&gt;bdb_size &gt; size) {</span>
<span class="lineNum">    1274 </span>            :                 DRM_DEBUG_DRIVER(&quot;BDB incomplete\n&quot;);
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1276 </span>            :         }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :         DRM_DEBUG_KMS(&quot;Using VBT from %s: %20s\n&quot;,
<span class="lineNum">    1279 </span>            :                       source, vbt-&gt;signature);
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :         return bdb;</span>
<a name="1281"><span class="lineNum">    1281 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 : static const struct bdb_header *find_vbt(void __iomem *bios, size_t size)</span>
<span class="lineNum">    1284 </span>            : {
<span class="lineNum">    1285 </span>            :         const struct bdb_header *bdb = NULL;
<span class="lineNum">    1286 </span>            :         size_t i;
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :         /* Scour memory looking for the VBT signature. */
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :         for (i = 0; i + 4 &lt; size; i++) {</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                 if (ioread32(bios + i) == *((const u32 *) &quot;$VBT&quot;)) {</span>
<span class="lineNum">    1291 </span>            :                         /*
<span class="lineNum">    1292 </span>            :                          * This is the one place where we explicitly discard the
<span class="lineNum">    1293 </span>            :                          * address space (__iomem) of the BIOS/VBT. From now on
<span class="lineNum">    1294 </span>            :                          * everything is based on 'base', and treated as regular
<span class="lineNum">    1295 </span>            :                          * memory.
<span class="lineNum">    1296 </span>            :                          */
<span class="lineNum">    1297 </span>            :                         void *_bios = (void __force *) bios;
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :                         bdb = validate_vbt(_bios, size, _bios + i, &quot;PCI ROM&quot;);</span>
<span class="lineNum">    1300 </span>            :                         break;
<span class="lineNum">    1301 </span>            :                 }
<span class="lineNum">    1302 </span>            :         }
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :         return bdb;</span>
<span class="lineNum">    1305 </span>            : }
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            : #include &lt;dev/isa/isareg.h&gt;
<span class="lineNum">    1308 </span>            : #include &lt;dev/isa/isavar.h&gt;
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            : #define VGA_BIOS_ADDR   0xc0000
<span class="lineNum">    1311 </span>            : #define VGA_BIOS_LEN    0x10000
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : /**
<span class="lineNum">    1314 </span>            :  * intel_parse_bios - find VBT and initialize settings from the BIOS
<span class="lineNum">    1315 </span>            :  * @dev: DRM device
<span class="lineNum">    1316 </span>            :  *
<span class="lineNum">    1317 </span>            :  * Loads the Video BIOS and checks that the VBT exists.  Sets scratch registers
<span class="lineNum">    1318 </span>            :  * to appropriate values.
<span class="lineNum">    1319 </span>            :  *
<span class="lineNum">    1320 </span>            :  * Returns 0 on success, nonzero on failure.
<a name="1321"><span class="lineNum">    1321 </span>            :  */</a>
<span class="lineNum">    1322 </span>            : int
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 : intel_parse_bios(struct drm_device *dev)</span>
<span class="lineNum">    1324 </span>            : {
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">    1326 </span>            : #ifdef __linux__
<span class="lineNum">    1327 </span>            :         struct pci_dev *pdev = dev-&gt;pdev;
<span class="lineNum">    1328 </span>            : #endif
<span class="lineNum">    1329 </span>            :         const struct bdb_header *bdb = NULL;
<span class="lineNum">    1330 </span>            :         u8 __iomem *bios = NULL;
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         if (HAS_PCH_NOP(dev))</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                 return -ENODEV;</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :         init_vbt_defaults(dev_priv);</span>
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            :         /* XXX Should this validation be moved to intel_opregion.c? */
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :         if (!dmi_check_system(intel_no_opregion_vbt) &amp;&amp; dev_priv-&gt;opregion.vbt)</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :                 bdb = validate_vbt(dev_priv-&gt;opregion.header, OPREGION_SIZE,</span>
<span class="lineNum">    1340 </span>            :                                    dev_priv-&gt;opregion.vbt, &quot;OpRegion&quot;);
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         if (bdb == NULL) {</span>
<span class="lineNum">    1343 </span>            :                 size_t size;
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            : #ifdef __linux__
<span class="lineNum">    1346 </span>            :                 bios = pci_map_rom(pdev, &amp;size);
<span class="lineNum">    1347 </span>            :                 if (!bios)
<span class="lineNum">    1348 </span>            :                         return -1;
<span class="lineNum">    1349 </span>            : #else
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                 bios = (u8 *)ISA_HOLE_VADDR(VGA_BIOS_ADDR);</span>
<span class="lineNum">    1351 </span>            :                 size = VGA_BIOS_LEN;
<span class="lineNum">    1352 </span>            : #endif
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :                 bdb = find_vbt(bios, size);</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :                 if (!bdb) {</span>
<span class="lineNum">    1356 </span>            : #ifdef __linux__
<span class="lineNum">    1357 </span>            :                         pci_unmap_rom(pdev, bios);
<span class="lineNum">    1358 </span>            : #endif
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1360 </span>            :                 }
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            :         /* Grab useful general definitions */
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :         parse_general_features(dev_priv, bdb);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :         parse_general_definitions(dev_priv, bdb);</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :         parse_lfp_panel_data(dev_priv, bdb);</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :         parse_lfp_backlight(dev_priv, bdb);</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :         parse_sdvo_panel_data(dev_priv, bdb);</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         parse_sdvo_device_mapping(dev_priv, bdb);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :         parse_device_mapping(dev_priv, bdb);</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :         parse_driver_features(dev_priv, bdb);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :         parse_edp(dev_priv, bdb);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :         parse_psr(dev_priv, bdb);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :         parse_mipi(dev_priv, bdb);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :         parse_ddi_ports(dev_priv, bdb);</span>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            : #ifdef __linux__
<span class="lineNum">    1378 </span>            :         if (bios)
<span class="lineNum">    1379 </span>            :                 pci_unmap_rom(pdev, bios);
<span class="lineNum">    1380 </span>            : #endif
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            : /**
<span class="lineNum">    1386 </span>            :  * intel_bios_is_port_present - is the specified digital port present
<span class="lineNum">    1387 </span>            :  * @dev_priv:   i915 device instance
<span class="lineNum">    1388 </span>            :  * @port:       port to check
<span class="lineNum">    1389 </span>            :  *
<a name="1390"><span class="lineNum">    1390 </span>            :  * Return true if the device in %port is present.</a>
<span class="lineNum">    1391 </span>            :  */
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 : bool intel_bios_is_port_present(struct drm_i915_private *dev_priv, enum port port)</span>
<span class="lineNum">    1393 </span>            : {
<span class="lineNum">    1394 </span>            :         static const struct {
<span class="lineNum">    1395 </span>            :                 u16 dp, hdmi;
<span class="lineNum">    1396 </span>            :         } port_mapping[] = {
<span class="lineNum">    1397 </span>            :                 [PORT_B] = { DVO_PORT_DPB, DVO_PORT_HDMIB, },
<span class="lineNum">    1398 </span>            :                 [PORT_C] = { DVO_PORT_DPC, DVO_PORT_HDMIC, },
<span class="lineNum">    1399 </span>            :                 [PORT_D] = { DVO_PORT_DPD, DVO_PORT_HDMID, },
<span class="lineNum">    1400 </span>            :                 [PORT_E] = { DVO_PORT_DPE, DVO_PORT_HDMIE, },
<span class="lineNum">    1401 </span>            :         };
<span class="lineNum">    1402 </span>            :         int i;
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            :         /* FIXME maybe deal with port A as well? */
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         if (WARN_ON(port == PORT_A) || port &gt;= ARRAY_SIZE(port_mapping))</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :         if (!dev_priv-&gt;vbt.child_dev_num)</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; dev_priv-&gt;vbt.child_dev_num; i++) {</span>
<span class="lineNum">    1412 </span>            :                 const union child_device_config *p_child =
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                         &amp;dev_priv-&gt;vbt.child_dev[i];</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :                 if ((p_child-&gt;common.dvo_port == port_mapping[port].dp ||</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :                      p_child-&gt;common.dvo_port == port_mapping[port].hdmi) &amp;&amp;</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :                     (p_child-&gt;common.device_type &amp; (DEVICE_TYPE_TMDS_DVI_SIGNALING |</span>
<span class="lineNum">    1417 </span>            :                                                     DEVICE_TYPE_DISPLAYPORT_OUTPUT)))
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :                         return true;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
