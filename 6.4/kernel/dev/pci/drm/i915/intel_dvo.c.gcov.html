<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/i915/intel_dvo.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/i915</a> - intel_dvo.c<span style="font-size: 80%;"> (source / <a href="intel_dvo.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">219</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2006 Dave Airlie &lt;airlied@linux.ie&gt;
<span class="lineNum">       3 </span>            :  * Copyright Â© 2006-2007 Intel Corporation
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       6 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">       7 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">       8 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">       9 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">      10 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      13 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      14 </span>            :  * Software.
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      17 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      18 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      19 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      20 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      21 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
<span class="lineNum">      22 </span>            :  * DEALINGS IN THE SOFTWARE.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Authors:
<span class="lineNum">      25 </span>            :  *      Eric Anholt &lt;eric@anholt.net&gt;
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : #ifdef __linux__
<span class="lineNum">      28 </span>            : #include &lt;linux/i2c.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;linux/slab.h&gt;
<span class="lineNum">      30 </span>            : #endif
<span class="lineNum">      31 </span>            : #include &lt;dev/pci/drm/drmP.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;dev/pci/drm/drm_atomic_helper.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;dev/pci/drm/drm_crtc.h&gt;
<span class="lineNum">      34 </span>            : #include &quot;intel_drv.h&quot;
<span class="lineNum">      35 </span>            : #include &lt;dev/pci/drm/i915_drm.h&gt;
<span class="lineNum">      36 </span>            : #include &quot;i915_drv.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;dvo.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #define SIL164_ADDR     0x38
<span class="lineNum">      40 </span>            : #define CH7xxx_ADDR     0x76
<span class="lineNum">      41 </span>            : #define TFP410_ADDR     0x38
<span class="lineNum">      42 </span>            : #define NS2501_ADDR     0x38
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : static const struct intel_dvo_device intel_dvo_devices[] = {
<span class="lineNum">      45 </span>            :         {
<span class="lineNum">      46 </span>            :                 .type = INTEL_DVO_CHIP_TMDS,
<span class="lineNum">      47 </span>            :                 .name = &quot;sil164&quot;,
<span class="lineNum">      48 </span>            :                 .dvo_reg = DVOC,
<span class="lineNum">      49 </span>            :                 .slave_addr = SIL164_ADDR,
<span class="lineNum">      50 </span>            :                 .dev_ops = &amp;sil164_ops,
<span class="lineNum">      51 </span>            :         },
<span class="lineNum">      52 </span>            :         {
<span class="lineNum">      53 </span>            :                 .type = INTEL_DVO_CHIP_TMDS,
<span class="lineNum">      54 </span>            :                 .name = &quot;ch7xxx&quot;,
<span class="lineNum">      55 </span>            :                 .dvo_reg = DVOC,
<span class="lineNum">      56 </span>            :                 .slave_addr = CH7xxx_ADDR,
<span class="lineNum">      57 </span>            :                 .dev_ops = &amp;ch7xxx_ops,
<span class="lineNum">      58 </span>            :         },
<span class="lineNum">      59 </span>            :         {
<span class="lineNum">      60 </span>            :                 .type = INTEL_DVO_CHIP_TMDS,
<span class="lineNum">      61 </span>            :                 .name = &quot;ch7xxx&quot;,
<span class="lineNum">      62 </span>            :                 .dvo_reg = DVOC,
<span class="lineNum">      63 </span>            :                 .slave_addr = 0x75, /* For some ch7010 */
<span class="lineNum">      64 </span>            :                 .dev_ops = &amp;ch7xxx_ops,
<span class="lineNum">      65 </span>            :         },
<span class="lineNum">      66 </span>            :         {
<span class="lineNum">      67 </span>            :                 .type = INTEL_DVO_CHIP_LVDS,
<span class="lineNum">      68 </span>            :                 .name = &quot;ivch&quot;,
<span class="lineNum">      69 </span>            :                 .dvo_reg = DVOA,
<span class="lineNum">      70 </span>            :                 .slave_addr = 0x02, /* Might also be 0x44, 0x84, 0xc4 */
<span class="lineNum">      71 </span>            :                 .dev_ops = &amp;ivch_ops,
<span class="lineNum">      72 </span>            :         },
<span class="lineNum">      73 </span>            :         {
<span class="lineNum">      74 </span>            :                 .type = INTEL_DVO_CHIP_TMDS,
<span class="lineNum">      75 </span>            :                 .name = &quot;tfp410&quot;,
<span class="lineNum">      76 </span>            :                 .dvo_reg = DVOC,
<span class="lineNum">      77 </span>            :                 .slave_addr = TFP410_ADDR,
<span class="lineNum">      78 </span>            :                 .dev_ops = &amp;tfp410_ops,
<span class="lineNum">      79 </span>            :         },
<span class="lineNum">      80 </span>            :         {
<span class="lineNum">      81 </span>            :                 .type = INTEL_DVO_CHIP_LVDS,
<span class="lineNum">      82 </span>            :                 .name = &quot;ch7017&quot;,
<span class="lineNum">      83 </span>            :                 .dvo_reg = DVOC,
<span class="lineNum">      84 </span>            :                 .slave_addr = 0x75,
<span class="lineNum">      85 </span>            :                 .gpio = GMBUS_PIN_DPB,
<span class="lineNum">      86 </span>            :                 .dev_ops = &amp;ch7017_ops,
<span class="lineNum">      87 </span>            :         },
<span class="lineNum">      88 </span>            :         {
<span class="lineNum">      89 </span>            :                 .type = INTEL_DVO_CHIP_TMDS,
<span class="lineNum">      90 </span>            :                 .name = &quot;ns2501&quot;,
<span class="lineNum">      91 </span>            :                 .dvo_reg = DVOB,
<span class="lineNum">      92 </span>            :                 .slave_addr = NS2501_ADDR,
<span class="lineNum">      93 </span>            :                 .dev_ops = &amp;ns2501_ops,
<span class="lineNum">      94 </span>            :        }
<span class="lineNum">      95 </span>            : };
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : struct intel_dvo {
<span class="lineNum">      98 </span>            :         struct intel_encoder base;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :         struct intel_dvo_device dev;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :         struct intel_connector *attached_connector;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :         bool panel_wants_dither;
<a name="105"><span class="lineNum">     105 </span>            : };</a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : static struct intel_dvo *enc_to_dvo(struct intel_encoder *encoder)</span>
<span class="lineNum">     108 </span>            : {
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         return container_of(encoder, struct intel_dvo, base);</span>
<a name="110"><span class="lineNum">     110 </span>            : }</a>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineNoCov">          0 : static struct intel_dvo *intel_attached_dvo(struct drm_connector *connector)</span>
<span class="lineNum">     113 </span>            : {
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :         return enc_to_dvo(intel_attached_encoder(connector));</span>
<a name="115"><span class="lineNum">     115 </span>            : }</a>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span><span class="lineNoCov">          0 : static bool intel_dvo_connector_get_hw_state(struct intel_connector *connector)</span>
<span class="lineNum">     118 </span>            : {
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :         struct drm_device *dev = connector-&gt;base.dev;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = intel_attached_dvo(&amp;connector-&gt;base);</span>
<span class="lineNum">     122 </span>            :         u32 tmp;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         tmp = I915_READ(intel_dvo-&gt;dev.dvo_reg);</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :         if (!(tmp &amp; DVO_ENABLE))</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         return intel_dvo-&gt;dev.dev_ops-&gt;get_hw_state(&amp;intel_dvo-&gt;dev);</span>
<a name="130"><span class="lineNum">     130 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineNoCov">          0 : static bool intel_dvo_get_hw_state(struct intel_encoder *encoder,</span>
<span class="lineNum">     133 </span>            :                                    enum pipe *pipe)
<span class="lineNum">     134 </span>            : {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         struct drm_device *dev = encoder-&gt;base.dev;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(encoder);</span>
<span class="lineNum">     138 </span>            :         u32 tmp;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :         tmp = I915_READ(intel_dvo-&gt;dev.dvo_reg);</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         if (!(tmp &amp; DVO_ENABLE))</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         *pipe = PORT_TO_PIPE(tmp);</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :         return true;</span>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineNoCov">          0 : static void intel_dvo_get_config(struct intel_encoder *encoder,</span>
<span class="lineNum">     151 </span>            :                                  struct intel_crtc_state *pipe_config)
<span class="lineNum">     152 </span>            : {
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = encoder-&gt;base.dev-&gt;dev_private;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(encoder);</span>
<span class="lineNum">     155 </span>            :         u32 tmp, flags = 0;
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         tmp = I915_READ(intel_dvo-&gt;dev.dvo_reg);</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         if (tmp &amp; DVO_HSYNC_ACTIVE_HIGH)</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                 flags |= DRM_MODE_FLAG_PHSYNC;</span>
<span class="lineNum">     160 </span>            :         else
<span class="lineNum">     161 </span>            :                 flags |= DRM_MODE_FLAG_NHSYNC;
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :         if (tmp &amp; DVO_VSYNC_ACTIVE_HIGH)</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                 flags |= DRM_MODE_FLAG_PVSYNC;</span>
<span class="lineNum">     164 </span>            :         else
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :                 flags |= DRM_MODE_FLAG_NVSYNC;</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         pipe_config-&gt;base.adjusted_mode.flags |= flags;</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         pipe_config-&gt;base.adjusted_mode.crtc_clock = pipe_config-&gt;port_clock;</span>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 : static void intel_disable_dvo(struct intel_encoder *encoder)</span>
<span class="lineNum">     173 </span>            : {
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = encoder-&gt;base.dev-&gt;dev_private;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(encoder);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         u32 dvo_reg = intel_dvo-&gt;dev.dvo_reg;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         u32 temp = I915_READ(dvo_reg);</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         intel_dvo-&gt;dev.dev_ops-&gt;dpms(&amp;intel_dvo-&gt;dev, false);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         I915_WRITE(dvo_reg, temp &amp; ~DVO_ENABLE);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         I915_READ(dvo_reg);</span>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 : static void intel_enable_dvo(struct intel_encoder *encoder)</span>
<span class="lineNum">     185 </span>            : {
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = encoder-&gt;base.dev-&gt;dev_private;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(encoder);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         struct intel_crtc *crtc = to_intel_crtc(encoder-&gt;base.crtc);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         u32 dvo_reg = intel_dvo-&gt;dev.dvo_reg;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :         u32 temp = I915_READ(dvo_reg);</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         intel_dvo-&gt;dev.dev_ops-&gt;mode_set(&amp;intel_dvo-&gt;dev,</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :                                          &amp;crtc-&gt;config-&gt;base.mode,</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :                                          &amp;crtc-&gt;config-&gt;base.adjusted_mode);</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         I915_WRITE(dvo_reg, temp | DVO_ENABLE);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         I915_READ(dvo_reg);</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         intel_dvo-&gt;dev.dev_ops-&gt;dpms(&amp;intel_dvo-&gt;dev, true);</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 : }</span>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<span class="lineNum">     202 </span>            : static enum drm_mode_status
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : intel_dvo_mode_valid(struct drm_connector *connector,</span>
<span class="lineNum">     204 </span>            :                      struct drm_display_mode *mode)
<span class="lineNum">     205 </span>            : {
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = intel_attached_dvo(connector);</span>
<span class="lineNum">     207 </span>            :         const struct drm_display_mode *fixed_mode =
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :                 to_intel_connector(connector)-&gt;panel.fixed_mode;</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         int max_dotclk = to_i915(connector-&gt;dev)-&gt;max_dotclk_freq;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         int target_clock = mode-&gt;clock;</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :                 return MODE_NO_DBLESCAN;</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :         /* XXX: Validate clock range */
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         if (fixed_mode) {</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :                 if (mode-&gt;hdisplay &gt; fixed_mode-&gt;hdisplay)</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :                         return MODE_PANEL;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :                 if (mode-&gt;vdisplay &gt; fixed_mode-&gt;vdisplay)</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                         return MODE_PANEL;</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                 target_clock = fixed_mode-&gt;clock;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         if (target_clock &gt; max_dotclk)</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 return MODE_CLOCK_HIGH;</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         return intel_dvo-&gt;dev.dev_ops-&gt;mode_valid(&amp;intel_dvo-&gt;dev, mode);</span>
<a name="230"><span class="lineNum">     230 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : static bool intel_dvo_compute_config(struct intel_encoder *encoder,</span>
<span class="lineNum">     233 </span>            :                                      struct intel_crtc_state *pipe_config)
<span class="lineNum">     234 </span>            : {
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(encoder);</span>
<span class="lineNum">     236 </span>            :         const struct drm_display_mode *fixed_mode =
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                 intel_dvo-&gt;attached_connector-&gt;panel.fixed_mode;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         struct drm_display_mode *adjusted_mode = &amp;pipe_config-&gt;base.adjusted_mode;</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :         /* If we have timings from the BIOS for the panel, put them in
<span class="lineNum">     241 </span>            :          * to the adjusted mode.  The CRTC will be set up for this mode,
<span class="lineNum">     242 </span>            :          * with the panel scaling set up to source from the H/VDisplay
<span class="lineNum">     243 </span>            :          * of the original mode.
<span class="lineNum">     244 </span>            :          */
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         if (fixed_mode)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                 intel_fixed_panel_mode(fixed_mode, adjusted_mode);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         return true;</span>
<a name="249"><span class="lineNum">     249 </span>            : }</a>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 : static void intel_dvo_pre_enable(struct intel_encoder *encoder)</span>
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         struct drm_device *dev = encoder-&gt;base.dev;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         struct intel_crtc *crtc = to_intel_crtc(encoder-&gt;base.crtc);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         const struct drm_display_mode *adjusted_mode = &amp;crtc-&gt;config-&gt;base.adjusted_mode;</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(encoder);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         int pipe = crtc-&gt;pipe;</span>
<span class="lineNum">     259 </span>            :         u32 dvo_val;
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         u32 dvo_reg = intel_dvo-&gt;dev.dvo_reg, dvo_srcdim_reg;</span>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         switch (dvo_reg) {</span>
<span class="lineNum">     263 </span>            :         case DVOA:
<span class="lineNum">     264 </span>            :         default:
<span class="lineNum">     265 </span>            :                 dvo_srcdim_reg = DVOA_SRCDIM;
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     267 </span>            :         case DVOB:
<span class="lineNum">     268 </span>            :                 dvo_srcdim_reg = DVOB_SRCDIM;
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     270 </span>            :         case DVOC:
<span class="lineNum">     271 </span>            :                 dvo_srcdim_reg = DVOC_SRCDIM;
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     273 </span>            :         }
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :         /* Save the data order, since I don't know what it should be set to. */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         dvo_val = I915_READ(dvo_reg) &amp;</span>
<span class="lineNum">     277 </span>            :                   (DVO_PRESERVE_MASK | DVO_DATA_ORDER_GBRG);
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         dvo_val |= DVO_DATA_ORDER_FP | DVO_BORDER_ENABLE |</span>
<span class="lineNum">     279 </span>            :                    DVO_BLANK_ACTIVE_HIGH;
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         if (pipe == 1)</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 dvo_val |= DVO_PIPE_B_SELECT;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         dvo_val |= DVO_PIPE_STALL;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         if (adjusted_mode-&gt;flags &amp; DRM_MODE_FLAG_PHSYNC)</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :                 dvo_val |= DVO_HSYNC_ACTIVE_HIGH;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         if (adjusted_mode-&gt;flags &amp; DRM_MODE_FLAG_PVSYNC)</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :                 dvo_val |= DVO_VSYNC_ACTIVE_HIGH;</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :         /*I915_WRITE(DVOB_SRCDIM,
<span class="lineNum">     290 </span>            :           (adjusted_mode-&gt;crtc_hdisplay &lt;&lt; DVO_SRCDIM_HORIZONTAL_SHIFT) |
<span class="lineNum">     291 </span>            :           (adjusted_mode-&gt;crtc_vdisplay &lt;&lt; DVO_SRCDIM_VERTICAL_SHIFT));*/
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         I915_WRITE(dvo_srcdim_reg,</span>
<span class="lineNum">     293 </span>            :                    (adjusted_mode-&gt;crtc_hdisplay &lt;&lt; DVO_SRCDIM_HORIZONTAL_SHIFT) |
<span class="lineNum">     294 </span>            :                    (adjusted_mode-&gt;crtc_vdisplay &lt;&lt; DVO_SRCDIM_VERTICAL_SHIFT));
<span class="lineNum">     295 </span>            :         /*I915_WRITE(DVOB, dvo_val);*/
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         I915_WRITE(dvo_reg, dvo_val);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : /**
<span class="lineNum">     300 </span>            :  * Detect the output connection on our DVO device.
<span class="lineNum">     301 </span>            :  *
<span class="lineNum">     302 </span>            :  * Unimplemented.
<a name="303"><span class="lineNum">     303 </span>            :  */</a>
<span class="lineNum">     304 </span>            : static enum drm_connector_status
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : intel_dvo_detect(struct drm_connector *connector, bool force)</span>
<span class="lineNum">     306 </span>            : {
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = intel_attached_dvo(connector);</span>
<span class="lineNum">     308 </span>            :         DRM_DEBUG_KMS(&quot;[CONNECTOR:%d:%s]\n&quot;,
<span class="lineNum">     309 </span>            :                       connector-&gt;base.id, connector-&gt;name);
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         return intel_dvo-&gt;dev.dev_ops-&gt;detect(&amp;intel_dvo-&gt;dev);</span>
<a name="311"><span class="lineNum">     311 </span>            : }</a>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : static int intel_dvo_get_modes(struct drm_connector *connector)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = connector-&gt;dev-&gt;dev_private;</span>
<span class="lineNum">     316 </span>            :         const struct drm_display_mode *fixed_mode =
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                 to_intel_connector(connector)-&gt;panel.fixed_mode;</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :         /* We should probably have an i2c driver get_modes function for those
<span class="lineNum">     320 </span>            :          * devices which will have a fixed set of modes determined by the chip
<span class="lineNum">     321 </span>            :          * (TV-out, for example), but for now with just TMDS and LVDS,
<span class="lineNum">     322 </span>            :          * that's not the case.
<span class="lineNum">     323 </span>            :          */
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         intel_ddc_get_modes(connector,</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :                             intel_gmbus_get_adapter(dev_priv, GMBUS_PIN_DPC));</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         if (!list_empty(&amp;connector-&gt;probed_modes))</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         if (fixed_mode) {</span>
<span class="lineNum">     330 </span>            :                 struct drm_display_mode *mode;
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                 mode = drm_mode_duplicate(connector-&gt;dev, fixed_mode);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                 if (mode) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                         drm_mode_probed_add(connector, mode);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                         return 1;</span>
<span class="lineNum">     335 </span>            :                 }
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="339"><span class="lineNum">     339 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span><span class="lineNoCov">          0 : static void intel_dvo_destroy(struct drm_connector *connector)</span>
<span class="lineNum">     342 </span>            : {
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         drm_connector_cleanup(connector);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         intel_panel_fini(&amp;to_intel_connector(connector)-&gt;panel);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         kfree(connector);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : static const struct drm_connector_funcs intel_dvo_connector_funcs = {
<span class="lineNum">     349 </span>            :         .dpms = drm_atomic_helper_connector_dpms,
<span class="lineNum">     350 </span>            :         .detect = intel_dvo_detect,
<span class="lineNum">     351 </span>            :         .destroy = intel_dvo_destroy,
<span class="lineNum">     352 </span>            :         .fill_modes = drm_helper_probe_single_connector_modes,
<span class="lineNum">     353 </span>            :         .atomic_get_property = intel_connector_atomic_get_property,
<span class="lineNum">     354 </span>            :         .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
<span class="lineNum">     355 </span>            :         .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
<span class="lineNum">     356 </span>            : };
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : static const struct drm_connector_helper_funcs intel_dvo_connector_helper_funcs = {
<span class="lineNum">     359 </span>            :         .mode_valid = intel_dvo_mode_valid,
<span class="lineNum">     360 </span>            :         .get_modes = intel_dvo_get_modes,
<span class="lineNum">     361 </span>            :         .best_encoder = intel_best_encoder,
<a name="362"><span class="lineNum">     362 </span>            : };</a>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 : static void intel_dvo_enc_destroy(struct drm_encoder *encoder)</span>
<span class="lineNum">     365 </span>            : {
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = enc_to_dvo(to_intel_encoder(encoder));</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         if (intel_dvo-&gt;dev.dev_ops-&gt;destroy)</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                 intel_dvo-&gt;dev.dev_ops-&gt;destroy(&amp;intel_dvo-&gt;dev);</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         intel_encoder_destroy(encoder);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : static const struct drm_encoder_funcs intel_dvo_enc_funcs = {
<span class="lineNum">     375 </span>            :         .destroy = intel_dvo_enc_destroy,
<span class="lineNum">     376 </span>            : };
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            : /**
<span class="lineNum">     379 </span>            :  * Attempts to get a fixed panel timing for LVDS (currently only the i830).
<span class="lineNum">     380 </span>            :  *
<span class="lineNum">     381 </span>            :  * Other chips with DVO LVDS will need to extend this to deal with the LVDS
<span class="lineNum">     382 </span>            :  * chip being on DVOB/C and having multiple pipes.
<a name="383"><span class="lineNum">     383 </span>            :  */</a>
<span class="lineNum">     384 </span>            : static struct drm_display_mode *
<span class="lineNum">     385 </span><span class="lineNoCov">          0 : intel_dvo_get_current_mode(struct drm_connector *connector)</span>
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         struct drm_device *dev = connector-&gt;dev;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         struct intel_dvo *intel_dvo = intel_attached_dvo(connector);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         uint32_t dvo_val = I915_READ(intel_dvo-&gt;dev.dvo_reg);</span>
<span class="lineNum">     391 </span>            :         struct drm_display_mode *mode = NULL;
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :         /* If the DVO port is active, that'll be the LVDS, so we can pull out
<span class="lineNum">     394 </span>            :          * its timings to get how the BIOS set up the panel.
<span class="lineNum">     395 </span>            :          */
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         if (dvo_val &amp; DVO_ENABLE) {</span>
<span class="lineNum">     397 </span>            :                 struct drm_crtc *crtc;
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :                 int pipe = (dvo_val &amp; DVO_PIPE_B_SELECT) ? 1 : 0;</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                 crtc = intel_get_crtc_for_pipe(dev, pipe);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                 if (crtc) {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                         mode = intel_crtc_mode_get(dev, crtc);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                         if (mode) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                                 mode-&gt;type |= DRM_MODE_TYPE_PREFERRED;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                                 if (dvo_val &amp; DVO_HSYNC_ACTIVE_HIGH)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                                         mode-&gt;flags |= DRM_MODE_FLAG_PHSYNC;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                                 if (dvo_val &amp; DVO_VSYNC_ACTIVE_HIGH)</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                                         mode-&gt;flags |= DRM_MODE_FLAG_PVSYNC;</span>
<span class="lineNum">     409 </span>            :                         }
<span class="lineNum">     410 </span>            :                 }
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         return mode;</span>
<a name="414"><span class="lineNum">     414 </span>            : }</a>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : void intel_dvo_init(struct drm_device *dev)</span>
<span class="lineNum">     417 </span>            : {
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
<span class="lineNum">     419 </span>            :         struct intel_encoder *intel_encoder;
<span class="lineNum">     420 </span>            :         struct intel_dvo *intel_dvo;
<span class="lineNum">     421 </span>            :         struct intel_connector *intel_connector;
<span class="lineNum">     422 </span>            :         int i;
<span class="lineNum">     423 </span>            :         int encoder_type = DRM_MODE_ENCODER_NONE;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         intel_dvo = kzalloc(sizeof(*intel_dvo), GFP_KERNEL);</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         if (!intel_dvo)</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         intel_connector = intel_connector_alloc();</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         if (!intel_connector) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                 kfree(intel_dvo);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     433 </span>            :         }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         intel_dvo-&gt;attached_connector = intel_connector;</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         intel_encoder = &amp;intel_dvo-&gt;base;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :         drm_encoder_init(dev, &amp;intel_encoder-&gt;base,</span>
<span class="lineNum">     439 </span>            :                          &amp;intel_dvo_enc_funcs, encoder_type);
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         intel_encoder-&gt;disable = intel_disable_dvo;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         intel_encoder-&gt;enable = intel_enable_dvo;</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :         intel_encoder-&gt;get_hw_state = intel_dvo_get_hw_state;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         intel_encoder-&gt;get_config = intel_dvo_get_config;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         intel_encoder-&gt;compute_config = intel_dvo_compute_config;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         intel_encoder-&gt;pre_enable = intel_dvo_pre_enable;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         intel_connector-&gt;get_hw_state = intel_dvo_connector_get_hw_state;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         intel_connector-&gt;unregister = intel_connector_unregister;</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :         /* Now, try to find a controller */
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; ARRAY_SIZE(intel_dvo_devices); i++) {</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                 struct drm_connector *connector = &amp;intel_connector-&gt;base;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 const struct intel_dvo_device *dvo = &amp;intel_dvo_devices[i];</span>
<span class="lineNum">     454 </span>            :                 struct i2c_adapter *i2c;
<span class="lineNum">     455 </span>            :                 int gpio;
<span class="lineNum">     456 </span>            :                 bool dvoinit;
<span class="lineNum">     457 </span>            :                 enum pipe pipe;
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 uint32_t dpll[I915_MAX_PIPES];</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :                 /* Allow the I2C driver info to specify the GPIO to be used in
<span class="lineNum">     461 </span>            :                  * special cases, but otherwise default to what's defined
<span class="lineNum">     462 </span>            :                  * in the spec.
<span class="lineNum">     463 </span>            :                  */
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                 if (intel_gmbus_is_valid_pin(dev_priv, dvo-&gt;gpio))</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                         gpio = dvo-&gt;gpio;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                 else if (dvo-&gt;type == INTEL_DVO_CHIP_LVDS)</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         gpio = GMBUS_PIN_SSC;</span>
<span class="lineNum">     468 </span>            :                 else
<span class="lineNum">     469 </span>            :                         gpio = GMBUS_PIN_DPB;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :                 /* Set up the I2C bus necessary for the chip we're probing.
<span class="lineNum">     472 </span>            :                  * It appears that everything is on GPIOE except for panels
<span class="lineNum">     473 </span>            :                  * on i830 laptops, which are on GPIOB (DVOA).
<span class="lineNum">     474 </span>            :                  */
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                 i2c = intel_gmbus_get_adapter(dev_priv, gpio);</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                 intel_dvo-&gt;dev = *dvo;</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :                 /* GMBUS NAK handling seems to be unstable, hence let the
<span class="lineNum">     480 </span>            :                  * transmitter detection run in bit banging mode for now.
<span class="lineNum">     481 </span>            :                  */
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                 intel_gmbus_force_bit(i2c, true);</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :                 /* ns2501 requires the DVO 2x clock before it will
<span class="lineNum">     485 </span>            :                  * respond to i2c accesses, so make sure we have
<span class="lineNum">     486 </span>            :                  * have the clock enabled before we attempt to
<span class="lineNum">     487 </span>            :                  * initialize the device.
<span class="lineNum">     488 </span>            :                  */
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                 for_each_pipe(dev_priv, pipe) {</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                         dpll[pipe] = I915_READ(DPLL(pipe));</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                         I915_WRITE(DPLL(pipe), dpll[pipe] | DPLL_DVO_2X_MODE);</span>
<span class="lineNum">     492 </span>            :                 }
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                 dvoinit = dvo-&gt;dev_ops-&gt;init(&amp;intel_dvo-&gt;dev, i2c);</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :                 /* restore the DVO 2x clock state to original */
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 for_each_pipe(dev_priv, pipe) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :                         I915_WRITE(DPLL(pipe), dpll[pipe]);</span>
<span class="lineNum">     499 </span>            :                 }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                 intel_gmbus_force_bit(i2c, false);</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                 if (!dvoinit)</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :                 intel_encoder-&gt;type = INTEL_OUTPUT_DVO;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                 intel_encoder-&gt;crtc_mask = (1 &lt;&lt; 0) | (1 &lt;&lt; 1);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                 switch (dvo-&gt;type) {</span>
<span class="lineNum">     509 </span>            :                 case INTEL_DVO_CHIP_TMDS:
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                         intel_encoder-&gt;cloneable = (1 &lt;&lt; INTEL_OUTPUT_ANALOG) |</span>
<span class="lineNum">     511 </span>            :                                 (1 &lt;&lt; INTEL_OUTPUT_DVO);
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :                         drm_connector_init(dev, connector,</span>
<span class="lineNum">     513 </span>            :                                            &amp;intel_dvo_connector_funcs,
<span class="lineNum">     514 </span>            :                                            DRM_MODE_CONNECTOR_DVII);
<span class="lineNum">     515 </span>            :                         encoder_type = DRM_MODE_ENCODER_TMDS;
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     517 </span>            :                 case INTEL_DVO_CHIP_LVDS:
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                         intel_encoder-&gt;cloneable = 0;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                         drm_connector_init(dev, connector,</span>
<span class="lineNum">     520 </span>            :                                            &amp;intel_dvo_connector_funcs,
<span class="lineNum">     521 </span>            :                                            DRM_MODE_CONNECTOR_LVDS);
<span class="lineNum">     522 </span>            :                         encoder_type = DRM_MODE_ENCODER_LVDS;
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     524 </span>            :                 }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                 drm_connector_helper_add(connector,</span>
<span class="lineNum">     527 </span>            :                                          &amp;intel_dvo_connector_helper_funcs);
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 connector-&gt;display_info.subpixel_order = SubPixelHorizontalRGB;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                 connector-&gt;interlace_allowed = false;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                 connector-&gt;doublescan_allowed = false;</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                 intel_connector_attach_encoder(intel_connector, intel_encoder);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                 if (dvo-&gt;type == INTEL_DVO_CHIP_LVDS) {</span>
<span class="lineNum">     534 </span>            :                         /* For our LVDS chipsets, we should hopefully be able
<span class="lineNum">     535 </span>            :                          * to dig the fixed panel mode out of the BIOS data.
<span class="lineNum">     536 </span>            :                          * However, it's in a different format from the BIOS
<span class="lineNum">     537 </span>            :                          * data on chipsets with integrated LVDS (stored in AIM
<span class="lineNum">     538 </span>            :                          * headers, likely), so for now, just get the current
<span class="lineNum">     539 </span>            :                          * mode being output through DVO.
<span class="lineNum">     540 </span>            :                          */
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :                         intel_panel_init(&amp;intel_connector-&gt;panel,</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                                          intel_dvo_get_current_mode(connector),</span>
<span class="lineNum">     543 </span>            :                                          NULL);
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                         intel_dvo-&gt;panel_wants_dither = true;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 drm_connector_register(connector);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         drm_encoder_cleanup(&amp;intel_encoder-&gt;base);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         kfree(intel_dvo);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         kfree(intel_connector);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
