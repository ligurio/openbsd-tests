<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/radeon/radeon_fence.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">dev/pci/drm/radeon</a> - radeon_fence.c<span style="font-size: 80%;"> (source / <a href="radeon_fence.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">368</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2009 Jerome Glisse.
<span class="lineNum">       3 </span>            :  * All Rights Reserved.
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">       6 </span>            :  * copy of this software and associated documentation files (the
<span class="lineNum">       7 </span>            :  * &quot;Software&quot;), to deal in the Software without restriction, including
<span class="lineNum">       8 </span>            :  * without limitation the rights to use, copy, modify, merge, publish,
<span class="lineNum">       9 </span>            :  * distribute, sub license, and/or sell copies of the Software, and to
<span class="lineNum">      10 </span>            :  * permit persons to whom the Software is furnished to do so, subject to
<span class="lineNum">      11 </span>            :  * the following conditions:
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      14 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      15 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
<span class="lineNum">      16 </span>            :  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
<span class="lineNum">      17 </span>            :  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
<span class="lineNum">      18 </span>            :  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
<span class="lineNum">      19 </span>            :  * USE OR OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * The above copyright notice and this permission notice (including the
<span class="lineNum">      22 </span>            :  * next paragraph) shall be included in all copies or substantial portions
<span class="lineNum">      23 </span>            :  * of the Software.
<span class="lineNum">      24 </span>            :  *
<span class="lineNum">      25 </span>            :  */
<span class="lineNum">      26 </span>            : /*
<span class="lineNum">      27 </span>            :  * Authors:
<span class="lineNum">      28 </span>            :  *    Jerome Glisse &lt;glisse@freedesktop.org&gt;
<span class="lineNum">      29 </span>            :  *    Dave Airlie
<span class="lineNum">      30 </span>            :  */
<span class="lineNum">      31 </span>            : #include &lt;dev/pci/drm/drm_linux.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;dev/pci/drm/drmP.h&gt;
<span class="lineNum">      33 </span>            : #include &quot;radeon_reg.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;radeon.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;radeon_trace.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : /*
<span class="lineNum">      38 </span>            :  * Fences
<span class="lineNum">      39 </span>            :  * Fences mark an event in the GPUs pipeline and are used
<span class="lineNum">      40 </span>            :  * for GPU/CPU synchronization.  When the fence is written,
<span class="lineNum">      41 </span>            :  * it is expected that all buffers associated with that fence
<span class="lineNum">      42 </span>            :  * are no longer in use by the associated ring on the GPU and
<span class="lineNum">      43 </span>            :  * that the the relevant GPU caches have been flushed.  Whether
<span class="lineNum">      44 </span>            :  * we use a scratch register or memory location depends on the asic
<span class="lineNum">      45 </span>            :  * and whether writeback is enabled.
<span class="lineNum">      46 </span>            :  */
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : /**
<span class="lineNum">      49 </span>            :  * radeon_fence_write - write a fence value
<span class="lineNum">      50 </span>            :  *
<span class="lineNum">      51 </span>            :  * @rdev: radeon_device pointer
<span class="lineNum">      52 </span>            :  * @seq: sequence number to write
<span class="lineNum">      53 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">      54 </span>            :  *
<a name="55"><span class="lineNum">      55 </span>            :  * Writes a fence value to memory or a scratch register (all asics).</a>
<span class="lineNum">      56 </span>            :  */
<span class="lineNum">      57 </span><span class="lineNoCov">          0 : static void radeon_fence_write(struct radeon_device *rdev, u32 seq, int ring)</span>
<span class="lineNum">      58 </span>            : {
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :         struct radeon_fence_driver *drv = &amp;rdev-&gt;fence_drv[ring];</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :         if (likely(rdev-&gt;wb.enabled || !drv-&gt;scratch_reg)) {</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :                 if (drv-&gt;cpu_addr) {</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :                         *drv-&gt;cpu_addr = cpu_to_le32(seq);</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">      64 </span>            :         } else {
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :                 WREG32(drv-&gt;scratch_reg, seq);</span>
<span class="lineNum">      66 </span>            :         }
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : /**
<span class="lineNum">      70 </span>            :  * radeon_fence_read - read a fence value
<span class="lineNum">      71 </span>            :  *
<span class="lineNum">      72 </span>            :  * @rdev: radeon_device pointer
<span class="lineNum">      73 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">      74 </span>            :  *
<span class="lineNum">      75 </span>            :  * Reads a fence value from memory or a scratch register (all asics).
<a name="76"><span class="lineNum">      76 </span>            :  * Returns the value of the fence read from memory or register.</a>
<span class="lineNum">      77 </span>            :  */
<span class="lineNum">      78 </span><span class="lineNoCov">          0 : static u32 radeon_fence_read(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">      79 </span>            : {
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :         struct radeon_fence_driver *drv = &amp;rdev-&gt;fence_drv[ring];</span>
<span class="lineNum">      81 </span>            :         u32 seq = 0;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :         if (likely(rdev-&gt;wb.enabled || !drv-&gt;scratch_reg)) {</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :                 if (drv-&gt;cpu_addr) {</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :                         seq = le32_to_cpu(*drv-&gt;cpu_addr);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :                         seq = lower_32_bits(atomic64_read(&amp;drv-&gt;last_seq));</span>
<span class="lineNum">      88 </span>            :                 }
<span class="lineNum">      89 </span>            :         } else {
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :                 seq = RREG32(drv-&gt;scratch_reg);</span>
<span class="lineNum">      91 </span>            :         }
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :         return seq;</span>
<span class="lineNum">      93 </span>            : }
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : /**
<span class="lineNum">      96 </span>            :  * radeon_fence_schedule_check - schedule lockup check
<span class="lineNum">      97 </span>            :  *
<span class="lineNum">      98 </span>            :  * @rdev: radeon_device pointer
<span class="lineNum">      99 </span>            :  * @ring: ring index we should work with
<span class="lineNum">     100 </span>            :  *
<a name="101"><span class="lineNum">     101 </span>            :  * Queues a delayed work item to check for lockups.</a>
<span class="lineNum">     102 </span>            :  */
<span class="lineNum">     103 </span><span class="lineNoCov">          0 : static void radeon_fence_schedule_check(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span>            :         /*
<span class="lineNum">     106 </span>            :          * Do not reset the timer here with mod_delayed_work,
<span class="lineNum">     107 </span>            :          * this can livelock in an interaction with TTM delayed destroy.
<span class="lineNum">     108 </span>            :          */
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         queue_delayed_work(system_power_efficient_wq,</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :                            &amp;rdev-&gt;fence_drv[ring].lockup_work,</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :                            RADEON_FENCE_JIFFIES_TIMEOUT);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : /**
<span class="lineNum">     115 </span>            :  * radeon_fence_emit - emit a fence on the requested ring
<span class="lineNum">     116 </span>            :  *
<span class="lineNum">     117 </span>            :  * @rdev: radeon_device pointer
<span class="lineNum">     118 </span>            :  * @fence: radeon fence object
<span class="lineNum">     119 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     120 </span>            :  *
<span class="lineNum">     121 </span>            :  * Emits a fence command on the requested ring (all asics).
<a name="122"><span class="lineNum">     122 </span>            :  * Returns 0 on success, -ENOMEM on failure.</a>
<span class="lineNum">     123 </span>            :  */
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : int radeon_fence_emit(struct radeon_device *rdev,</span>
<span class="lineNum">     125 </span>            :                       struct radeon_fence **fence,
<span class="lineNum">     126 </span>            :                       int ring)
<span class="lineNum">     127 </span>            : {
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         u64 seq = ++rdev-&gt;fence_drv[ring].sync_seq[ring];</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :         /* we are protected by the ring emission mutex */
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :         *fence = kmalloc(sizeof(struct radeon_fence), GFP_KERNEL);</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         if ((*fence) == NULL) {</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :                 return -ENOMEM;</span>
<span class="lineNum">     134 </span>            :         }
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         (*fence)-&gt;rdev = rdev;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         (*fence)-&gt;seq = seq;</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         (*fence)-&gt;ring = ring;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         (*fence)-&gt;is_vm_update = false;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         fence_init(&amp;(*fence)-&gt;base, &amp;radeon_fence_ops,</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :                    &amp;rdev-&gt;fence_queue.lock, rdev-&gt;fence_context + ring, seq);</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         radeon_fence_ring_emit(rdev, ring, *fence);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         trace_radeon_fence_emit(rdev-&gt;ddev, ring, (*fence)-&gt;seq);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         radeon_fence_schedule_check(rdev, ring);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : /**
<span class="lineNum">     148 </span>            :  * radeon_fence_check_signaled - callback from fence_queue
<span class="lineNum">     149 </span>            :  *
<span class="lineNum">     150 </span>            :  * this function is called with fence_queue lock held, which is also used
<span class="lineNum">     151 </span>            :  * for the fence locking itself, so unlocked variants are used for
<a name="152"><span class="lineNum">     152 </span>            :  * fence_signal, and remove_wait_queue.</a>
<span class="lineNum">     153 </span>            :  */
<span class="lineNum">     154 </span><span class="lineNoCov">          0 : static int radeon_fence_check_signaled(wait_queue_t *wait, unsigned mode, int flags, void *key)</span>
<span class="lineNum">     155 </span>            : {
<span class="lineNum">     156 </span>            :         struct radeon_fence *fence;
<span class="lineNum">     157 </span>            :         u64 seq;
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         fence = container_of(wait, struct radeon_fence, fence_wake);</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :         /*
<span class="lineNum">     162 </span>            :          * We cannot use radeon_fence_process here because we're already
<span class="lineNum">     163 </span>            :          * in the waitqueue, in a call from wake_up_all.
<span class="lineNum">     164 </span>            :          */
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :         seq = atomic64_read(&amp;fence-&gt;rdev-&gt;fence_drv[fence-&gt;ring].last_seq);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         if (seq &gt;= fence-&gt;seq) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                 int ret = fence_signal_locked(&amp;fence-&gt;base);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :                 if (!ret)
<span class="lineNum">     170 </span>            :                         FENCE_TRACE(&amp;fence-&gt;base, &quot;signaled from irq context\n&quot;);
<span class="lineNum">     171 </span>            :                 else
<span class="lineNum">     172 </span>            :                         FENCE_TRACE(&amp;fence-&gt;base, &quot;was already signaled\n&quot;);
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :                 radeon_irq_kms_sw_irq_put(fence-&gt;rdev, fence-&gt;ring);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :                 __remove_wait_queue(&amp;fence-&gt;rdev-&gt;fence_queue, &amp;fence-&gt;fence_wake);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :                 fence_put(&amp;fence-&gt;base);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         } else</span>
<span class="lineNum">     178 </span>            :                 FENCE_TRACE(&amp;fence-&gt;base, &quot;pending\n&quot;);
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     180 </span>            : }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /**
<span class="lineNum">     183 </span>            :  * radeon_fence_activity - check for fence activity
<span class="lineNum">     184 </span>            :  *
<span class="lineNum">     185 </span>            :  * @rdev: radeon_device pointer
<span class="lineNum">     186 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     187 </span>            :  *
<span class="lineNum">     188 </span>            :  * Checks the current fence value and calculates the last
<span class="lineNum">     189 </span>            :  * signalled fence value. Returns true if activity occured
<a name="190"><span class="lineNum">     190 </span>            :  * on the ring, and the fence_queue should be waken up.</a>
<span class="lineNum">     191 </span>            :  */
<span class="lineNum">     192 </span><span class="lineNoCov">          0 : static bool radeon_fence_activity(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     193 </span>            : {
<span class="lineNum">     194 </span>            :         uint64_t seq, last_seq, last_emitted;
<span class="lineNum">     195 </span>            :         unsigned count_loop = 0;
<span class="lineNum">     196 </span>            :         bool wake = false;
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :         /* Note there is a scenario here for an infinite loop but it's
<span class="lineNum">     199 </span>            :          * very unlikely to happen. For it to happen, the current polling
<span class="lineNum">     200 </span>            :          * process need to be interrupted by another process and another
<span class="lineNum">     201 </span>            :          * process needs to update the last_seq btw the atomic read and
<span class="lineNum">     202 </span>            :          * xchg of the current process.
<span class="lineNum">     203 </span>            :          *
<span class="lineNum">     204 </span>            :          * More over for this to go in infinite loop there need to be
<span class="lineNum">     205 </span>            :          * continuously new fence signaled ie radeon_fence_read needs
<span class="lineNum">     206 </span>            :          * to return a different value each time for both the currently
<span class="lineNum">     207 </span>            :          * polling process and the other process that xchg the last_seq
<span class="lineNum">     208 </span>            :          * btw atomic read and xchg of the current process. And the
<span class="lineNum">     209 </span>            :          * value the other process set as last seq must be higher than
<span class="lineNum">     210 </span>            :          * the seq value we just read. Which means that current process
<span class="lineNum">     211 </span>            :          * need to be interrupted after radeon_fence_read and before
<span class="lineNum">     212 </span>            :          * atomic xchg.
<span class="lineNum">     213 </span>            :          *
<span class="lineNum">     214 </span>            :          * To be even more safe we count the number of time we loop and
<span class="lineNum">     215 </span>            :          * we bail after 10 loop just accepting the fact that we might
<span class="lineNum">     216 </span>            :          * have temporarly set the last_seq not to the true real last
<span class="lineNum">     217 </span>            :          * seq but to an older one.
<span class="lineNum">     218 </span>            :          */
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         last_seq = atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                 last_emitted = rdev-&gt;fence_drv[ring].sync_seq[ring];</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :                 seq = radeon_fence_read(rdev, ring);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                 seq |= last_seq &amp; 0xffffffff00000000LL;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                 if (seq &lt; last_seq) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :                         seq &amp;= 0xffffffff;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                         seq |= last_emitted &amp; 0xffffffff00000000LL;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :                 if (seq &lt;= last_seq || seq &gt; last_emitted) {</span>
<span class="lineNum">     230 </span>            :                         break;
<span class="lineNum">     231 </span>            :                 }
<span class="lineNum">     232 </span>            :                 /* If we loop over we don't want to return without
<span class="lineNum">     233 </span>            :                  * checking if a fence is signaled as it means that the
<span class="lineNum">     234 </span>            :                  * seq we just read is different from the previous on.
<span class="lineNum">     235 </span>            :                  */
<span class="lineNum">     236 </span>            :                 wake = true;
<span class="lineNum">     237 </span>            :                 last_seq = seq;
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                 if ((count_loop++) &gt; 10) {</span>
<span class="lineNum">     239 </span>            :                         /* We looped over too many time leave with the
<span class="lineNum">     240 </span>            :                          * fact that we might have set an older fence
<span class="lineNum">     241 </span>            :                          * seq then the current real last seq as signaled
<span class="lineNum">     242 </span>            :                          * by the hw.
<span class="lineNum">     243 </span>            :                          */
<span class="lineNum">     244 </span>            :                         break;
<span class="lineNum">     245 </span>            :                 }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         } while (atomic64_xchg(&amp;rdev-&gt;fence_drv[ring].last_seq, seq) &gt; seq);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         if (seq &lt; last_emitted)</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                 radeon_fence_schedule_check(rdev, ring);</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         return wake;</span>
<span class="lineNum">     252 </span>            : }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : /**
<span class="lineNum">     255 </span>            :  * radeon_fence_check_lockup - check for hardware lockup
<span class="lineNum">     256 </span>            :  *
<span class="lineNum">     257 </span>            :  * @work: delayed work item
<span class="lineNum">     258 </span>            :  *
<span class="lineNum">     259 </span>            :  * Checks for fence activity and if there is none probe
<a name="260"><span class="lineNum">     260 </span>            :  * the hardware if a lockup occured.</a>
<span class="lineNum">     261 </span>            :  */
<span class="lineNum">     262 </span><span class="lineNoCov">          0 : static void radeon_fence_check_lockup(struct work_struct *work)</span>
<span class="lineNum">     263 </span>            : {
<span class="lineNum">     264 </span>            :         struct radeon_fence_driver *fence_drv;
<span class="lineNum">     265 </span>            :         struct radeon_device *rdev;
<span class="lineNum">     266 </span>            :         int ring;
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         fence_drv = container_of(work, struct radeon_fence_driver,</span>
<span class="lineNum">     269 </span>            :                                  lockup_work.work);
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         rdev = fence_drv-&gt;rdev;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         ring = fence_drv - &amp;rdev-&gt;fence_drv[0];</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         if (!down_read_trylock(&amp;rdev-&gt;exclusive_lock)) {</span>
<span class="lineNum">     274 </span>            :                 /* just reschedule the check if a reset is going on */
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                 radeon_fence_schedule_check(rdev, ring);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     277 </span>            :         }
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         if (fence_drv-&gt;delayed_irq &amp;&amp; rdev-&gt;ddev-&gt;irq_enabled) {</span>
<span class="lineNum">     280 </span>            :                 unsigned long irqflags;
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 fence_drv-&gt;delayed_irq = false;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                 spin_lock_irqsave(&amp;rdev-&gt;irq.lock, irqflags);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                 radeon_irq_set(rdev);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :                 spin_unlock_irqrestore(&amp;rdev-&gt;irq.lock, irqflags);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         if (radeon_fence_activity(rdev, ring))</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                 wake_up_all(&amp;rdev-&gt;fence_queue);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         else if (radeon_ring_is_lockup(rdev, ring, &amp;rdev-&gt;ring[ring])) {</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :                 /* good news we believe it's a lockup */
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                 dev_warn(rdev-&gt;dev, &quot;GPU lockup (current fence id &quot;</span>
<span class="lineNum">     295 </span>            :                          &quot;0x%016llx last fence id 0x%016llx on ring %d)\n&quot;,
<span class="lineNum">     296 </span>            :                          (uint64_t)atomic64_read(&amp;fence_drv-&gt;last_seq),
<span class="lineNum">     297 </span>            :                          fence_drv-&gt;sync_seq[ring], ring);
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :                 /* remember that we need an reset */
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                 rdev-&gt;needs_reset = true;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :                 wake_up_all(&amp;rdev-&gt;fence_queue);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         up_read(&amp;rdev-&gt;exclusive_lock);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : /**
<span class="lineNum">     307 </span>            :  * radeon_fence_process - process a fence
<span class="lineNum">     308 </span>            :  *
<span class="lineNum">     309 </span>            :  * @rdev: radeon_device pointer
<span class="lineNum">     310 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     311 </span>            :  *
<span class="lineNum">     312 </span>            :  * Checks the current fence value and wakes the fence queue
<a name="313"><span class="lineNum">     313 </span>            :  * if the sequence number has increased (all asics).</a>
<span class="lineNum">     314 </span>            :  */
<span class="lineNum">     315 </span><span class="lineNoCov">          0 : void radeon_fence_process(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     316 </span>            : {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         if (radeon_fence_activity(rdev, ring))</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 wake_up_all(&amp;rdev-&gt;fence_queue);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : /**
<span class="lineNum">     322 </span>            :  * radeon_fence_seq_signaled - check if a fence sequence number has signaled
<span class="lineNum">     323 </span>            :  *
<span class="lineNum">     324 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     325 </span>            :  * @seq: sequence number
<span class="lineNum">     326 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     327 </span>            :  *
<span class="lineNum">     328 </span>            :  * Check if the last signaled fence sequnce number is &gt;= the requested
<span class="lineNum">     329 </span>            :  * sequence number (all asics).
<span class="lineNum">     330 </span>            :  * Returns true if the fence has signaled (current fence value
<span class="lineNum">     331 </span>            :  * is &gt;= requested value) or false if it has not (current fence
<span class="lineNum">     332 </span>            :  * value is &lt; the requested value.  Helper function for
<a name="333"><span class="lineNum">     333 </span>            :  * radeon_fence_signaled().</a>
<span class="lineNum">     334 </span>            :  */
<span class="lineNum">     335 </span><span class="lineNoCov">          0 : static bool radeon_fence_seq_signaled(struct radeon_device *rdev,</span>
<span class="lineNum">     336 </span>            :                                       u64 seq, unsigned ring)
<span class="lineNum">     337 </span>            : {
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         if (atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq) &gt;= seq) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     340 </span>            :         }
<span class="lineNum">     341 </span>            :         /* poll new last sequence at least once */
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         radeon_fence_process(rdev, ring);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         if (atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq) &gt;= seq) {</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     345 </span>            :         }
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         return false;</span>
<a name="347"><span class="lineNum">     347 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 : static bool radeon_fence_is_signaled(struct fence *f)</span>
<span class="lineNum">     350 </span>            : {
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         struct radeon_fence *fence = to_radeon_fence(f);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         struct radeon_device *rdev = fence-&gt;rdev;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         unsigned ring = fence-&gt;ring;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         u64 seq = fence-&gt;seq;</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         if (atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq) &gt;= seq) {</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     358 </span>            :         }
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         if (down_read_trylock(&amp;rdev-&gt;exclusive_lock)) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                 radeon_fence_process(rdev, ring);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :                 up_read(&amp;rdev-&gt;exclusive_lock);</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                 if (atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq) &gt;= seq) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                         return true;</span>
<span class="lineNum">     366 </span>            :                 }
<span class="lineNum">     367 </span>            :         }
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : /**
<span class="lineNum">     372 </span>            :  * radeon_fence_enable_signaling - enable signalling on fence
<span class="lineNum">     373 </span>            :  * @fence: fence
<span class="lineNum">     374 </span>            :  *
<span class="lineNum">     375 </span>            :  * This function is called with fence_queue lock held, and adds a callback
<span class="lineNum">     376 </span>            :  * to fence_queue that checks if this fence is signaled, and if so it
<a name="377"><span class="lineNum">     377 </span>            :  * signals the fence and removes itself.</a>
<span class="lineNum">     378 </span>            :  */
<span class="lineNum">     379 </span><span class="lineNoCov">          0 : static bool radeon_fence_enable_signaling(struct fence *f)</span>
<span class="lineNum">     380 </span>            : {
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         struct radeon_fence *fence = to_radeon_fence(f);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         struct radeon_device *rdev = fence-&gt;rdev;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         if (atomic64_read(&amp;rdev-&gt;fence_drv[fence-&gt;ring].last_seq) &gt;= fence-&gt;seq)</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         if (down_read_trylock(&amp;rdev-&gt;exclusive_lock)) {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :                 radeon_irq_kms_sw_irq_get(rdev, fence-&gt;ring);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 if (radeon_fence_activity(rdev, fence-&gt;ring))</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :                         wake_up_all_locked(&amp;rdev-&gt;fence_queue);</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :                 /* did fence get signaled after we enabled the sw irq? */
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :                 if (atomic64_read(&amp;rdev-&gt;fence_drv[fence-&gt;ring].last_seq) &gt;= fence-&gt;seq) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                         radeon_irq_kms_sw_irq_put(rdev, fence-&gt;ring);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                         up_read(&amp;rdev-&gt;exclusive_lock);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     398 </span>            :                 }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                 up_read(&amp;rdev-&gt;exclusive_lock);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     402 </span>            :                 /* we're probably in a lockup, lets not fiddle too much */
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                 if (radeon_irq_kms_sw_irq_get_delayed(rdev, fence-&gt;ring))</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                         rdev-&gt;fence_drv[fence-&gt;ring].delayed_irq = true;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                 radeon_fence_schedule_check(rdev, fence-&gt;ring);</span>
<span class="lineNum">     406 </span>            :         }
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         fence-&gt;fence_wake.flags = 0;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         fence-&gt;fence_wake.private = NULL;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         fence-&gt;fence_wake.func = radeon_fence_check_signaled;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         __add_wait_queue(&amp;rdev-&gt;fence_queue, &amp;fence-&gt;fence_wake);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         fence_get(f);</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :         FENCE_TRACE(&amp;fence-&gt;base, &quot;armed on ring %i!\n&quot;, fence-&gt;ring);
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : /**
<span class="lineNum">     419 </span>            :  * radeon_fence_signaled - check if a fence has signaled
<span class="lineNum">     420 </span>            :  *
<span class="lineNum">     421 </span>            :  * @fence: radeon fence object
<span class="lineNum">     422 </span>            :  *
<span class="lineNum">     423 </span>            :  * Check if the requested fence has signaled (all asics).
<a name="424"><span class="lineNum">     424 </span>            :  * Returns true if the fence has signaled or false if it has not.</a>
<span class="lineNum">     425 </span>            :  */
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : bool radeon_fence_signaled(struct radeon_fence *fence)</span>
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         if (!fence)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         if (radeon_fence_seq_signaled(fence-&gt;rdev, fence-&gt;seq, fence-&gt;ring)) {</span>
<span class="lineNum">     432 </span>            :                 int ret;
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                 ret = fence_signal(&amp;fence-&gt;base);</span>
<span class="lineNum">     435 </span>            :                 if (!ret)
<span class="lineNum">     436 </span>            :                         FENCE_TRACE(&amp;fence-&gt;base, &quot;signaled from radeon_fence_signaled\n&quot;);
<span class="lineNum">     437 </span>            :                 return true;
<span class="lineNum">     438 </span>            :         }
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            : /**
<span class="lineNum">     443 </span>            :  * radeon_fence_any_seq_signaled - check if any sequence number is signaled
<span class="lineNum">     444 </span>            :  *
<span class="lineNum">     445 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     446 </span>            :  * @seq: sequence numbers
<span class="lineNum">     447 </span>            :  *
<span class="lineNum">     448 </span>            :  * Check if the last signaled fence sequnce number is &gt;= the requested
<span class="lineNum">     449 </span>            :  * sequence number (all asics).
<span class="lineNum">     450 </span>            :  * Returns true if any has signaled (current value is &gt;= requested value)
<a name="451"><span class="lineNum">     451 </span>            :  * or false if it has not. Helper function for radeon_fence_wait_seq.</a>
<span class="lineNum">     452 </span>            :  */
<span class="lineNum">     453 </span><span class="lineNoCov">          0 : static bool radeon_fence_any_seq_signaled(struct radeon_device *rdev, u64 *seq)</span>
<span class="lineNum">     454 </span>            : {
<span class="lineNum">     455 </span>            :         unsigned i;
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 if (seq[i] &amp;&amp; radeon_fence_seq_signaled(rdev, seq[i], i))</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                         return true;</span>
<span class="lineNum">     460 </span>            :         }
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : /**
<span class="lineNum">     465 </span>            :  * radeon_fence_wait_seq_timeout - wait for a specific sequence numbers
<span class="lineNum">     466 </span>            :  *
<span class="lineNum">     467 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     468 </span>            :  * @target_seq: sequence number(s) we want to wait for
<span class="lineNum">     469 </span>            :  * @intr: use interruptable sleep
<span class="lineNum">     470 </span>            :  * @timeout: maximum time to wait, or MAX_SCHEDULE_TIMEOUT for infinite wait
<span class="lineNum">     471 </span>            :  *
<span class="lineNum">     472 </span>            :  * Wait for the requested sequence number(s) to be written by any ring
<span class="lineNum">     473 </span>            :  * (all asics).  Sequnce number array is indexed by ring id.
<span class="lineNum">     474 </span>            :  * @intr selects whether to use interruptable (true) or non-interruptable
<span class="lineNum">     475 </span>            :  * (false) sleep when waiting for the sequence number.  Helper function
<span class="lineNum">     476 </span>            :  * for radeon_fence_wait_*().
<span class="lineNum">     477 </span>            :  * Returns remaining time if the sequence number has passed, 0 when
<span class="lineNum">     478 </span>            :  * the wait timeout, or an error for all other cases.
<a name="479"><span class="lineNum">     479 </span>            :  * -EDEADLK is returned when a GPU lockup has been detected.</a>
<span class="lineNum">     480 </span>            :  */
<span class="lineNum">     481 </span><span class="lineNoCov">          0 : static long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,</span>
<span class="lineNum">     482 </span>            :                                           u64 *target_seq, bool intr,
<span class="lineNum">     483 </span>            :                                           long timeout)
<span class="lineNum">     484 </span>            : {
<span class="lineNum">     485 </span>            :         long r;
<span class="lineNum">     486 </span>            :         int i;
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         if (radeon_fence_any_seq_signaled(rdev, target_seq))</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                 return timeout;</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :         /* enable IRQs and tracing */
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                 if (!target_seq[i])</span>
<span class="lineNum">     494 </span>            :                         continue;
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                 trace_radeon_fence_wait_begin(rdev-&gt;ddev, i, target_seq[i]);</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 radeon_irq_kms_sw_irq_get(rdev, i);</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         if (intr) {</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                 r = wait_event_interruptible_timeout(rdev-&gt;fence_queue, (</span>
<span class="lineNum">     502 </span>            :                         radeon_fence_any_seq_signaled(rdev, target_seq)
<span class="lineNum">     503 </span>            :                          || rdev-&gt;needs_reset), timeout);
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                 r = wait_event_timeout(rdev-&gt;fence_queue, (</span>
<span class="lineNum">     506 </span>            :                         radeon_fence_any_seq_signaled(rdev, target_seq)
<span class="lineNum">     507 </span>            :                          || rdev-&gt;needs_reset), timeout);
<span class="lineNum">     508 </span>            :         }
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         if (rdev-&gt;needs_reset)</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :                 r = -EDEADLK;</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i) {</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :                 if (!target_seq[i])</span>
<span class="lineNum">     515 </span>            :                         continue;
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                 radeon_irq_kms_sw_irq_put(rdev, i);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                 trace_radeon_fence_wait_end(rdev-&gt;ddev, i, target_seq[i]);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         return r;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : /**
<span class="lineNum">     525 </span>            :  * radeon_fence_wait - wait for a fence to signal
<span class="lineNum">     526 </span>            :  *
<span class="lineNum">     527 </span>            :  * @fence: radeon fence object
<span class="lineNum">     528 </span>            :  * @intr: use interruptible sleep
<span class="lineNum">     529 </span>            :  *
<span class="lineNum">     530 </span>            :  * Wait for the requested fence to signal (all asics).
<span class="lineNum">     531 </span>            :  * @intr selects whether to use interruptable (true) or non-interruptable
<span class="lineNum">     532 </span>            :  * (false) sleep when waiting for the fence.
<a name="533"><span class="lineNum">     533 </span>            :  * Returns 0 if the fence has passed, error for all other cases.</a>
<span class="lineNum">     534 </span>            :  */
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : int radeon_fence_wait(struct radeon_fence *fence, bool intr)</span>
<span class="lineNum">     536 </span>            : {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         uint64_t seq[RADEON_NUM_RINGS] = {};</span>
<span class="lineNum">     538 </span>            :         long r;
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :         /*
<span class="lineNum">     541 </span>            :          * This function should not be called on !radeon fences.
<span class="lineNum">     542 </span>            :          * If this is the case, it would mean this function can
<span class="lineNum">     543 </span>            :          * also be called on radeon fences belonging to another card.
<span class="lineNum">     544 </span>            :          * exclusive_lock is not held in that case.
<span class="lineNum">     545 </span>            :          */
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         if (WARN_ON_ONCE(!to_radeon_fence(&amp;fence-&gt;base)))</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 return fence_wait(&amp;fence-&gt;base, intr);</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         seq[fence-&gt;ring] = fence-&gt;seq;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         r = radeon_fence_wait_seq_timeout(fence-&gt;rdev, seq, intr, MAX_SCHEDULE_TIMEOUT);</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         if (r &lt; 0) {</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                 return r;</span>
<span class="lineNum">     553 </span>            :         }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         r = fence_signal(&amp;fence-&gt;base);</span>
<span class="lineNum">     556 </span>            :         if (!r)
<span class="lineNum">     557 </span>            :                 FENCE_TRACE(&amp;fence-&gt;base, &quot;signaled from fence_wait\n&quot;);
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : /**
<span class="lineNum">     562 </span>            :  * radeon_fence_wait_any - wait for a fence to signal on any ring
<span class="lineNum">     563 </span>            :  *
<span class="lineNum">     564 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     565 </span>            :  * @fences: radeon fence object(s)
<span class="lineNum">     566 </span>            :  * @intr: use interruptable sleep
<span class="lineNum">     567 </span>            :  *
<span class="lineNum">     568 </span>            :  * Wait for any requested fence to signal (all asics).  Fence
<span class="lineNum">     569 </span>            :  * array is indexed by ring id.  @intr selects whether to use
<span class="lineNum">     570 </span>            :  * interruptable (true) or non-interruptable (false) sleep when
<span class="lineNum">     571 </span>            :  * waiting for the fences. Used by the suballocator.
<a name="572"><span class="lineNum">     572 </span>            :  * Returns 0 if any fence has passed, error for all other cases.</a>
<span class="lineNum">     573 </span>            :  */
<span class="lineNum">     574 </span><span class="lineNoCov">          0 : int radeon_fence_wait_any(struct radeon_device *rdev,</span>
<span class="lineNum">     575 </span>            :                           struct radeon_fence **fences,
<span class="lineNum">     576 </span>            :                           bool intr)
<span class="lineNum">     577 </span>            : {
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         uint64_t seq[RADEON_NUM_RINGS];</span>
<span class="lineNum">     579 </span>            :         unsigned i, num_rings = 0;
<span class="lineNum">     580 </span>            :         long r;
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                 seq[i] = 0;</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                 if (!fences[i]) {</span>
<span class="lineNum">     586 </span>            :                         continue;
<span class="lineNum">     587 </span>            :                 }
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                 seq[i] = fences[i]-&gt;seq;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                 ++num_rings;</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :         /* nothing to wait for ? */
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         if (num_rings == 0)</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :                 return -ENOENT;</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         r = radeon_fence_wait_seq_timeout(rdev, seq, intr, MAX_SCHEDULE_TIMEOUT);</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         if (r &lt; 0) {</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                 return r;</span>
<span class="lineNum">     600 </span>            :         }
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : /**
<span class="lineNum">     605 </span>            :  * radeon_fence_wait_next - wait for the next fence to signal
<span class="lineNum">     606 </span>            :  *
<span class="lineNum">     607 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     608 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     609 </span>            :  *
<span class="lineNum">     610 </span>            :  * Wait for the next fence on the requested ring to signal (all asics).
<span class="lineNum">     611 </span>            :  * Returns 0 if the next fence has passed, error for all other cases.
<a name="612"><span class="lineNum">     612 </span>            :  * Caller must hold ring lock.</a>
<span class="lineNum">     613 </span>            :  */
<span class="lineNum">     614 </span><span class="lineNoCov">          0 : int radeon_fence_wait_next(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     615 </span>            : {
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         uint64_t seq[RADEON_NUM_RINGS] = {};</span>
<span class="lineNum">     617 </span>            :         long r;
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         seq[ring] = atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq) + 1ULL;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         if (seq[ring] &gt;= rdev-&gt;fence_drv[ring].sync_seq[ring]) {</span>
<span class="lineNum">     621 </span>            :                 /* nothing to wait for, last_seq is
<span class="lineNum">     622 </span>            :                    already the last emited fence */
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                 return -ENOENT;</span>
<span class="lineNum">     624 </span>            :         }
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         r = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         if (r &lt; 0)</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :                 return r;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            : /**
<span class="lineNum">     632 </span>            :  * radeon_fence_wait_empty - wait for all fences to signal
<span class="lineNum">     633 </span>            :  *
<span class="lineNum">     634 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     635 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     636 </span>            :  *
<span class="lineNum">     637 </span>            :  * Wait for all fences on the requested ring to signal (all asics).
<span class="lineNum">     638 </span>            :  * Returns 0 if the fences have passed, error for all other cases.
<a name="639"><span class="lineNum">     639 </span>            :  * Caller must hold ring lock.</a>
<span class="lineNum">     640 </span>            :  */
<span class="lineNum">     641 </span><span class="lineNoCov">          0 : int radeon_fence_wait_empty(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     642 </span>            : {
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         uint64_t seq[RADEON_NUM_RINGS] = {};</span>
<span class="lineNum">     644 </span>            :         long r;
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         seq[ring] = rdev-&gt;fence_drv[ring].sync_seq[ring];</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         if (!seq[ring])</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         r = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         if (r &lt; 0) {</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :                 if (r == -EDEADLK)</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                         return -EDEADLK;</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                 dev_err(rdev-&gt;dev, &quot;error waiting for ring[%d] to become idle (%ld)\n&quot;,</span>
<span class="lineNum">     656 </span>            :                         ring, r);
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : /**
<span class="lineNum">     662 </span>            :  * radeon_fence_ref - take a ref on a fence
<span class="lineNum">     663 </span>            :  *
<span class="lineNum">     664 </span>            :  * @fence: radeon fence object
<span class="lineNum">     665 </span>            :  *
<span class="lineNum">     666 </span>            :  * Take a reference on a fence (all asics).
<a name="667"><span class="lineNum">     667 </span>            :  * Returns the fence.</a>
<span class="lineNum">     668 </span>            :  */
<span class="lineNum">     669 </span><span class="lineNoCov">          0 : struct radeon_fence *radeon_fence_ref(struct radeon_fence *fence)</span>
<span class="lineNum">     670 </span>            : {
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         fence_get(&amp;fence-&gt;base);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         return fence;</span>
<span class="lineNum">     673 </span>            : }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            : /**
<span class="lineNum">     676 </span>            :  * radeon_fence_unref - remove a ref on a fence
<span class="lineNum">     677 </span>            :  *
<span class="lineNum">     678 </span>            :  * @fence: radeon fence object
<span class="lineNum">     679 </span>            :  *
<a name="680"><span class="lineNum">     680 </span>            :  * Remove a reference on a fence (all asics).</a>
<span class="lineNum">     681 </span>            :  */
<span class="lineNum">     682 </span><span class="lineNoCov">          0 : void radeon_fence_unref(struct radeon_fence **fence)</span>
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         struct radeon_fence *tmp = *fence;</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         *fence = NULL;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :         if (tmp) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :                 fence_put(&amp;tmp-&gt;base);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            : /**
<span class="lineNum">     693 </span>            :  * radeon_fence_count_emitted - get the count of emitted fences
<span class="lineNum">     694 </span>            :  *
<span class="lineNum">     695 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     696 </span>            :  * @ring: ring index the fence is associated with
<span class="lineNum">     697 </span>            :  *
<span class="lineNum">     698 </span>            :  * Get the number of fences emitted on the requested ring (all asics).
<span class="lineNum">     699 </span>            :  * Returns the number of emitted fences on the ring.  Used by the
<a name="700"><span class="lineNum">     700 </span>            :  * dynpm code to ring track activity.</a>
<span class="lineNum">     701 </span>            :  */
<span class="lineNum">     702 </span><span class="lineNoCov">          0 : unsigned radeon_fence_count_emitted(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     703 </span>            : {
<span class="lineNum">     704 </span>            :         uint64_t emitted;
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :         /* We are not protected by ring lock when reading the last sequence
<span class="lineNum">     707 </span>            :          * but it's ok to report slightly wrong fence count here.
<span class="lineNum">     708 </span>            :          */
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         radeon_fence_process(rdev, ring);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         emitted = rdev-&gt;fence_drv[ring].sync_seq[ring]</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                 - atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq);</span>
<span class="lineNum">     712 </span>            :         /* to avoid 32bits warp around */
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         if (emitted &gt; 0x10000000) {</span>
<span class="lineNum">     714 </span>            :                 emitted = 0x10000000;
<span class="lineNum">     715 </span>            :         }
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         return (unsigned)emitted;</span>
<span class="lineNum">     717 </span>            : }
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : /**
<span class="lineNum">     720 </span>            :  * radeon_fence_need_sync - do we need a semaphore
<span class="lineNum">     721 </span>            :  *
<span class="lineNum">     722 </span>            :  * @fence: radeon fence object
<span class="lineNum">     723 </span>            :  * @dst_ring: which ring to check against
<span class="lineNum">     724 </span>            :  *
<span class="lineNum">     725 </span>            :  * Check if the fence needs to be synced against another ring
<span class="lineNum">     726 </span>            :  * (all asics).  If so, we need to emit a semaphore.
<span class="lineNum">     727 </span>            :  * Returns true if we need to sync with another ring, false if
<a name="728"><span class="lineNum">     728 </span>            :  * not.</a>
<span class="lineNum">     729 </span>            :  */
<span class="lineNum">     730 </span><span class="lineNoCov">          0 : bool radeon_fence_need_sync(struct radeon_fence *fence, int dst_ring)</span>
<span class="lineNum">     731 </span>            : {
<span class="lineNum">     732 </span>            :         struct radeon_fence_driver *fdrv;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         if (!fence) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     736 </span>            :         }
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         if (fence-&gt;ring == dst_ring) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     740 </span>            :         }
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :         /* we are protected by the ring mutex */
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         fdrv = &amp;fence-&gt;rdev-&gt;fence_drv[dst_ring];</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :         if (fence-&gt;seq &lt;= fdrv-&gt;sync_seq[fence-&gt;ring]) {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     746 </span>            :         }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            : /**
<span class="lineNum">     752 </span>            :  * radeon_fence_note_sync - record the sync point
<span class="lineNum">     753 </span>            :  *
<span class="lineNum">     754 </span>            :  * @fence: radeon fence object
<span class="lineNum">     755 </span>            :  * @dst_ring: which ring to check against
<span class="lineNum">     756 </span>            :  *
<span class="lineNum">     757 </span>            :  * Note the sequence number at which point the fence will
<a name="758"><span class="lineNum">     758 </span>            :  * be synced with the requested ring (all asics).</a>
<span class="lineNum">     759 </span>            :  */
<span class="lineNum">     760 </span><span class="lineNoCov">          0 : void radeon_fence_note_sync(struct radeon_fence *fence, int dst_ring)</span>
<span class="lineNum">     761 </span>            : {
<span class="lineNum">     762 </span>            :         struct radeon_fence_driver *dst, *src;
<span class="lineNum">     763 </span>            :         unsigned i;
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         if (!fence) {</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     767 </span>            :         }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         if (fence-&gt;ring == dst_ring) {</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     771 </span>            :         }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :         /* we are protected by the ring mutex */
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :         src = &amp;fence-&gt;rdev-&gt;fence_drv[fence-&gt;ring];</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         dst = &amp;fence-&gt;rdev-&gt;fence_drv[dst_ring];</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i) {</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                 if (i == dst_ring) {</span>
<span class="lineNum">     778 </span>            :                         continue;
<span class="lineNum">     779 </span>            :                 }
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                 dst-&gt;sync_seq[i] = max(dst-&gt;sync_seq[i], src-&gt;sync_seq[i]);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : /**
<span class="lineNum">     785 </span>            :  * radeon_fence_driver_start_ring - make the fence driver
<span class="lineNum">     786 </span>            :  * ready for use on the requested ring.
<span class="lineNum">     787 </span>            :  *
<span class="lineNum">     788 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     789 </span>            :  * @ring: ring index to start the fence driver on
<span class="lineNum">     790 </span>            :  *
<span class="lineNum">     791 </span>            :  * Make the fence driver ready for processing (all asics).
<span class="lineNum">     792 </span>            :  * Not all asics have all rings, so each asic will only
<span class="lineNum">     793 </span>            :  * start the fence driver on the rings it has.
<a name="794"><span class="lineNum">     794 </span>            :  * Returns 0 for success, errors for failure.</a>
<span class="lineNum">     795 </span>            :  */
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : int radeon_fence_driver_start_ring(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     797 </span>            : {
<span class="lineNum">     798 </span>            :         uint64_t index;
<span class="lineNum">     799 </span>            :         int r;
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         radeon_scratch_free(rdev, rdev-&gt;fence_drv[ring].scratch_reg);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         if (rdev-&gt;wb.use_event || !radeon_ring_supports_scratch_reg(rdev, &amp;rdev-&gt;ring[ring])) {</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :                 rdev-&gt;fence_drv[ring].scratch_reg = 0;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :                 if (ring != R600_RING_TYPE_UVD_INDEX) {</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                         index = R600_WB_EVENT_OFFSET + ring * 4;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                         rdev-&gt;fence_drv[ring].cpu_addr = &amp;rdev-&gt;wb.wb[index/4];</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :                         rdev-&gt;fence_drv[ring].gpu_addr = rdev-&gt;wb.gpu_addr +</span>
<span class="lineNum">     808 </span>            :                                                          index;
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">     811 </span>            :                         /* put fence directly behind firmware */
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :                         index = roundup2(rdev-&gt;uvd_fw-&gt;size, 8);</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :                         rdev-&gt;fence_drv[ring].cpu_addr = rdev-&gt;uvd.cpu_addr + index;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :                         rdev-&gt;fence_drv[ring].gpu_addr = rdev-&gt;uvd.gpu_addr + index;</span>
<span class="lineNum">     815 </span>            :                 }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :         } else {
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :                 r = radeon_scratch_get(rdev, &amp;rdev-&gt;fence_drv[ring].scratch_reg);</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :                 if (r) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                         dev_err(rdev-&gt;dev, &quot;fence failed to get scratch register\n&quot;);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :                         return r;</span>
<span class="lineNum">     822 </span>            :                 }
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :                 index = RADEON_WB_SCRATCH_OFFSET +</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                         rdev-&gt;fence_drv[ring].scratch_reg -</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                         rdev-&gt;scratch.reg_base;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 rdev-&gt;fence_drv[ring].cpu_addr = &amp;rdev-&gt;wb.wb[index/4];</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :                 rdev-&gt;fence_drv[ring].gpu_addr = rdev-&gt;wb.gpu_addr + index;</span>
<span class="lineNum">     828 </span>            :         }
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         radeon_fence_write(rdev, atomic64_read(&amp;rdev-&gt;fence_drv[ring].last_seq), ring);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :         rdev-&gt;fence_drv[ring].initialized = true;</span>
<span class="lineNum">     831 </span>            :         dev_info(rdev-&gt;dev, &quot;fence driver on ring %d use gpu addr 0x%016llx and cpu addr 0x%p\n&quot;,
<span class="lineNum">     832 </span>            :                  ring, rdev-&gt;fence_drv[ring].gpu_addr, rdev-&gt;fence_drv[ring].cpu_addr);
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : /**
<span class="lineNum">     837 </span>            :  * radeon_fence_driver_init_ring - init the fence driver
<span class="lineNum">     838 </span>            :  * for the requested ring.
<span class="lineNum">     839 </span>            :  *
<span class="lineNum">     840 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     841 </span>            :  * @ring: ring index to start the fence driver on
<span class="lineNum">     842 </span>            :  *
<span class="lineNum">     843 </span>            :  * Init the fence driver for the requested ring (all asics).
<a name="844"><span class="lineNum">     844 </span>            :  * Helper function for radeon_fence_driver_init().</a>
<span class="lineNum">     845 </span>            :  */
<span class="lineNum">     846 </span><span class="lineNoCov">          0 : static void radeon_fence_driver_init_ring(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     847 </span>            : {
<span class="lineNum">     848 </span>            :         int i;
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         rdev-&gt;fence_drv[ring].scratch_reg = -1;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         rdev-&gt;fence_drv[ring].cpu_addr = NULL;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :         rdev-&gt;fence_drv[ring].gpu_addr = 0;</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i)</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :                 rdev-&gt;fence_drv[ring].sync_seq[i] = 0;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :         atomic64_set(&amp;rdev-&gt;fence_drv[ring].last_seq, 0);</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :         rdev-&gt;fence_drv[ring].initialized = false;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :         INIT_DELAYED_WORK(&amp;rdev-&gt;fence_drv[ring].lockup_work,</span>
<span class="lineNum">     858 </span>            :                           radeon_fence_check_lockup);
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :         rdev-&gt;fence_drv[ring].rdev = rdev;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            : /**
<span class="lineNum">     863 </span>            :  * radeon_fence_driver_init - init the fence driver
<span class="lineNum">     864 </span>            :  * for all possible rings.
<span class="lineNum">     865 </span>            :  *
<span class="lineNum">     866 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     867 </span>            :  *
<span class="lineNum">     868 </span>            :  * Init the fence driver for all possible rings (all asics).
<span class="lineNum">     869 </span>            :  * Not all asics have all rings, so each asic will only
<span class="lineNum">     870 </span>            :  * start the fence driver on the rings it has using
<span class="lineNum">     871 </span>            :  * radeon_fence_driver_start_ring().
<a name="872"><span class="lineNum">     872 </span>            :  * Returns 0 for success.</a>
<span class="lineNum">     873 </span>            :  */
<span class="lineNum">     874 </span><span class="lineNoCov">          0 : int radeon_fence_driver_init(struct radeon_device *rdev)</span>
<span class="lineNum">     875 </span>            : {
<span class="lineNum">     876 </span>            :         int ring;
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         init_waitqueue_head(&amp;rdev-&gt;fence_queue);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         for (ring = 0; ring &lt; RADEON_NUM_RINGS; ring++) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                 radeon_fence_driver_init_ring(rdev, ring);</span>
<span class="lineNum">     881 </span>            :         }
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :         if (radeon_debugfs_fence_init(rdev)) {</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                 dev_err(rdev-&gt;dev, &quot;fence debugfs file creation failed\n&quot;);</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     886 </span>            : }
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : /**
<span class="lineNum">     889 </span>            :  * radeon_fence_driver_fini - tear down the fence driver
<span class="lineNum">     890 </span>            :  * for all possible rings.
<span class="lineNum">     891 </span>            :  *
<span class="lineNum">     892 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     893 </span>            :  *
<a name="894"><span class="lineNum">     894 </span>            :  * Tear down the fence driver for all possible rings (all asics).</a>
<span class="lineNum">     895 </span>            :  */
<span class="lineNum">     896 </span><span class="lineNoCov">          0 : void radeon_fence_driver_fini(struct radeon_device *rdev)</span>
<span class="lineNum">     897 </span>            : {
<span class="lineNum">     898 </span>            :         int ring, r;
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         mutex_lock(&amp;rdev-&gt;ring_lock);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         for (ring = 0; ring &lt; RADEON_NUM_RINGS; ring++) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                 if (!rdev-&gt;fence_drv[ring].initialized)</span>
<span class="lineNum">     903 </span>            :                         continue;
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                 r = radeon_fence_wait_empty(rdev, ring);</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :                 if (r) {</span>
<span class="lineNum">     906 </span>            :                         /* no need to trigger GPU reset as we are unloading */
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                         radeon_fence_driver_force_completion(rdev, ring);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                 cancel_delayed_work_sync(&amp;rdev-&gt;fence_drv[ring].lockup_work);</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :                 wake_up_all(&amp;rdev-&gt;fence_queue);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 radeon_scratch_free(rdev, rdev-&gt;fence_drv[ring].scratch_reg);</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :                 rdev-&gt;fence_drv[ring].initialized = false;</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :         mutex_unlock(&amp;rdev-&gt;ring_lock);</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            : /**
<span class="lineNum">     918 </span>            :  * radeon_fence_driver_force_completion - force all fence waiter to complete
<span class="lineNum">     919 </span>            :  *
<span class="lineNum">     920 </span>            :  * @rdev: radeon device pointer
<span class="lineNum">     921 </span>            :  * @ring: the ring to complete
<span class="lineNum">     922 </span>            :  *
<span class="lineNum">     923 </span>            :  * In case of GPU reset failure make sure no process keep waiting on fence
<a name="924"><span class="lineNum">     924 </span>            :  * that will never complete.</a>
<span class="lineNum">     925 </span>            :  */
<span class="lineNum">     926 </span><span class="lineNoCov">          0 : void radeon_fence_driver_force_completion(struct radeon_device *rdev, int ring)</span>
<span class="lineNum">     927 </span>            : {
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         if (rdev-&gt;fence_drv[ring].initialized) {</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :                 radeon_fence_write(rdev, rdev-&gt;fence_drv[ring].sync_seq[ring], ring);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                 cancel_delayed_work_sync(&amp;rdev-&gt;fence_drv[ring].lockup_work);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : /*
<span class="lineNum">     936 </span>            :  * Fence debugfs
<span class="lineNum">     937 </span>            :  */
<span class="lineNum">     938 </span>            : #if defined(CONFIG_DEBUG_FS)
<span class="lineNum">     939 </span>            : static int radeon_debugfs_fence_info(struct seq_file *m, void *data)
<span class="lineNum">     940 </span>            : {
<span class="lineNum">     941 </span>            :         struct drm_info_node *node = (struct drm_info_node *)m-&gt;private;
<span class="lineNum">     942 </span>            :         struct drm_device *dev = node-&gt;minor-&gt;dev;
<span class="lineNum">     943 </span>            :         struct radeon_device *rdev = dev-&gt;dev_private;
<span class="lineNum">     944 </span>            :         int i, j;
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :         for (i = 0; i &lt; RADEON_NUM_RINGS; ++i) {
<span class="lineNum">     947 </span>            :                 if (!rdev-&gt;fence_drv[i].initialized)
<span class="lineNum">     948 </span>            :                         continue;
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :                 radeon_fence_process(rdev, i);
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :                 seq_printf(m, &quot;--- ring %d ---\n&quot;, i);
<span class="lineNum">     953 </span>            :                 seq_printf(m, &quot;Last signaled fence 0x%016llx\n&quot;,
<span class="lineNum">     954 </span>            :                            (unsigned long long)atomic64_read(&amp;rdev-&gt;fence_drv[i].last_seq));
<span class="lineNum">     955 </span>            :                 seq_printf(m, &quot;Last emitted        0x%016llx\n&quot;,
<span class="lineNum">     956 </span>            :                            rdev-&gt;fence_drv[i].sync_seq[i]);
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :                 for (j = 0; j &lt; RADEON_NUM_RINGS; ++j) {
<span class="lineNum">     959 </span>            :                         if (i != j &amp;&amp; rdev-&gt;fence_drv[j].initialized)
<span class="lineNum">     960 </span>            :                                 seq_printf(m, &quot;Last sync to ring %d 0x%016llx\n&quot;,
<span class="lineNum">     961 </span>            :                                            j, rdev-&gt;fence_drv[i].sync_seq[j]);
<span class="lineNum">     962 </span>            :                 }
<span class="lineNum">     963 </span>            :         }
<span class="lineNum">     964 </span>            :         return 0;
<span class="lineNum">     965 </span>            : }
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            : /**
<span class="lineNum">     968 </span>            :  * radeon_debugfs_gpu_reset - manually trigger a gpu reset
<span class="lineNum">     969 </span>            :  *
<span class="lineNum">     970 </span>            :  * Manually trigger a gpu reset at the next fence wait.
<span class="lineNum">     971 </span>            :  */
<span class="lineNum">     972 </span>            : static int radeon_debugfs_gpu_reset(struct seq_file *m, void *data)
<span class="lineNum">     973 </span>            : {
<span class="lineNum">     974 </span>            :         struct drm_info_node *node = (struct drm_info_node *) m-&gt;private;
<span class="lineNum">     975 </span>            :         struct drm_device *dev = node-&gt;minor-&gt;dev;
<span class="lineNum">     976 </span>            :         struct radeon_device *rdev = dev-&gt;dev_private;
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :         down_read(&amp;rdev-&gt;exclusive_lock);
<span class="lineNum">     979 </span>            :         seq_printf(m, &quot;%d\n&quot;, rdev-&gt;needs_reset);
<span class="lineNum">     980 </span>            :         rdev-&gt;needs_reset = true;
<span class="lineNum">     981 </span>            :         wake_up_all(&amp;rdev-&gt;fence_queue);
<span class="lineNum">     982 </span>            :         up_read(&amp;rdev-&gt;exclusive_lock);
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :         return 0;
<span class="lineNum">     985 </span>            : }
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : static struct drm_info_list radeon_debugfs_fence_list[] = {
<span class="lineNum">     988 </span>            :         {&quot;radeon_fence_info&quot;, &amp;radeon_debugfs_fence_info, 0, NULL},
<span class="lineNum">     989 </span>            :         {&quot;radeon_gpu_reset&quot;, &amp;radeon_debugfs_gpu_reset, 0, NULL}
<span class="lineNum">     990 </span>            : };
<a name="991"><span class="lineNum">     991 </span>            : #endif</a>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 : int radeon_debugfs_fence_init(struct radeon_device *rdev)</span>
<span class="lineNum">     994 </span>            : {
<span class="lineNum">     995 </span>            : #if defined(CONFIG_DEBUG_FS)
<span class="lineNum">     996 </span>            :         return radeon_debugfs_add_files(rdev, radeon_debugfs_fence_list, 2);
<span class="lineNum">     997 </span>            : #else
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     999 </span>            : #endif
<a name="1000"><span class="lineNum">    1000 </span>            : }</a>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 : static const char *radeon_fence_get_driver_name(struct fence *fence)</span>
<span class="lineNum">    1003 </span>            : {
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         return &quot;radeon&quot;;</span>
<a name="1005"><span class="lineNum">    1005 </span>            : }</a>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 : static const char *radeon_fence_get_timeline_name(struct fence *f)</span>
<span class="lineNum">    1008 </span>            : {
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         struct radeon_fence *fence = to_radeon_fence(f);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :         switch (fence-&gt;ring) {</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         case RADEON_RING_TYPE_GFX_INDEX: return &quot;radeon.gfx&quot;;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         case CAYMAN_RING_TYPE_CP1_INDEX: return &quot;radeon.cp1&quot;;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         case CAYMAN_RING_TYPE_CP2_INDEX: return &quot;radeon.cp2&quot;;</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         case R600_RING_TYPE_DMA_INDEX: return &quot;radeon.dma&quot;;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :         case CAYMAN_RING_TYPE_DMA1_INDEX: return &quot;radeon.dma1&quot;;</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :         case R600_RING_TYPE_UVD_INDEX: return &quot;radeon.uvd&quot;;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         case TN_RING_TYPE_VCE1_INDEX: return &quot;radeon.vce1&quot;;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         case TN_RING_TYPE_VCE2_INDEX: return &quot;radeon.vce2&quot;;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         default: WARN_ON_ONCE(1); return &quot;radeon.unk&quot;;</span>
<span class="lineNum">    1020 </span>            :         }
<a name="1021"><span class="lineNum">    1021 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 : static inline bool radeon_test_signaled(struct radeon_fence *fence)</span>
<span class="lineNum">    1024 </span>            : {
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :         return test_bit(FENCE_FLAG_SIGNALED_BIT, &amp;fence-&gt;base.flags);</span>
<span class="lineNum">    1026 </span>            : }
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : struct radeon_wait_cb {
<span class="lineNum">    1029 </span>            :         struct fence_cb base;
<span class="lineNum">    1030 </span>            :         void *task;
<span class="lineNum">    1031 </span>            : };
<a name="1032"><span class="lineNum">    1032 </span>            : </a>
<span class="lineNum">    1033 </span>            : static void
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 : radeon_fence_wait_cb(struct fence *fence, struct fence_cb *cb)</span>
<span class="lineNum">    1035 </span>            : {
<span class="lineNum">    1036 </span>            :         struct radeon_wait_cb *wait =
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :                 container_of(cb, struct radeon_wait_cb, base);</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         wake_up_process(wait-&gt;task);</span>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 : static signed long radeon_fence_default_wait(struct fence *f, bool intr,</span>
<span class="lineNum">    1042 </span>            :                                              signed long t)
<span class="lineNum">    1043 </span>            : {
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :         struct radeon_fence *fence = to_radeon_fence(f);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :         struct radeon_device *rdev = fence-&gt;rdev;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :         struct radeon_wait_cb cb;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         cb.task = curproc;</span>
<span class="lineNum">    1049 </span>            : 
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         if (fence_add_callback(f, &amp;cb.base, radeon_fence_wait_cb))</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                 return t;</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :         while (t &gt; 0) {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                 if (intr)</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                         set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="lineNum">    1056 </span>            :                 else
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :                         set_current_state(TASK_UNINTERRUPTIBLE);</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :                 /*
<span class="lineNum">    1060 </span>            :                  * radeon_test_signaled must be called after
<span class="lineNum">    1061 </span>            :                  * set_current_state to prevent a race with wake_up_process
<span class="lineNum">    1062 </span>            :                  */
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :                 if (radeon_test_signaled(fence))</span>
<span class="lineNum">    1064 </span>            :                         break;
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :                 if (rdev-&gt;needs_reset) {</span>
<span class="lineNum">    1067 </span>            :                         t = -EDEADLK;
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1069 </span>            :                 }
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                 KASSERT(sch_ident != NULL);</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                 t = schedule_timeout(t);</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                 if (t &gt; 0 &amp;&amp; intr &amp;&amp; signal_pending(current))</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                         t = -ERESTARTSYS;</span>
<span class="lineNum">    1076 </span>            :         }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         __set_current_state(TASK_RUNNING);</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         fence_remove_callback(f, &amp;cb.base);</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         return t;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : const struct fence_ops radeon_fence_ops = {
<span class="lineNum">    1085 </span>            :         .get_driver_name = radeon_fence_get_driver_name,
<span class="lineNum">    1086 </span>            :         .get_timeline_name = radeon_fence_get_timeline_name,
<span class="lineNum">    1087 </span>            :         .enable_signaling = radeon_fence_enable_signaling,
<span class="lineNum">    1088 </span>            :         .signaled = radeon_fence_is_signaled,
<span class="lineNum">    1089 </span>            :         .wait = radeon_fence_default_wait,
<span class="lineNum">    1090 </span>            :         .release = NULL,
<span class="lineNum">    1091 </span>            : };
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
