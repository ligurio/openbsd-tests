<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/drmP.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">dev/pci/drm</a> - drmP.h<span style="font-size: 80%;"> (source / <a href="drmP.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* $OpenBSD: drmP.h,v 1.219 2018/08/20 19:36:04 kettenis Exp $ */</a>
<span class="lineNum">       2 </span>            : /* drmP.h -- Private header for Direct Rendering Manager -*- linux-c -*-
<span class="lineNum">       3 </span>            :  * Created: Mon Jan  4 10:05:05 1999 by faith@precisioninsight.com
<span class="lineNum">       4 </span>            :  */
<span class="lineNum">       5 </span>            : /*-
<span class="lineNum">       6 </span>            :  * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
<span class="lineNum">       7 </span>            :  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
<span class="lineNum">       8 </span>            :  * All rights reserved.
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">      11 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">      12 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">      13 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">      14 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">      15 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * The above copyright notice and this permission notice (including the next
<span class="lineNum">      18 </span>            :  * paragraph) shall be included in all copies or substantial portions of the
<span class="lineNum">      19 </span>            :  * Software.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      22 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      23 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      24 </span>            :  * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
<span class="lineNum">      25 </span>            :  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
<span class="lineNum">      26 </span>            :  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
<span class="lineNum">      27 </span>            :  * OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  * Authors:
<span class="lineNum">      30 </span>            :  *    Rickard E. (Rik) Faith &lt;faith@valinux.com&gt;
<span class="lineNum">      31 </span>            :  *    Gareth Hughes &lt;gareth@valinux.com&gt;
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  */
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #ifndef _DRM_P_H_
<span class="lineNum">      36 </span>            : #define _DRM_P_H_
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #if defined(_KERNEL) || defined(__KERNEL__)
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : //#define DRMDEBUG
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      43 </span>            : #include &lt;sys/queue.h&gt;
<span class="lineNum">      44 </span>            : #include &lt;sys/malloc.h&gt;
<span class="lineNum">      45 </span>            : #include &lt;sys/pool.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;sys/kernel.h&gt;
<span class="lineNum">      47 </span>            : #include &lt;sys/systm.h&gt;
<span class="lineNum">      48 </span>            : #include &lt;sys/proc.h&gt;
<span class="lineNum">      49 </span>            : #include &lt;sys/conf.h&gt;
<span class="lineNum">      50 </span>            : #include &lt;sys/mutex.h&gt;
<span class="lineNum">      51 </span>            : #include &lt;sys/tree.h&gt;
<span class="lineNum">      52 </span>            : #include &lt;sys/endian.h&gt;
<span class="lineNum">      53 </span>            : #include &lt;sys/stdint.h&gt;
<span class="lineNum">      54 </span>            : #include &lt;sys/memrange.h&gt;
<span class="lineNum">      55 </span>            : #include &lt;sys/extent.h&gt;
<span class="lineNum">      56 </span>            : #include &lt;sys/rwlock.h&gt;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #ifdef DDB
<span class="lineNum">      59 </span>            : #include &lt;ddb/db_var.h&gt;
<span class="lineNum">      60 </span>            : #endif
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : #include &lt;uvm/uvm_extern.h&gt;
<span class="lineNum">      63 </span>            : #include &lt;uvm/uvm_object.h&gt;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : #include &lt;dev/pci/pcidevs.h&gt;
<span class="lineNum">      66 </span>            : #include &lt;dev/pci/pcivar.h&gt;
<span class="lineNum">      67 </span>            : #include &lt;dev/pci/agpvar.h&gt;
<span class="lineNum">      68 </span>            : #include &lt;machine/bus.h&gt;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : #define CONFIG_DRM_FBDEV_EMULATION 1
<span class="lineNum">      71 </span>            : #define CONFIG_BACKLIGHT_CLASS_DEVICE 1
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : #include &quot;drm_linux.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;drm_linux_list.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;drm.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;drm_vma_manager.h&quot;
<span class="lineNum">      77 </span>            : #include &lt;dev/pci/drm/drm_crtc.h&gt;
<span class="lineNum">      78 </span>            : #include &quot;drm_mm.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;drm_linux_atomic.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;agp.h&quot;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : struct fb_cmap;
<span class="lineNum">      83 </span>            : struct fb_fillrect;
<span class="lineNum">      84 </span>            : struct fb_copyarea;
<span class="lineNum">      85 </span>            : struct fb_image;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : #define drm_debug       0
<span class="lineNum">      88 </span>            : #define DRM_UT_KMS      0
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : /***********************************************************************/
<span class="lineNum">      91 </span>            : /** \name DRM template customization defaults */
<span class="lineNum">      92 </span>            : /*@{*/
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : /* driver capabilities and requirements mask */
<span class="lineNum">      95 </span>            : #define DRIVER_USE_AGP     0x1
<span class="lineNum">      96 </span>            : #define DRIVER_PCI_DMA     0x8
<span class="lineNum">      97 </span>            : #define DRIVER_SG          0x10
<span class="lineNum">      98 </span>            : #define DRIVER_HAVE_DMA    0x20
<span class="lineNum">      99 </span>            : #define DRIVER_HAVE_IRQ    0x40
<span class="lineNum">     100 </span>            : #define DRIVER_IRQ_SHARED  0x80
<span class="lineNum">     101 </span>            : #define DRIVER_GEM         0x1000
<span class="lineNum">     102 </span>            : #define DRIVER_MODESET     0x2000
<span class="lineNum">     103 </span>            : #define DRIVER_PRIME       0x4000
<span class="lineNum">     104 </span>            : #define DRIVER_RENDER      0x8000
<span class="lineNum">     105 </span>            : #define DRIVER_ATOMIC      0x10000
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : #define DRM_DEBUGBITS_DEBUG             0x1
<span class="lineNum">     108 </span>            : #define DRM_DEBUGBITS_KMS               0x2
<span class="lineNum">     109 </span>            : #define DRM_DEBUGBITS_FAILED_IOCTL      0x4
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #define __OS_HAS_AGP            (NAGP &gt; 0)
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :                                 /* Internal types and structures */
<span class="lineNum">     114 </span>            : #define DRM_IF_VERSION(maj, min) (maj &lt;&lt; 16 | min)
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : #define DRM_CURRENTPID          curproc-&gt;p_p-&gt;ps_pid
<span class="lineNum">     117 </span>            : #define DRM_MAXUNITS            8
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : /* DRM_SUSER returns true if the user is superuser */
<span class="lineNum">     120 </span>            : #define DRM_SUSER(p)            (suser(p) == 0)
<span class="lineNum">     121 </span>            : #define DRM_MTRR_WC             MDF_WRITECOMBINE
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #define DRM_WAKEUP(x)           wakeup(x)
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : #define drm_msleep(x)           mdelay(x)
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : extern struct cfdriver drm_cd;
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : /* freebsd compat */
<span class="lineNum">     130 </span>            : #define TAILQ_CONCAT(head1, head2, field) do {                          \
<span class="lineNum">     131 </span>            :         if (!TAILQ_EMPTY(head2)) {                                      \
<span class="lineNum">     132 </span>            :                 *(head1)-&gt;tqh_last = (head2)-&gt;tqh_first;          \
<span class="lineNum">     133 </span>            :                 (head2)-&gt;tqh_first-&gt;field.tqe_prev = (head1)-&gt;tqh_last;        \
<span class="lineNum">     134 </span>            :                 (head1)-&gt;tqh_last = (head2)-&gt;tqh_last;                    \
<span class="lineNum">     135 </span>            :                 TAILQ_INIT((head2));                                    \
<span class="lineNum">     136 </span>            :         }                                                               \
<span class="lineNum">     137 </span>            : } while (0)
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : #define DRM_ARRAY_SIZE nitems
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : /* DRM_READMEMORYBARRIER() prevents reordering of reads.
<span class="lineNum">     142 </span>            :  * DRM_WRITEMEMORYBARRIER() prevents reordering of writes.
<span class="lineNum">     143 </span>            :  * DRM_MEMORYBARRIER() prevents reordering of reads and writes.
<span class="lineNum">     144 </span>            :  */
<span class="lineNum">     145 </span>            : #if defined(__i386__)
<span class="lineNum">     146 </span>            : #define DRM_READMEMORYBARRIER()         __asm __volatile( \
<span class="lineNum">     147 </span>            :                                         &quot;lock; addl $0,0(%%esp)&quot; : : : &quot;memory&quot;);
<span class="lineNum">     148 </span>            : #define DRM_WRITEMEMORYBARRIER()        __asm __volatile(&quot;&quot; : : : &quot;memory&quot;);
<span class="lineNum">     149 </span>            : #define DRM_MEMORYBARRIER()             __asm __volatile( \
<span class="lineNum">     150 </span>            :                                         &quot;lock; addl $0,0(%%esp)&quot; : : : &quot;memory&quot;);
<span class="lineNum">     151 </span>            : #elif defined(__alpha__)
<span class="lineNum">     152 </span>            : #define DRM_READMEMORYBARRIER()         alpha_mb();
<span class="lineNum">     153 </span>            : #define DRM_WRITEMEMORYBARRIER()        alpha_wmb();
<span class="lineNum">     154 </span>            : #define DRM_MEMORYBARRIER()             alpha_mb();
<span class="lineNum">     155 </span>            : #elif defined(__amd64__)
<span class="lineNum">     156 </span>            : #define DRM_READMEMORYBARRIER()         __asm __volatile( \
<span class="lineNum">     157 </span>            :                                         &quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;memory&quot;);
<span class="lineNum">     158 </span>            : #define DRM_WRITEMEMORYBARRIER()        __asm __volatile(&quot;&quot; : : : &quot;memory&quot;);
<span class="lineNum">     159 </span>            : #define DRM_MEMORYBARRIER()             __asm __volatile( \
<span class="lineNum">     160 </span>            :                                         &quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;memory&quot;);
<span class="lineNum">     161 </span>            : #elif defined(__aarch64__)
<span class="lineNum">     162 </span>            : #define DRM_READMEMORYBARRIER()         __membar(&quot;dsb ld&quot;)
<span class="lineNum">     163 </span>            : #define DRM_WRITEMEMORYBARRIER()        __membar(&quot;dsb st&quot;)
<span class="lineNum">     164 </span>            : #define DRM_MEMORYBARRIER()             __membar(&quot;dsb sy&quot;)
<span class="lineNum">     165 </span>            : #elif defined(__mips64__)
<span class="lineNum">     166 </span>            : #define DRM_READMEMORYBARRIER()         DRM_MEMORYBARRIER() 
<span class="lineNum">     167 </span>            : #define DRM_WRITEMEMORYBARRIER()        DRM_MEMORYBARRIER()
<span class="lineNum">     168 </span>            : #define DRM_MEMORYBARRIER()             mips_sync()
<span class="lineNum">     169 </span>            : #elif defined(__powerpc__)
<span class="lineNum">     170 </span>            : #define DRM_READMEMORYBARRIER()         DRM_MEMORYBARRIER() 
<span class="lineNum">     171 </span>            : #define DRM_WRITEMEMORYBARRIER()        DRM_MEMORYBARRIER()
<span class="lineNum">     172 </span>            : #define DRM_MEMORYBARRIER()             __asm __volatile(&quot;sync&quot; : : : &quot;memory&quot;);
<span class="lineNum">     173 </span>            : #elif defined(__sparc64__)
<span class="lineNum">     174 </span>            : #define DRM_READMEMORYBARRIER()         DRM_MEMORYBARRIER() 
<span class="lineNum">     175 </span>            : #define DRM_WRITEMEMORYBARRIER()        DRM_MEMORYBARRIER()
<span class="lineNum">     176 </span>            : #define DRM_MEMORYBARRIER()             membar_sync()
<span class="lineNum">     177 </span>            : #endif
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : #define smp_mb__before_atomic()         DRM_MEMORYBARRIER()
<span class="lineNum">     180 </span>            : #define smp_mb__before_atomic_dec()     DRM_MEMORYBARRIER()
<span class="lineNum">     181 </span>            : #define smp_mb__after_atomic_dec()      DRM_MEMORYBARRIER()
<span class="lineNum">     182 </span>            : #define smp_mb__before_atomic_inc()     DRM_MEMORYBARRIER()
<span class="lineNum">     183 </span>            : #define smp_mb__after_atomic_inc()      DRM_MEMORYBARRIER()
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : #define mb()                            DRM_MEMORYBARRIER()
<span class="lineNum">     186 </span>            : #define rmb()                           DRM_READMEMORYBARRIER()
<span class="lineNum">     187 </span>            : #define wmb()                           DRM_WRITEMEMORYBARRIER()
<span class="lineNum">     188 </span>            : #define smp_rmb()                       DRM_READMEMORYBARRIER()
<span class="lineNum">     189 </span>            : #define smp_wmb()                       DRM_WRITEMEMORYBARRIER()
<span class="lineNum">     190 </span>            : #define mmiowb()                        DRM_WRITEMEMORYBARRIER()
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : #define DRM_COPY_TO_USER(user, kern, size)      copyout(kern, user, size)
<span class="lineNum">     193 </span>            : #define DRM_COPY_FROM_USER(kern, user, size)    copyin(user, kern, size)
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : #define DRM_UDELAY(udelay)      DELAY(udelay)
<a name="196"><span class="lineNum">     196 </span>            : </a>
<span class="lineNum">     197 </span>            : static inline bool
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : drm_can_sleep(void)</span>
<span class="lineNum">     199 </span>            : {
<span class="lineNum">     200 </span>            : #if defined(__i386__) || defined(__amd64__)
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         if (pagefault_disabled() || in_dbg_master() || irqs_disabled())</span>
<span class="lineNum">     202 </span>            : #else
<span class="lineNum">     203 </span>            :         if (in_dbg_master() || irqs_disabled())
<span class="lineNum">     204 </span>            : #endif
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : #define DRM_WAIT_ON(ret, wq, timo, condition) do {                      \
<span class="lineNum">     210 </span>            :         ret = wait_event_interruptible_timeout(wq, condition, timo);    \
<span class="lineNum">     211 </span>            :         if (ret == 0)                                                   \
<span class="lineNum">     212 </span>            :                 ret = -EBUSY;                                           \
<span class="lineNum">     213 </span>            :         if (ret &gt; 0)                                                 \
<span class="lineNum">     214 </span>            :                 ret = 0;                                                \
<span class="lineNum">     215 </span>            : } while (0)
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : #define DRM_ERROR(fmt, arg...) \
<span class="lineNum">     218 </span>            :         printf(&quot;error: [&quot; DRM_NAME &quot;:pid%d:%s] *ERROR* &quot; fmt,               \
<span class="lineNum">     219 </span>            :             curproc-&gt;p_p-&gt;ps_pid, __func__ , ## arg)
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : #ifdef DRMDEBUG
<span class="lineNum">     223 </span>            : #define DRM_INFO(fmt, arg...)  printf(&quot;drm: &quot; fmt, ## arg)
<span class="lineNum">     224 </span>            : #define DRM_INFO_ONCE(fmt, arg...)  printf(&quot;drm: &quot; fmt, ## arg)
<span class="lineNum">     225 </span>            : #else
<span class="lineNum">     226 </span>            : #define DRM_INFO(fmt, arg...) do { } while(/* CONSTCOND */ 0)
<span class="lineNum">     227 </span>            : #define DRM_INFO_ONCE(fmt, arg...) do { } while(/* CONSTCOND */ 0)
<span class="lineNum">     228 </span>            : #endif
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : #ifdef DRMDEBUG
<span class="lineNum">     231 </span>            : #undef DRM_DEBUG
<span class="lineNum">     232 </span>            : #define DRM_DEBUG(fmt, arg...) do {                                     \
<span class="lineNum">     233 </span>            :         if (drm_debug_flag)                                             \
<span class="lineNum">     234 </span>            :                 printf(&quot;[&quot; DRM_NAME &quot;:pid%d:%s] &quot; fmt,                      \
<span class="lineNum">     235 </span>            :                     curproc-&gt;p_p-&gt;ps_pid, __func__ , ## arg);             \
<span class="lineNum">     236 </span>            : } while (0)
<span class="lineNum">     237 </span>            : #else
<span class="lineNum">     238 </span>            : #define DRM_DEBUG(fmt, arg...) do { } while(/* CONSTCOND */ 0)
<span class="lineNum">     239 </span>            : #endif
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : #ifdef DRMDEBUG
<span class="lineNum">     242 </span>            : #undef DRM_DEBUG_KMS
<span class="lineNum">     243 </span>            : #define DRM_DEBUG_KMS(fmt, arg...) do {                                 \
<span class="lineNum">     244 </span>            :         if (drm_debug_flag)                                             \
<span class="lineNum">     245 </span>            :                 printf(&quot;[&quot; DRM_NAME &quot;:pid%d:%s] &quot; fmt,                      \
<span class="lineNum">     246 </span>            :                     curproc-&gt;p_p-&gt;ps_pid, __func__ , ## arg);             \
<span class="lineNum">     247 </span>            : } while (0)
<span class="lineNum">     248 </span>            : #else
<span class="lineNum">     249 </span>            : #define DRM_DEBUG_KMS(fmt, arg...) do { } while(/* CONSTCOND */ 0)
<span class="lineNum">     250 </span>            : #endif
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : #ifdef DRMDEBUG
<span class="lineNum">     253 </span>            : #undef DRM_LOG_KMS
<span class="lineNum">     254 </span>            : #define DRM_LOG_KMS(fmt, arg...) do {                                   \
<span class="lineNum">     255 </span>            :         if (drm_debug_flag)                                             \
<span class="lineNum">     256 </span>            :                 printf(fmt, ## arg);                                    \
<span class="lineNum">     257 </span>            : } while (0)
<span class="lineNum">     258 </span>            : #else
<span class="lineNum">     259 </span>            : #define DRM_LOG_KMS(fmt, arg...) do { } while(/* CONSTCOND */ 0)
<span class="lineNum">     260 </span>            : #endif
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : #ifdef DRMDEBUG
<span class="lineNum">     263 </span>            : #undef DRM_DEBUG_DRIVER
<span class="lineNum">     264 </span>            : #define DRM_DEBUG_DRIVER(fmt, arg...) do {                                      \
<span class="lineNum">     265 </span>            :         if (drm_debug_flag)                                             \
<span class="lineNum">     266 </span>            :                 printf(&quot;[&quot; DRM_NAME &quot;:pid%d:%s] &quot; fmt,                      \
<span class="lineNum">     267 </span>            :                     curproc-&gt;p_p-&gt;ps_pid, __func__ , ## arg);             \
<span class="lineNum">     268 </span>            : } while (0)
<span class="lineNum">     269 </span>            : #else
<span class="lineNum">     270 </span>            : #define DRM_DEBUG_DRIVER(fmt, arg...) do { } while(/* CONSTCOND */ 0)
<span class="lineNum">     271 </span>            : #endif
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : #ifdef DRMDEBUG
<span class="lineNum">     274 </span>            : #undef DRM_DEBUG_ATOMIC
<span class="lineNum">     275 </span>            : #define DRM_DEBUG_ATOMIC(fmt, arg...) do {                                      \
<span class="lineNum">     276 </span>            :         if (drm_debug_flag)                                             \
<span class="lineNum">     277 </span>            :                 printf(&quot;[&quot; DRM_NAME &quot;:pid%d:%s] &quot; fmt,                      \
<span class="lineNum">     278 </span>            :                     curproc-&gt;p_p-&gt;ps_pid, __func__ , ## arg);             \
<span class="lineNum">     279 </span>            : } while (0)
<span class="lineNum">     280 </span>            : #else
<span class="lineNum">     281 </span>            : #define DRM_DEBUG_ATOMIC(fmt, arg...) do { } while(0)
<span class="lineNum">     282 </span>            : #endif
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : #define DRM_DEBUG_VBL(fmt, arg...) do {} while(0)
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : struct drm_pcidev {
<span class="lineNum">     287 </span>            :         uint16_t vendor;
<span class="lineNum">     288 </span>            :         uint16_t device;
<span class="lineNum">     289 </span>            :         uint16_t subvendor;
<span class="lineNum">     290 </span>            :         uint16_t subdevice;
<span class="lineNum">     291 </span>            :         uint32_t class;
<span class="lineNum">     292 </span>            :         uint32_t class_mask;
<span class="lineNum">     293 </span>            :         unsigned long driver_data;
<span class="lineNum">     294 </span>            : };
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            : struct drm_file;
<span class="lineNum">     297 </span>            : struct drm_device;
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : /**
<span class="lineNum">     300 </span>            :  * Ioctl function type.
<span class="lineNum">     301 </span>            :  *
<span class="lineNum">     302 </span>            :  * \param inode device inode.
<span class="lineNum">     303 </span>            :  * \param file_priv DRM file private pointer.
<span class="lineNum">     304 </span>            :  * \param cmd command.
<span class="lineNum">     305 </span>            :  * \param arg argument.
<span class="lineNum">     306 </span>            :  */
<span class="lineNum">     307 </span>            : typedef int drm_ioctl_t(struct drm_device *dev, void *data,
<span class="lineNum">     308 </span>            :                         struct drm_file *file_priv);
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : typedef int drm_ioctl_compat_t(struct file *filp, unsigned int cmd,
<span class="lineNum">     311 </span>            :                                unsigned long arg);
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : #define DRM_AUTH        0x1
<span class="lineNum">     314 </span>            : #define DRM_MASTER      0x2
<span class="lineNum">     315 </span>            : #define DRM_ROOT_ONLY   0x4
<span class="lineNum">     316 </span>            : #define DRM_CONTROL_ALLOW 0x8
<span class="lineNum">     317 </span>            : #define DRM_UNLOCKED    0x10
<span class="lineNum">     318 </span>            : #define DRM_RENDER_ALLOW 0x20
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            : struct drm_ioctl_desc {
<span class="lineNum">     321 </span>            :         unsigned int cmd;
<span class="lineNum">     322 </span>            :         int flags;
<span class="lineNum">     323 </span>            :         drm_ioctl_t *func;
<span class="lineNum">     324 </span>            :         unsigned int cmd_drv;
<span class="lineNum">     325 </span>            : };
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : /**
<span class="lineNum">     328 </span>            :  * Creates a driver or general drm_ioctl_desc array entry for the given
<span class="lineNum">     329 </span>            :  * ioctl, for use by drm_ioctl().
<span class="lineNum">     330 </span>            :  */
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : #define DRM_IOCTL_DEF_DRV(ioctl, _func, _flags)                 \
<span class="lineNum">     333 </span>            :         [DRM_IOCTL_NR(DRM_##ioctl)] = {.cmd = DRM_##ioctl, .func = _func, .flags = _flags, .cmd_drv = DRM_IOCTL_##ioctl}
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            : struct drm_dmamem {
<span class="lineNum">     336 </span>            :         bus_dmamap_t            map;
<span class="lineNum">     337 </span>            :         caddr_t                 kva;
<span class="lineNum">     338 </span>            :         bus_size_t              size;
<span class="lineNum">     339 </span>            :         int                     nsegs;
<span class="lineNum">     340 </span>            :         bus_dma_segment_t       segs[1];
<span class="lineNum">     341 </span>            : };
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : typedef struct drm_dma_handle {
<span class="lineNum">     344 </span>            :         struct drm_dmamem *mem;
<span class="lineNum">     345 </span>            :         dma_addr_t busaddr;
<span class="lineNum">     346 </span>            :         void *vaddr;
<span class="lineNum">     347 </span>            :         size_t size;
<span class="lineNum">     348 </span>            : } drm_dma_handle_t;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : struct drm_pending_event {
<span class="lineNum">     351 </span>            :         struct drm_event *event;
<span class="lineNum">     352 </span>            :         struct list_head link;
<span class="lineNum">     353 </span>            :         struct drm_file *file_priv;
<span class="lineNum">     354 </span>            :         pid_t pid; /* pid of requester, no guarantee it's valid by the time
<span class="lineNum">     355 </span>            :                       we deliver the event, for tracing only */
<span class="lineNum">     356 </span>            :         void (*destroy)(struct drm_pending_event *event);
<span class="lineNum">     357 </span>            : };
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : /* initial implementaton using a linked list - todo hashtab */
<span class="lineNum">     360 </span>            : struct drm_prime_file_private {
<span class="lineNum">     361 </span>            :         struct list_head head;
<span class="lineNum">     362 </span>            :         struct rwlock lock;
<span class="lineNum">     363 </span>            : };
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : /** File private data */
<span class="lineNum">     366 </span>            : struct drm_file {
<span class="lineNum">     367 </span>            :         unsigned always_authenticated :1;
<span class="lineNum">     368 </span>            :         unsigned authenticated :1;
<span class="lineNum">     369 </span>            :         unsigned is_master :1; /* this file private is a master for a minor */
<span class="lineNum">     370 </span>            :         /* true when the client has asked us to expose stereo 3D mode flags */
<span class="lineNum">     371 </span>            :         unsigned stereo_allowed :1;
<span class="lineNum">     372 </span>            :         /*
<span class="lineNum">     373 </span>            :          * true if client understands CRTC primary planes and cursor planes
<span class="lineNum">     374 </span>            :          * in the plane list
<span class="lineNum">     375 </span>            :          */
<span class="lineNum">     376 </span>            :         unsigned universal_planes:1;
<span class="lineNum">     377 </span>            :         /* true if client understands atomic properties */
<span class="lineNum">     378 </span>            :         unsigned atomic:1;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :         drm_magic_t magic;
<span class="lineNum">     381 </span>            :         int minor;
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :         /** Mapping of mm object handles to object pointers. */
<span class="lineNum">     384 </span>            :         struct idr object_idr;
<span class="lineNum">     385 </span>            :         /** Lock for synchronization of access to object_idr. */
<span class="lineNum">     386 </span>            :         spinlock_t table_lock;
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :         struct file *filp;
<span class="lineNum">     389 </span>            :         void *driver_priv;
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :         /**
<span class="lineNum">     392 </span>            :          * fbs - List of framebuffers associated with this file.
<span class="lineNum">     393 </span>            :          *
<span class="lineNum">     394 </span>            :          * Protected by fbs_lock. Note that the fbs list holds a reference on
<span class="lineNum">     395 </span>            :          * the fb object to prevent it from untimely disappearing.
<span class="lineNum">     396 </span>            :          */
<span class="lineNum">     397 </span>            :         struct list_head fbs;
<span class="lineNum">     398 </span>            :         struct rwlock fbs_lock;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :         /** User-created blob properties; this retains a reference on the
<span class="lineNum">     401 </span>            :          *  property. */
<span class="lineNum">     402 </span>            :         struct list_head blobs;
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :         wait_queue_head_t event_wait;
<span class="lineNum">     405 </span>            :         struct list_head event_list;
<span class="lineNum">     406 </span>            :         int event_space;
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :         struct drm_prime_file_private prime;
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :         struct selinfo rsel;
<span class="lineNum">     411 </span>            :         SPLAY_ENTRY(drm_file) link;
<span class="lineNum">     412 </span>            : };
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : struct drm_agp_head {
<span class="lineNum">     415 </span>            :         struct agp_softc                        *agpdev;
<span class="lineNum">     416 </span>            :         const char                              *chipset;
<span class="lineNum">     417 </span>            :         TAILQ_HEAD(agp_memlist, drm_agp_mem)     memory;
<span class="lineNum">     418 </span>            :         struct agp_info                          info;
<span class="lineNum">     419 </span>            :         unsigned long                            base;
<span class="lineNum">     420 </span>            :         unsigned long                            mode;
<span class="lineNum">     421 </span>            :         unsigned long                            page_mask;
<span class="lineNum">     422 </span>            :         int                                      acquired;
<span class="lineNum">     423 </span>            :         int                                      cant_use_aperture;
<span class="lineNum">     424 </span>            :         int                                      enabled;
<span class="lineNum">     425 </span>            :         int                                      mtrr;
<span class="lineNum">     426 </span>            : };
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : /* location of GART table */
<span class="lineNum">     429 </span>            : #define DRM_ATI_GART_MAIN 1
<span class="lineNum">     430 </span>            : #define DRM_ATI_GART_FB   2
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : #define DRM_ATI_GART_PCI  1
<span class="lineNum">     433 </span>            : #define DRM_ATI_GART_PCIE 2
<span class="lineNum">     434 </span>            : #define DRM_ATI_GART_IGP  3
<span class="lineNum">     435 </span>            : #define DRM_ATI_GART_R600 4
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : /**
<span class="lineNum">     438 </span>            :  * This structure defines the drm_mm memory object, which will be used by the
<span class="lineNum">     439 </span>            :  * DRM for its buffer objects.
<span class="lineNum">     440 </span>            :  */
<span class="lineNum">     441 </span>            : struct drm_gem_object {
<span class="lineNum">     442 </span>            :         /** Reference count of this object */
<span class="lineNum">     443 </span>            :         struct kref refcount;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :         /**
<span class="lineNum">     446 </span>            :          * handle_count - gem file_priv handle count of this object
<span class="lineNum">     447 </span>            :          *
<span class="lineNum">     448 </span>            :          * Each handle also holds a reference. Note that when the handle_count
<span class="lineNum">     449 </span>            :          * drops to 0 any global names (e.g. the id in the flink namespace) will
<span class="lineNum">     450 </span>            :          * be cleared.
<span class="lineNum">     451 </span>            :          *
<span class="lineNum">     452 </span>            :          * Protected by dev-&gt;object_name_lock.
<span class="lineNum">     453 </span>            :          * */
<span class="lineNum">     454 </span>            :         unsigned handle_count;
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :         /** Related drm device */
<span class="lineNum">     457 </span>            :         struct drm_device *dev;
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :         /** File representing the shmem storage */
<span class="lineNum">     460 </span>            :         struct file *filp;
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :         /* Mapping info for this object */
<span class="lineNum">     463 </span>            :         struct drm_vma_offset_node vma_node;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :         /**
<span class="lineNum">     466 </span>            :          * Size of the object, in bytes.  Immutable over the object's
<span class="lineNum">     467 </span>            :          * lifetime.
<span class="lineNum">     468 </span>            :          */
<span class="lineNum">     469 </span>            :         size_t size;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :         /**
<span class="lineNum">     472 </span>            :          * Global name for this object, starts at 1. 0 means unnamed.
<span class="lineNum">     473 </span>            :          * Access is covered by the object_name_lock in the related drm_device
<span class="lineNum">     474 </span>            :          */
<span class="lineNum">     475 </span>            :         int name;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :         /**
<span class="lineNum">     478 </span>            :          * Memory domains. These monitor which caches contain read/write data
<span class="lineNum">     479 </span>            :          * related to the object. When transitioning from one set of domains
<span class="lineNum">     480 </span>            :          * to another, the driver is called to ensure that caches are suitably
<span class="lineNum">     481 </span>            :          * flushed and invalidated
<span class="lineNum">     482 </span>            :          */
<span class="lineNum">     483 </span>            :         uint32_t read_domains;
<span class="lineNum">     484 </span>            :         uint32_t write_domain;
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :         /**
<span class="lineNum">     487 </span>            :          * While validating an exec operation, the
<span class="lineNum">     488 </span>            :          * new read/write domain values are computed here.
<span class="lineNum">     489 </span>            :          * They will be transferred to the above values
<span class="lineNum">     490 </span>            :          * at the point that any cache flushing occurs
<span class="lineNum">     491 </span>            :          */
<span class="lineNum">     492 </span>            :         uint32_t pending_read_domains;
<span class="lineNum">     493 </span>            :         uint32_t pending_write_domain;
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :         /**
<span class="lineNum">     496 </span>            :          * dma_buf - dma buf associated with this GEM object
<span class="lineNum">     497 </span>            :          *
<span class="lineNum">     498 </span>            :          * Pointer to the dma-buf associated with this gem object (either
<span class="lineNum">     499 </span>            :          * through importing or exporting). We break the resulting reference
<span class="lineNum">     500 </span>            :          * loop when the last gem handle for this object is released.
<span class="lineNum">     501 </span>            :          *
<span class="lineNum">     502 </span>            :          * Protected by obj-&gt;object_name_lock
<span class="lineNum">     503 </span>            :          */
<span class="lineNum">     504 </span>            :         struct dma_buf *dma_buf;
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :         /**
<span class="lineNum">     507 </span>            :          * import_attach - dma buf attachment backing this object
<span class="lineNum">     508 </span>            :          *
<span class="lineNum">     509 </span>            :          * Any foreign dma_buf imported as a gem object has this set to the
<span class="lineNum">     510 </span>            :          * attachment point for the device. This is invariant over the lifetime
<span class="lineNum">     511 </span>            :          * of a gem object.
<span class="lineNum">     512 </span>            :          *
<span class="lineNum">     513 </span>            :          * The driver's -&gt;gem_free_object callback is responsible for cleaning
<span class="lineNum">     514 </span>            :          * up the dma_buf attachment and references acquired at import time.
<span class="lineNum">     515 </span>            :          *
<span class="lineNum">     516 </span>            :          * Note that the drm gem/prime core does not depend upon drivers setting
<span class="lineNum">     517 </span>            :          * this field any more. So for drivers where this doesn't make sense
<span class="lineNum">     518 </span>            :          * (e.g. virtual devices or a displaylink behind an usb bus) they can
<span class="lineNum">     519 </span>            :          * simply leave it as NULL.
<span class="lineNum">     520 </span>            :          */
<span class="lineNum">     521 </span>            :         struct dma_buf_attachment *import_attach;
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :         struct uvm_object uobj;
<span class="lineNum">     524 </span>            :         SPLAY_ENTRY(drm_gem_object) entry;
<span class="lineNum">     525 </span>            :         struct uvm_object *uao;
<span class="lineNum">     526 </span>            : };
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : /* Size of ringbuffer for vblank timestamps. Just double-buffer
<span class="lineNum">     529 </span>            :  * in initial implementation.
<span class="lineNum">     530 </span>            :  */
<span class="lineNum">     531 </span>            : #define DRM_VBLANKTIME_RBSIZE 2
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : /* Flags and return codes for get_vblank_timestamp() driver function. */
<span class="lineNum">     534 </span>            : #define DRM_CALLED_FROM_VBLIRQ 1
<span class="lineNum">     535 </span>            : #define DRM_VBLANKTIME_SCANOUTPOS_METHOD (1 &lt;&lt; 0)
<span class="lineNum">     536 </span>            : #define DRM_VBLANKTIME_IN_VBLANK         (1 &lt;&lt; 1)
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : /* get_scanout_position() return flags */
<span class="lineNum">     539 </span>            : #define DRM_SCANOUTPOS_VALID        (1 &lt;&lt; 0)
<span class="lineNum">     540 </span>            : #define DRM_SCANOUTPOS_IN_VBLANK    (1 &lt;&lt; 1)
<span class="lineNum">     541 </span>            : #define DRM_SCANOUTPOS_ACCURATE     (1 &lt;&lt; 2)
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : struct drm_driver {
<span class="lineNum">     544 </span>            :         int     (*firstopen)(struct drm_device *);
<span class="lineNum">     545 </span>            :         int     (*open)(struct drm_device *, struct drm_file *);
<span class="lineNum">     546 </span>            :         void    (*close)(struct drm_device *, struct drm_file *);
<span class="lineNum">     547 </span>            :         void    (*preclose)(struct drm_device *, struct drm_file *);
<span class="lineNum">     548 </span>            :         void    (*postclose)(struct drm_device *, struct drm_file *);
<span class="lineNum">     549 </span>            :         void    (*lastclose)(struct drm_device *);
<span class="lineNum">     550 </span>            :         struct uvm_object *(*mmap)(struct drm_device *, voff_t, vsize_t);
<span class="lineNum">     551 </span>            :         int     (*dma_ioctl)(struct drm_device *, struct drm_dma *,
<span class="lineNum">     552 </span>            :                     struct drm_file *);
<span class="lineNum">     553 </span>            :         int     (*irq_handler)(int, void *);
<span class="lineNum">     554 </span>            :         void    (*irq_preinstall) (struct drm_device *);
<span class="lineNum">     555 </span>            :         int     (*irq_install)(struct drm_device *);
<span class="lineNum">     556 </span>            :         int     (*irq_postinstall) (struct drm_device *);
<span class="lineNum">     557 </span>            :         void    (*irq_uninstall)(struct drm_device *);
<span class="lineNum">     558 </span>            :         int     vblank_pipes;
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :         /**
<span class="lineNum">     561 </span>            :          * get_vblank_counter - get raw hardware vblank counter
<span class="lineNum">     562 </span>            :          * @dev: DRM device
<span class="lineNum">     563 </span>            :          * @pipe: counter to fetch
<span class="lineNum">     564 </span>            :          *
<span class="lineNum">     565 </span>            :          * Driver callback for fetching a raw hardware vblank counter for @crtc.
<span class="lineNum">     566 </span>            :          * If a device doesn't have a hardware counter, the driver can simply
<span class="lineNum">     567 </span>            :          * return the value of drm_vblank_count. The DRM core will account for
<span class="lineNum">     568 </span>            :          * missed vblank events while interrupts where disabled based on system
<span class="lineNum">     569 </span>            :          * timestamps.
<span class="lineNum">     570 </span>            :          *
<span class="lineNum">     571 </span>            :          * Wraparound handling and loss of events due to modesetting is dealt
<span class="lineNum">     572 </span>            :          * with in the DRM core code.
<span class="lineNum">     573 </span>            :          *
<span class="lineNum">     574 </span>            :          * RETURNS
<span class="lineNum">     575 </span>            :          * Raw vblank counter value.
<span class="lineNum">     576 </span>            :          */
<span class="lineNum">     577 </span>            :         u32 (*get_vblank_counter) (struct drm_device *dev, unsigned int pipe);
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :         /**
<span class="lineNum">     580 </span>            :          * enable_vblank - enable vblank interrupt events
<span class="lineNum">     581 </span>            :          * @dev: DRM device
<span class="lineNum">     582 </span>            :          * @pipe: which irq to enable
<span class="lineNum">     583 </span>            :          *
<span class="lineNum">     584 </span>            :          * Enable vblank interrupts for @crtc.  If the device doesn't have
<span class="lineNum">     585 </span>            :          * a hardware vblank counter, this routine should be a no-op, since
<span class="lineNum">     586 </span>            :          * interrupts will have to stay on to keep the count accurate.
<span class="lineNum">     587 </span>            :          *
<span class="lineNum">     588 </span>            :          * RETURNS
<span class="lineNum">     589 </span>            :          * Zero on success, appropriate errno if the given @crtc's vblank
<span class="lineNum">     590 </span>            :          * interrupt cannot be enabled.
<span class="lineNum">     591 </span>            :          */
<span class="lineNum">     592 </span>            :         int (*enable_vblank) (struct drm_device *dev, unsigned int pipe);
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :         /**
<span class="lineNum">     595 </span>            :          * disable_vblank - disable vblank interrupt events
<span class="lineNum">     596 </span>            :          * @dev: DRM device
<span class="lineNum">     597 </span>            :          * @pipe: which irq to enable
<span class="lineNum">     598 </span>            :          *
<span class="lineNum">     599 </span>            :          * Disable vblank interrupts for @crtc.  If the device doesn't have
<span class="lineNum">     600 </span>            :          * a hardware vblank counter, this routine should be a no-op, since
<span class="lineNum">     601 </span>            :          * interrupts will have to stay on to keep the count accurate.
<span class="lineNum">     602 </span>            :          */
<span class="lineNum">     603 </span>            :         void (*disable_vblank) (struct drm_device *dev, unsigned int pipe);
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :         /**
<span class="lineNum">     606 </span>            :          * Called by vblank timestamping code.
<span class="lineNum">     607 </span>            :          *
<span class="lineNum">     608 </span>            :          * Return the current display scanout position from a crtc, and an
<span class="lineNum">     609 </span>            :          * optional accurate ktime_get timestamp of when position was measured.
<span class="lineNum">     610 </span>            :          *
<span class="lineNum">     611 </span>            :          * \param dev  DRM device.
<span class="lineNum">     612 </span>            :          * \param pipe Id of the crtc to query.
<span class="lineNum">     613 </span>            :          * \param flags Flags from the caller (DRM_CALLED_FROM_VBLIRQ or 0).
<span class="lineNum">     614 </span>            :          * \param *vpos Target location for current vertical scanout position.
<span class="lineNum">     615 </span>            :          * \param *hpos Target location for current horizontal scanout position.
<span class="lineNum">     616 </span>            :          * \param *stime Target location for timestamp taken immediately before
<span class="lineNum">     617 </span>            :          *               scanout position query. Can be NULL to skip timestamp.
<span class="lineNum">     618 </span>            :          * \param *etime Target location for timestamp taken immediately after
<span class="lineNum">     619 </span>            :          *               scanout position query. Can be NULL to skip timestamp.
<span class="lineNum">     620 </span>            :          * \param mode Current display timings.
<span class="lineNum">     621 </span>            :          *
<span class="lineNum">     622 </span>            :          * Returns vpos as a positive number while in active scanout area.
<span class="lineNum">     623 </span>            :          * Returns vpos as a negative number inside vblank, counting the number
<span class="lineNum">     624 </span>            :          * of scanlines to go until end of vblank, e.g., -1 means &quot;one scanline
<span class="lineNum">     625 </span>            :          * until start of active scanout / end of vblank.&quot;
<span class="lineNum">     626 </span>            :          *
<span class="lineNum">     627 </span>            :          * \return Flags, or'ed together as follows:
<span class="lineNum">     628 </span>            :          *
<span class="lineNum">     629 </span>            :          * DRM_SCANOUTPOS_VALID = Query successful.
<span class="lineNum">     630 </span>            :          * DRM_SCANOUTPOS_INVBL = Inside vblank.
<span class="lineNum">     631 </span>            :          * DRM_SCANOUTPOS_ACCURATE = Returned position is accurate. A lack of
<span class="lineNum">     632 </span>            :          * this flag means that returned position may be offset by a constant
<span class="lineNum">     633 </span>            :          * but unknown small number of scanlines wrt. real scanout position.
<span class="lineNum">     634 </span>            :          *
<span class="lineNum">     635 </span>            :          */
<span class="lineNum">     636 </span>            :         int (*get_scanout_position) (struct drm_device *dev, unsigned int pipe,
<span class="lineNum">     637 </span>            :                                      unsigned int flags, int *vpos, int *hpos,
<span class="lineNum">     638 </span>            :                                      ktime_t *stime, ktime_t *etime,
<span class="lineNum">     639 </span>            :                                      const struct drm_display_mode *mode);
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :         /**
<span class="lineNum">     642 </span>            :          * Called by \c drm_get_last_vbltimestamp. Should return a precise
<span class="lineNum">     643 </span>            :          * timestamp when the most recent VBLANK interval ended or will end.
<span class="lineNum">     644 </span>            :          *
<span class="lineNum">     645 </span>            :          * Specifically, the timestamp in @vblank_time should correspond as
<span class="lineNum">     646 </span>            :          * closely as possible to the time when the first video scanline of
<span class="lineNum">     647 </span>            :          * the video frame after the end of VBLANK will start scanning out,
<span class="lineNum">     648 </span>            :          * the time immediately after end of the VBLANK interval. If the
<span class="lineNum">     649 </span>            :          * @crtc is currently inside VBLANK, this will be a time in the future.
<span class="lineNum">     650 </span>            :          * If the @crtc is currently scanning out a frame, this will be the
<span class="lineNum">     651 </span>            :          * past start time of the current scanout. This is meant to adhere
<span class="lineNum">     652 </span>            :          * to the OpenML OML_sync_control extension specification.
<span class="lineNum">     653 </span>            :          *
<span class="lineNum">     654 </span>            :          * \param dev dev DRM device handle.
<span class="lineNum">     655 </span>            :          * \param pipe crtc for which timestamp should be returned.
<span class="lineNum">     656 </span>            :          * \param *max_error Maximum allowable timestamp error in nanoseconds.
<span class="lineNum">     657 </span>            :          *                   Implementation should strive to provide timestamp
<span class="lineNum">     658 </span>            :          *                   with an error of at most *max_error nanoseconds.
<span class="lineNum">     659 </span>            :          *                   Returns true upper bound on error for timestamp.
<span class="lineNum">     660 </span>            :          * \param *vblank_time Target location for returned vblank timestamp.
<span class="lineNum">     661 </span>            :          * \param flags 0 = Defaults, no special treatment needed.
<span class="lineNum">     662 </span>            :          * \param       DRM_CALLED_FROM_VBLIRQ = Function is called from vblank
<span class="lineNum">     663 </span>            :          *              irq handler. Some drivers need to apply some workarounds
<span class="lineNum">     664 </span>            :          *              for gpu-specific vblank irq quirks if flag is set.
<span class="lineNum">     665 </span>            :          *
<span class="lineNum">     666 </span>            :          * \returns
<span class="lineNum">     667 </span>            :          * Zero if timestamping isn't supported in current display mode or a
<span class="lineNum">     668 </span>            :          * negative number on failure. A positive status code on success,
<span class="lineNum">     669 </span>            :          * which describes how the vblank_time timestamp was computed.
<span class="lineNum">     670 </span>            :          */
<span class="lineNum">     671 </span>            :         int (*get_vblank_timestamp) (struct drm_device *dev, unsigned int pipe,
<span class="lineNum">     672 </span>            :                                      int *max_error,
<span class="lineNum">     673 </span>            :                                      struct timeval *vblank_time,
<span class="lineNum">     674 </span>            :                                      unsigned flags);
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :         /**
<span class="lineNum">     677 </span>            :          * Driver-specific constructor for drm_gem_objects, to set up
<span class="lineNum">     678 </span>            :          * obj-&gt;driver_private.
<span class="lineNum">     679 </span>            :          *
<span class="lineNum">     680 </span>            :          * Returns 0 on success.
<span class="lineNum">     681 </span>            :          */
<span class="lineNum">     682 </span>            :         void (*gem_free_object) (struct drm_gem_object *obj);
<span class="lineNum">     683 </span>            :         int (*gem_open_object) (struct drm_gem_object *, struct drm_file *);
<span class="lineNum">     684 </span>            :         void (*gem_close_object) (struct drm_gem_object *, struct drm_file *);
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :         int     (*gem_fault)(struct drm_gem_object *, struct uvm_faultinfo *,
<span class="lineNum">     687 </span>            :                     off_t, vaddr_t, vm_page_t *, int, int, vm_prot_t, int);
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :         /* prime: */
<span class="lineNum">     690 </span>            :         /* export handle -&gt; fd (see drm_gem_prime_handle_to_fd() helper) */
<span class="lineNum">     691 </span>            :         int (*prime_handle_to_fd)(struct drm_device *dev, struct drm_file *file_priv,
<span class="lineNum">     692 </span>            :                                 uint32_t handle, uint32_t flags, int *prime_fd);
<span class="lineNum">     693 </span>            :         /* import fd -&gt; handle (see drm_gem_prime_fd_to_handle() helper) */
<span class="lineNum">     694 </span>            :         int (*prime_fd_to_handle)(struct drm_device *dev, struct drm_file *file_priv,
<span class="lineNum">     695 </span>            :                                 int prime_fd, uint32_t *handle);
<span class="lineNum">     696 </span>            :         /* export GEM -&gt; dmabuf */
<span class="lineNum">     697 </span>            :         struct dma_buf * (*gem_prime_export)(struct drm_device *dev,
<span class="lineNum">     698 </span>            :                                 struct drm_gem_object *obj, int flags);
<span class="lineNum">     699 </span>            :         /* import dmabuf -&gt; GEM */
<span class="lineNum">     700 </span>            :         struct drm_gem_object * (*gem_prime_import)(struct drm_device *dev,
<span class="lineNum">     701 </span>            :                                 struct dma_buf *dma_buf);
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :         int     (*dumb_create)(struct drm_file *file_priv,
<span class="lineNum">     704 </span>            :                     struct drm_device *dev, struct drm_mode_create_dumb *args);
<span class="lineNum">     705 </span>            :         int     (*dumb_map_offset)(struct drm_file *file_priv,
<span class="lineNum">     706 </span>            :                     struct drm_device *dev, uint32_t handle, uint64_t *offset);
<span class="lineNum">     707 </span>            :         int     (*dumb_destroy)(struct drm_file *file_priv,
<span class="lineNum">     708 </span>            :                     struct drm_device *dev, uint32_t handle);
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :         size_t  gem_size;
<span class="lineNum">     711 </span>            :         size_t  buf_priv_size;
<span class="lineNum">     712 </span>            :         size_t  file_priv_size;
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :         int     major;
<span class="lineNum">     715 </span>            :         int     minor;
<span class="lineNum">     716 </span>            :         int     patchlevel;
<span class="lineNum">     717 </span>            :         const char *name;               /* Simple driver name              */
<span class="lineNum">     718 </span>            :         const char *desc;               /* Longer driver name              */
<span class="lineNum">     719 </span>            :         const char *date;               /* Date of last major changes.     */
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            :         u32 driver_features;
<span class="lineNum">     722 </span>            :         const struct drm_ioctl_desc *ioctls;
<span class="lineNum">     723 </span>            :         int num_ioctls;
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : };
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : enum drm_minor_type {
<span class="lineNum">     728 </span>            :         DRM_MINOR_LEGACY,
<span class="lineNum">     729 </span>            :         DRM_MINOR_CONTROL,
<span class="lineNum">     730 </span>            :         DRM_MINOR_RENDER,
<span class="lineNum">     731 </span>            :         DRM_MINOR_CNT,
<span class="lineNum">     732 </span>            : };
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            : #include &quot;drm_crtc.h&quot;
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            : #if 0
<span class="lineNum">     737 </span>            : /* mode specified on the command line */
<span class="lineNum">     738 </span>            : struct drm_cmdline_mode {
<span class="lineNum">     739 </span>            :         bool specified;
<span class="lineNum">     740 </span>            :         bool refresh_specified;
<span class="lineNum">     741 </span>            :         bool bpp_specified;
<span class="lineNum">     742 </span>            :         int xres, yres;
<span class="lineNum">     743 </span>            :         int bpp;
<span class="lineNum">     744 </span>            :         int refresh;
<span class="lineNum">     745 </span>            :         bool rb;
<span class="lineNum">     746 </span>            :         bool interlace;
<span class="lineNum">     747 </span>            :         bool cvt;
<span class="lineNum">     748 </span>            :         bool margins;
<span class="lineNum">     749 </span>            :         enum drm_connector_force force;
<span class="lineNum">     750 </span>            : };
<span class="lineNum">     751 </span>            : #endif
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : struct drm_minor;
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : struct drm_pending_vblank_event {
<span class="lineNum">     756 </span>            :         struct drm_pending_event base;
<span class="lineNum">     757 </span>            :         int pipe;
<span class="lineNum">     758 </span>            :         struct drm_event_vblank event;
<span class="lineNum">     759 </span>            : };
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            : struct drm_vblank_crtc {
<span class="lineNum">     762 </span>            :         struct drm_device *dev;         /* pointer to the drm_device */
<span class="lineNum">     763 </span>            :         wait_queue_head_t queue;        /**&lt; VBLANK wait queue */
<span class="lineNum">     764 </span>            :         struct timeout disable_timer;           /* delayed disable timer */
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :         /* vblank counter, protected by dev-&gt;vblank_time_lock for writes */
<span class="lineNum">     767 </span>            :         u32 count;
<span class="lineNum">     768 </span>            :         /* vblank timestamps, protected by dev-&gt;vblank_time_lock for writes */
<span class="lineNum">     769 </span>            :         struct timeval time[DRM_VBLANKTIME_RBSIZE];
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :         atomic_t refcount;              /* number of users of vblank interruptsper crtc */
<span class="lineNum">     772 </span>            :         u32 last;                       /* protected by dev-&gt;vbl_lock, used */
<span class="lineNum">     773 </span>            :                                         /* for wraparound handling */
<span class="lineNum">     774 </span>            :         u32 last_wait;                  /* Last vblank seqno waited per CRTC */
<span class="lineNum">     775 </span>            :         unsigned int inmodeset;         /* Display driver is setting mode */
<span class="lineNum">     776 </span>            :         unsigned int pipe;              /* crtc index */
<span class="lineNum">     777 </span>            :         int framedur_ns;                /* frame/field duration in ns */
<span class="lineNum">     778 </span>            :         int linedur_ns;                 /* line duration in ns */
<span class="lineNum">     779 </span>            :         bool enabled;                   /* so we don't call enable more than
<span class="lineNum">     780 </span>            :                                            once per disable */
<span class="lineNum">     781 </span>            : };
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : /** 
<span class="lineNum">     784 </span>            :  * DRM device functions structure
<span class="lineNum">     785 </span>            :  */
<span class="lineNum">     786 </span>            : struct drm_device {
<span class="lineNum">     787 </span>            :         struct device    device; /* softc is an extension of struct device */
<span class="lineNum">     788 </span>            :         struct device   *dev;
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :         struct drm_driver *driver;
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :         struct klist     note;
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :         struct pci_dev  _pdev;
<span class="lineNum">     795 </span>            :         struct pci_dev  *pdev;
<span class="lineNum">     796 </span>            :         u_int16_t        pci_device;
<span class="lineNum">     797 </span>            :         u_int16_t        pci_vendor;
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :         pci_chipset_tag_t                pc;
<span class="lineNum">     800 </span>            :         pcitag_t                        *bridgetag;
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :         bus_dma_tag_t                   dmat;
<span class="lineNum">     803 </span>            :         bus_space_tag_t                 bst;
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :         struct mutex    quiesce_mtx;
<span class="lineNum">     806 </span>            :         int             quiesce;
<span class="lineNum">     807 </span>            :         int             quiesce_count;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :         char              *unique;      /* Unique identifier: e.g., busid  */
<span class="lineNum">     810 </span>            :         int               unique_len;   /* Length of unique field          */
<span class="lineNum">     811 </span>            :         
<span class="lineNum">     812 </span>            :         int               if_version;   /* Highest interface version set */
<span class="lineNum">     813 </span>            :                                 /* Locks */
<span class="lineNum">     814 </span>            :         struct rwlock     struct_mutex; /* protects everything else */
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :                                 /* Usage Counters */
<span class="lineNum">     817 </span>            :         int               open_count;   /* Outstanding files open          */
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :                                 /* Authentication */
<span class="lineNum">     820 </span>            :         SPLAY_HEAD(drm_file_tree, drm_file)     files;
<span class="lineNum">     821 </span>            :         drm_magic_t       magicid;
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :                                 /* Context support */
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :         /** \name VBLANK IRQ support */
<span class="lineNum">     826 </span>            :         /*@{ */
<span class="lineNum">     827 </span>            :         bool irq_enabled;
<span class="lineNum">     828 </span>            :         int irq;
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            :         /*
<span class="lineNum">     831 </span>            :          * At load time, disabling the vblank interrupt won't be allowed since
<span class="lineNum">     832 </span>            :          * old clients may not call the modeset ioctl and therefore misbehave.
<span class="lineNum">     833 </span>            :          * Once the modeset ioctl *has* been called though, we can safely
<span class="lineNum">     834 </span>            :          * disable them when unused.
<span class="lineNum">     835 </span>            :          */
<span class="lineNum">     836 </span>            :         bool vblank_disable_allowed;
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :         /*
<span class="lineNum">     839 </span>            :          * If true, vblank interrupt will be disabled immediately when the
<span class="lineNum">     840 </span>            :          * refcount drops to zero, as opposed to via the vblank disable
<span class="lineNum">     841 </span>            :          * timer.
<span class="lineNum">     842 </span>            :          * This can be set to true it the hardware has a working vblank
<span class="lineNum">     843 </span>            :          * counter and the driver uses drm_vblank_on() and drm_vblank_off()
<span class="lineNum">     844 </span>            :          * appropriately.
<span class="lineNum">     845 </span>            :          */
<span class="lineNum">     846 </span>            :         bool vblank_disable_immediate;
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :         /* array of size num_crtcs */
<span class="lineNum">     849 </span>            :         struct drm_vblank_crtc *vblank;
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :         struct mutex vblank_time_lock;    /**&lt; Protects vblank count and time updates during vblank enable/disable */
<span class="lineNum">     852 </span>            :         struct mutex vbl_lock;
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :         u32 max_vblank_count;           /**&lt; size of vblank counter register */
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :         /**
<span class="lineNum">     857 </span>            :          * List of events
<span class="lineNum">     858 </span>            :          */
<span class="lineNum">     859 </span>            :         struct list_head vblank_event_list;
<span class="lineNum">     860 </span>            :         spinlock_t event_lock;
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            :         /*@} */
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :         int                     *vblank_enabled;
<span class="lineNum">     865 </span>            :         int                     *vblank_inmodeset;
<span class="lineNum">     866 </span>            :         u32                     *last_vblank_wait;
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :         int                      num_crtcs;
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :         pid_t                    buf_pgid;
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :         struct drm_agp_head     *agp;
<span class="lineNum">     873 </span>            :         void                    *dev_private;
<span class="lineNum">     874 </span>            :         struct address_space    *dev_mapping;
<span class="lineNum">     875 </span>            :         struct drm_local_map    *agp_buffer_map;
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            :         struct drm_mode_config   mode_config; /* Current mode config */
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            :         /* GEM info */
<span class="lineNum">     880 </span>            :         atomic_t                 obj_count;
<span class="lineNum">     881 </span>            :         u_int                    obj_name;
<span class="lineNum">     882 </span>            :         atomic_t                 obj_memory;
<span class="lineNum">     883 </span>            :         struct pool                             objpl;
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :         /** \name GEM information */
<span class="lineNum">     886 </span>            :         /*@{ */
<span class="lineNum">     887 </span>            :         struct rwlock object_name_lock;
<span class="lineNum">     888 </span>            :         struct idr object_name_idr;
<span class="lineNum">     889 </span>            :         struct drm_vma_offset_manager *vma_offset_manager;
<span class="lineNum">     890 </span>            :         /*@} */
<span class="lineNum">     891 </span>            : };
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span>            : struct drm_attach_args {
<span class="lineNum">     894 </span>            :         struct drm_driver               *driver;
<span class="lineNum">     895 </span>            :         char                            *busid;
<span class="lineNum">     896 </span>            :         bus_dma_tag_t                    dmat;
<span class="lineNum">     897 </span>            :         bus_space_tag_t                  bst;
<span class="lineNum">     898 </span>            :         size_t                           busid_len;
<span class="lineNum">     899 </span>            :         int                              is_agp;
<span class="lineNum">     900 </span>            :         u_int16_t                        pci_vendor;
<span class="lineNum">     901 </span>            :         u_int16_t                        pci_device;
<span class="lineNum">     902 </span>            :         u_int16_t                        pci_subvendor;
<span class="lineNum">     903 </span>            :         u_int16_t                        pci_subdevice;
<span class="lineNum">     904 </span>            :         u_int8_t                         pci_revision;
<span class="lineNum">     905 </span>            :         struct pci_attach_args          *pa;
<span class="lineNum">     906 </span>            :         pci_chipset_tag_t                pc;
<span class="lineNum">     907 </span>            :         pcitag_t                         tag;
<span class="lineNum">     908 </span>            :         pcitag_t                        *bridgetag;
<span class="lineNum">     909 </span>            :         int                              console;
<span class="lineNum">     910 </span>            : };
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            : #define DRMDEVCF_CONSOLE        0
<span class="lineNum">     913 </span>            : #define drmdevcf_console        cf_loc[DRMDEVCF_CONSOLE]
<span class="lineNum">     914 </span>            : /* spec'd as console? */
<span class="lineNum">     915 </span>            : #define DRMDEVCF_CONSOLE_UNK    -1
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            : extern int      drm_debug_flag;
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : /* Device setup support (drm_drv.c) */
<span class="lineNum">     920 </span>            : int     drm_pciprobe(struct pci_attach_args *, const struct drm_pcidev * );
<span class="lineNum">     921 </span>            : struct device   *drm_attach_pci(struct drm_driver *, 
<span class="lineNum">     922 </span>            :                      struct pci_attach_args *, int, int, struct device *);
<span class="lineNum">     923 </span>            : dev_type_ioctl(drmioctl);
<span class="lineNum">     924 </span>            : dev_type_read(drmread);
<span class="lineNum">     925 </span>            : dev_type_poll(drmpoll);
<span class="lineNum">     926 </span>            : dev_type_open(drmopen);
<span class="lineNum">     927 </span>            : dev_type_close(drmclose);
<span class="lineNum">     928 </span>            : dev_type_mmap(drmmmap);
<span class="lineNum">     929 </span>            : struct drm_local_map    *drm_getsarea(struct drm_device *);
<span class="lineNum">     930 </span>            : struct drm_dmamem       *drm_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
<span class="lineNum">     931 </span>            :                              int, bus_size_t, int, int);
<span class="lineNum">     932 </span>            : void                     drm_dmamem_free(bus_dma_tag_t, struct drm_dmamem *);
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : extern struct drm_dma_handle *drm_pci_alloc(struct drm_device *dev, size_t size,
<span class="lineNum">     935 </span>            :                                             size_t align);
<span class="lineNum">     936 </span>            : extern void drm_pci_free(struct drm_device *dev, struct drm_dma_handle * dmah);
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            : const struct drm_pcidev *drm_find_description(int , int ,
<span class="lineNum">     939 </span>            :                              const struct drm_pcidev *);
<span class="lineNum">     940 </span>            : int      drm_order(unsigned long);
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            : /* File operations helpers (drm_fops.c) */
<span class="lineNum">     943 </span>            : struct drm_file *drm_find_file_by_minor(struct drm_device *, int);
<span class="lineNum">     944 </span>            : struct drm_device *drm_get_device_from_kdev(dev_t);
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : /* Memory management support (drm_memory.c) */
<span class="lineNum">     947 </span>            : void    *drm_alloc(size_t);
<span class="lineNum">     948 </span>            : void    *drm_calloc(size_t, size_t);
<span class="lineNum">     949 </span>            : void    *drm_realloc(void *, size_t, size_t);
<span class="lineNum">     950 </span>            : void     drm_free(void *);
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            : #include &quot;drm_mem_util.h&quot;
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            : /* XXX until we get PAT support */
<span class="lineNum">     955 </span>            : #define drm_core_ioremap_wc drm_core_ioremap
<span class="lineNum">     956 </span>            : void    drm_core_ioremap(struct drm_local_map *, struct drm_device *);
<span class="lineNum">     957 </span>            : void    drm_core_ioremapfree(struct drm_local_map *, struct drm_device *);
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : int     drm_mtrr_add(unsigned long, size_t, int);
<span class="lineNum">     960 </span>            : int     drm_mtrr_del(int, unsigned long, size_t, int);
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            : /* Misc. IOCTL support (drm_ioctl.c) */
<span class="lineNum">     963 </span>            : int drm_noop(struct drm_device *dev, void *data,
<span class="lineNum">     964 </span>            :              struct drm_file *file_priv);
<span class="lineNum">     965 </span>            : int drm_invalid_op(struct drm_device *dev, void *data,
<span class="lineNum">     966 </span>            :                    struct drm_file *file_priv);
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            : /* Cache management (drm_cache.c) */
<span class="lineNum">     969 </span>            : void drm_clflush_pages(struct vm_page *pages[], unsigned long num_pages);
<span class="lineNum">     970 </span>            : void drm_clflush_sg(struct sg_table *st);
<span class="lineNum">     971 </span>            : void drm_clflush_virt_range(void *addr, unsigned long length);
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            : /*
<span class="lineNum">     974 </span>            :  * These are exported to drivers so that they can implement fencing using
<span class="lineNum">     975 </span>            :  * DMA quiscent + idle. DMA quiescent usually requires the hardware lock.
<span class="lineNum">     976 </span>            :  */
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :                                 /* IRQ support (drm_irq.h) */
<span class="lineNum">     979 </span>            : extern int drm_irq_install(struct drm_device *dev, int irq);
<span class="lineNum">     980 </span>            : extern int drm_irq_uninstall(struct drm_device *dev);
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            : extern int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
<span class="lineNum">     983 </span>            : extern int drm_wait_vblank(struct drm_device *dev, void *data,
<span class="lineNum">     984 </span>            :                            struct drm_file *filp);
<span class="lineNum">     985 </span>            : extern u32 drm_vblank_count(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">     986 </span>            : extern u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
<span class="lineNum">     987 </span>            : extern u32 drm_vblank_count_and_time(struct drm_device *dev, unsigned int pipe,
<span class="lineNum">     988 </span>            :                                      struct timeval *vblanktime);
<span class="lineNum">     989 </span>            : extern u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
<span class="lineNum">     990 </span>            :                                           struct timeval *vblanktime);
<span class="lineNum">     991 </span>            : extern void drm_send_vblank_event(struct drm_device *dev, unsigned int pipe,
<span class="lineNum">     992 </span>            :                                   struct drm_pending_vblank_event *e);
<span class="lineNum">     993 </span>            : extern void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
<span class="lineNum">     994 </span>            :                                        struct drm_pending_vblank_event *e);
<span class="lineNum">     995 </span>            : extern void drm_arm_vblank_event(struct drm_device *dev, unsigned int pipe,
<span class="lineNum">     996 </span>            :                                  struct drm_pending_vblank_event *e);
<span class="lineNum">     997 </span>            : extern void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
<span class="lineNum">     998 </span>            :                                       struct drm_pending_vblank_event *e);
<span class="lineNum">     999 </span>            : extern bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1000 </span>            : extern bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
<span class="lineNum">    1001 </span>            : extern int drm_vblank_get(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1002 </span>            : extern void drm_vblank_put(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1003 </span>            : extern int drm_crtc_vblank_get(struct drm_crtc *crtc);
<span class="lineNum">    1004 </span>            : extern void drm_crtc_vblank_put(struct drm_crtc *crtc);
<span class="lineNum">    1005 </span>            : extern void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1006 </span>            : extern void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
<span class="lineNum">    1007 </span>            : extern void drm_vblank_off(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1008 </span>            : extern void drm_vblank_on(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1009 </span>            : extern void drm_crtc_vblank_off(struct drm_crtc *crtc);
<span class="lineNum">    1010 </span>            : extern void drm_crtc_vblank_reset(struct drm_crtc *crtc);
<span class="lineNum">    1011 </span>            : extern void drm_crtc_vblank_on(struct drm_crtc *crtc);
<span class="lineNum">    1012 </span>            : extern void drm_vblank_cleanup(struct drm_device *dev);
<span class="lineNum">    1013 </span>            : extern u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : extern int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
<span class="lineNum">    1016 </span>            :                                                  unsigned int pipe, int *max_error,
<span class="lineNum">    1017 </span>            :                                                  struct timeval *vblank_time,
<span class="lineNum">    1018 </span>            :                                                  unsigned flags,
<span class="lineNum">    1019 </span>            :                                                  const struct drm_display_mode *mode);
<span class="lineNum">    1020 </span>            : extern void drm_calc_timestamping_constants(struct drm_crtc *crtc,
<span class="lineNum">    1021 </span>            :                                             const struct drm_display_mode *mode);
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            : /**
<span class="lineNum">    1024 </span>            :  * drm_crtc_vblank_waitqueue - get vblank waitqueue for the CRTC
<span class="lineNum">    1025 </span>            :  * @crtc: which CRTC's vblank waitqueue to retrieve
<span class="lineNum">    1026 </span>            :  *
<span class="lineNum">    1027 </span>            :  * This function returns a pointer to the vblank waitqueue for the CRTC.
<a name="1028"><span class="lineNum">    1028 </span>            :  * Drivers can use this to implement vblank waits using wait_event() &amp; co.</a>
<span class="lineNum">    1029 </span>            :  */
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 : static inline wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc)</span>
<span class="lineNum">    1031 </span>            : {
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :         return &amp;crtc-&gt;dev-&gt;vblank[drm_crtc_index(crtc)].queue;</span>
<span class="lineNum">    1033 </span>            : }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            : /* Modesetting support */
<span class="lineNum">    1036 </span>            : extern void drm_vblank_pre_modeset(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1037 </span>            : extern void drm_vblank_post_modeset(struct drm_device *dev, unsigned int pipe);
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            : extern struct dma_buf *drm_gem_prime_export(struct drm_device *dev,
<span class="lineNum">    1040 </span>            :                                             struct drm_gem_object *obj,
<span class="lineNum">    1041 </span>            :                                             int flags);
<span class="lineNum">    1042 </span>            : extern int drm_gem_prime_handle_to_fd(struct drm_device *dev,
<span class="lineNum">    1043 </span>            :                 struct drm_file *file_priv, uint32_t handle, uint32_t flags,
<span class="lineNum">    1044 </span>            :                 int *prime_fd);
<span class="lineNum">    1045 </span>            : extern struct drm_gem_object *drm_gem_prime_import(struct drm_device *dev,
<span class="lineNum">    1046 </span>            :                 struct dma_buf *dma_buf);
<span class="lineNum">    1047 </span>            : extern int drm_gem_prime_fd_to_handle(struct drm_device *dev,
<span class="lineNum">    1048 </span>            :                 struct drm_file *file_priv, int prime_fd, uint32_t *handle);
<span class="lineNum">    1049 </span>            : extern void drm_gem_dmabuf_release(struct dma_buf *dma_buf);
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            : bool    drm_mode_parse_command_line_for_connector(const char *,
<span class="lineNum">    1052 </span>            :             struct drm_connector *, struct drm_cmdline_mode *);
<span class="lineNum">    1053 </span>            : struct drm_display_mode *
<span class="lineNum">    1054 </span>            :          drm_mode_create_from_cmdline_mode(struct drm_device *,
<span class="lineNum">    1055 </span>            :              struct drm_cmdline_mode *);
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : extern unsigned int drm_timestamp_monotonic;
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            : /* AGP/PCI Express/GART support (drm_agpsupport.c) */
<span class="lineNum">    1060 </span>            : struct drm_agp_head *drm_agp_init(void);
<span class="lineNum">    1061 </span>            : void    drm_agp_takedown(struct drm_device *);
<span class="lineNum">    1062 </span>            : int     drm_agp_acquire(struct drm_device *);
<span class="lineNum">    1063 </span>            : int     drm_agp_release(struct drm_device *);
<span class="lineNum">    1064 </span>            : int     drm_agp_info(struct drm_device *, struct drm_agp_info *);
<span class="lineNum">    1065 </span>            : int     drm_agp_enable(struct drm_device *, struct drm_agp_mode);
<span class="lineNum">    1066 </span>            : void    *drm_agp_allocate_memory(size_t, u32);
<span class="lineNum">    1067 </span>            : int     drm_agp_free_memory(void *);
<span class="lineNum">    1068 </span>            : int     drm_agp_bind_memory(void *, off_t);
<span class="lineNum">    1069 </span>            : int     drm_agp_unbind_memory(void *);
<span class="lineNum">    1070 </span>            : int     drm_agp_alloc(struct drm_device *, struct drm_agp_buffer *);
<span class="lineNum">    1071 </span>            : int     drm_agp_free(struct drm_device *, struct drm_agp_buffer *);
<span class="lineNum">    1072 </span>            : int     drm_agp_bind(struct drm_device *, struct drm_agp_binding *);
<span class="lineNum">    1073 </span>            : int     drm_agp_unbind(struct drm_device *, struct drm_agp_binding *);
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            : /* AGP/GART support (drm_agpsupport.c) */
<span class="lineNum">    1076 </span>            : int     drm_agp_acquire_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1077 </span>            : int     drm_agp_release_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1078 </span>            : int     drm_agp_enable_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1079 </span>            : int     drm_agp_info_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1080 </span>            : int     drm_agp_alloc_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1081 </span>            : int     drm_agp_free_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1082 </span>            : int     drm_agp_unbind_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1083 </span>            : int     drm_agp_bind_ioctl(struct drm_device *, void *, struct drm_file *);
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            : /* hotplug support */
<span class="lineNum">    1086 </span>            : void    drm_sysfs_hotplug_event(struct drm_device *);
<a name="1087"><span class="lineNum">    1087 </span>            : </a>
<span class="lineNum">    1088 </span>            : static inline int
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 : drm_sysfs_connector_add(struct drm_connector *connector)</span>
<span class="lineNum">    1090 </span>            : {
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1092 </span>            : }
<a name="1093"><span class="lineNum">    1093 </span>            : </a>
<span class="lineNum">    1094 </span>            : static inline void
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 : drm_sysfs_connector_remove(struct drm_connector *connector)</span>
<span class="lineNum">    1096 </span>            : {
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            : /* Graphics Execution Manager library functions (drm_gem.c) */
<span class="lineNum">    1100 </span>            : int drm_gem_init(struct drm_device *dev);
<span class="lineNum">    1101 </span>            : void drm_gem_destroy(struct drm_device *dev);
<span class="lineNum">    1102 </span>            : void drm_gem_object_release(struct drm_gem_object *obj);
<span class="lineNum">    1103 </span>            : void drm_gem_object_free(struct kref *kref);
<span class="lineNum">    1104 </span>            : int drm_gem_object_init(struct drm_device *dev,
<span class="lineNum">    1105 </span>            :                         struct drm_gem_object *obj, size_t size);
<span class="lineNum">    1106 </span>            : void drm_gem_private_object_init(struct drm_device *dev,
<span class="lineNum">    1107 </span>            :                                  struct drm_gem_object *obj, size_t size);
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            : int drm_gem_handle_create_tail(struct drm_file *file_priv,
<span class="lineNum">    1110 </span>            :                                struct drm_gem_object *obj,
<span class="lineNum">    1111 </span>            :                                u32 *handlep);
<span class="lineNum">    1112 </span>            : int drm_gem_handle_create(struct drm_file *file_priv,
<span class="lineNum">    1113 </span>            :                           struct drm_gem_object *obj,
<span class="lineNum">    1114 </span>            :                           u32 *handlep);
<span class="lineNum">    1115 </span>            : int drm_gem_handle_delete(struct drm_file *filp, u32 handle);
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            : void drm_gem_free_mmap_offset(struct drm_gem_object *obj);
<span class="lineNum">    1118 </span>            : int drm_gem_create_mmap_offset(struct drm_gem_object *obj);
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : struct drm_gem_object *drm_gem_object_lookup(struct drm_device *dev,
<span class="lineNum">    1121 </span>            :                                              struct drm_file *filp,
<span class="lineNum">    1122 </span>            :                                              u32 handle);
<span class="lineNum">    1123 </span>            : struct drm_gem_object *drm_gem_object_find(struct drm_file *, u32);
<span class="lineNum">    1124 </span>            : int drm_gem_close_ioctl(struct drm_device *dev, void *data,
<span class="lineNum">    1125 </span>            :                         struct drm_file *file_priv);
<span class="lineNum">    1126 </span>            : int drm_gem_flink_ioctl(struct drm_device *dev, void *data,
<span class="lineNum">    1127 </span>            :                         struct drm_file *file_priv);
<span class="lineNum">    1128 </span>            : int drm_gem_open_ioctl(struct drm_device *dev, void *data,
<span class="lineNum">    1129 </span>            :                        struct drm_file *file_priv);
<span class="lineNum">    1130 </span>            : void drm_gem_open(struct drm_device *dev, struct drm_file *file_private);
<span class="lineNum">    1131 </span>            : void drm_gem_release(struct drm_device *dev,struct drm_file *file_private);
<a name="1132"><span class="lineNum">    1132 </span>            : </a>
<span class="lineNum">    1133 </span>            : static __inline void
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 : drm_gem_object_reference(struct drm_gem_object *obj)</span>
<span class="lineNum">    1135 </span>            : {
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         kref_get(&amp;obj-&gt;refcount);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 : }</span>
<a name="1138"><span class="lineNum">    1138 </span>            : </a>
<span class="lineNum">    1139 </span>            : static __inline void
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 : drm_gem_object_unreference(struct drm_gem_object *obj)</span>
<span class="lineNum">    1141 </span>            : {
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :         if (obj != NULL)</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                 kref_put(&amp;obj-&gt;refcount, drm_gem_object_free);</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 : }</span>
<a name="1145"><span class="lineNum">    1145 </span>            : </a>
<span class="lineNum">    1146 </span>            : static __inline void
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 : drm_gem_object_unreference_unlocked(struct drm_gem_object *obj)</span>
<span class="lineNum">    1148 </span>            : {
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         if (obj &amp;&amp; !atomic_add_unless(&amp;obj-&gt;refcount.refcount, -1, 1)) {</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :                 struct drm_device *dev = obj-&gt;dev;</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :                 mutex_lock(&amp;dev-&gt;struct_mutex);</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                 if (likely(atomic_dec_and_test(&amp;obj-&gt;refcount.refcount)))</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                         drm_gem_object_free(&amp;obj-&gt;refcount);</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                 mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            : int drm_gem_dumb_destroy(struct drm_file *file,
<span class="lineNum">    1160 </span>            :                          struct drm_device *dev,
<a name="1161"><span class="lineNum">    1161 </span>            :                          uint32_t handle);</a>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 : static __inline__ int drm_core_check_feature(struct drm_device *dev,</span>
<span class="lineNum">    1164 </span>            :                                              int feature)
<span class="lineNum">    1165 </span>            : {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         return ((dev-&gt;driver-&gt;driver_features &amp; feature) ? 1 : 0);</span>
<span class="lineNum">    1167 </span>            : }
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            : static inline bool drm_is_render_client(const struct drm_file *file_priv)
<span class="lineNum">    1170 </span>            : {
<span class="lineNum">    1171 </span>            : #ifdef notyet
<span class="lineNum">    1172 </span>            :         return file_priv-&gt;minor-&gt;type == DRM_MINOR_RENDER;
<span class="lineNum">    1173 </span>            : #else
<span class="lineNum">    1174 </span>            :         return 0;
<span class="lineNum">    1175 </span>            : #endif
<a name="1176"><span class="lineNum">    1176 </span>            : }</a>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 : static inline bool drm_is_control_client(const struct drm_file *file_priv)</span>
<span class="lineNum">    1179 </span>            : {
<span class="lineNum">    1180 </span>            : #ifdef notyet
<span class="lineNum">    1181 </span>            :         return file_priv-&gt;minor-&gt;type == DRM_MINOR_CONTROL;
<span class="lineNum">    1182 </span>            : #else
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1184 </span>            : #endif
<span class="lineNum">    1185 </span>            : }
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span>            : static inline bool drm_is_primary_client(const struct drm_file *file_priv)
<span class="lineNum">    1188 </span>            : {
<span class="lineNum">    1189 </span>            : #ifdef notyet
<span class="lineNum">    1190 </span>            :         return file_priv-&gt;minor-&gt;type == DRM_MINOR_LEGACY;
<span class="lineNum">    1191 </span>            : #else
<span class="lineNum">    1192 </span>            :         return 1;
<span class="lineNum">    1193 </span>            : #endif
<span class="lineNum">    1194 </span>            : }
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            : static inline int drm_dev_to_irq(struct drm_device *dev)
<span class="lineNum">    1197 </span>            : {
<span class="lineNum">    1198 </span>            :         return -1;
<span class="lineNum">    1199 </span>            : }
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span>            : #define DRM_PCIE_SPEED_25 1
<span class="lineNum">    1202 </span>            : #define DRM_PCIE_SPEED_50 2
<span class="lineNum">    1203 </span>            : #define DRM_PCIE_SPEED_80 4
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            : int      drm_pcie_get_speed_cap_mask(struct drm_device *, u32 *);
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span>            : #endif /* __KERNEL__ */
<span class="lineNum">    1208 </span>            : #endif /* _DRM_P_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
