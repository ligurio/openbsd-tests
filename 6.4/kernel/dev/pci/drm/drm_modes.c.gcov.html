<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/drm/drm_modes.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">dev/pci/drm</a> - drm_modes.c<span style="font-size: 80%;"> (source / <a href="drm_modes.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">422</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright © 1997-2003 by The XFree86 Project, Inc.
<span class="lineNum">       3 </span>            :  * Copyright © 2007 Dave Airlie
<span class="lineNum">       4 </span>            :  * Copyright © 2007-2008 Intel Corporation
<span class="lineNum">       5 </span>            :  *   Jesse Barnes &lt;jesse.barnes@intel.com&gt;
<span class="lineNum">       6 </span>            :  * Copyright 2005-2006 Luc Verhaegen
<span class="lineNum">       7 </span>            :  * Copyright (c) 2001, Andy Ritger  aritger@nvidia.com
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">      10 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">      11 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">      12 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">      13 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">      14 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * The above copyright notice and this permission notice shall be included in
<span class="lineNum">      17 </span>            :  * all copies or substantial portions of the Software.
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      20 </span>            :  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      21 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
<span class="lineNum">      22 </span>            :  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
<span class="lineNum">      23 </span>            :  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
<span class="lineNum">      24 </span>            :  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
<span class="lineNum">      25 </span>            :  * OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * Except as contained in this notice, the name of the copyright holder(s)
<span class="lineNum">      28 </span>            :  * and author(s) shall not be used in advertising or otherwise to promote
<span class="lineNum">      29 </span>            :  * the sale, use or other dealings in this Software without prior written
<span class="lineNum">      30 </span>            :  * authorization from the copyright holder(s) and author(s).
<span class="lineNum">      31 </span>            :  */
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #ifdef __linux__
<span class="lineNum">      34 </span>            : #include &lt;linux/list.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;linux/list_sort.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;linux/export.h&gt;
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : #include &lt;dev/pci/drm/drmP.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;dev/pci/drm/drm_crtc.h&gt;
<span class="lineNum">      40 </span>            : #ifdef __linux__
<span class="lineNum">      41 </span>            : #include &lt;video/of_videomode.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;video/videomode.h&gt;
<span class="lineNum">      43 </span>            : #endif
<span class="lineNum">      44 </span>            : #include &lt;dev/pci/drm/drm_modes.h&gt;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #include &quot;drm_crtc_internal.h&quot;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : /**
<span class="lineNum">      49 </span>            :  * drm_mode_debug_printmodeline - print a mode to dmesg
<span class="lineNum">      50 </span>            :  * @mode: mode to print
<span class="lineNum">      51 </span>            :  *
<a name="52"><span class="lineNum">      52 </span>            :  * Describe @mode using DRM_DEBUG.</a>
<span class="lineNum">      53 </span>            :  */
<span class="lineNum">      54 </span><span class="lineNoCov">          0 : void drm_mode_debug_printmodeline(const struct drm_display_mode *mode)</span>
<span class="lineNum">      55 </span>            : {
<span class="lineNum">      56 </span>            :         DRM_DEBUG_KMS(&quot;Modeline %d:\&quot;%s\&quot; %d %d %d %d %d %d %d %d %d %d &quot;
<span class="lineNum">      57 </span>            :                         &quot;0x%x 0x%x\n&quot;,
<span class="lineNum">      58 </span>            :                 mode-&gt;base.id, mode-&gt;name, mode-&gt;vrefresh, mode-&gt;clock,
<span class="lineNum">      59 </span>            :                 mode-&gt;hdisplay, mode-&gt;hsync_start,
<span class="lineNum">      60 </span>            :                 mode-&gt;hsync_end, mode-&gt;htotal,
<span class="lineNum">      61 </span>            :                 mode-&gt;vdisplay, mode-&gt;vsync_start,
<span class="lineNum">      62 </span>            :                 mode-&gt;vsync_end, mode-&gt;vtotal, mode-&gt;type, mode-&gt;flags);
<span class="lineNum">      63 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      64 </span>            : EXPORT_SYMBOL(drm_mode_debug_printmodeline);
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : /**
<span class="lineNum">      67 </span>            :  * drm_mode_create - create a new display mode
<span class="lineNum">      68 </span>            :  * @dev: DRM device
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * Create a new, cleared drm_display_mode with kzalloc, allocate an ID for it
<span class="lineNum">      71 </span>            :  * and return it.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * Returns:
<a name="74"><span class="lineNum">      74 </span>            :  * Pointer to new mode on success, NULL on error.</a>
<span class="lineNum">      75 </span>            :  */
<span class="lineNum">      76 </span><span class="lineNoCov">          0 : struct drm_display_mode *drm_mode_create(struct drm_device *dev)</span>
<span class="lineNum">      77 </span>            : {
<span class="lineNum">      78 </span>            :         struct drm_display_mode *nmode;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :         nmode = kzalloc(sizeof(struct drm_display_mode), GFP_KERNEL);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :         if (!nmode)</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :         if (drm_mode_object_get(dev, &amp;nmode-&gt;base, DRM_MODE_OBJECT_MODE)) {</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :                 kfree(nmode);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">      87 </span>            :         }
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         return nmode;</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      91 </span>            : EXPORT_SYMBOL(drm_mode_create);
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /**
<span class="lineNum">      94 </span>            :  * drm_mode_destroy - remove a mode
<span class="lineNum">      95 </span>            :  * @dev: DRM device
<span class="lineNum">      96 </span>            :  * @mode: mode to remove
<span class="lineNum">      97 </span>            :  *
<a name="98"><span class="lineNum">      98 </span>            :  * Release @mode's unique ID, then free it @mode structure itself using kfree.</a>
<span class="lineNum">      99 </span>            :  */
<span class="lineNum">     100 </span><span class="lineNoCov">          0 : void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)</span>
<span class="lineNum">     101 </span>            : {
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         if (!mode)</span>
<span class="lineNum">     103 </span>            :                 return;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :         drm_mode_object_put(dev, &amp;mode-&gt;base);</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         kfree(mode);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     109 </span>            : EXPORT_SYMBOL(drm_mode_destroy);
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : /**
<span class="lineNum">     112 </span>            :  * drm_mode_probed_add - add a mode to a connector's probed_mode list
<span class="lineNum">     113 </span>            :  * @connector: connector the new mode
<span class="lineNum">     114 </span>            :  * @mode: mode data
<span class="lineNum">     115 </span>            :  *
<span class="lineNum">     116 </span>            :  * Add @mode to @connector's probed_mode list for later use. This list should
<span class="lineNum">     117 </span>            :  * then in a second step get filtered and all the modes actually supported by
<a name="118"><span class="lineNum">     118 </span>            :  * the hardware moved to the @connector's modes list.</a>
<span class="lineNum">     119 </span>            :  */
<span class="lineNum">     120 </span><span class="lineNoCov">          0 : void drm_mode_probed_add(struct drm_connector *connector,</span>
<span class="lineNum">     121 </span>            :                          struct drm_display_mode *mode)
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :         WARN_ON(!mutex_is_locked(&amp;connector-&gt;dev-&gt;mode_config.mutex));</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :         list_add_tail(&amp;mode-&gt;head, &amp;connector-&gt;probed_modes);</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     127 </span>            : EXPORT_SYMBOL(drm_mode_probed_add);
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : /**
<span class="lineNum">     130 </span>            :  * drm_cvt_mode -create a modeline based on the CVT algorithm
<span class="lineNum">     131 </span>            :  * @dev: drm device
<span class="lineNum">     132 </span>            :  * @hdisplay: hdisplay size
<span class="lineNum">     133 </span>            :  * @vdisplay: vdisplay size
<span class="lineNum">     134 </span>            :  * @vrefresh: vrefresh rate
<span class="lineNum">     135 </span>            :  * @reduced: whether to use reduced blanking
<span class="lineNum">     136 </span>            :  * @interlaced: whether to compute an interlaced mode
<span class="lineNum">     137 </span>            :  * @margins: whether to add margins (borders)
<span class="lineNum">     138 </span>            :  *
<span class="lineNum">     139 </span>            :  * This function is called to generate the modeline based on CVT algorithm
<span class="lineNum">     140 </span>            :  * according to the hdisplay, vdisplay, vrefresh.
<span class="lineNum">     141 </span>            :  * It is based from the VESA(TM) Coordinated Video Timing Generator by
<span class="lineNum">     142 </span>            :  * Graham Loveridge April 9, 2003 available at
<span class="lineNum">     143 </span>            :  * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls 
<span class="lineNum">     144 </span>            :  *
<span class="lineNum">     145 </span>            :  * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
<span class="lineNum">     146 </span>            :  * What I have done is to translate it by using integer calculation.
<span class="lineNum">     147 </span>            :  *
<span class="lineNum">     148 </span>            :  * Returns:
<span class="lineNum">     149 </span>            :  * The modeline based on the CVT algorithm stored in a drm_display_mode object.
<span class="lineNum">     150 </span>            :  * The display mode object is allocated with drm_mode_create(). Returns NULL
<a name="151"><span class="lineNum">     151 </span>            :  * when no mode could be allocated.</a>
<span class="lineNum">     152 </span>            :  */
<span class="lineNum">     153 </span><span class="lineNoCov">          0 : struct drm_display_mode *drm_cvt_mode(struct drm_device *dev, int hdisplay,</span>
<span class="lineNum">     154 </span>            :                                       int vdisplay, int vrefresh,
<span class="lineNum">     155 </span>            :                                       bool reduced, bool interlaced, bool margins)
<span class="lineNum">     156 </span>            : {
<span class="lineNum">     157 </span>            : #define HV_FACTOR                       1000
<span class="lineNum">     158 </span>            :         /* 1) top/bottom margin size (% of height) - default: 1.8, */
<span class="lineNum">     159 </span>            : #define CVT_MARGIN_PERCENTAGE           18
<span class="lineNum">     160 </span>            :         /* 2) character cell horizontal granularity (pixels) - default 8 */
<span class="lineNum">     161 </span>            : #define CVT_H_GRANULARITY               8
<span class="lineNum">     162 </span>            :         /* 3) Minimum vertical porch (lines) - default 3 */
<span class="lineNum">     163 </span>            : #define CVT_MIN_V_PORCH                 3
<span class="lineNum">     164 </span>            :         /* 4) Minimum number of vertical back porch lines - default 6 */
<span class="lineNum">     165 </span>            : #define CVT_MIN_V_BPORCH                6
<span class="lineNum">     166 </span>            :         /* Pixel Clock step (kHz) */
<span class="lineNum">     167 </span>            : #define CVT_CLOCK_STEP                  250
<span class="lineNum">     168 </span>            :         struct drm_display_mode *drm_mode;
<span class="lineNum">     169 </span>            :         unsigned int vfieldrate, hperiod;
<span class="lineNum">     170 </span>            :         int hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;
<span class="lineNum">     171 </span>            :         int interlace;
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :         /* allocate the drm_display_mode structure. If failure, we will
<span class="lineNum">     174 </span>            :          * return directly
<span class="lineNum">     175 </span>            :          */
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         drm_mode = drm_mode_create(dev);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         if (!drm_mode)</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :         /* the CVT default refresh rate is 60Hz */
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         if (!vrefresh)</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :                 vrefresh = 60;</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :         /* the required field fresh rate */
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                 vfieldrate = vrefresh * 2;</span>
<span class="lineNum">     187 </span>            :         else
<span class="lineNum">     188 </span>            :                 vfieldrate = vrefresh;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :         /* horizontal pixels */
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         hdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :         /* determine the left&amp;right borders */
<span class="lineNum">     194 </span>            :         hmargin = 0;
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         if (margins) {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 hmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                 hmargin -= hmargin % CVT_H_GRANULARITY;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     199 </span>            :         /* find the total active pixels */
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         drm_mode-&gt;hdisplay = hdisplay_rnd + 2 * hmargin;</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :         /* find the number of lines per field */
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :                 vdisplay_rnd = vdisplay / 2;</span>
<span class="lineNum">     205 </span>            :         else
<span class="lineNum">     206 </span>            :                 vdisplay_rnd = vdisplay;
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :         /* find the top &amp; bottom borders */
<span class="lineNum">     209 </span>            :         vmargin = 0;
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         if (margins)</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :                 vmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         drm_mode-&gt;vdisplay = vdisplay + 2 * vmargin;</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :         /* Interlaced */
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :                 interlace = 1;</span>
<span class="lineNum">     218 </span>            :         else
<span class="lineNum">     219 </span>            :                 interlace = 0;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :         /* Determine VSync Width from aspect ratio */
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         if (!(vdisplay % 3) &amp;&amp; ((vdisplay * 4 / 3) == hdisplay))</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                 vsync = 4;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         else if (!(vdisplay % 9) &amp;&amp; ((vdisplay * 16 / 9) == hdisplay))</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :                 vsync = 5;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         else if (!(vdisplay % 10) &amp;&amp; ((vdisplay * 16 / 10) == hdisplay))</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 vsync = 6;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         else if (!(vdisplay % 4) &amp;&amp; ((vdisplay * 5 / 4) == hdisplay))</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :                 vsync = 7;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :         else if (!(vdisplay % 9) &amp;&amp; ((vdisplay * 15 / 9) == hdisplay))</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :                 vsync = 7;</span>
<span class="lineNum">     232 </span>            :         else /* custom */
<span class="lineNum">     233 </span>            :                 vsync = 10;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         if (!reduced) {</span>
<span class="lineNum">     236 </span>            :                 /* simplify the GTF calculation */
<span class="lineNum">     237 </span>            :                 /* 4) Minimum time of vertical sync + back porch interval (µs)
<span class="lineNum">     238 </span>            :                  * default 550.0
<span class="lineNum">     239 </span>            :                  */
<span class="lineNum">     240 </span>            :                 int tmp1, tmp2;
<span class="lineNum">     241 </span>            : #define CVT_MIN_VSYNC_BP        550
<span class="lineNum">     242 </span>            :                 /* 3) Nominal HSync width (% of line period) - default 8 */
<span class="lineNum">     243 </span>            : #define CVT_HSYNC_PERCENTAGE    8
<span class="lineNum">     244 </span>            :                 unsigned int hblank_percentage;
<span class="lineNum">     245 </span>            :                 int vsyncandback_porch, vback_porch, hblank;
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :                 /* estimated the horizontal period */
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                 tmp1 = HV_FACTOR * 1000000  -</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                                 CVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                 tmp2 = (vdisplay_rnd + 2 * vmargin + CVT_MIN_V_PORCH) * 2 +</span>
<span class="lineNum">     251 </span>            :                                 interlace;
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 hperiod = tmp1 * 2 / (tmp2 * vfieldrate);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                 tmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + 1;</span>
<span class="lineNum">     255 </span>            :                 /* 9. Find number of lines in sync + backporch */
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :                 if (tmp1 &lt; (vsync + CVT_MIN_V_PORCH))</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                         vsyncandback_porch = vsync + CVT_MIN_V_PORCH;</span>
<span class="lineNum">     258 </span>            :                 else
<span class="lineNum">     259 </span>            :                         vsyncandback_porch = tmp1;
<span class="lineNum">     260 </span>            :                 /* 10. Find number of lines in back porch */
<span class="lineNum">     261 </span>            :                 vback_porch = vsyncandback_porch - vsync;
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vtotal = vdisplay_rnd + 2 * vmargin +</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :                                 vsyncandback_porch + CVT_MIN_V_PORCH;</span>
<span class="lineNum">     264 </span>            :                 /* 5) Definition of Horizontal blanking time limitation */
<span class="lineNum">     265 </span>            :                 /* Gradient (%/kHz) - default 600 */
<span class="lineNum">     266 </span>            : #define CVT_M_FACTOR    600
<span class="lineNum">     267 </span>            :                 /* Offset (%) - default 40 */
<span class="lineNum">     268 </span>            : #define CVT_C_FACTOR    40
<span class="lineNum">     269 </span>            :                 /* Blanking time scaling factor - default 128 */
<span class="lineNum">     270 </span>            : #define CVT_K_FACTOR    128
<span class="lineNum">     271 </span>            :                 /* Scaling factor weighting - default 20 */
<span class="lineNum">     272 </span>            : #define CVT_J_FACTOR    20
<span class="lineNum">     273 </span>            : #define CVT_M_PRIME     (CVT_M_FACTOR * CVT_K_FACTOR / 256)
<span class="lineNum">     274 </span>            : #define CVT_C_PRIME     ((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \
<span class="lineNum">     275 </span>            :                          CVT_J_FACTOR)
<span class="lineNum">     276 </span>            :                 /* 12. Find ideal blanking duty cycle from formula */
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                 hblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                                         hperiod / 1000;</span>
<span class="lineNum">     279 </span>            :                 /* 13. Blanking time */
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                 if (hblank_percentage &lt; 20 * HV_FACTOR)</span>
<span class="lineNum">     281 </span>            :                         hblank_percentage = 20 * HV_FACTOR;
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 hblank = drm_mode-&gt;hdisplay * hblank_percentage /</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                          (100 * HV_FACTOR - hblank_percentage);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                 hblank -= hblank % (2 * CVT_H_GRANULARITY);</span>
<span class="lineNum">     285 </span>            :                 /* 14. find the total pixels per line */
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;htotal = drm_mode-&gt;hdisplay + hblank;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;hsync_end = drm_mode-&gt;hdisplay + hblank / 2;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;hsync_start = drm_mode-&gt;hsync_end -</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                         (drm_mode-&gt;htotal * CVT_HSYNC_PERCENTAGE) / 100;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;hsync_start += CVT_H_GRANULARITY -</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :                         drm_mode-&gt;hsync_start % CVT_H_GRANULARITY;</span>
<span class="lineNum">     292 </span>            :                 /* fill the Vsync values */
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vsync_start = drm_mode-&gt;vdisplay + CVT_MIN_V_PORCH;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vsync_end = drm_mode-&gt;vsync_start + vsync;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     296 </span>            :                 /* Reduced blanking */
<span class="lineNum">     297 </span>            :                 /* Minimum vertical blanking interval time (µs)- default 460 */
<span class="lineNum">     298 </span>            : #define CVT_RB_MIN_VBLANK       460
<span class="lineNum">     299 </span>            :                 /* Fixed number of clocks for horizontal sync */
<span class="lineNum">     300 </span>            : #define CVT_RB_H_SYNC           32
<span class="lineNum">     301 </span>            :                 /* Fixed number of clocks for horizontal blanking */
<span class="lineNum">     302 </span>            : #define CVT_RB_H_BLANK          160
<span class="lineNum">     303 </span>            :                 /* Fixed number of lines for vertical front porch - default 3*/
<span class="lineNum">     304 </span>            : #define CVT_RB_VFPORCH          3
<span class="lineNum">     305 </span>            :                 int vbilines;
<span class="lineNum">     306 </span>            :                 int tmp1, tmp2;
<span class="lineNum">     307 </span>            :                 /* 8. Estimate Horizontal period. */
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                 tmp1 = HV_FACTOR * 1000000 -</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                         CVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :                 tmp2 = vdisplay_rnd + 2 * vmargin;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                 hperiod = tmp1 / (tmp2 * vfieldrate);</span>
<span class="lineNum">     312 </span>            :                 /* 9. Find number of lines in vertical blanking */
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                 vbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + 1;</span>
<span class="lineNum">     314 </span>            :                 /* 10. Check if vertical blanking is sufficient */
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                 if (vbilines &lt; (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                         vbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;</span>
<span class="lineNum">     317 </span>            :                 /* 11. Find total number of lines in vertical field */
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vtotal = vdisplay_rnd + 2 * vmargin + vbilines;</span>
<span class="lineNum">     319 </span>            :                 /* 12. Find total number of pixels in a line */
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;htotal = drm_mode-&gt;hdisplay + CVT_RB_H_BLANK;</span>
<span class="lineNum">     321 </span>            :                 /* Fill in HSync values */
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;hsync_end = drm_mode-&gt;hdisplay + CVT_RB_H_BLANK / 2;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;hsync_start = drm_mode-&gt;hsync_end - CVT_RB_H_SYNC;</span>
<span class="lineNum">     324 </span>            :                 /* Fill in VSync values */
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vsync_start = drm_mode-&gt;vdisplay + CVT_RB_VFPORCH;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vsync_end = drm_mode-&gt;vsync_start + vsync;</span>
<span class="lineNum">     327 </span>            :         }
<span class="lineNum">     328 </span>            :         /* 15/13. Find pixel clock frequency (kHz for xf86) */
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         drm_mode-&gt;clock = drm_mode-&gt;htotal * HV_FACTOR * 1000 / hperiod;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         drm_mode-&gt;clock -= drm_mode-&gt;clock % CVT_CLOCK_STEP;</span>
<span class="lineNum">     331 </span>            :         /* 18/16. Find actual vertical frame frequency */
<span class="lineNum">     332 </span>            :         /* ignore - just set the mode flag for interlaced */
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         if (interlaced) {</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vtotal *= 2;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;flags |= DRM_MODE_FLAG_INTERLACE;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     337 </span>            :         /* Fill the mode line name */
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         drm_mode_set_name(drm_mode);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         if (reduced)</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;flags |= (DRM_MODE_FLAG_PHSYNC |</span>
<span class="lineNum">     341 </span>            :                                         DRM_MODE_FLAG_NVSYNC);
<span class="lineNum">     342 </span>            :         else
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;flags |= (DRM_MODE_FLAG_PVSYNC |</span>
<span class="lineNum">     344 </span>            :                                         DRM_MODE_FLAG_NHSYNC);
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         return drm_mode;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     348 </span>            : EXPORT_SYMBOL(drm_cvt_mode);
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : /**
<span class="lineNum">     351 </span>            :  * drm_gtf_mode_complex - create the modeline based on the full GTF algorithm
<span class="lineNum">     352 </span>            :  * @dev: drm device
<span class="lineNum">     353 </span>            :  * @hdisplay: hdisplay size
<span class="lineNum">     354 </span>            :  * @vdisplay: vdisplay size
<span class="lineNum">     355 </span>            :  * @vrefresh: vrefresh rate.
<span class="lineNum">     356 </span>            :  * @interlaced: whether to compute an interlaced mode
<span class="lineNum">     357 </span>            :  * @margins: desired margin (borders) size
<span class="lineNum">     358 </span>            :  * @GTF_M: extended GTF formula parameters
<span class="lineNum">     359 </span>            :  * @GTF_2C: extended GTF formula parameters
<span class="lineNum">     360 </span>            :  * @GTF_K: extended GTF formula parameters
<span class="lineNum">     361 </span>            :  * @GTF_2J: extended GTF formula parameters
<span class="lineNum">     362 </span>            :  *
<span class="lineNum">     363 </span>            :  * GTF feature blocks specify C and J in multiples of 0.5, so we pass them
<span class="lineNum">     364 </span>            :  * in here multiplied by two.  For a C of 40, pass in 80.
<span class="lineNum">     365 </span>            :  *
<span class="lineNum">     366 </span>            :  * Returns:
<span class="lineNum">     367 </span>            :  * The modeline based on the full GTF algorithm stored in a drm_display_mode object.
<span class="lineNum">     368 </span>            :  * The display mode object is allocated with drm_mode_create(). Returns NULL
<span class="lineNum">     369 </span>            :  * when no mode could be allocated.
<a name="370"><span class="lineNum">     370 </span>            :  */</a>
<span class="lineNum">     371 </span>            : struct drm_display_mode *
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : drm_gtf_mode_complex(struct drm_device *dev, int hdisplay, int vdisplay,</span>
<span class="lineNum">     373 </span>            :                      int vrefresh, bool interlaced, int margins,
<span class="lineNum">     374 </span>            :                      int GTF_M, int GTF_2C, int GTF_K, int GTF_2J)
<span class="lineNum">     375 </span>            : {       /* 1) top/bottom margin size (% of height) - default: 1.8, */
<span class="lineNum">     376 </span>            : #define GTF_MARGIN_PERCENTAGE           18
<span class="lineNum">     377 </span>            :         /* 2) character cell horizontal granularity (pixels) - default 8 */
<span class="lineNum">     378 </span>            : #define GTF_CELL_GRAN                   8
<span class="lineNum">     379 </span>            :         /* 3) Minimum vertical porch (lines) - default 3 */
<span class="lineNum">     380 </span>            : #define GTF_MIN_V_PORCH                 1
<span class="lineNum">     381 </span>            :         /* width of vsync in lines */
<span class="lineNum">     382 </span>            : #define V_SYNC_RQD                      3
<span class="lineNum">     383 </span>            :         /* width of hsync as % of total line */
<span class="lineNum">     384 </span>            : #define H_SYNC_PERCENT                  8
<span class="lineNum">     385 </span>            :         /* min time of vsync + back porch (microsec) */
<span class="lineNum">     386 </span>            : #define MIN_VSYNC_PLUS_BP               550
<span class="lineNum">     387 </span>            :         /* C' and M' are part of the Blanking Duty Cycle computation */
<span class="lineNum">     388 </span>            : #define GTF_C_PRIME     ((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)
<span class="lineNum">     389 </span>            : #define GTF_M_PRIME     (GTF_K * GTF_M / 256)
<span class="lineNum">     390 </span>            :         struct drm_display_mode *drm_mode;
<span class="lineNum">     391 </span>            :         unsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;
<span class="lineNum">     392 </span>            :         int top_margin, bottom_margin;
<span class="lineNum">     393 </span>            :         int interlace;
<span class="lineNum">     394 </span>            :         unsigned int hfreq_est;
<span class="lineNum">     395 </span>            :         int vsync_plus_bp, vback_porch;
<span class="lineNum">     396 </span>            :         unsigned int vtotal_lines, vfieldrate_est, hperiod;
<span class="lineNum">     397 </span>            :         unsigned int vfield_rate, vframe_rate;
<span class="lineNum">     398 </span>            :         int left_margin, right_margin;
<span class="lineNum">     399 </span>            :         unsigned int total_active_pixels, ideal_duty_cycle;
<span class="lineNum">     400 </span>            :         unsigned int hblank, total_pixels, pixel_freq;
<span class="lineNum">     401 </span>            :         int hsync, hfront_porch, vodd_front_porch_lines;
<span class="lineNum">     402 </span>            :         unsigned int tmp1, tmp2;
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         drm_mode = drm_mode_create(dev);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         if (!drm_mode)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :         /* 1. In order to give correct results, the number of horizontal
<span class="lineNum">     409 </span>            :          * pixels requested is first processed to ensure that it is divisible
<span class="lineNum">     410 </span>            :          * by the character size, by rounding it to the nearest character
<span class="lineNum">     411 </span>            :          * cell boundary:
<span class="lineNum">     412 </span>            :          */
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         hdisplay_rnd = (hdisplay + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         hdisplay_rnd = hdisplay_rnd * GTF_CELL_GRAN;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :         /* 2. If interlace is requested, the number of vertical lines assumed
<span class="lineNum">     417 </span>            :          * by the calculation must be halved, as the computation calculates
<span class="lineNum">     418 </span>            :          * the number of vertical lines per field.
<span class="lineNum">     419 </span>            :          */
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :                 vdisplay_rnd = vdisplay / 2;</span>
<span class="lineNum">     422 </span>            :         else
<span class="lineNum">     423 </span>            :                 vdisplay_rnd = vdisplay;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :         /* 3. Find the frame rate required: */
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                 vfieldrate_rqd = vrefresh * 2;</span>
<span class="lineNum">     428 </span>            :         else
<span class="lineNum">     429 </span>            :                 vfieldrate_rqd = vrefresh;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :         /* 4. Find number of lines in Top margin: */
<span class="lineNum">     432 </span>            :         top_margin = 0;
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         if (margins)</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                 top_margin = (vdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /</span>
<span class="lineNum">     435 </span>            :                                 1000;
<span class="lineNum">     436 </span>            :         /* 5. Find number of lines in bottom margin: */
<span class="lineNum">     437 </span>            :         bottom_margin = top_margin;
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :         /* 6. If interlace is required, then set variable interlace: */
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                 interlace = 1;</span>
<span class="lineNum">     442 </span>            :         else
<span class="lineNum">     443 </span>            :                 interlace = 0;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :         /* 7. Estimate the Horizontal frequency */
<span class="lineNum">     446 </span>            :         {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                 tmp1 = (1000000  - MIN_VSYNC_PLUS_BP * vfieldrate_rqd) / 500;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                 tmp2 = (vdisplay_rnd + 2 * top_margin + GTF_MIN_V_PORCH) *</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                                 2 + interlace;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                 hfreq_est = (tmp2 * 1000 * vfieldrate_rqd) / tmp1;</span>
<span class="lineNum">     451 </span>            :         }
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :         /* 8. Find the number of lines in V sync + back porch */
<span class="lineNum">     454 </span>            :         /* [V SYNC+BP] = RINT(([MIN VSYNC+BP] * hfreq_est / 1000000)) */
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         vsync_plus_bp = MIN_VSYNC_PLUS_BP * hfreq_est / 1000;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         vsync_plus_bp = (vsync_plus_bp + 500) / 1000;</span>
<span class="lineNum">     457 </span>            :         /*  9. Find the number of lines in V back porch alone: */
<span class="lineNum">     458 </span>            :         vback_porch = vsync_plus_bp - V_SYNC_RQD;
<span class="lineNum">     459 </span>            :         /*  10. Find the total number of lines in Vertical field period: */
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         vtotal_lines = vdisplay_rnd + top_margin + bottom_margin +</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                         vsync_plus_bp + GTF_MIN_V_PORCH;</span>
<span class="lineNum">     462 </span>            :         /*  11. Estimate the Vertical field frequency: */
<span class="lineNum">     463 </span>            :         vfieldrate_est = hfreq_est / vtotal_lines;
<span class="lineNum">     464 </span>            :         /*  12. Find the actual horizontal period: */
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         hperiod = 1000000 / (vfieldrate_rqd * vtotal_lines);</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :         /*  13. Find the actual Vertical field frequency: */
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         vfield_rate = hfreq_est / vtotal_lines;</span>
<span class="lineNum">     469 </span>            :         /*  14. Find the Vertical frame frequency: */
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :         if (interlaced)</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                 vframe_rate = vfield_rate / 2;</span>
<span class="lineNum">     472 </span>            :         else
<span class="lineNum">     473 </span>            :                 vframe_rate = vfield_rate;
<span class="lineNum">     474 </span>            :         /*  15. Find number of pixels in left margin: */
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         if (margins)</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                 left_margin = (hdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /</span>
<span class="lineNum">     477 </span>            :                                 1000;
<span class="lineNum">     478 </span>            :         else
<span class="lineNum">     479 </span>            :                 left_margin = 0;
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :         /* 16.Find number of pixels in right margin: */
<span class="lineNum">     482 </span>            :         right_margin = left_margin;
<span class="lineNum">     483 </span>            :         /* 17.Find total number of active pixels in image and left and right */
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         total_active_pixels = hdisplay_rnd + left_margin + right_margin;</span>
<span class="lineNum">     485 </span>            :         /* 18.Find the ideal blanking duty cycle from blanking duty cycle */
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         ideal_duty_cycle = GTF_C_PRIME * 1000 -</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                                 (GTF_M_PRIME * 1000000 / hfreq_est);</span>
<span class="lineNum">     488 </span>            :         /* 19.Find the number of pixels in the blanking time to the nearest
<span class="lineNum">     489 </span>            :          * double character cell: */
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         hblank = total_active_pixels * ideal_duty_cycle /</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                         (100000 - ideal_duty_cycle);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         hblank = (hblank + GTF_CELL_GRAN) / (2 * GTF_CELL_GRAN);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         hblank = hblank * 2 * GTF_CELL_GRAN;</span>
<span class="lineNum">     494 </span>            :         /* 20.Find total number of pixels: */
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         total_pixels = total_active_pixels + hblank;</span>
<span class="lineNum">     496 </span>            :         /* 21.Find pixel clock frequency: */
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         pixel_freq = total_pixels * hfreq_est / 1000;</span>
<span class="lineNum">     498 </span>            :         /* Stage 1 computations are now complete; I should really pass
<span class="lineNum">     499 </span>            :          * the results to another function and do the Stage 2 computations,
<span class="lineNum">     500 </span>            :          * but I only need a few more values so I'll just append the
<span class="lineNum">     501 </span>            :          * computations here for now */
<span class="lineNum">     502 </span>            :         /* 17. Find the number of pixels in the horizontal sync period: */
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         hsync = H_SYNC_PERCENT * total_pixels / 100;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         hsync = (hsync + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         hsync = hsync * GTF_CELL_GRAN;</span>
<span class="lineNum">     506 </span>            :         /* 18. Find the number of pixels in horizontal front porch period */
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         hfront_porch = hblank / 2 - hsync;</span>
<span class="lineNum">     508 </span>            :         /*  36. Find the number of lines in the odd front porch period: */
<span class="lineNum">     509 </span>            :         vodd_front_porch_lines = GTF_MIN_V_PORCH ;
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :         /* finally, pack the results in the mode struct */
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         drm_mode-&gt;hdisplay = hdisplay_rnd;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         drm_mode-&gt;hsync_start = hdisplay_rnd + hfront_porch;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         drm_mode-&gt;hsync_end = drm_mode-&gt;hsync_start + hsync;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         drm_mode-&gt;htotal = total_pixels;</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         drm_mode-&gt;vdisplay = vdisplay_rnd;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         drm_mode-&gt;vsync_start = vdisplay_rnd + vodd_front_porch_lines;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         drm_mode-&gt;vsync_end = drm_mode-&gt;vsync_start + V_SYNC_RQD;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         drm_mode-&gt;vtotal = vtotal_lines;</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         drm_mode-&gt;clock = pixel_freq;</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         if (interlaced) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;vtotal *= 2;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;flags |= DRM_MODE_FLAG_INTERLACE;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         drm_mode_set_name(drm_mode);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         if (GTF_M == 600 &amp;&amp; GTF_2C == 80 &amp;&amp; GTF_K == 128 &amp;&amp; GTF_2J == 40)</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;</span>
<span class="lineNum">     531 </span>            :         else
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                 drm_mode-&gt;flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         return drm_mode;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     536 </span>            : EXPORT_SYMBOL(drm_gtf_mode_complex);
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : /**
<span class="lineNum">     539 </span>            :  * drm_gtf_mode - create the modeline based on the GTF algorithm
<span class="lineNum">     540 </span>            :  * @dev: drm device
<span class="lineNum">     541 </span>            :  * @hdisplay: hdisplay size
<span class="lineNum">     542 </span>            :  * @vdisplay: vdisplay size
<span class="lineNum">     543 </span>            :  * @vrefresh: vrefresh rate.
<span class="lineNum">     544 </span>            :  * @interlaced: whether to compute an interlaced mode
<span class="lineNum">     545 </span>            :  * @margins: desired margin (borders) size
<span class="lineNum">     546 </span>            :  *
<span class="lineNum">     547 </span>            :  * return the modeline based on GTF algorithm
<span class="lineNum">     548 </span>            :  *
<span class="lineNum">     549 </span>            :  * This function is to create the modeline based on the GTF algorithm.
<span class="lineNum">     550 </span>            :  * Generalized Timing Formula is derived from:
<span class="lineNum">     551 </span>            :  *      GTF Spreadsheet by Andy Morrish (1/5/97)
<span class="lineNum">     552 </span>            :  *      available at http://www.vesa.org
<span class="lineNum">     553 </span>            :  *
<span class="lineNum">     554 </span>            :  * And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
<span class="lineNum">     555 </span>            :  * What I have done is to translate it by using integer calculation.
<span class="lineNum">     556 </span>            :  * I also refer to the function of fb_get_mode in the file of
<span class="lineNum">     557 </span>            :  * drivers/video/fbmon.c
<span class="lineNum">     558 </span>            :  *
<span class="lineNum">     559 </span>            :  * Standard GTF parameters:
<span class="lineNum">     560 </span>            :  * M = 600
<span class="lineNum">     561 </span>            :  * C = 40
<span class="lineNum">     562 </span>            :  * K = 128
<span class="lineNum">     563 </span>            :  * J = 20
<span class="lineNum">     564 </span>            :  *
<span class="lineNum">     565 </span>            :  * Returns:
<span class="lineNum">     566 </span>            :  * The modeline based on the GTF algorithm stored in a drm_display_mode object.
<span class="lineNum">     567 </span>            :  * The display mode object is allocated with drm_mode_create(). Returns NULL
<span class="lineNum">     568 </span>            :  * when no mode could be allocated.
<a name="569"><span class="lineNum">     569 </span>            :  */</a>
<span class="lineNum">     570 </span>            : struct drm_display_mode *
<span class="lineNum">     571 </span><span class="lineNoCov">          0 : drm_gtf_mode(struct drm_device *dev, int hdisplay, int vdisplay, int vrefresh,</span>
<span class="lineNum">     572 </span>            :              bool interlaced, int margins)
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         return drm_gtf_mode_complex(dev, hdisplay, vdisplay, vrefresh,</span>
<span class="lineNum">     575 </span>            :                                     interlaced, margins,
<span class="lineNum">     576 </span>            :                                     600, 40 * 2, 128, 20 * 2);
<span class="lineNum">     577 </span>            : }
<span class="lineNum">     578 </span>            : EXPORT_SYMBOL(drm_gtf_mode);
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            : #ifdef CONFIG_VIDEOMODE_HELPERS
<span class="lineNum">     581 </span>            : /**
<span class="lineNum">     582 </span>            :  * drm_display_mode_from_videomode - fill in @dmode using @vm,
<span class="lineNum">     583 </span>            :  * @vm: videomode structure to use as source
<span class="lineNum">     584 </span>            :  * @dmode: drm_display_mode structure to use as destination
<span class="lineNum">     585 </span>            :  *
<span class="lineNum">     586 </span>            :  * Fills out @dmode using the display mode specified in @vm.
<span class="lineNum">     587 </span>            :  */
<span class="lineNum">     588 </span>            : void drm_display_mode_from_videomode(const struct videomode *vm,
<span class="lineNum">     589 </span>            :                                      struct drm_display_mode *dmode)
<span class="lineNum">     590 </span>            : {
<span class="lineNum">     591 </span>            :         dmode-&gt;hdisplay = vm-&gt;hactive;
<span class="lineNum">     592 </span>            :         dmode-&gt;hsync_start = dmode-&gt;hdisplay + vm-&gt;hfront_porch;
<span class="lineNum">     593 </span>            :         dmode-&gt;hsync_end = dmode-&gt;hsync_start + vm-&gt;hsync_len;
<span class="lineNum">     594 </span>            :         dmode-&gt;htotal = dmode-&gt;hsync_end + vm-&gt;hback_porch;
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :         dmode-&gt;vdisplay = vm-&gt;vactive;
<span class="lineNum">     597 </span>            :         dmode-&gt;vsync_start = dmode-&gt;vdisplay + vm-&gt;vfront_porch;
<span class="lineNum">     598 </span>            :         dmode-&gt;vsync_end = dmode-&gt;vsync_start + vm-&gt;vsync_len;
<span class="lineNum">     599 </span>            :         dmode-&gt;vtotal = dmode-&gt;vsync_end + vm-&gt;vback_porch;
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :         dmode-&gt;clock = vm-&gt;pixelclock / 1000;
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :         dmode-&gt;flags = 0;
<span class="lineNum">     604 </span>            :         if (vm-&gt;flags &amp; DISPLAY_FLAGS_HSYNC_HIGH)
<span class="lineNum">     605 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_PHSYNC;
<span class="lineNum">     606 </span>            :         else if (vm-&gt;flags &amp; DISPLAY_FLAGS_HSYNC_LOW)
<span class="lineNum">     607 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_NHSYNC;
<span class="lineNum">     608 </span>            :         if (vm-&gt;flags &amp; DISPLAY_FLAGS_VSYNC_HIGH)
<span class="lineNum">     609 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_PVSYNC;
<span class="lineNum">     610 </span>            :         else if (vm-&gt;flags &amp; DISPLAY_FLAGS_VSYNC_LOW)
<span class="lineNum">     611 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_NVSYNC;
<span class="lineNum">     612 </span>            :         if (vm-&gt;flags &amp; DISPLAY_FLAGS_INTERLACED)
<span class="lineNum">     613 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_INTERLACE;
<span class="lineNum">     614 </span>            :         if (vm-&gt;flags &amp; DISPLAY_FLAGS_DOUBLESCAN)
<span class="lineNum">     615 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_DBLSCAN;
<span class="lineNum">     616 </span>            :         if (vm-&gt;flags &amp; DISPLAY_FLAGS_DOUBLECLK)
<span class="lineNum">     617 </span>            :                 dmode-&gt;flags |= DRM_MODE_FLAG_DBLCLK;
<span class="lineNum">     618 </span>            :         drm_mode_set_name(dmode);
<span class="lineNum">     619 </span>            : }
<span class="lineNum">     620 </span>            : EXPORT_SYMBOL_GPL(drm_display_mode_from_videomode);
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            : /**
<span class="lineNum">     623 </span>            :  * drm_display_mode_to_videomode - fill in @vm using @dmode,
<span class="lineNum">     624 </span>            :  * @dmode: drm_display_mode structure to use as source
<span class="lineNum">     625 </span>            :  * @vm: videomode structure to use as destination
<span class="lineNum">     626 </span>            :  *
<span class="lineNum">     627 </span>            :  * Fills out @vm using the display mode specified in @dmode.
<span class="lineNum">     628 </span>            :  */
<span class="lineNum">     629 </span>            : void drm_display_mode_to_videomode(const struct drm_display_mode *dmode,
<span class="lineNum">     630 </span>            :                                    struct videomode *vm)
<span class="lineNum">     631 </span>            : {
<span class="lineNum">     632 </span>            :         vm-&gt;hactive = dmode-&gt;hdisplay;
<span class="lineNum">     633 </span>            :         vm-&gt;hfront_porch = dmode-&gt;hsync_start - dmode-&gt;hdisplay;
<span class="lineNum">     634 </span>            :         vm-&gt;hsync_len = dmode-&gt;hsync_end - dmode-&gt;hsync_start;
<span class="lineNum">     635 </span>            :         vm-&gt;hback_porch = dmode-&gt;htotal - dmode-&gt;hsync_end;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :         vm-&gt;vactive = dmode-&gt;vdisplay;
<span class="lineNum">     638 </span>            :         vm-&gt;vfront_porch = dmode-&gt;vsync_start - dmode-&gt;vdisplay;
<span class="lineNum">     639 </span>            :         vm-&gt;vsync_len = dmode-&gt;vsync_end - dmode-&gt;vsync_start;
<span class="lineNum">     640 </span>            :         vm-&gt;vback_porch = dmode-&gt;vtotal - dmode-&gt;vsync_end;
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :         vm-&gt;pixelclock = dmode-&gt;clock * 1000;
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :         vm-&gt;flags = 0;
<span class="lineNum">     645 </span>            :         if (dmode-&gt;flags &amp; DRM_MODE_FLAG_PHSYNC)
<span class="lineNum">     646 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_HSYNC_HIGH;
<span class="lineNum">     647 </span>            :         else if (dmode-&gt;flags &amp; DRM_MODE_FLAG_NHSYNC)
<span class="lineNum">     648 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_HSYNC_LOW;
<span class="lineNum">     649 </span>            :         if (dmode-&gt;flags &amp; DRM_MODE_FLAG_PVSYNC)
<span class="lineNum">     650 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_VSYNC_HIGH;
<span class="lineNum">     651 </span>            :         else if (dmode-&gt;flags &amp; DRM_MODE_FLAG_NVSYNC)
<span class="lineNum">     652 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_VSYNC_LOW;
<span class="lineNum">     653 </span>            :         if (dmode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
<span class="lineNum">     654 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_INTERLACED;
<span class="lineNum">     655 </span>            :         if (dmode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)
<span class="lineNum">     656 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_DOUBLESCAN;
<span class="lineNum">     657 </span>            :         if (dmode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)
<span class="lineNum">     658 </span>            :                 vm-&gt;flags |= DISPLAY_FLAGS_DOUBLECLK;
<span class="lineNum">     659 </span>            : }
<span class="lineNum">     660 </span>            : EXPORT_SYMBOL_GPL(drm_display_mode_to_videomode);
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : #ifdef CONFIG_OF
<span class="lineNum">     663 </span>            : /**
<span class="lineNum">     664 </span>            :  * of_get_drm_display_mode - get a drm_display_mode from devicetree
<span class="lineNum">     665 </span>            :  * @np: device_node with the timing specification
<span class="lineNum">     666 </span>            :  * @dmode: will be set to the return value
<span class="lineNum">     667 </span>            :  * @index: index into the list of display timings in devicetree
<span class="lineNum">     668 </span>            :  *
<span class="lineNum">     669 </span>            :  * This function is expensive and should only be used, if only one mode is to be
<span class="lineNum">     670 </span>            :  * read from DT. To get multiple modes start with of_get_display_timings and
<span class="lineNum">     671 </span>            :  * work with that instead.
<span class="lineNum">     672 </span>            :  *
<span class="lineNum">     673 </span>            :  * Returns:
<span class="lineNum">     674 </span>            :  * 0 on success, a negative errno code when no of videomode node was found.
<span class="lineNum">     675 </span>            :  */
<span class="lineNum">     676 </span>            : int of_get_drm_display_mode(struct device_node *np,
<span class="lineNum">     677 </span>            :                             struct drm_display_mode *dmode, int index)
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span>            :         struct videomode vm;
<span class="lineNum">     680 </span>            :         int ret;
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            :         ret = of_get_videomode(np, &amp;vm, index);
<span class="lineNum">     683 </span>            :         if (ret)
<span class="lineNum">     684 </span>            :                 return ret;
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :         drm_display_mode_from_videomode(&amp;vm, dmode);
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :         pr_debug(&quot;%s: got %dx%d display mode from %s\n&quot;,
<span class="lineNum">     689 </span>            :                 of_node_full_name(np), vm.hactive, vm.vactive, np-&gt;name);
<span class="lineNum">     690 </span>            :         drm_mode_debug_printmodeline(dmode);
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :         return 0;
<span class="lineNum">     693 </span>            : }
<span class="lineNum">     694 </span>            : EXPORT_SYMBOL_GPL(of_get_drm_display_mode);
<span class="lineNum">     695 </span>            : #endif /* CONFIG_OF */
<span class="lineNum">     696 </span>            : #endif /* CONFIG_VIDEOMODE_HELPERS */
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : /**
<span class="lineNum">     699 </span>            :  * drm_mode_set_name - set the name on a mode
<span class="lineNum">     700 </span>            :  * @mode: name will be set in this mode
<span class="lineNum">     701 </span>            :  *
<span class="lineNum">     702 </span>            :  * Set the name of @mode to a standard format which is &lt;hdisplay&gt;x&lt;vdisplay&gt;
<a name="703"><span class="lineNum">     703 </span>            :  * with an optional 'i' suffix for interlaced modes.</a>
<span class="lineNum">     704 </span>            :  */
<span class="lineNum">     705 </span><span class="lineNoCov">          0 : void drm_mode_set_name(struct drm_display_mode *mode)</span>
<span class="lineNum">     706 </span>            : {
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         bool interlaced = !!(mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE);</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         snprintf(mode-&gt;name, DRM_DISPLAY_MODE_LEN, &quot;%dx%d%s&quot;,</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                  mode-&gt;hdisplay, mode-&gt;vdisplay,</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                  interlaced ? &quot;i&quot; : &quot;&quot;);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     713 </span>            : EXPORT_SYMBOL(drm_mode_set_name);
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            : /** drm_mode_hsync - get the hsync of a mode
<span class="lineNum">     716 </span>            :  * @mode: mode
<span class="lineNum">     717 </span>            :  *
<span class="lineNum">     718 </span>            :  * Returns:
<span class="lineNum">     719 </span>            :  * @modes's hsync rate in kHz, rounded to the nearest integer. Calculates the
<a name="720"><span class="lineNum">     720 </span>            :  * value first if it is not yet set.</a>
<span class="lineNum">     721 </span>            :  */
<span class="lineNum">     722 </span><span class="lineNoCov">          0 : int drm_mode_hsync(const struct drm_display_mode *mode)</span>
<span class="lineNum">     723 </span>            : {
<span class="lineNum">     724 </span>            :         unsigned int calc_val;
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         if (mode-&gt;hsync)</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :                 return mode-&gt;hsync;</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :         if (mode-&gt;htotal &lt; 0)</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         calc_val = (mode-&gt;clock * 1000) / mode-&gt;htotal; /* hsync in Hz */</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         calc_val += 500;                                /* round to 1000Hz */</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         calc_val /= 1000;                               /* truncate to kHz */</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :         return calc_val;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     738 </span>            : EXPORT_SYMBOL(drm_mode_hsync);
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : /**
<span class="lineNum">     741 </span>            :  * drm_mode_vrefresh - get the vrefresh of a mode
<span class="lineNum">     742 </span>            :  * @mode: mode
<span class="lineNum">     743 </span>            :  *
<span class="lineNum">     744 </span>            :  * Returns:
<span class="lineNum">     745 </span>            :  * @modes's vrefresh rate in Hz, rounded to the nearest integer. Calculates the
<a name="746"><span class="lineNum">     746 </span>            :  * value first if it is not yet set.</a>
<span class="lineNum">     747 </span>            :  */
<span class="lineNum">     748 </span><span class="lineNoCov">          0 : int drm_mode_vrefresh(const struct drm_display_mode *mode)</span>
<span class="lineNum">     749 </span>            : {
<span class="lineNum">     750 </span>            :         int refresh = 0;
<span class="lineNum">     751 </span>            :         unsigned int calc_val;
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         if (mode-&gt;vrefresh &gt; 0)</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :                 refresh = mode-&gt;vrefresh;</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         else if (mode-&gt;htotal &gt; 0 &amp;&amp; mode-&gt;vtotal &gt; 0) {</span>
<span class="lineNum">     756 </span>            :                 int vtotal;
<span class="lineNum">     757 </span>            :                 vtotal = mode-&gt;vtotal;
<span class="lineNum">     758 </span>            :                 /* work out vrefresh the value will be x1000 */
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                 calc_val = (mode-&gt;clock * 1000);</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :                 calc_val /= mode-&gt;htotal;</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :                 refresh = (calc_val + vtotal / 2) / vtotal;</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                 if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :                         refresh *= 2;</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                 if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                         refresh /= 2;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :                 if (mode-&gt;vscan &gt; 1)</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :                         refresh /= mode-&gt;vscan;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         return refresh;</span>
<span class="lineNum">     771 </span>            : }
<span class="lineNum">     772 </span>            : EXPORT_SYMBOL(drm_mode_vrefresh);
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : /**
<span class="lineNum">     775 </span>            :  * drm_mode_set_crtcinfo - set CRTC modesetting timing parameters
<span class="lineNum">     776 </span>            :  * @p: mode
<span class="lineNum">     777 </span>            :  * @adjust_flags: a combination of adjustment flags
<span class="lineNum">     778 </span>            :  *
<span class="lineNum">     779 </span>            :  * Setup the CRTC modesetting timing parameters for @p, adjusting if necessary.
<span class="lineNum">     780 </span>            :  *
<span class="lineNum">     781 </span>            :  * - The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
<span class="lineNum">     782 </span>            :  *   interlaced modes.
<span class="lineNum">     783 </span>            :  * - The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
<span class="lineNum">     784 </span>            :  *   buffers containing two eyes (only adjust the timings when needed, eg. for
<span class="lineNum">     785 </span>            :  *   &quot;frame packing&quot; or &quot;side by side full&quot;).
<span class="lineNum">     786 </span>            :  * - The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment *not*
<a name="787"><span class="lineNum">     787 </span>            :  *   be performed for doublescan and vscan &gt; 1 modes respectively.</a>
<span class="lineNum">     788 </span>            :  */
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : void drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)</span>
<span class="lineNum">     790 </span>            : {
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         if ((p == NULL) || ((p-&gt;type &amp; DRM_MODE_TYPE_CRTC_C) == DRM_MODE_TYPE_BUILTIN))</span>
<span class="lineNum">     792 </span>            :                 return;
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         p-&gt;crtc_clock = p-&gt;clock;</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         p-&gt;crtc_hdisplay = p-&gt;hdisplay;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         p-&gt;crtc_hsync_start = p-&gt;hsync_start;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         p-&gt;crtc_hsync_end = p-&gt;hsync_end;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         p-&gt;crtc_htotal = p-&gt;htotal;</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         p-&gt;crtc_hskew = p-&gt;hskew;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         p-&gt;crtc_vdisplay = p-&gt;vdisplay;</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         p-&gt;crtc_vsync_start = p-&gt;vsync_start;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         p-&gt;crtc_vsync_end = p-&gt;vsync_end;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         p-&gt;crtc_vtotal = p-&gt;vtotal;</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         if (p-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE) {</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                 if (adjust_flags &amp; CRTC_INTERLACE_HALVE_V) {</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vdisplay /= 2;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_start /= 2;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_end /= 2;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vtotal /= 2;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     812 </span>            :         }
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         if (!(adjust_flags &amp; CRTC_NO_DBLSCAN)) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                 if (p-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN) {</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vdisplay *= 2;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_start *= 2;</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_end *= 2;</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vtotal *= 2;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     821 </span>            :         }
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         if (!(adjust_flags &amp; CRTC_NO_VSCAN)) {</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                 if (p-&gt;vscan &gt; 1) {</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vdisplay *= p-&gt;vscan;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_start *= p-&gt;vscan;</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_end *= p-&gt;vscan;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vtotal *= p-&gt;vscan;</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     830 </span>            :         }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :         if (adjust_flags &amp; CRTC_STEREO_DOUBLE) {</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :                 unsigned int layout = p-&gt;flags &amp; DRM_MODE_FLAG_3D_MASK;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                 switch (layout) {</span>
<span class="lineNum">     836 </span>            :                 case DRM_MODE_FLAG_3D_FRAME_PACKING:
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_clock *= 2;</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vdisplay += p-&gt;crtc_vtotal;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_start += p-&gt;crtc_vtotal;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vsync_end += p-&gt;crtc_vtotal;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                         p-&gt;crtc_vtotal += p-&gt;crtc_vtotal;</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     843 </span>            :                 }
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :         p-&gt;crtc_vblank_start = min(p-&gt;crtc_vsync_start, p-&gt;crtc_vdisplay);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         p-&gt;crtc_vblank_end = max(p-&gt;crtc_vsync_end, p-&gt;crtc_vtotal);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         p-&gt;crtc_hblank_start = min(p-&gt;crtc_hsync_start, p-&gt;crtc_hdisplay);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :         p-&gt;crtc_hblank_end = max(p-&gt;crtc_hsync_end, p-&gt;crtc_htotal);</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     851 </span>            : EXPORT_SYMBOL(drm_mode_set_crtcinfo);
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : /**
<span class="lineNum">     854 </span>            :  * drm_mode_copy - copy the mode
<span class="lineNum">     855 </span>            :  * @dst: mode to overwrite
<span class="lineNum">     856 </span>            :  * @src: mode to copy
<span class="lineNum">     857 </span>            :  *
<span class="lineNum">     858 </span>            :  * Copy an existing mode into another mode, preserving the object id and
<a name="859"><span class="lineNum">     859 </span>            :  * list head of the destination mode.</a>
<span class="lineNum">     860 </span>            :  */
<span class="lineNum">     861 </span><span class="lineNoCov">          0 : void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src)</span>
<span class="lineNum">     862 </span>            : {
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :         int id = dst-&gt;base.id;</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         struct list_head head = dst-&gt;head;</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :         *dst = *src;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         dst-&gt;base.id = id;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         dst-&gt;head = head;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     870 </span>            : EXPORT_SYMBOL(drm_mode_copy);
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            : /**
<span class="lineNum">     873 </span>            :  * drm_mode_duplicate - allocate and duplicate an existing mode
<span class="lineNum">     874 </span>            :  * @dev: drm_device to allocate the duplicated mode for
<span class="lineNum">     875 </span>            :  * @mode: mode to duplicate
<span class="lineNum">     876 </span>            :  *
<span class="lineNum">     877 </span>            :  * Just allocate a new mode, copy the existing mode into it, and return
<span class="lineNum">     878 </span>            :  * a pointer to it.  Used to create new instances of established modes.
<span class="lineNum">     879 </span>            :  *
<span class="lineNum">     880 </span>            :  * Returns:
<a name="881"><span class="lineNum">     881 </span>            :  * Pointer to duplicated mode on success, NULL on error.</a>
<span class="lineNum">     882 </span>            :  */
<span class="lineNum">     883 </span><span class="lineNoCov">          0 : struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,</span>
<span class="lineNum">     884 </span>            :                                             const struct drm_display_mode *mode)
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span>            :         struct drm_display_mode *nmode;
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         nmode = drm_mode_create(dev);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         if (!nmode)</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         drm_mode_copy(nmode, mode);</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         return nmode;</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     896 </span>            : EXPORT_SYMBOL(drm_mode_duplicate);
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            : /**
<span class="lineNum">     899 </span>            :  * drm_mode_equal - test modes for equality
<span class="lineNum">     900 </span>            :  * @mode1: first mode
<span class="lineNum">     901 </span>            :  * @mode2: second mode
<span class="lineNum">     902 </span>            :  *
<span class="lineNum">     903 </span>            :  * Check to see if @mode1 and @mode2 are equivalent.
<span class="lineNum">     904 </span>            :  *
<span class="lineNum">     905 </span>            :  * Returns:
<a name="906"><span class="lineNum">     906 </span>            :  * True if the modes are equal, false otherwise.</a>
<span class="lineNum">     907 </span>            :  */
<span class="lineNum">     908 </span><span class="lineNoCov">          0 : bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2)</span>
<span class="lineNum">     909 </span>            : {
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         if (!mode1 &amp;&amp; !mode2)</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :         if (!mode1 || !mode2)</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :         /* do clock check convert to PICOS so fb modes get matched
<span class="lineNum">     917 </span>            :          * the same */
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         if (mode1-&gt;clock &amp;&amp; mode2-&gt;clock) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 if (KHZ2PICOS(mode1-&gt;clock) != KHZ2PICOS(mode2-&gt;clock))</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :         } else if (mode1-&gt;clock != mode2-&gt;clock)</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         if ((mode1-&gt;flags &amp; DRM_MODE_FLAG_3D_MASK) !=</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :             (mode2-&gt;flags &amp; DRM_MODE_FLAG_3D_MASK))</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         return drm_mode_equal_no_clocks_no_stereo(mode1, mode2);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     930 </span>            : EXPORT_SYMBOL(drm_mode_equal);
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            : /**
<span class="lineNum">     933 </span>            :  * drm_mode_equal_no_clocks_no_stereo - test modes for equality
<span class="lineNum">     934 </span>            :  * @mode1: first mode
<span class="lineNum">     935 </span>            :  * @mode2: second mode
<span class="lineNum">     936 </span>            :  *
<span class="lineNum">     937 </span>            :  * Check to see if @mode1 and @mode2 are equivalent, but
<span class="lineNum">     938 </span>            :  * don't check the pixel clocks nor the stereo layout.
<span class="lineNum">     939 </span>            :  *
<span class="lineNum">     940 </span>            :  * Returns:
<a name="941"><span class="lineNum">     941 </span>            :  * True if the modes are equal, false otherwise.</a>
<span class="lineNum">     942 </span>            :  */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 : bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,</span>
<span class="lineNum">     944 </span>            :                                         const struct drm_display_mode *mode2)
<span class="lineNum">     945 </span>            : {
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         if (mode1-&gt;hdisplay == mode2-&gt;hdisplay &amp;&amp;</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :             mode1-&gt;hsync_start == mode2-&gt;hsync_start &amp;&amp;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :             mode1-&gt;hsync_end == mode2-&gt;hsync_end &amp;&amp;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :             mode1-&gt;htotal == mode2-&gt;htotal &amp;&amp;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :             mode1-&gt;hskew == mode2-&gt;hskew &amp;&amp;</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :             mode1-&gt;vdisplay == mode2-&gt;vdisplay &amp;&amp;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :             mode1-&gt;vsync_start == mode2-&gt;vsync_start &amp;&amp;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :             mode1-&gt;vsync_end == mode2-&gt;vsync_end &amp;&amp;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :             mode1-&gt;vtotal == mode2-&gt;vtotal &amp;&amp;</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :             mode1-&gt;vscan == mode2-&gt;vscan &amp;&amp;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :             (mode1-&gt;flags &amp; ~DRM_MODE_FLAG_3D_MASK) ==</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :              (mode2-&gt;flags &amp; ~DRM_MODE_FLAG_3D_MASK))</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     962 </span>            : EXPORT_SYMBOL(drm_mode_equal_no_clocks_no_stereo);
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            : /**
<span class="lineNum">     965 </span>            :  * drm_mode_validate_basic - make sure the mode is somewhat sane
<span class="lineNum">     966 </span>            :  * @mode: mode to check
<span class="lineNum">     967 </span>            :  *
<span class="lineNum">     968 </span>            :  * Check that the mode timings are at least somewhat reasonable.
<span class="lineNum">     969 </span>            :  * Any hardware specific limits are left up for each driver to check.
<span class="lineNum">     970 </span>            :  *
<span class="lineNum">     971 </span>            :  * Returns:
<span class="lineNum">     972 </span>            :  * The mode status
<a name="973"><span class="lineNum">     973 </span>            :  */</a>
<span class="lineNum">     974 </span>            : enum drm_mode_status
<span class="lineNum">     975 </span><span class="lineNoCov">          0 : drm_mode_validate_basic(const struct drm_display_mode *mode)</span>
<span class="lineNum">     976 </span>            : {
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         if (mode-&gt;clock == 0)</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 return MODE_CLOCK_LOW;</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         if (mode-&gt;hdisplay == 0 ||</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :             mode-&gt;hsync_start &lt; mode-&gt;hdisplay ||</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :             mode-&gt;hsync_end &lt; mode-&gt;hsync_start ||</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :             mode-&gt;htotal &lt; mode-&gt;hsync_end)</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 return MODE_H_ILLEGAL;</span>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :         if (mode-&gt;vdisplay == 0 ||</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :             mode-&gt;vsync_start &lt; mode-&gt;vdisplay ||</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :             mode-&gt;vsync_end &lt; mode-&gt;vsync_start ||</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :             mode-&gt;vtotal &lt; mode-&gt;vsync_end)</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :                 return MODE_V_ILLEGAL;</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         return MODE_OK;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     994 </span>            : EXPORT_SYMBOL(drm_mode_validate_basic);
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            : /**
<span class="lineNum">     997 </span>            :  * drm_mode_validate_size - make sure modes adhere to size constraints
<span class="lineNum">     998 </span>            :  * @mode: mode to check
<span class="lineNum">     999 </span>            :  * @maxX: maximum width
<span class="lineNum">    1000 </span>            :  * @maxY: maximum height
<span class="lineNum">    1001 </span>            :  *
<span class="lineNum">    1002 </span>            :  * This function is a helper which can be used to validate modes against size
<span class="lineNum">    1003 </span>            :  * limitations of the DRM device/connector. If a mode is too big its status
<span class="lineNum">    1004 </span>            :  * member is updated with the appropriate validation failure code. The list
<span class="lineNum">    1005 </span>            :  * itself is not changed.
<span class="lineNum">    1006 </span>            :  *
<span class="lineNum">    1007 </span>            :  * Returns:
<span class="lineNum">    1008 </span>            :  * The mode status
<a name="1009"><span class="lineNum">    1009 </span>            :  */</a>
<span class="lineNum">    1010 </span>            : enum drm_mode_status
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 : drm_mode_validate_size(const struct drm_display_mode *mode,</span>
<span class="lineNum">    1012 </span>            :                        int maxX, int maxY)
<span class="lineNum">    1013 </span>            : {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         if (maxX &gt; 0 &amp;&amp; mode-&gt;hdisplay &gt; maxX)</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                 return MODE_VIRTUAL_X;</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         if (maxY &gt; 0 &amp;&amp; mode-&gt;vdisplay &gt; maxY)</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                 return MODE_VIRTUAL_Y;</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :         return MODE_OK;</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1022 </span>            : EXPORT_SYMBOL(drm_mode_validate_size);
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            : #ifdef DRMDEBUG
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : #define MODE_STATUS(status) [MODE_ ## status + 3] = #status
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : static const char * const drm_mode_status_names[] = {
<span class="lineNum">    1029 </span>            :         MODE_STATUS(OK),
<span class="lineNum">    1030 </span>            :         MODE_STATUS(HSYNC),
<span class="lineNum">    1031 </span>            :         MODE_STATUS(VSYNC),
<span class="lineNum">    1032 </span>            :         MODE_STATUS(H_ILLEGAL),
<span class="lineNum">    1033 </span>            :         MODE_STATUS(V_ILLEGAL),
<span class="lineNum">    1034 </span>            :         MODE_STATUS(BAD_WIDTH),
<span class="lineNum">    1035 </span>            :         MODE_STATUS(NOMODE),
<span class="lineNum">    1036 </span>            :         MODE_STATUS(NO_INTERLACE),
<span class="lineNum">    1037 </span>            :         MODE_STATUS(NO_DBLESCAN),
<span class="lineNum">    1038 </span>            :         MODE_STATUS(NO_VSCAN),
<span class="lineNum">    1039 </span>            :         MODE_STATUS(MEM),
<span class="lineNum">    1040 </span>            :         MODE_STATUS(VIRTUAL_X),
<span class="lineNum">    1041 </span>            :         MODE_STATUS(VIRTUAL_Y),
<span class="lineNum">    1042 </span>            :         MODE_STATUS(MEM_VIRT),
<span class="lineNum">    1043 </span>            :         MODE_STATUS(NOCLOCK),
<span class="lineNum">    1044 </span>            :         MODE_STATUS(CLOCK_HIGH),
<span class="lineNum">    1045 </span>            :         MODE_STATUS(CLOCK_LOW),
<span class="lineNum">    1046 </span>            :         MODE_STATUS(CLOCK_RANGE),
<span class="lineNum">    1047 </span>            :         MODE_STATUS(BAD_HVALUE),
<span class="lineNum">    1048 </span>            :         MODE_STATUS(BAD_VVALUE),
<span class="lineNum">    1049 </span>            :         MODE_STATUS(BAD_VSCAN),
<span class="lineNum">    1050 </span>            :         MODE_STATUS(HSYNC_NARROW),
<span class="lineNum">    1051 </span>            :         MODE_STATUS(HSYNC_WIDE),
<span class="lineNum">    1052 </span>            :         MODE_STATUS(HBLANK_NARROW),
<span class="lineNum">    1053 </span>            :         MODE_STATUS(HBLANK_WIDE),
<span class="lineNum">    1054 </span>            :         MODE_STATUS(VSYNC_NARROW),
<span class="lineNum">    1055 </span>            :         MODE_STATUS(VSYNC_WIDE),
<span class="lineNum">    1056 </span>            :         MODE_STATUS(VBLANK_NARROW),
<span class="lineNum">    1057 </span>            :         MODE_STATUS(VBLANK_WIDE),
<span class="lineNum">    1058 </span>            :         MODE_STATUS(PANEL),
<span class="lineNum">    1059 </span>            :         MODE_STATUS(INTERLACE_WIDTH),
<span class="lineNum">    1060 </span>            :         MODE_STATUS(ONE_WIDTH),
<span class="lineNum">    1061 </span>            :         MODE_STATUS(ONE_HEIGHT),
<span class="lineNum">    1062 </span>            :         MODE_STATUS(ONE_SIZE),
<span class="lineNum">    1063 </span>            :         MODE_STATUS(NO_REDUCED),
<span class="lineNum">    1064 </span>            :         MODE_STATUS(NO_STEREO),
<span class="lineNum">    1065 </span>            :         MODE_STATUS(UNVERIFIED),
<span class="lineNum">    1066 </span>            :         MODE_STATUS(BAD),
<span class="lineNum">    1067 </span>            :         MODE_STATUS(ERROR),
<span class="lineNum">    1068 </span>            : };
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            : #undef MODE_STATUS
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            : static const char *drm_get_mode_status_name(enum drm_mode_status status)
<span class="lineNum">    1073 </span>            : {
<span class="lineNum">    1074 </span>            :         int index = status + 3;
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            :         if (WARN_ON(index &lt; 0 || index &gt;= ARRAY_SIZE(drm_mode_status_names)))
<span class="lineNum">    1077 </span>            :                 return &quot;&quot;;
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :         return drm_mode_status_names[index];
<span class="lineNum">    1080 </span>            : }
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            : #endif
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : /**
<span class="lineNum">    1085 </span>            :  * drm_mode_prune_invalid - remove invalid modes from mode list
<span class="lineNum">    1086 </span>            :  * @dev: DRM device
<span class="lineNum">    1087 </span>            :  * @mode_list: list of modes to check
<span class="lineNum">    1088 </span>            :  * @verbose: be verbose about it
<span class="lineNum">    1089 </span>            :  *
<span class="lineNum">    1090 </span>            :  * This helper function can be used to prune a display mode list after
<span class="lineNum">    1091 </span>            :  * validation has been completed. All modes who's status is not MODE_OK will be
<span class="lineNum">    1092 </span>            :  * removed from the list, and if @verbose the status code and mode name is also
<a name="1093"><span class="lineNum">    1093 </span>            :  * printed to dmesg.</a>
<span class="lineNum">    1094 </span>            :  */
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 : void drm_mode_prune_invalid(struct drm_device *dev,</span>
<span class="lineNum">    1096 </span>            :                             struct list_head *mode_list, bool verbose)
<span class="lineNum">    1097 </span>            : {
<span class="lineNum">    1098 </span>            :         struct drm_display_mode *mode, *t;
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         list_for_each_entry_safe(mode, t, mode_list, head) {</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                 if (mode-&gt;status != MODE_OK) {</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :                         list_del(&amp;mode-&gt;head);</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                         if (verbose) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                                 drm_mode_debug_printmodeline(mode);</span>
<span class="lineNum">    1105 </span>            :                                 DRM_DEBUG_KMS(&quot;Not using %s mode: %s\n&quot;,
<span class="lineNum">    1106 </span>            :                                               mode-&gt;name,
<span class="lineNum">    1107 </span>            :                                               drm_get_mode_status_name(mode-&gt;status));
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :                         drm_mode_destroy(dev, mode);</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1111 </span>            :         }
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1113 </span>            : EXPORT_SYMBOL(drm_mode_prune_invalid);
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            : /**
<span class="lineNum">    1116 </span>            :  * drm_mode_compare - compare modes for favorability
<span class="lineNum">    1117 </span>            :  * @priv: unused
<span class="lineNum">    1118 </span>            :  * @lh_a: list_head for first mode
<span class="lineNum">    1119 </span>            :  * @lh_b: list_head for second mode
<span class="lineNum">    1120 </span>            :  *
<span class="lineNum">    1121 </span>            :  * Compare two modes, given by @lh_a and @lh_b, returning a value indicating
<span class="lineNum">    1122 </span>            :  * which is better.
<span class="lineNum">    1123 </span>            :  *
<span class="lineNum">    1124 </span>            :  * Returns:
<span class="lineNum">    1125 </span>            :  * Negative if @lh_a is better than @lh_b, zero if they're equivalent, or
<a name="1126"><span class="lineNum">    1126 </span>            :  * positive if @lh_b is better than @lh_a.</a>
<span class="lineNum">    1127 </span>            :  */
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 : static int drm_mode_compare(void *priv, struct list_head *lh_a, struct list_head *lh_b)</span>
<span class="lineNum">    1129 </span>            : {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         struct drm_display_mode *a = list_entry(lh_a, struct drm_display_mode, head);</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :         struct drm_display_mode *b = list_entry(lh_b, struct drm_display_mode, head);</span>
<span class="lineNum">    1132 </span>            :         int diff;
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         diff = ((b-&gt;type &amp; DRM_MODE_TYPE_PREFERRED) != 0) -</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :                 ((a-&gt;type &amp; DRM_MODE_TYPE_PREFERRED) != 0);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         if (diff)</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                 return diff;</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :         diff = b-&gt;hdisplay * b-&gt;vdisplay - a-&gt;hdisplay * a-&gt;vdisplay;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         if (diff)</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                 return diff;</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :         diff = b-&gt;vrefresh - a-&gt;vrefresh;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :         if (diff)</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 return diff;</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         diff = b-&gt;clock - a-&gt;clock;</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :         return diff;</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            : /**
<span class="lineNum">    1151 </span>            :  * drm_mode_sort - sort mode list
<span class="lineNum">    1152 </span>            :  * @mode_list: list of drm_display_mode structures to sort
<span class="lineNum">    1153 </span>            :  *
<a name="1154"><span class="lineNum">    1154 </span>            :  * Sort @mode_list by favorability, moving good modes to the head of the list.</a>
<span class="lineNum">    1155 </span>            :  */
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 : void drm_mode_sort(struct list_head *mode_list)</span>
<span class="lineNum">    1157 </span>            : {
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         list_sort(NULL, mode_list, drm_mode_compare);</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1160 </span>            : EXPORT_SYMBOL(drm_mode_sort);
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            : /**
<span class="lineNum">    1163 </span>            :  * drm_mode_connector_list_update - update the mode list for the connector
<span class="lineNum">    1164 </span>            :  * @connector: the connector to update
<span class="lineNum">    1165 </span>            :  * @merge_type_bits: whether to merge or overwrite type bits
<span class="lineNum">    1166 </span>            :  *
<span class="lineNum">    1167 </span>            :  * This moves the modes from the @connector probed_modes list
<span class="lineNum">    1168 </span>            :  * to the actual mode list. It compares the probed mode against the current
<span class="lineNum">    1169 </span>            :  * list and only adds different/new modes.
<span class="lineNum">    1170 </span>            :  *
<span class="lineNum">    1171 </span>            :  * This is just a helper functions doesn't validate any modes itself and also
<a name="1172"><span class="lineNum">    1172 </span>            :  * doesn't prune any invalid modes. Callers need to do that themselves.</a>
<span class="lineNum">    1173 </span>            :  */
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 : void drm_mode_connector_list_update(struct drm_connector *connector,</span>
<span class="lineNum">    1175 </span>            :                                     bool merge_type_bits)
<span class="lineNum">    1176 </span>            : {
<span class="lineNum">    1177 </span>            :         struct drm_display_mode *mode;
<span class="lineNum">    1178 </span>            :         struct drm_display_mode *pmode, *pt;
<span class="lineNum">    1179 </span>            :         int found_it;
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :         WARN_ON(!mutex_is_locked(&amp;connector-&gt;dev-&gt;mode_config.mutex));</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         list_for_each_entry_safe(pmode, pt, &amp;connector-&gt;probed_modes,</span>
<span class="lineNum">    1184 </span>            :                                  head) {
<span class="lineNum">    1185 </span>            :                 found_it = 0;
<span class="lineNum">    1186 </span>            :                 /* go through current modes checking for the new probed mode */
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                 list_for_each_entry(mode, &amp;connector-&gt;modes, head) {</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                         if (drm_mode_equal(pmode, mode)) {</span>
<span class="lineNum">    1189 </span>            :                                 found_it = 1;
<span class="lineNum">    1190 </span>            :                                 /* if equal delete the probed mode */
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :                                 mode-&gt;status = pmode-&gt;status;</span>
<span class="lineNum">    1192 </span>            :                                 /* Merge type bits together */
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                                 if (merge_type_bits)</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                                         mode-&gt;type |= pmode-&gt;type;</span>
<span class="lineNum">    1195 </span>            :                                 else
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :                                         mode-&gt;type = pmode-&gt;type;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :                                 list_del(&amp;pmode-&gt;head);</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                                 drm_mode_destroy(connector-&gt;dev, pmode);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1200 </span>            :                         }
<span class="lineNum">    1201 </span>            :                 }
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                 if (!found_it) {</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                         list_move_tail(&amp;pmode-&gt;head, &amp;connector-&gt;modes);</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1206 </span>            :         }
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1208 </span>            : EXPORT_SYMBOL(drm_mode_connector_list_update);
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span>            : /**
<span class="lineNum">    1211 </span>            :  * drm_mode_parse_command_line_for_connector - parse command line modeline for connector
<span class="lineNum">    1212 </span>            :  * @mode_option: optional per connector mode option
<span class="lineNum">    1213 </span>            :  * @connector: connector to parse modeline for
<span class="lineNum">    1214 </span>            :  * @mode: preallocated drm_cmdline_mode structure to fill out
<span class="lineNum">    1215 </span>            :  *
<span class="lineNum">    1216 </span>            :  * This parses @mode_option command line modeline for modes and options to
<span class="lineNum">    1217 </span>            :  * configure the connector. If @mode_option is NULL the default command line
<span class="lineNum">    1218 </span>            :  * modeline in fb_mode_option will be parsed instead.
<span class="lineNum">    1219 </span>            :  *
<span class="lineNum">    1220 </span>            :  * This uses the same parameters as the fb modedb.c, except for an extra
<span class="lineNum">    1221 </span>            :  * force-enable, force-enable-digital and force-disable bit at the end:
<span class="lineNum">    1222 </span>            :  *
<span class="lineNum">    1223 </span>            :  *      &lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m][eDd]
<span class="lineNum">    1224 </span>            :  *
<span class="lineNum">    1225 </span>            :  * The intermediate drm_cmdline_mode structure is required to store additional
<span class="lineNum">    1226 </span>            :  * options from the command line modline like the force-enable/disable flag.
<span class="lineNum">    1227 </span>            :  *
<span class="lineNum">    1228 </span>            :  * Returns:
<a name="1229"><span class="lineNum">    1229 </span>            :  * True if a valid modeline has been parsed, false otherwise.</a>
<span class="lineNum">    1230 </span>            :  */
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 : bool drm_mode_parse_command_line_for_connector(const char *mode_option,</span>
<span class="lineNum">    1232 </span>            :                                                struct drm_connector *connector,
<span class="lineNum">    1233 </span>            :                                                struct drm_cmdline_mode *mode)
<span class="lineNum">    1234 </span>            : {
<span class="lineNum">    1235 </span>            : #ifdef __linux__
<span class="lineNum">    1236 </span>            :         const char *name;
<span class="lineNum">    1237 </span>            :         unsigned int namelen;
<span class="lineNum">    1238 </span>            :         bool res_specified = false, bpp_specified = false, refresh_specified = false;
<span class="lineNum">    1239 </span>            :         unsigned int xres = 0, yres = 0, bpp = 32, refresh = 0;
<span class="lineNum">    1240 </span>            :         bool yres_specified = false, cvt = false, rb = false;
<span class="lineNum">    1241 </span>            :         bool interlace = false, margins = false, was_digit = false;
<span class="lineNum">    1242 </span>            :         int i;
<span class="lineNum">    1243 </span>            :         enum drm_connector_force force = DRM_FORCE_UNSPECIFIED;
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : #ifdef CONFIG_FB
<span class="lineNum">    1246 </span>            :         if (!mode_option)
<span class="lineNum">    1247 </span>            :                 mode_option = fb_mode_option;
<span class="lineNum">    1248 </span>            : #endif
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :         if (!mode_option) {
<span class="lineNum">    1251 </span>            :                 mode-&gt;specified = false;
<span class="lineNum">    1252 </span>            :                 return false;
<span class="lineNum">    1253 </span>            :         }
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            :         name = mode_option;
<span class="lineNum">    1256 </span>            :         namelen = strlen(name);
<span class="lineNum">    1257 </span>            :         for (i = namelen-1; i &gt;= 0; i--) {
<span class="lineNum">    1258 </span>            :                 switch (name[i]) {
<span class="lineNum">    1259 </span>            :                 case '@':
<span class="lineNum">    1260 </span>            :                         if (!refresh_specified &amp;&amp; !bpp_specified &amp;&amp;
<span class="lineNum">    1261 </span>            :                             !yres_specified &amp;&amp; !cvt &amp;&amp; !rb &amp;&amp; was_digit) {
<span class="lineNum">    1262 </span>            :                                 refresh = simple_strtol(&amp;name[i+1], NULL, 10);
<span class="lineNum">    1263 </span>            :                                 refresh_specified = true;
<span class="lineNum">    1264 </span>            :                                 was_digit = false;
<span class="lineNum">    1265 </span>            :                         } else
<span class="lineNum">    1266 </span>            :                                 goto done;
<span class="lineNum">    1267 </span>            :                         break;
<span class="lineNum">    1268 </span>            :                 case '-':
<span class="lineNum">    1269 </span>            :                         if (!bpp_specified &amp;&amp; !yres_specified &amp;&amp; !cvt &amp;&amp;
<span class="lineNum">    1270 </span>            :                             !rb &amp;&amp; was_digit) {
<span class="lineNum">    1271 </span>            :                                 bpp = simple_strtol(&amp;name[i+1], NULL, 10);
<span class="lineNum">    1272 </span>            :                                 bpp_specified = true;
<span class="lineNum">    1273 </span>            :                                 was_digit = false;
<span class="lineNum">    1274 </span>            :                         } else
<span class="lineNum">    1275 </span>            :                                 goto done;
<span class="lineNum">    1276 </span>            :                         break;
<span class="lineNum">    1277 </span>            :                 case 'x':
<span class="lineNum">    1278 </span>            :                         if (!yres_specified &amp;&amp; was_digit) {
<span class="lineNum">    1279 </span>            :                                 yres = simple_strtol(&amp;name[i+1], NULL, 10);
<span class="lineNum">    1280 </span>            :                                 yres_specified = true;
<span class="lineNum">    1281 </span>            :                                 was_digit = false;
<span class="lineNum">    1282 </span>            :                         } else
<span class="lineNum">    1283 </span>            :                                 goto done;
<span class="lineNum">    1284 </span>            :                         break;
<span class="lineNum">    1285 </span>            :                 case '0' ... '9':
<span class="lineNum">    1286 </span>            :                         was_digit = true;
<span class="lineNum">    1287 </span>            :                         break;
<span class="lineNum">    1288 </span>            :                 case 'M':
<span class="lineNum">    1289 </span>            :                         if (yres_specified || cvt || was_digit)
<span class="lineNum">    1290 </span>            :                                 goto done;
<span class="lineNum">    1291 </span>            :                         cvt = true;
<span class="lineNum">    1292 </span>            :                         break;
<span class="lineNum">    1293 </span>            :                 case 'R':
<span class="lineNum">    1294 </span>            :                         if (yres_specified || cvt || rb || was_digit)
<span class="lineNum">    1295 </span>            :                                 goto done;
<span class="lineNum">    1296 </span>            :                         rb = true;
<span class="lineNum">    1297 </span>            :                         break;
<span class="lineNum">    1298 </span>            :                 case 'm':
<span class="lineNum">    1299 </span>            :                         if (cvt || yres_specified || was_digit)
<span class="lineNum">    1300 </span>            :                                 goto done;
<span class="lineNum">    1301 </span>            :                         margins = true;
<span class="lineNum">    1302 </span>            :                         break;
<span class="lineNum">    1303 </span>            :                 case 'i':
<span class="lineNum">    1304 </span>            :                         if (cvt || yres_specified || was_digit)
<span class="lineNum">    1305 </span>            :                                 goto done;
<span class="lineNum">    1306 </span>            :                         interlace = true;
<span class="lineNum">    1307 </span>            :                         break;
<span class="lineNum">    1308 </span>            :                 case 'e':
<span class="lineNum">    1309 </span>            :                         if (yres_specified || bpp_specified || refresh_specified ||
<span class="lineNum">    1310 </span>            :                             was_digit || (force != DRM_FORCE_UNSPECIFIED))
<span class="lineNum">    1311 </span>            :                                 goto done;
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            :                         force = DRM_FORCE_ON;
<span class="lineNum">    1314 </span>            :                         break;
<span class="lineNum">    1315 </span>            :                 case 'D':
<span class="lineNum">    1316 </span>            :                         if (yres_specified || bpp_specified || refresh_specified ||
<span class="lineNum">    1317 </span>            :                             was_digit || (force != DRM_FORCE_UNSPECIFIED))
<span class="lineNum">    1318 </span>            :                                 goto done;
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            :                         if ((connector-&gt;connector_type != DRM_MODE_CONNECTOR_DVII) &amp;&amp;
<span class="lineNum">    1321 </span>            :                             (connector-&gt;connector_type != DRM_MODE_CONNECTOR_HDMIB))
<span class="lineNum">    1322 </span>            :                                 force = DRM_FORCE_ON;
<span class="lineNum">    1323 </span>            :                         else
<span class="lineNum">    1324 </span>            :                                 force = DRM_FORCE_ON_DIGITAL;
<span class="lineNum">    1325 </span>            :                         break;
<span class="lineNum">    1326 </span>            :                 case 'd':
<span class="lineNum">    1327 </span>            :                         if (yres_specified || bpp_specified || refresh_specified ||
<span class="lineNum">    1328 </span>            :                             was_digit || (force != DRM_FORCE_UNSPECIFIED))
<span class="lineNum">    1329 </span>            :                                 goto done;
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            :                         force = DRM_FORCE_OFF;
<span class="lineNum">    1332 </span>            :                         break;
<span class="lineNum">    1333 </span>            :                 default:
<span class="lineNum">    1334 </span>            :                         goto done;
<span class="lineNum">    1335 </span>            :                 }
<span class="lineNum">    1336 </span>            :         }
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            :         if (i &lt; 0 &amp;&amp; yres_specified) {
<span class="lineNum">    1339 </span>            :                 char *ch;
<span class="lineNum">    1340 </span>            :                 xres = simple_strtol(name, &amp;ch, 10);
<span class="lineNum">    1341 </span>            :                 if ((ch != NULL) &amp;&amp; (*ch == 'x'))
<span class="lineNum">    1342 </span>            :                         res_specified = true;
<span class="lineNum">    1343 </span>            :                 else
<span class="lineNum">    1344 </span>            :                         i = ch - name;
<span class="lineNum">    1345 </span>            :         } else if (!yres_specified &amp;&amp; was_digit) {
<span class="lineNum">    1346 </span>            :                 /* catch mode that begins with digits but has no 'x' */
<span class="lineNum">    1347 </span>            :                 i = 0;
<span class="lineNum">    1348 </span>            :         }
<span class="lineNum">    1349 </span>            : done:
<span class="lineNum">    1350 </span>            :         if (i &gt;= 0) {
<span class="lineNum">    1351 </span>            :                 printk(KERN_WARNING
<span class="lineNum">    1352 </span>            :                         &quot;parse error at position %i in video mode '%s'\n&quot;,
<span class="lineNum">    1353 </span>            :                         i, name);
<span class="lineNum">    1354 </span>            :                 mode-&gt;specified = false;
<span class="lineNum">    1355 </span>            :                 return false;
<span class="lineNum">    1356 </span>            :         }
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            :         if (res_specified) {
<span class="lineNum">    1359 </span>            :                 mode-&gt;specified = true;
<span class="lineNum">    1360 </span>            :                 mode-&gt;xres = xres;
<span class="lineNum">    1361 </span>            :                 mode-&gt;yres = yres;
<span class="lineNum">    1362 </span>            :         }
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :         if (refresh_specified) {
<span class="lineNum">    1365 </span>            :                 mode-&gt;refresh_specified = true;
<span class="lineNum">    1366 </span>            :                 mode-&gt;refresh = refresh;
<span class="lineNum">    1367 </span>            :         }
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            :         if (bpp_specified) {
<span class="lineNum">    1370 </span>            :                 mode-&gt;bpp_specified = true;
<span class="lineNum">    1371 </span>            :                 mode-&gt;bpp = bpp;
<span class="lineNum">    1372 </span>            :         }
<span class="lineNum">    1373 </span>            :         mode-&gt;rb = rb;
<span class="lineNum">    1374 </span>            :         mode-&gt;cvt = cvt;
<span class="lineNum">    1375 </span>            :         mode-&gt;interlace = interlace;
<span class="lineNum">    1376 </span>            :         mode-&gt;margins = margins;
<span class="lineNum">    1377 </span>            :         mode-&gt;force = force;
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :         return true;
<span class="lineNum">    1380 </span>            : #else
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1382 </span>            : #endif
<span class="lineNum">    1383 </span>            : }
<span class="lineNum">    1384 </span>            : EXPORT_SYMBOL(drm_mode_parse_command_line_for_connector);
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            : /**
<span class="lineNum">    1387 </span>            :  * drm_mode_create_from_cmdline_mode - convert a command line modeline into a DRM display mode
<span class="lineNum">    1388 </span>            :  * @dev: DRM device to create the new mode for
<span class="lineNum">    1389 </span>            :  * @cmd: input command line modeline
<span class="lineNum">    1390 </span>            :  *
<span class="lineNum">    1391 </span>            :  * Returns:
<span class="lineNum">    1392 </span>            :  * Pointer to converted mode on success, NULL on error.
<a name="1393"><span class="lineNum">    1393 </span>            :  */</a>
<span class="lineNum">    1394 </span>            : struct drm_display_mode *
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 : drm_mode_create_from_cmdline_mode(struct drm_device *dev,</span>
<span class="lineNum">    1396 </span>            :                                   struct drm_cmdline_mode *cmd)
<span class="lineNum">    1397 </span>            : {
<span class="lineNum">    1398 </span>            :         struct drm_display_mode *mode;
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         if (cmd-&gt;cvt)</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :                 mode = drm_cvt_mode(dev,</span>
<span class="lineNum">    1402 </span>            :                                     cmd-&gt;xres, cmd-&gt;yres,
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :                                     cmd-&gt;refresh_specified ? cmd-&gt;refresh : 60,</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :                                     cmd-&gt;rb, cmd-&gt;interlace,</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :                                     cmd-&gt;margins);</span>
<span class="lineNum">    1406 </span>            :         else
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :                 mode = drm_gtf_mode(dev,</span>
<span class="lineNum">    1408 </span>            :                                     cmd-&gt;xres, cmd-&gt;yres,
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :                                     cmd-&gt;refresh_specified ? cmd-&gt;refresh : 60,</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :                                     cmd-&gt;interlace,</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                                     cmd-&gt;margins);</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :         if (!mode)</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :         mode-&gt;type |= DRM_MODE_TYPE_USERDEF;</span>
<span class="lineNum">    1416 </span>            :         /* fix up 1368x768: GFT/CVT can't express 1366 width due to alignment */
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :         if (cmd-&gt;xres == 1366 &amp;&amp; mode-&gt;hdisplay == 1368) {</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :                 mode-&gt;hdisplay = 1366;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                 mode-&gt;hsync_start--;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :                 mode-&gt;hsync_end--;</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :                 drm_mode_set_name(mode);</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :         drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :         return mode;</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1426 </span>            : EXPORT_SYMBOL(drm_mode_create_from_cmdline_mode);
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            : /**
<span class="lineNum">    1429 </span>            :  * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo
<span class="lineNum">    1430 </span>            :  * @out: drm_mode_modeinfo struct to return to the user
<span class="lineNum">    1431 </span>            :  * @in: drm_display_mode to use
<span class="lineNum">    1432 </span>            :  *
<span class="lineNum">    1433 </span>            :  * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to
<a name="1434"><span class="lineNum">    1434 </span>            :  * the user.</a>
<span class="lineNum">    1435 </span>            :  */
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 : void drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,</span>
<span class="lineNum">    1437 </span>            :                                const struct drm_display_mode *in)
<span class="lineNum">    1438 </span>            : {
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :         WARN(in-&gt;hdisplay &gt; USHRT_MAX || in-&gt;hsync_start &gt; USHRT_MAX ||</span>
<span class="lineNum">    1440 </span>            :              in-&gt;hsync_end &gt; USHRT_MAX || in-&gt;htotal &gt; USHRT_MAX ||
<span class="lineNum">    1441 </span>            :              in-&gt;hskew &gt; USHRT_MAX || in-&gt;vdisplay &gt; USHRT_MAX ||
<span class="lineNum">    1442 </span>            :              in-&gt;vsync_start &gt; USHRT_MAX || in-&gt;vsync_end &gt; USHRT_MAX ||
<span class="lineNum">    1443 </span>            :              in-&gt;vtotal &gt; USHRT_MAX || in-&gt;vscan &gt; USHRT_MAX,
<span class="lineNum">    1444 </span>            :              &quot;timing values too large for mode info\n&quot;);
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :         out-&gt;clock = in-&gt;clock;</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :         out-&gt;hdisplay = in-&gt;hdisplay;</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :         out-&gt;hsync_start = in-&gt;hsync_start;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :         out-&gt;hsync_end = in-&gt;hsync_end;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :         out-&gt;htotal = in-&gt;htotal;</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :         out-&gt;hskew = in-&gt;hskew;</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :         out-&gt;vdisplay = in-&gt;vdisplay;</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :         out-&gt;vsync_start = in-&gt;vsync_start;</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :         out-&gt;vsync_end = in-&gt;vsync_end;</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :         out-&gt;vtotal = in-&gt;vtotal;</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :         out-&gt;vscan = in-&gt;vscan;</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :         out-&gt;vrefresh = in-&gt;vrefresh;</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :         out-&gt;flags = in-&gt;flags;</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :         out-&gt;type = in-&gt;type;</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :         strncpy(out-&gt;name, in-&gt;name, DRM_DISPLAY_MODE_LEN);</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :         out-&gt;name[DRM_DISPLAY_MODE_LEN-1] = 0;</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span>            : /**
<span class="lineNum">    1465 </span>            :  * drm_crtc_convert_umode - convert a modeinfo into a drm_display_mode
<span class="lineNum">    1466 </span>            :  * @out: drm_display_mode to return to the user
<span class="lineNum">    1467 </span>            :  * @in: drm_mode_modeinfo to use
<span class="lineNum">    1468 </span>            :  *
<span class="lineNum">    1469 </span>            :  * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to
<span class="lineNum">    1470 </span>            :  * the caller.
<span class="lineNum">    1471 </span>            :  *
<span class="lineNum">    1472 </span>            :  * Returns:
<a name="1473"><span class="lineNum">    1473 </span>            :  * Zero on success, negative errno on failure.</a>
<span class="lineNum">    1474 </span>            :  */
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 : int drm_mode_convert_umode(struct drm_display_mode *out,</span>
<span class="lineNum">    1476 </span>            :                            const struct drm_mode_modeinfo *in)
<span class="lineNum">    1477 </span>            : {
<span class="lineNum">    1478 </span>            :         int ret = -EINVAL;
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         if (in-&gt;clock &gt; INT_MAX || in-&gt;vrefresh &gt; INT_MAX) {</span>
<span class="lineNum">    1481 </span>            :                 ret = -ERANGE;
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :                 goto out;</span>
<span class="lineNum">    1483 </span>            :         }
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :         if ((in-&gt;flags &amp; DRM_MODE_FLAG_3D_MASK) &gt; DRM_MODE_FLAG_3D_MAX)</span>
<span class="lineNum">    1486 </span>            :                 goto out;
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :         out-&gt;clock = in-&gt;clock;</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :         out-&gt;hdisplay = in-&gt;hdisplay;</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         out-&gt;hsync_start = in-&gt;hsync_start;</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :         out-&gt;hsync_end = in-&gt;hsync_end;</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         out-&gt;htotal = in-&gt;htotal;</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         out-&gt;hskew = in-&gt;hskew;</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         out-&gt;vdisplay = in-&gt;vdisplay;</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         out-&gt;vsync_start = in-&gt;vsync_start;</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :         out-&gt;vsync_end = in-&gt;vsync_end;</span>
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :         out-&gt;vtotal = in-&gt;vtotal;</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :         out-&gt;vscan = in-&gt;vscan;</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :         out-&gt;vrefresh = in-&gt;vrefresh;</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :         out-&gt;flags = in-&gt;flags;</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         out-&gt;type = in-&gt;type;</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :         strncpy(out-&gt;name, in-&gt;name, DRM_DISPLAY_MODE_LEN);</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :         out-&gt;name[DRM_DISPLAY_MODE_LEN-1] = 0;</span>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :         out-&gt;status = drm_mode_validate_basic(out);</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :         if (out-&gt;status != MODE_OK)</span>
<span class="lineNum">    1507 </span>            :                 goto out;
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :         drm_mode_set_crtcinfo(out, CRTC_INTERLACE_HALVE_V);</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :         ret = 0;</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : out:
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    1515 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
