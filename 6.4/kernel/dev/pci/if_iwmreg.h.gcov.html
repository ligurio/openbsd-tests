<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/pci/if_iwmreg.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dev/pci</a> - if_iwmreg.h<span style="font-size: 80%;"> (source / <a href="if_iwmreg.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: if_iwmreg.h,v 1.28 2018/02/28 14:39:35 stsp Exp $     */</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : /******************************************************************************
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * This file is provided under a dual BSD/GPLv2 license.  When using or
<span class="lineNum">       6 </span>            :  * redistributing this file, you may do so under either license.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * GPL LICENSE SUMMARY
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * This program is free software; you can redistribute it and/or modify
<span class="lineNum">      13 </span>            :  * it under the terms of version 2 of the GNU General Public License as
<span class="lineNum">      14 </span>            :  * published by the Free Software Foundation.
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * This program is distributed in the hope that it will be useful, but
<span class="lineNum">      17 </span>            :  * WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      18 </span>            :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      19 </span>            :  * General Public License for more details.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * You should have received a copy of the GNU General Public License
<span class="lineNum">      22 </span>            :  * along with this program; if not, write to the Free Software
<span class="lineNum">      23 </span>            :  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
<span class="lineNum">      24 </span>            :  * USA
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  * The full GNU General Public License is included in this distribution
<span class="lineNum">      27 </span>            :  * in the file called COPYING.
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  * Contact Information:
<span class="lineNum">      30 </span>            :  *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;
<span class="lineNum">      31 </span>            :  * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * BSD LICENSE
<span class="lineNum">      34 </span>            :  *
<span class="lineNum">      35 </span>            :  * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
<span class="lineNum">      36 </span>            :  * All rights reserved.
<span class="lineNum">      37 </span>            :  *
<span class="lineNum">      38 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">      39 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      40 </span>            :  * are met:
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  *  * Redistributions of source code must retain the above copyright
<span class="lineNum">      43 </span>            :  *    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      44 </span>            :  *  * Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      45 </span>            :  *    notice, this list of conditions and the following disclaimer in
<span class="lineNum">      46 </span>            :  *    the documentation and/or other materials provided with the
<span class="lineNum">      47 </span>            :  *    distribution.
<span class="lineNum">      48 </span>            :  *  * Neither the name Intel Corporation nor the names of its
<span class="lineNum">      49 </span>            :  *    contributors may be used to endorse or promote products derived
<span class="lineNum">      50 </span>            :  *    from this software without specific prior written permission.
<span class="lineNum">      51 </span>            :  *
<span class="lineNum">      52 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      53 </span>            :  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      54 </span>            :  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      55 </span>            :  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      56 </span>            :  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      57 </span>            :  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      58 </span>            :  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      59 </span>            :  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      60 </span>            :  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      61 </span>            :  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      62 </span>            :  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      63 </span>            :  *
<span class="lineNum">      64 </span>            :  *****************************************************************************/
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : /*
<span class="lineNum">      67 </span>            :  * CSR (control and status registers)
<span class="lineNum">      68 </span>            :  *
<span class="lineNum">      69 </span>            :  * CSR registers are mapped directly into PCI bus space, and are accessible
<span class="lineNum">      70 </span>            :  * whenever platform supplies power to device, even when device is in
<span class="lineNum">      71 </span>            :  * low power states due to driver-invoked device resets
<span class="lineNum">      72 </span>            :  * (e.g. IWM_CSR_RESET_REG_FLAG_SW_RESET) or uCode-driven power-saving modes.
<span class="lineNum">      73 </span>            :  *
<span class="lineNum">      74 </span>            :  * Use iwl_write32() and iwl_read32() family to access these registers;
<span class="lineNum">      75 </span>            :  * these provide simple PCI bus access, without waking up the MAC.
<span class="lineNum">      76 </span>            :  * Do not use iwl_write_direct32() family for these registers;
<span class="lineNum">      77 </span>            :  * no need to &quot;grab nic access&quot; via IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ.
<span class="lineNum">      78 </span>            :  * The MAC (uCode processor, etc.) does not need to be powered up for accessing
<span class="lineNum">      79 </span>            :  * the CSR registers.
<span class="lineNum">      80 </span>            :  *
<span class="lineNum">      81 </span>            :  * NOTE:  Device does need to be awake in order to read this memory
<span class="lineNum">      82 </span>            :  *        via IWM_CSR_EEPROM and IWM_CSR_OTP registers
<span class="lineNum">      83 </span>            :  */
<span class="lineNum">      84 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG    (0x000) /* hardware interface config */
<span class="lineNum">      85 </span>            : #define IWM_CSR_INT_COALESCING      (0x004) /* accum ints, 32-usec units */
<span class="lineNum">      86 </span>            : #define IWM_CSR_INT                 (0x008) /* host interrupt status/ack */
<span class="lineNum">      87 </span>            : #define IWM_CSR_INT_MASK            (0x00c) /* host interrupt enable */
<span class="lineNum">      88 </span>            : #define IWM_CSR_FH_INT_STATUS       (0x010) /* busmaster int status/ack*/
<span class="lineNum">      89 </span>            : #define IWM_CSR_GPIO_IN             (0x018) /* read external chip pins */
<span class="lineNum">      90 </span>            : #define IWM_CSR_RESET               (0x020) /* busmaster enable, NMI, etc*/
<span class="lineNum">      91 </span>            : #define IWM_CSR_GP_CNTRL            (0x024)
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /* 2nd byte of IWM_CSR_INT_COALESCING, not accessible via iwl_write32()! */
<span class="lineNum">      94 </span>            : #define IWM_CSR_INT_PERIODIC_REG        (0x005)
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : /*
<span class="lineNum">      97 </span>            :  * Hardware revision info
<span class="lineNum">      98 </span>            :  * Bit fields:
<span class="lineNum">      99 </span>            :  * 31-16:  Reserved
<span class="lineNum">     100 </span>            :  *  15-4:  Type of device:  see IWM_CSR_HW_REV_TYPE_xxx definitions
<span class="lineNum">     101 </span>            :  *  3-2:  Revision step:  0 = A, 1 = B, 2 = C, 3 = D
<span class="lineNum">     102 </span>            :  *  1-0:  &quot;Dash&quot; (-) value, as in A-1, etc.
<span class="lineNum">     103 </span>            :  */
<span class="lineNum">     104 </span>            : #define IWM_CSR_HW_REV              (0x028)
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /*
<span class="lineNum">     107 </span>            :  * EEPROM and OTP (one-time-programmable) memory reads
<span class="lineNum">     108 </span>            :  *
<span class="lineNum">     109 </span>            :  * NOTE:  Device must be awake, initialized via apm_ops.init(),
<span class="lineNum">     110 </span>            :  *        in order to read.
<span class="lineNum">     111 </span>            :  */
<span class="lineNum">     112 </span>            : #define IWM_CSR_EEPROM_REG          (0x02c)
<span class="lineNum">     113 </span>            : #define IWM_CSR_EEPROM_GP           (0x030)
<span class="lineNum">     114 </span>            : #define IWM_CSR_OTP_GP_REG          (0x034)
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : #define IWM_CSR_GIO_REG         (0x03C)
<span class="lineNum">     117 </span>            : #define IWM_CSR_GP_UCODE_REG    (0x048)
<span class="lineNum">     118 </span>            : #define IWM_CSR_GP_DRIVER_REG   (0x050)
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : /*
<span class="lineNum">     121 </span>            :  * UCODE-DRIVER GP (general purpose) mailbox registers.
<span class="lineNum">     122 </span>            :  * SET/CLR registers set/clear bit(s) if &quot;1&quot; is written.
<span class="lineNum">     123 </span>            :  */
<span class="lineNum">     124 </span>            : #define IWM_CSR_UCODE_DRV_GP1       (0x054)
<span class="lineNum">     125 </span>            : #define IWM_CSR_UCODE_DRV_GP1_SET   (0x058)
<span class="lineNum">     126 </span>            : #define IWM_CSR_UCODE_DRV_GP1_CLR   (0x05c)
<span class="lineNum">     127 </span>            : #define IWM_CSR_UCODE_DRV_GP2       (0x060)
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : #define IWM_CSR_MBOX_SET_REG            (0x088)
<span class="lineNum">     130 </span>            : #define IWM_CSR_MBOX_SET_REG_OS_ALIVE   0x20
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : #define IWM_CSR_LED_REG                 (0x094)
<span class="lineNum">     133 </span>            : #define IWM_CSR_DRAM_INT_TBL_REG        (0x0A0)
<span class="lineNum">     134 </span>            : #define IWM_CSR_MAC_SHADOW_REG_CTRL     (0x0A8) /* 6000 and up */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : /* GIO Chicken Bits (PCI Express bus link power management) */
<span class="lineNum">     138 </span>            : #define IWM_CSR_GIO_CHICKEN_BITS    (0x100)
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : /* Analog phase-lock-loop configuration  */
<span class="lineNum">     141 </span>            : #define IWM_CSR_ANA_PLL_CFG         (0x20c)
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : /*
<span class="lineNum">     144 </span>            :  * CSR Hardware Revision Workaround Register.  Indicates hardware rev;
<span class="lineNum">     145 </span>            :  * &quot;step&quot; determines CCK backoff for txpower calculation.  Used for 4965 only.
<span class="lineNum">     146 </span>            :  * See also IWM_CSR_HW_REV register.
<span class="lineNum">     147 </span>            :  * Bit fields:
<span class="lineNum">     148 </span>            :  *  3-2:  0 = A, 1 = B, 2 = C, 3 = D step
<span class="lineNum">     149 </span>            :  *  1-0:  &quot;Dash&quot; (-) value, as in C-1, etc.
<span class="lineNum">     150 </span>            :  */
<span class="lineNum">     151 </span>            : #define IWM_CSR_HW_REV_WA_REG           (0x22C)
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : #define IWM_CSR_DBG_HPET_MEM_REG        (0x240)
<span class="lineNum">     154 </span>            : #define IWM_CSR_DBG_LINK_PWR_MGMT_REG   (0x250)
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : /* Bits for IWM_CSR_HW_IF_CONFIG_REG */
<span class="lineNum">     157 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_MSK_MAC_DASH   (0x00000003)
<span class="lineNum">     158 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_MSK_MAC_STEP   (0x0000000C)
<span class="lineNum">     159 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_MSK_BOARD_VER  (0x000000C0)
<span class="lineNum">     160 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_BIT_MAC_SI     (0x00000100)
<span class="lineNum">     161 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_BIT_RADIO_SI   (0x00000200)
<span class="lineNum">     162 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_MSK_PHY_TYPE   (0x00000C00)
<span class="lineNum">     163 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_MSK_PHY_DASH   (0x00003000)
<span class="lineNum">     164 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_MSK_PHY_STEP   (0x0000C000)
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_DASH   (0)
<span class="lineNum">     167 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_STEP   (2)
<span class="lineNum">     168 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_POS_BOARD_VER  (6)
<span class="lineNum">     169 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE   (10)
<span class="lineNum">     170 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_DASH   (12)
<span class="lineNum">     171 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_STEP   (14)
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A       (0x00080000)
<span class="lineNum">     174 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM     (0x00200000)
<span class="lineNum">     175 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY  (0x00400000) /* PCI_OWN_SEM */
<span class="lineNum">     176 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE (0x02000000) /* ME_OWN */
<span class="lineNum">     177 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_PREPARE        (0x08000000) /* WAKE_ME */
<span class="lineNum">     178 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_ENABLE_PME     (0x10000000)
<span class="lineNum">     179 </span>            : #define IWM_CSR_HW_IF_CONFIG_REG_PERSIST_MODE   (0x40000000) /* PERSISTENCE */
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : #define IWM_CSR_INT_PERIODIC_DIS                (0x00) /* disable periodic int*/
<span class="lineNum">     182 </span>            : #define IWM_CSR_INT_PERIODIC_ENA                (0xFF) /* 255*32 usec ~ 8 msec*/
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : /* interrupt flags in INTA, set by uCode or hardware (e.g. dma),
<span class="lineNum">     185 </span>            :  * acknowledged (reset) by host writing &quot;1&quot; to flagged bits. */
<span class="lineNum">     186 </span>            : #define IWM_CSR_INT_BIT_FH_RX   (1 &lt;&lt; 31) /* Rx DMA, cmd responses, FH_INT[17:16] */
<span class="lineNum">     187 </span>            : #define IWM_CSR_INT_BIT_HW_ERR  (1 &lt;&lt; 29) /* DMA hardware error FH_INT[31] */
<span class="lineNum">     188 </span>            : #define IWM_CSR_INT_BIT_RX_PERIODIC     (1 &lt;&lt; 28) /* Rx periodic */
<span class="lineNum">     189 </span>            : #define IWM_CSR_INT_BIT_FH_TX   (1 &lt;&lt; 27) /* Tx DMA FH_INT[1:0] */
<span class="lineNum">     190 </span>            : #define IWM_CSR_INT_BIT_SCD     (1 &lt;&lt; 26) /* TXQ pointer advanced */
<span class="lineNum">     191 </span>            : #define IWM_CSR_INT_BIT_SW_ERR  (1 &lt;&lt; 25) /* uCode error */
<span class="lineNum">     192 </span>            : #define IWM_CSR_INT_BIT_RF_KILL (1 &lt;&lt; 7)  /* HW RFKILL switch GP_CNTRL[27] toggled */
<span class="lineNum">     193 </span>            : #define IWM_CSR_INT_BIT_CT_KILL (1 &lt;&lt; 6)  /* Critical temp (chip too hot) rfkill */
<span class="lineNum">     194 </span>            : #define IWM_CSR_INT_BIT_SW_RX   (1 &lt;&lt; 3)  /* Rx, command responses */
<span class="lineNum">     195 </span>            : #define IWM_CSR_INT_BIT_WAKEUP  (1 &lt;&lt; 1)  /* NIC controller waking up (pwr mgmt) */
<span class="lineNum">     196 </span>            : #define IWM_CSR_INT_BIT_ALIVE   (1 &lt;&lt; 0)  /* uCode interrupts once it initializes */
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : #define IWM_CSR_INI_SET_MASK    (IWM_CSR_INT_BIT_FH_RX   | \
<span class="lineNum">     199 </span>            :                                  IWM_CSR_INT_BIT_HW_ERR  | \
<span class="lineNum">     200 </span>            :                                  IWM_CSR_INT_BIT_FH_TX   | \
<span class="lineNum">     201 </span>            :                                  IWM_CSR_INT_BIT_SW_ERR  | \
<span class="lineNum">     202 </span>            :                                  IWM_CSR_INT_BIT_RF_KILL | \
<span class="lineNum">     203 </span>            :                                  IWM_CSR_INT_BIT_SW_RX   | \
<span class="lineNum">     204 </span>            :                                  IWM_CSR_INT_BIT_WAKEUP  | \
<span class="lineNum">     205 </span>            :                                  IWM_CSR_INT_BIT_ALIVE   | \
<span class="lineNum">     206 </span>            :                                  IWM_CSR_INT_BIT_RX_PERIODIC)
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /* interrupt flags in FH (flow handler) (PCI busmaster DMA) */
<span class="lineNum">     209 </span>            : #define IWM_CSR_FH_INT_BIT_ERR       (1 &lt;&lt; 31) /* Error */
<span class="lineNum">     210 </span>            : #define IWM_CSR_FH_INT_BIT_HI_PRIOR  (1 &lt;&lt; 30) /* High priority Rx, bypass coalescing */
<span class="lineNum">     211 </span>            : #define IWM_CSR_FH_INT_BIT_RX_CHNL1  (1 &lt;&lt; 17) /* Rx channel 1 */
<span class="lineNum">     212 </span>            : #define IWM_CSR_FH_INT_BIT_RX_CHNL0  (1 &lt;&lt; 16) /* Rx channel 0 */
<span class="lineNum">     213 </span>            : #define IWM_CSR_FH_INT_BIT_TX_CHNL1  (1 &lt;&lt; 1)  /* Tx channel 1 */
<span class="lineNum">     214 </span>            : #define IWM_CSR_FH_INT_BIT_TX_CHNL0  (1 &lt;&lt; 0)  /* Tx channel 0 */
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : #define IWM_CSR_FH_INT_RX_MASK  (IWM_CSR_FH_INT_BIT_HI_PRIOR | \
<span class="lineNum">     217 </span>            :                                 IWM_CSR_FH_INT_BIT_RX_CHNL1 | \
<span class="lineNum">     218 </span>            :                                 IWM_CSR_FH_INT_BIT_RX_CHNL0)
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : #define IWM_CSR_FH_INT_TX_MASK  (IWM_CSR_FH_INT_BIT_TX_CHNL1 | \
<span class="lineNum">     221 </span>            :                                 IWM_CSR_FH_INT_BIT_TX_CHNL0)
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : /* GPIO */
<span class="lineNum">     224 </span>            : #define IWM_CSR_GPIO_IN_BIT_AUX_POWER                   (0x00000200)
<span class="lineNum">     225 </span>            : #define IWM_CSR_GPIO_IN_VAL_VAUX_PWR_SRC                (0x00000000)
<span class="lineNum">     226 </span>            : #define IWM_CSR_GPIO_IN_VAL_VMAIN_PWR_SRC               (0x00000200)
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : /* RESET */
<span class="lineNum">     229 </span>            : #define IWM_CSR_RESET_REG_FLAG_NEVO_RESET                (0x00000001)
<span class="lineNum">     230 </span>            : #define IWM_CSR_RESET_REG_FLAG_FORCE_NMI                 (0x00000002)
<span class="lineNum">     231 </span>            : #define IWM_CSR_RESET_REG_FLAG_SW_RESET                  (0x00000080)
<span class="lineNum">     232 </span>            : #define IWM_CSR_RESET_REG_FLAG_MASTER_DISABLED           (0x00000100)
<span class="lineNum">     233 </span>            : #define IWM_CSR_RESET_REG_FLAG_STOP_MASTER               (0x00000200)
<span class="lineNum">     234 </span>            : #define IWM_CSR_RESET_LINK_PWR_MGMT_DISABLED             (0x80000000)
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /*
<span class="lineNum">     237 </span>            :  * GP (general purpose) CONTROL REGISTER
<span class="lineNum">     238 </span>            :  * Bit fields:
<span class="lineNum">     239 </span>            :  *    27:  HW_RF_KILL_SW
<span class="lineNum">     240 </span>            :  *         Indicates state of (platform's) hardware RF-Kill switch
<span class="lineNum">     241 </span>            :  * 26-24:  POWER_SAVE_TYPE
<span class="lineNum">     242 </span>            :  *         Indicates current power-saving mode:
<span class="lineNum">     243 </span>            :  *         000 -- No power saving
<span class="lineNum">     244 </span>            :  *         001 -- MAC power-down
<span class="lineNum">     245 </span>            :  *         010 -- PHY (radio) power-down
<span class="lineNum">     246 </span>            :  *         011 -- Error
<span class="lineNum">     247 </span>            :  *   9-6:  SYS_CONFIG
<span class="lineNum">     248 </span>            :  *         Indicates current system configuration, reflecting pins on chip
<span class="lineNum">     249 </span>            :  *         as forced high/low by device circuit board.
<span class="lineNum">     250 </span>            :  *     4:  GOING_TO_SLEEP
<span class="lineNum">     251 </span>            :  *         Indicates MAC is entering a power-saving sleep power-down.
<span class="lineNum">     252 </span>            :  *         Not a good time to access device-internal resources.
<span class="lineNum">     253 </span>            :  *     3:  MAC_ACCESS_REQ
<span class="lineNum">     254 </span>            :  *         Host sets this to request and maintain MAC wakeup, to allow host
<span class="lineNum">     255 </span>            :  *         access to device-internal resources.  Host must wait for
<span class="lineNum">     256 </span>            :  *         MAC_CLOCK_READY (and !GOING_TO_SLEEP) before accessing non-CSR
<span class="lineNum">     257 </span>            :  *         device registers.
<span class="lineNum">     258 </span>            :  *     2:  INIT_DONE
<span class="lineNum">     259 </span>            :  *         Host sets this to put device into fully operational D0 power mode.
<span class="lineNum">     260 </span>            :  *         Host resets this after SW_RESET to put device into low power mode.
<span class="lineNum">     261 </span>            :  *     0:  MAC_CLOCK_READY
<span class="lineNum">     262 </span>            :  *         Indicates MAC (ucode processor, etc.) is powered up and can run.
<span class="lineNum">     263 </span>            :  *         Internal resources are accessible.
<span class="lineNum">     264 </span>            :  *         NOTE:  This does not indicate that the processor is actually running.
<span class="lineNum">     265 </span>            :  *         NOTE:  This does not indicate that device has completed
<span class="lineNum">     266 </span>            :  *                init or post-power-down restore of internal SRAM memory.
<span class="lineNum">     267 </span>            :  *                Use IWM_CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP as indication that
<span class="lineNum">     268 </span>            :  *                SRAM is restored and uCode is in normal operation mode.
<span class="lineNum">     269 </span>            :  *                Later devices (5xxx/6xxx/1xxx) use non-volatile SRAM, and
<span class="lineNum">     270 </span>            :  *                do not need to save/restore it.
<span class="lineNum">     271 </span>            :  *         NOTE:  After device reset, this bit remains &quot;0&quot; until host sets
<span class="lineNum">     272 </span>            :  *                INIT_DONE
<span class="lineNum">     273 </span>            :  */
<span class="lineNum">     274 </span>            : #define IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY        (0x00000001)
<span class="lineNum">     275 </span>            : #define IWM_CSR_GP_CNTRL_REG_FLAG_INIT_DONE              (0x00000004)
<span class="lineNum">     276 </span>            : #define IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ         (0x00000008)
<span class="lineNum">     277 </span>            : #define IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP         (0x00000010)
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            : #define IWM_CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN           (0x00000001)
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : #define IWM_CSR_GP_CNTRL_REG_MSK_POWER_SAVE_TYPE         (0x07000000)
<span class="lineNum">     282 </span>            : #define IWM_CSR_GP_CNTRL_REG_FLAG_MAC_POWER_SAVE         (0x04000000)
<span class="lineNum">     283 </span>            : #define IWM_CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW          (0x08000000)
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : /* HW REV */
<span class="lineNum">     287 </span>            : #define IWM_CSR_HW_REV_DASH(_val)          (((_val) &amp; 0x0000003) &gt;&gt; 0)
<span class="lineNum">     288 </span>            : #define IWM_CSR_HW_REV_STEP(_val)          (((_val) &amp; 0x000000C) &gt;&gt; 2)
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : #define IWM_CSR_HW_REV_TYPE_MSK         (0x000FFF0)
<span class="lineNum">     291 </span>            : #define IWM_CSR_HW_REV_TYPE_5300        (0x0000020)
<span class="lineNum">     292 </span>            : #define IWM_CSR_HW_REV_TYPE_5350        (0x0000030)
<span class="lineNum">     293 </span>            : #define IWM_CSR_HW_REV_TYPE_5100        (0x0000050)
<span class="lineNum">     294 </span>            : #define IWM_CSR_HW_REV_TYPE_5150        (0x0000040)
<span class="lineNum">     295 </span>            : #define IWM_CSR_HW_REV_TYPE_1000        (0x0000060)
<span class="lineNum">     296 </span>            : #define IWM_CSR_HW_REV_TYPE_6x00        (0x0000070)
<span class="lineNum">     297 </span>            : #define IWM_CSR_HW_REV_TYPE_6x50        (0x0000080)
<span class="lineNum">     298 </span>            : #define IWM_CSR_HW_REV_TYPE_6150        (0x0000084)
<span class="lineNum">     299 </span>            : #define IWM_CSR_HW_REV_TYPE_6x05        (0x00000B0)
<span class="lineNum">     300 </span>            : #define IWM_CSR_HW_REV_TYPE_6x30        IWM_CSR_HW_REV_TYPE_6x05
<span class="lineNum">     301 </span>            : #define IWM_CSR_HW_REV_TYPE_6x35        IWM_CSR_HW_REV_TYPE_6x05
<span class="lineNum">     302 </span>            : #define IWM_CSR_HW_REV_TYPE_2x30        (0x00000C0)
<span class="lineNum">     303 </span>            : #define IWM_CSR_HW_REV_TYPE_2x00        (0x0000100)
<span class="lineNum">     304 </span>            : #define IWM_CSR_HW_REV_TYPE_105         (0x0000110)
<span class="lineNum">     305 </span>            : #define IWM_CSR_HW_REV_TYPE_135         (0x0000120)
<span class="lineNum">     306 </span>            : #define IWM_CSR_HW_REV_TYPE_7265D       (0x0000210)
<span class="lineNum">     307 </span>            : #define IWM_CSR_HW_REV_TYPE_NONE        (0x00001F0)
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : /* EEPROM REG */
<span class="lineNum">     310 </span>            : #define IWM_CSR_EEPROM_REG_READ_VALID_MSK       (0x00000001)
<span class="lineNum">     311 </span>            : #define IWM_CSR_EEPROM_REG_BIT_CMD              (0x00000002)
<span class="lineNum">     312 </span>            : #define IWM_CSR_EEPROM_REG_MSK_ADDR             (0x0000FFFC)
<span class="lineNum">     313 </span>            : #define IWM_CSR_EEPROM_REG_MSK_DATA             (0xFFFF0000)
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : /* EEPROM GP */
<span class="lineNum">     316 </span>            : #define IWM_CSR_EEPROM_GP_VALID_MSK             (0x00000007) /* signature */
<span class="lineNum">     317 </span>            : #define IWM_CSR_EEPROM_GP_IF_OWNER_MSK  (0x00000180)
<span class="lineNum">     318 </span>            : #define IWM_CSR_EEPROM_GP_BAD_SIGNATURE_BOTH_EEP_AND_OTP        (0x00000000)
<span class="lineNum">     319 </span>            : #define IWM_CSR_EEPROM_GP_BAD_SIG_EEP_GOOD_SIG_OTP              (0x00000001)
<span class="lineNum">     320 </span>            : #define IWM_CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K             (0x00000002)
<span class="lineNum">     321 </span>            : #define IWM_CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K             (0x00000004)
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : /* One-time-programmable memory general purpose reg */
<span class="lineNum">     324 </span>            : #define IWM_CSR_OTP_GP_REG_DEVICE_SELECT  (0x00010000) /* 0 - EEPROM, 1 - OTP */
<span class="lineNum">     325 </span>            : #define IWM_CSR_OTP_GP_REG_OTP_ACCESS_MODE  (0x00020000) /* 0 - absolute, 1 - relative */
<span class="lineNum">     326 </span>            : #define IWM_CSR_OTP_GP_REG_ECC_CORR_STATUS_MSK    (0x00100000) /* bit 20 */
<span class="lineNum">     327 </span>            : #define IWM_CSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK  (0x00200000) /* bit 21 */
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /* GP REG */
<span class="lineNum">     330 </span>            : #define IWM_CSR_GP_REG_POWER_SAVE_STATUS_MSK    (0x03000000) /* bit 24/25 */
<span class="lineNum">     331 </span>            : #define IWM_CSR_GP_REG_NO_POWER_SAVE            (0x00000000)
<span class="lineNum">     332 </span>            : #define IWM_CSR_GP_REG_MAC_POWER_SAVE           (0x01000000)
<span class="lineNum">     333 </span>            : #define IWM_CSR_GP_REG_PHY_POWER_SAVE           (0x02000000)
<span class="lineNum">     334 </span>            : #define IWM_CSR_GP_REG_POWER_SAVE_ERROR         (0x03000000)
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : /* CSR GIO */
<span class="lineNum">     338 </span>            : #define IWM_CSR_GIO_REG_VAL_L0S_ENABLED (0x00000002)
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : /*
<span class="lineNum">     341 </span>            :  * UCODE-DRIVER GP (general purpose) mailbox register 1
<span class="lineNum">     342 </span>            :  * Host driver and uCode write and/or read this register to communicate with
<span class="lineNum">     343 </span>            :  * each other.
<span class="lineNum">     344 </span>            :  * Bit fields:
<span class="lineNum">     345 </span>            :  *     4:  UCODE_DISABLE
<span class="lineNum">     346 </span>            :  *         Host sets this to request permanent halt of uCode, same as
<span class="lineNum">     347 </span>            :  *         sending CARD_STATE command with &quot;halt&quot; bit set.
<span class="lineNum">     348 </span>            :  *     3:  CT_KILL_EXIT
<span class="lineNum">     349 </span>            :  *         Host sets this to request exit from CT_KILL state, i.e. host thinks
<span class="lineNum">     350 </span>            :  *         device temperature is low enough to continue normal operation.
<span class="lineNum">     351 </span>            :  *     2:  CMD_BLOCKED
<span class="lineNum">     352 </span>            :  *         Host sets this during RF KILL power-down sequence (HW, SW, CT KILL)
<span class="lineNum">     353 </span>            :  *         to release uCode to clear all Tx and command queues, enter
<span class="lineNum">     354 </span>            :  *         unassociated mode, and power down.
<span class="lineNum">     355 </span>            :  *         NOTE:  Some devices also use HBUS_TARG_MBX_C register for this bit.
<span class="lineNum">     356 </span>            :  *     1:  SW_BIT_RFKILL
<span class="lineNum">     357 </span>            :  *         Host sets this when issuing CARD_STATE command to request
<span class="lineNum">     358 </span>            :  *         device sleep.
<span class="lineNum">     359 </span>            :  *     0:  MAC_SLEEP
<span class="lineNum">     360 </span>            :  *         uCode sets this when preparing a power-saving power-down.
<span class="lineNum">     361 </span>            :  *         uCode resets this when power-up is complete and SRAM is sane.
<span class="lineNum">     362 </span>            :  *         NOTE:  device saves internal SRAM data to host when powering down,
<span class="lineNum">     363 </span>            :  *                and must restore this data after powering back up.
<span class="lineNum">     364 </span>            :  *                MAC_SLEEP is the best indication that restore is complete.
<span class="lineNum">     365 </span>            :  *                Later devices (5xxx/6xxx/1xxx) use non-volatile SRAM, and
<span class="lineNum">     366 </span>            :  *                do not need to save/restore it.
<span class="lineNum">     367 </span>            :  */
<span class="lineNum">     368 </span>            : #define IWM_CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP             (0x00000001)
<span class="lineNum">     369 </span>            : #define IWM_CSR_UCODE_SW_BIT_RFKILL                     (0x00000002)
<span class="lineNum">     370 </span>            : #define IWM_CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED           (0x00000004)
<span class="lineNum">     371 </span>            : #define IWM_CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT      (0x00000008)
<span class="lineNum">     372 </span>            : #define IWM_CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE       (0x00000020)
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : /* GP Driver */
<span class="lineNum">     375 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_RADIO_SKU_MSK             (0x00000003)
<span class="lineNum">     376 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_RADIO_SKU_3x3_HYB         (0x00000000)
<span class="lineNum">     377 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_RADIO_SKU_2x2_HYB         (0x00000001)
<span class="lineNum">     378 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_RADIO_SKU_2x2_IPA         (0x00000002)
<span class="lineNum">     379 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_CALIB_VERSION6            (0x00000004)
<span class="lineNum">     380 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_6050_1x2                  (0x00000008)
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : #define IWM_CSR_GP_DRIVER_REG_BIT_RADIO_IQ_INVER            (0x00000080)
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : /* GIO Chicken Bits (PCI Express bus link power management) */
<span class="lineNum">     385 </span>            : #define IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX  (0x00800000)
<span class="lineNum">     386 </span>            : #define IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER  (0x20000000)
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : /* LED */
<span class="lineNum">     389 </span>            : #define IWM_CSR_LED_BSM_CTRL_MSK (0xFFFFFFDF)
<span class="lineNum">     390 </span>            : #define IWM_CSR_LED_REG_TURN_ON (0x60)
<span class="lineNum">     391 </span>            : #define IWM_CSR_LED_REG_TURN_OFF (0x20)
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : /* ANA_PLL */
<span class="lineNum">     394 </span>            : #define IWM_CSR50_ANA_PLL_CFG_VAL        (0x00880300)
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : /* HPET MEM debug */
<span class="lineNum">     397 </span>            : #define IWM_CSR_DBG_HPET_MEM_REG_VAL    (0xFFFF0000)
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : /* DRAM INT TABLE */
<span class="lineNum">     400 </span>            : #define IWM_CSR_DRAM_INT_TBL_ENABLE             (1 &lt;&lt; 31)
<span class="lineNum">     401 </span>            : #define IWM_CSR_DRAM_INIT_TBL_WRITE_POINTER     (1 &lt;&lt; 28)
<span class="lineNum">     402 </span>            : #define IWM_CSR_DRAM_INIT_TBL_WRAP_CHECK        (1 &lt;&lt; 27)
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            : /* SECURE boot registers */
<span class="lineNum">     405 </span>            : #define IWM_CSR_SECURE_BOOT_CONFIG_ADDR (0x100)
<span class="lineNum">     406 </span>            : #define IWM_CSR_SECURE_BOOT_CONFIG_INSPECTOR_BURNED_IN_OTP      0x00000001
<span class="lineNum">     407 </span>            : #define IWM_CSR_SECURE_BOOT_CONFIG_INSPECTOR_NOT_REQ            0x00000002
<span class="lineNum">     408 </span>            : #define IWM_CSR_SECURE_BOOT_CPU1_STATUS_ADDR    (0x100)
<span class="lineNum">     409 </span>            : #define IWM_CSR_SECURE_BOOT_CPU2_STATUS_ADDR    (0x100)
<span class="lineNum">     410 </span>            : #define IWM_CSR_SECURE_BOOT_CPU_STATUS_VERF_STATUS      0x00000003
<span class="lineNum">     411 </span>            : #define IWM_CSR_SECURE_BOOT_CPU_STATUS_VERF_COMPLETED   0x00000002
<span class="lineNum">     412 </span>            : #define IWM_CSR_SECURE_BOOT_CPU_STATUS_VERF_SUCCESS     0x00000004
<span class="lineNum">     413 </span>            : #define IWM_CSR_SECURE_BOOT_CPU_STATUS_VERF_FAIL        0x00000008
<span class="lineNum">     414 </span>            : #define IWM_CSR_SECURE_BOOT_CPU_STATUS_SIGN_VERF_FAIL   0x00000010
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : #define IWM_FH_UCODE_LOAD_STATUS        0x1af0
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : #define IWM_FH_MEM_TB_MAX_LENGTH        0x20000
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : #define IWM_LMPM_SECURE_UCODE_LOAD_CPU1_HDR_ADDR        0x1e78
<span class="lineNum">     421 </span>            : #define IWM_LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR        0x1e7c
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : #define IWM_LMPM_SECURE_CPU1_HDR_MEM_SPACE              0x420000
<span class="lineNum">     424 </span>            : #define IWM_LMPM_SECURE_CPU2_HDR_MEM_SPACE              0x420400
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : #define IWM_CSR_SECURE_TIME_OUT (100)
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : /* extended range in FW SRAM */
<span class="lineNum">     429 </span>            : #define IWM_FW_MEM_EXTENDED_START       0x40000
<span class="lineNum">     430 </span>            : #define IWM_FW_MEM_EXTENDED_END         0x57FFF
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : /* FW chicken bits */
<span class="lineNum">     433 </span>            : #define IWM_LMPM_CHICK                          0xa01ff8
<span class="lineNum">     434 </span>            : #define IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE      0x01
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : #define IWM_FH_TCSR_0_REG0 (0x1D00)
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : /*
<span class="lineNum">     439 </span>            :  * HBUS (Host-side Bus)
<span class="lineNum">     440 </span>            :  *
<span class="lineNum">     441 </span>            :  * HBUS registers are mapped directly into PCI bus space, but are used
<span class="lineNum">     442 </span>            :  * to indirectly access device's internal memory or registers that
<span class="lineNum">     443 </span>            :  * may be powered-down.
<span class="lineNum">     444 </span>            :  *
<span class="lineNum">     445 </span>            :  * Use iwl_write_direct32()/iwl_read_direct32() family for these registers;
<span class="lineNum">     446 </span>            :  * host must &quot;grab nic access&quot; via CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
<span class="lineNum">     447 </span>            :  * to make sure the MAC (uCode processor, etc.) is powered up for accessing
<span class="lineNum">     448 </span>            :  * internal resources.
<span class="lineNum">     449 </span>            :  *
<span class="lineNum">     450 </span>            :  * Do not use iwl_write32()/iwl_read32() family to access these registers;
<span class="lineNum">     451 </span>            :  * these provide only simple PCI bus access, without waking up the MAC.
<span class="lineNum">     452 </span>            :  */
<span class="lineNum">     453 </span>            : #define IWM_HBUS_BASE   (0x400)
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : /*
<span class="lineNum">     456 </span>            :  * Registers for accessing device's internal SRAM memory (e.g. SCD SRAM
<span class="lineNum">     457 </span>            :  * structures, error log, event log, verifying uCode load).
<span class="lineNum">     458 </span>            :  * First write to address register, then read from or write to data register
<span class="lineNum">     459 </span>            :  * to complete the job.  Once the address register is set up, accesses to
<span class="lineNum">     460 </span>            :  * data registers auto-increment the address by one dword.
<span class="lineNum">     461 </span>            :  * Bit usage for address registers (read or write):
<span class="lineNum">     462 </span>            :  *  0-31:  memory address within device
<span class="lineNum">     463 </span>            :  */
<span class="lineNum">     464 </span>            : #define IWM_HBUS_TARG_MEM_RADDR     (IWM_HBUS_BASE+0x00c)
<span class="lineNum">     465 </span>            : #define IWM_HBUS_TARG_MEM_WADDR     (IWM_HBUS_BASE+0x010)
<span class="lineNum">     466 </span>            : #define IWM_HBUS_TARG_MEM_WDAT      (IWM_HBUS_BASE+0x018)
<span class="lineNum">     467 </span>            : #define IWM_HBUS_TARG_MEM_RDAT      (IWM_HBUS_BASE+0x01c)
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : /* Mailbox C, used as workaround alternative to CSR_UCODE_DRV_GP1 mailbox */
<span class="lineNum">     470 </span>            : #define IWM_HBUS_TARG_MBX_C         (IWM_HBUS_BASE+0x030)
<span class="lineNum">     471 </span>            : #define IWM_HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED         (0x00000004)
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : /*
<span class="lineNum">     474 </span>            :  * Registers for accessing device's internal peripheral registers
<span class="lineNum">     475 </span>            :  * (e.g. SCD, BSM, etc.).  First write to address register,
<span class="lineNum">     476 </span>            :  * then read from or write to data register to complete the job.
<span class="lineNum">     477 </span>            :  * Bit usage for address registers (read or write):
<span class="lineNum">     478 </span>            :  *  0-15:  register address (offset) within device
<span class="lineNum">     479 </span>            :  * 24-25:  (# bytes - 1) to read or write (e.g. 3 for dword)
<span class="lineNum">     480 </span>            :  */
<span class="lineNum">     481 </span>            : #define IWM_HBUS_TARG_PRPH_WADDR    (IWM_HBUS_BASE+0x044)
<span class="lineNum">     482 </span>            : #define IWM_HBUS_TARG_PRPH_RADDR    (IWM_HBUS_BASE+0x048)
<span class="lineNum">     483 </span>            : #define IWM_HBUS_TARG_PRPH_WDAT     (IWM_HBUS_BASE+0x04c)
<span class="lineNum">     484 </span>            : #define IWM_HBUS_TARG_PRPH_RDAT     (IWM_HBUS_BASE+0x050)
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : /* enable the ID buf for read */
<span class="lineNum">     487 </span>            : #define IWM_WFPM_PS_CTL_CLR                     0xa0300c
<span class="lineNum">     488 </span>            : #define IWM_WFMP_MAC_ADDR_0                     0xa03080
<span class="lineNum">     489 </span>            : #define IWM_WFMP_MAC_ADDR_1                     0xa03084
<span class="lineNum">     490 </span>            : #define IWM_LMPM_PMG_EN                         0xa01cec
<span class="lineNum">     491 </span>            : #define IWM_RADIO_REG_SYS_MANUAL_DFT_0          0xad4078
<span class="lineNum">     492 </span>            : #define IWM_RFIC_REG_RD                         0xad0470
<span class="lineNum">     493 </span>            : #define IWM_WFPM_CTRL_REG                       0xa03030
<span class="lineNum">     494 </span>            : #define IWM_WFPM_AUX_CTL_AUX_IF_MAC_OWNER_MSK   0x08000000
<span class="lineNum">     495 </span>            : #define IWM_ENABLE_WFPM                         0x80000000
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            : #define IWM_AUX_MISC_REG                        0xa200b0
<span class="lineNum">     498 </span>            : #define IWM_HW_STEP_LOCATION_BITS               24
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : #define IWM_AUX_MISC_MASTER1_EN                 0xa20818
<span class="lineNum">     501 </span>            : #define IWM_AUX_MISC_MASTER1_EN_SBE_MSK         0x1
<span class="lineNum">     502 </span>            : #define IWM_AUX_MISC_MASTER1_SMPHR_STATUS       0xa20800
<span class="lineNum">     503 </span>            : #define IWM_RSA_ENABLE                          0xa24b08
<span class="lineNum">     504 </span>            : #define IWM_PREG_AUX_BUS_WPROT_0                0xa04cc0
<span class="lineNum">     505 </span>            : #define IWM_SB_CFG_OVERRIDE_ADDR                0xa26c78
<span class="lineNum">     506 </span>            : #define IWM_SB_CFG_OVERRIDE_ENABLE              0x8000
<span class="lineNum">     507 </span>            : #define IWM_SB_CFG_BASE_OVERRIDE                0xa20000
<span class="lineNum">     508 </span>            : #define IWM_SB_MODIFY_CFG_FLAG                  0xa03088
<span class="lineNum">     509 </span>            : #define IWM_SB_CPU_1_STATUS                     0xa01e30
<span class="lineNum">     510 </span>            : #define IWM_SB_CPU_2_STATUS                     0Xa01e34
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : /* Used to enable DBGM */
<span class="lineNum">     513 </span>            : #define IWM_HBUS_TARG_TEST_REG  (IWM_HBUS_BASE+0x05c)
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            : /*
<span class="lineNum">     516 </span>            :  * Per-Tx-queue write pointer (index, really!)
<span class="lineNum">     517 </span>            :  * Indicates index to next TFD that driver will fill (1 past latest filled).
<span class="lineNum">     518 </span>            :  * Bit usage:
<span class="lineNum">     519 </span>            :  *  0-7:  queue write index
<span class="lineNum">     520 </span>            :  * 11-8:  queue selector
<span class="lineNum">     521 </span>            :  */
<span class="lineNum">     522 </span>            : #define IWM_HBUS_TARG_WRPTR         (IWM_HBUS_BASE+0x060)
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : /**********************************************************
<span class="lineNum">     525 </span>            :  * CSR values
<span class="lineNum">     526 </span>            :  **********************************************************/
<span class="lineNum">     527 </span>            :  /*
<span class="lineNum">     528 </span>            :  * host interrupt timeout value
<span class="lineNum">     529 </span>            :  * used with setting interrupt coalescing timer
<span class="lineNum">     530 </span>            :  * the CSR_INT_COALESCING is an 8 bit register in 32-usec unit
<span class="lineNum">     531 </span>            :  *
<span class="lineNum">     532 </span>            :  * default interrupt coalescing timer is 64 x 32 = 2048 usecs
<span class="lineNum">     533 </span>            :  */
<span class="lineNum">     534 </span>            : #define IWM_HOST_INT_TIMEOUT_MAX        (0xFF)
<span class="lineNum">     535 </span>            : #define IWM_HOST_INT_TIMEOUT_DEF        (0x40)
<span class="lineNum">     536 </span>            : #define IWM_HOST_INT_TIMEOUT_MIN        (0x0)
<span class="lineNum">     537 </span>            : #define IWM_HOST_INT_OPER_MODE          (1 &lt;&lt; 31)
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : /*****************************************************************************
<span class="lineNum">     540 </span>            :  *                        7000/3000 series SHR DTS addresses                 *
<span class="lineNum">     541 </span>            :  *****************************************************************************/
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : /* Diode Results Register Structure: */
<span class="lineNum">     544 </span>            : #define IWM_DTS_DIODE_REG_DIG_VAL               0x000000FF /* bits [7:0] */
<span class="lineNum">     545 </span>            : #define IWM_DTS_DIODE_REG_VREF_LOW              0x0000FF00 /* bits [15:8] */
<span class="lineNum">     546 </span>            : #define IWM_DTS_DIODE_REG_VREF_HIGH             0x00FF0000 /* bits [23:16] */
<span class="lineNum">     547 </span>            : #define IWM_DTS_DIODE_REG_VREF_ID               0x03000000 /* bits [25:24] */
<span class="lineNum">     548 </span>            : #define IWM_DTS_DIODE_REG_PASS_ONCE             0x80000000 /* bits [31:31] */
<span class="lineNum">     549 </span>            : #define IWM_DTS_DIODE_REG_FLAGS_MSK             0xFF000000 /* bits [31:24] */
<span class="lineNum">     550 </span>            : /* Those are the masks INSIDE the flags bit-field: */
<span class="lineNum">     551 </span>            : #define IWM_DTS_DIODE_REG_FLAGS_VREFS_ID_POS    0
<span class="lineNum">     552 </span>            : #define IWM_DTS_DIODE_REG_FLAGS_VREFS_ID        0x00000003 /* bits [1:0] */
<span class="lineNum">     553 </span>            : #define IWM_DTS_DIODE_REG_FLAGS_PASS_ONCE_POS   7
<span class="lineNum">     554 </span>            : #define IWM_DTS_DIODE_REG_FLAGS_PASS_ONCE       0x00000080 /* bits [7:7] */
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : /**
<span class="lineNum">     557 </span>            :  * uCode API flags
<span class="lineNum">     558 </span>            :  * @IWM_UCODE_TLV_FLAGS_PAN: This is PAN capable microcode; this previously
<span class="lineNum">     559 </span>            :  *      was a separate TLV but moved here to save space.
<span class="lineNum">     560 </span>            :  * @IWM_UCODE_TLV_FLAGS_NEWSCAN: new uCode scan behaviour on hidden SSID,
<span class="lineNum">     561 </span>            :  *      treats good CRC threshold as a boolean
<span class="lineNum">     562 </span>            :  * @IWM_UCODE_TLV_FLAGS_MFP: This uCode image supports MFP (802.11w).
<span class="lineNum">     563 </span>            :  * @IWM_UCODE_TLV_FLAGS_P2P: This uCode image supports P2P.
<span class="lineNum">     564 </span>            :  * @IWM_UCODE_TLV_FLAGS_DW_BC_TABLE: The SCD byte count table is in DWORDS
<span class="lineNum">     565 </span>            :  * @IWM_UCODE_TLV_FLAGS_UAPSD: This uCode image supports uAPSD
<span class="lineNum">     566 </span>            :  * @IWM_UCODE_TLV_FLAGS_SHORT_BL: 16 entries of black list instead of 64 in scan
<span class="lineNum">     567 </span>            :  *      offload profile config command.
<span class="lineNum">     568 </span>            :  * @IWM_UCODE_TLV_FLAGS_RX_ENERGY_API: supports rx signal strength api
<span class="lineNum">     569 </span>            :  * @IWM_UCODE_TLV_FLAGS_TIME_EVENT_API_V2: using the new time event API.
<span class="lineNum">     570 </span>            :  * @IWM_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS: D3 image supports up to six
<span class="lineNum">     571 </span>            :  *      (rather than two) IPv6 addresses
<span class="lineNum">     572 </span>            :  * @IWM_UCODE_TLV_FLAGS_BF_UPDATED: new beacon filtering API
<span class="lineNum">     573 </span>            :  * @IWM_UCODE_TLV_FLAGS_NO_BASIC_SSID: not sending a probe with the SSID element
<span class="lineNum">     574 </span>            :  *      from the probe request template.
<span class="lineNum">     575 </span>            :  * @IWM_UCODE_TLV_FLAGS_D3_CONTINUITY_API: modified D3 API to allow keeping
<span class="lineNum">     576 </span>            :  *      connection when going back to D0
<span class="lineNum">     577 </span>            :  * @IWM_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL: new NS offload (small version)
<span class="lineNum">     578 </span>            :  * @IWM_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE: new NS offload (large version)
<span class="lineNum">     579 </span>            :  * @IWM_UCODE_TLV_FLAGS_SCHED_SCAN: this uCode image supports scheduled scan.
<span class="lineNum">     580 </span>            :  * @IWM_UCODE_TLV_FLAGS_STA_KEY_CMD: new ADD_STA and ADD_STA_KEY command API
<span class="lineNum">     581 </span>            :  * @IWM_UCODE_TLV_FLAGS_DEVICE_PS_CMD: support device wide power command
<span class="lineNum">     582 </span>            :  *      containing CAM (Continuous Active Mode) indication.
<span class="lineNum">     583 </span>            :  * @IWM_UCODE_TLV_FLAGS_P2P_PS: P2P client power save is supported (only on a
<span class="lineNum">     584 </span>            :  *      single bound interface).
<span class="lineNum">     585 </span>            :  * @IWM_UCODE_TLV_FLAGS_UAPSD_SUPPORT: General support for uAPSD
<span class="lineNum">     586 </span>            :  * @IWM_UCODE_TLV_FLAGS_EBS_SUPPORT: this uCode image supports EBS.
<span class="lineNum">     587 </span>            :  * @IWM_UCODE_TLV_FLAGS_P2P_PS_UAPSD: P2P client supports uAPSD power save
<span class="lineNum">     588 </span>            :  * @IWM_UCODE_TLV_FLAGS_BCAST_FILTERING: uCode supports broadcast filtering.
<span class="lineNum">     589 </span>            :  * @IWM_UCODE_TLV_FLAGS_GO_UAPSD: AP/GO interfaces support uAPSD clients
<span class="lineNum">     590 </span>            :  *
<span class="lineNum">     591 </span>            :  */
<span class="lineNum">     592 </span>            : #define IWM_UCODE_TLV_FLAGS_PAN                 (1 &lt;&lt; 0)
<span class="lineNum">     593 </span>            : #define IWM_UCODE_TLV_FLAGS_NEWSCAN             (1 &lt;&lt; 1)
<span class="lineNum">     594 </span>            : #define IWM_UCODE_TLV_FLAGS_MFP                 (1 &lt;&lt; 2)
<span class="lineNum">     595 </span>            : #define IWM_UCODE_TLV_FLAGS_P2P                 (1 &lt;&lt; 3)
<span class="lineNum">     596 </span>            : #define IWM_UCODE_TLV_FLAGS_DW_BC_TABLE         (1 &lt;&lt; 4)
<span class="lineNum">     597 </span>            : #define IWM_UCODE_TLV_FLAGS_NEWBT_COEX          (1 &lt;&lt; 5)
<span class="lineNum">     598 </span>            : #define IWM_UCODE_TLV_FLAGS_PM_CMD_SUPPORT      (1 &lt;&lt; 6)
<span class="lineNum">     599 </span>            : #define IWM_UCODE_TLV_FLAGS_SHORT_BL            (1 &lt;&lt; 7)
<span class="lineNum">     600 </span>            : #define IWM_UCODE_TLV_FLAGS_RX_ENERGY_API       (1 &lt;&lt; 8)
<span class="lineNum">     601 </span>            : #define IWM_UCODE_TLV_FLAGS_TIME_EVENT_API_V2   (1 &lt;&lt; 9)
<span class="lineNum">     602 </span>            : #define IWM_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS     (1 &lt;&lt; 10)
<span class="lineNum">     603 </span>            : #define IWM_UCODE_TLV_FLAGS_BF_UPDATED          (1 &lt;&lt; 11)
<span class="lineNum">     604 </span>            : #define IWM_UCODE_TLV_FLAGS_NO_BASIC_SSID       (1 &lt;&lt; 12)
<span class="lineNum">     605 </span>            : #define IWM_UCODE_TLV_FLAGS_D3_CONTINUITY_API   (1 &lt;&lt; 14)
<span class="lineNum">     606 </span>            : #define IWM_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL    (1 &lt;&lt; 15)
<span class="lineNum">     607 </span>            : #define IWM_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE    (1 &lt;&lt; 16)
<span class="lineNum">     608 </span>            : #define IWM_UCODE_TLV_FLAGS_SCHED_SCAN          (1 &lt;&lt; 17)
<span class="lineNum">     609 </span>            : #define IWM_UCODE_TLV_FLAGS_STA_KEY_CMD         (1 &lt;&lt; 19)
<span class="lineNum">     610 </span>            : #define IWM_UCODE_TLV_FLAGS_DEVICE_PS_CMD       (1 &lt;&lt; 20)
<span class="lineNum">     611 </span>            : #define IWM_UCODE_TLV_FLAGS_P2P_PS              (1 &lt;&lt; 21)
<span class="lineNum">     612 </span>            : #define IWM_UCODE_TLV_FLAGS_BSS_P2P_PS_DCM      (1 &lt;&lt; 22)
<span class="lineNum">     613 </span>            : #define IWM_UCODE_TLV_FLAGS_BSS_P2P_PS_SCM      (1 &lt;&lt; 23)
<span class="lineNum">     614 </span>            : #define IWM_UCODE_TLV_FLAGS_UAPSD_SUPPORT       (1 &lt;&lt; 24)
<span class="lineNum">     615 </span>            : #define IWM_UCODE_TLV_FLAGS_EBS_SUPPORT         (1 &lt;&lt; 25)
<span class="lineNum">     616 </span>            : #define IWM_UCODE_TLV_FLAGS_P2P_PS_UAPSD        (1 &lt;&lt; 26)
<span class="lineNum">     617 </span>            : #define IWM_UCODE_TLV_FLAGS_BCAST_FILTERING     (1 &lt;&lt; 29)
<span class="lineNum">     618 </span>            : #define IWM_UCODE_TLV_FLAGS_GO_UAPSD            (1 &lt;&lt; 30)
<span class="lineNum">     619 </span>            : #define IWM_UCODE_TLV_FLAGS_LTE_COEX            (1 &lt;&lt; 31)
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : #define IWM_UCODE_TLV_FLAG_BITS \
<span class="lineNum">     622 </span>            :         &quot;\020\1PAN\2NEWSCAN\3MFP\4P2P\5DW_BC_TABLE\6NEWBT_COEX\7PM_CMD\10SHORT_BL\11RX_ENERGY\12TIME_EVENT_V2\13D3_6_IPV6\14BF_UPDATED\15NO_BASIC_SSID\17D3_CONTINUITY\20NEW_NSOFFL_S\21NEW_NSOFFL_L\22SCHED_SCAN\24STA_KEY_CMD\25DEVICE_PS_CMD\26P2P_PS\27P2P_PS_DCM\30P2P_PS_SCM\31UAPSD_SUPPORT\32EBS\33P2P_PS_UAPSD\36BCAST_FILTERING\37GO_UAPSD\40LTE_COEX&quot;
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            : /**
<span class="lineNum">     625 </span>            :  * uCode TLV api
<span class="lineNum">     626 </span>            :  * @IWM_UCODE_TLV_API_FRAGMENTED_SCAN: This ucode supports active dwell time
<span class="lineNum">     627 </span>            :  *      longer than the passive one, which is essential for fragmented scan.
<span class="lineNum">     628 </span>            :  * @IWM_UCODE_TLV_API_WIFI_MCC_UPDATE: ucode supports MCC updates with source.
<span class="lineNum">     629 </span>            :  * @IWM_UCODE_TLV_API_WIDE_CMD_HDR: ucode supports wide command header
<span class="lineNum">     630 </span>            :  * @IWM_UCODE_TLV_API_LQ_SS_PARAMS: Configure STBC/BFER via LQ CMD ss_params
<span class="lineNum">     631 </span>            :  * @IWM_UCODE_TLV_API_EXT_SCAN_PRIORITY: scan APIs use 8-level priority
<span class="lineNum">     632 </span>            :  *      instead of 3.
<span class="lineNum">     633 </span>            :  * @IWM_UCODE_TLV_API_TX_POWER_CHAIN: TX power API has larger command size
<span class="lineNum">     634 </span>            :  *      (command version 3) that supports per-chain limits
<span class="lineNum">     635 </span>            :  *
<span class="lineNum">     636 </span>            :  * @IWM_NUM_UCODE_TLV_API: number of bits used
<span class="lineNum">     637 </span>            :  */
<span class="lineNum">     638 </span>            : #define IWM_UCODE_TLV_API_FRAGMENTED_SCAN       (1 &lt;&lt; 8)
<span class="lineNum">     639 </span>            : #define IWM_UCODE_TLV_API_WIFI_MCC_UPDATE       (1 &lt;&lt; 9)
<span class="lineNum">     640 </span>            : #define IWM_UCODE_TLV_API_WIDE_CMD_HDR          (1 &lt;&lt; 14)
<span class="lineNum">     641 </span>            : #define IWM_UCODE_TLV_API_LQ_SS_PARAMS          (1 &lt;&lt; 18)
<span class="lineNum">     642 </span>            : #define IWM_UCODE_TLV_API_EXT_SCAN_PRIORITY     (1 &lt;&lt; 24)
<span class="lineNum">     643 </span>            : #define IWM_UCODE_TLV_API_TX_POWER_CHAIN        (1 &lt;&lt; 27)
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : #define IWM_NUM_UCODE_TLV_API = 32
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : #define IWM_UCODE_TLV_API_BITS \
<span class="lineNum">     648 </span>            :         &quot;\020\10FRAGMENTED_SCAN\11WIFI_MCC_UPDATE\16WIDE_CMD_HDR\22LQ_SS_PARAMS\30EXT_SCAN_PRIO\33TX_POWER_CHAIN&quot;
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : /**
<span class="lineNum">     651 </span>            :  * uCode capabilities
<span class="lineNum">     652 </span>            :  * @IWM_UCODE_TLV_CAPA_D0I3_SUPPORT: supports D0i3
<span class="lineNum">     653 </span>            :  * @IWM_UCODE_TLV_CAPA_LAR_SUPPORT: supports Location Aware Regulatory
<span class="lineNum">     654 </span>            :  * @IWM_UCODE_TLV_CAPA_UMAC_SCAN: supports UMAC scan.
<span class="lineNum">     655 </span>            :  * @IWM_UCODE_TLV_CAPA_BEAMFORMER: supports Beamformer
<span class="lineNum">     656 </span>            :  * @IWM_UCODE_TLV_CAPA_TOF_SUPPORT: supports Time of Flight (802.11mc FTM)
<span class="lineNum">     657 </span>            :  * @IWM_UCODE_TLV_CAPA_TDLS_SUPPORT: support basic TDLS functionality
<span class="lineNum">     658 </span>            :  * @IWM_UCODE_TLV_CAPA_TXPOWER_INSERTION_SUPPORT: supports insertion of current
<span class="lineNum">     659 </span>            :  *      tx power value into TPC Report action frame and Link Measurement Report
<span class="lineNum">     660 </span>            :  *      action frame
<span class="lineNum">     661 </span>            :  * @IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT: supports updating current
<span class="lineNum">     662 </span>            :  *      channel in DS parameter set element in probe requests.
<span class="lineNum">     663 </span>            :  * @IWM_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT: supports adding TPC Report IE in
<span class="lineNum">     664 </span>            :  *      probe requests.
<span class="lineNum">     665 </span>            :  * @IWM_UCODE_TLV_CAPA_QUIET_PERIOD_SUPPORT: supports Quiet Period requests
<span class="lineNum">     666 </span>            :  * @IWM_UCODE_TLV_CAPA_DQA_SUPPORT: supports dynamic queue allocation (DQA),
<span class="lineNum">     667 </span>            :  *      which also implies support for the scheduler configuration command
<span class="lineNum">     668 </span>            :  * @IWM_UCODE_TLV_CAPA_TDLS_CHANNEL_SWITCH: supports TDLS channel switching
<span class="lineNum">     669 </span>            :  * @IWM_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG: Consolidated D3-D0 image
<span class="lineNum">     670 </span>            :  * @IWM_UCODE_TLV_CAPA_HOTSPOT_SUPPORT: supports Hot Spot Command
<span class="lineNum">     671 </span>            :  * @IWM_UCODE_TLV_CAPA_DC2DC_SUPPORT: supports DC2DC Command
<span class="lineNum">     672 </span>            :  * @IWM_UCODE_TLV_CAPA_2G_COEX_SUPPORT: supports 2G coex Command
<span class="lineNum">     673 </span>            :  * @IWM_UCODE_TLV_CAPA_CSUM_SUPPORT: supports TCP Checksum Offload
<span class="lineNum">     674 </span>            :  * @IWM_UCODE_TLV_CAPA_RADIO_BEACON_STATS: support radio and beacon statistics
<span class="lineNum">     675 </span>            :  * @IWM_UCODE_TLV_CAPA_P2P_STANDALONE_UAPSD: support p2p standalone U-APSD
<span class="lineNum">     676 </span>            :  * @IWM_UCODE_TLV_CAPA_BT_COEX_PLCR: enabled BT Coex packet level co-running
<span class="lineNum">     677 </span>            :  * @IWM_UCODE_TLV_CAPA_LAR_MULTI_MCC: ucode supports LAR updates with different
<span class="lineNum">     678 </span>            :  *      sources for the MCC. This TLV bit is a future replacement to
<span class="lineNum">     679 </span>            :  *      IWM_UCODE_TLV_API_WIFI_MCC_UPDATE. When either is set, multi-source LAR
<span class="lineNum">     680 </span>            :  *      is supported.
<span class="lineNum">     681 </span>            :  * @IWM_UCODE_TLV_CAPA_BT_COEX_RRC: supports BT Coex RRC
<span class="lineNum">     682 </span>            :  * @IWM_UCODE_TLV_CAPA_GSCAN_SUPPORT: supports gscan
<span class="lineNum">     683 </span>            :  * @IWM_UCODE_TLV_CAPA_NAN_SUPPORT: supports NAN
<span class="lineNum">     684 </span>            :  * @IWM_UCODE_TLV_CAPA_UMAC_UPLOAD: supports upload mode in umac (1=supported,
<span class="lineNum">     685 </span>            :  *      0=no support)
<span class="lineNum">     686 </span>            :  * @IWM_UCODE_TLV_CAPA_EXTENDED_DTS_MEASURE: extended DTS measurement
<span class="lineNum">     687 </span>            :  * @IWM_UCODE_TLV_CAPA_SHORT_PM_TIMEOUTS: supports short PM timeouts
<span class="lineNum">     688 </span>            :  * @IWM_UCODE_TLV_CAPA_BT_MPLUT_SUPPORT: supports bt-coex Multi-priority LUT
<span class="lineNum">     689 </span>            :  * @IWM_UCODE_TLV_CAPA_BEACON_ANT_SELECTION: firmware will decide on what
<span class="lineNum">     690 </span>            :  *      antenna the beacon should be transmitted
<span class="lineNum">     691 </span>            :  * @IWM_UCODE_TLV_CAPA_BEACON_STORING: firmware will store the latest beacon
<span class="lineNum">     692 </span>            :  *      from AP and will send it upon d0i3 exit.
<span class="lineNum">     693 </span>            :  * @IWM_UCODE_TLV_CAPA_LAR_SUPPORT_V2: support LAR API V2
<span class="lineNum">     694 </span>            :  * @IWM_UCODE_TLV_CAPA_CT_KILL_BY_FW: firmware responsible for CT-kill
<span class="lineNum">     695 </span>            :  * @IWM_UCODE_TLV_CAPA_TEMP_THS_REPORT_SUPPORT: supports temperature
<span class="lineNum">     696 </span>            :  *      thresholds reporting
<span class="lineNum">     697 </span>            :  * @IWM_UCODE_TLV_CAPA_CTDP_SUPPORT: supports cTDP command
<span class="lineNum">     698 </span>            :  * @IWM_UCODE_TLV_CAPA_USNIFFER_UNIFIED: supports usniffer enabled in
<span class="lineNum">     699 </span>            :  *      regular image.
<span class="lineNum">     700 </span>            :  * @IWM_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG: support getting more shared
<span class="lineNum">     701 </span>            :  *      memory addresses from the firmware.
<span class="lineNum">     702 </span>            :  * @IWM_UCODE_TLV_CAPA_LQM_SUPPORT: supports Link Quality Measurement
<span class="lineNum">     703 </span>            :  * @IWM_UCODE_TLV_CAPA_LMAC_UPLOAD: supports upload mode in lmac (1=supported,
<span class="lineNum">     704 </span>            :  *      0=no support)
<span class="lineNum">     705 </span>            :  *
<span class="lineNum">     706 </span>            :  * @IWM_NUM_UCODE_TLV_CAPA: number of bits used
<span class="lineNum">     707 </span>            :  */
<span class="lineNum">     708 </span>            : #define IWM_UCODE_TLV_CAPA_D0I3_SUPPORT                 0
<span class="lineNum">     709 </span>            : #define IWM_UCODE_TLV_CAPA_LAR_SUPPORT                  1
<span class="lineNum">     710 </span>            : #define IWM_UCODE_TLV_CAPA_UMAC_SCAN                    2
<span class="lineNum">     711 </span>            : #define IWM_UCODE_TLV_CAPA_BEAMFORMER                   3
<span class="lineNum">     712 </span>            : #define IWM_UCODE_TLV_CAPA_TOF_SUPPORT                  5
<span class="lineNum">     713 </span>            : #define IWM_UCODE_TLV_CAPA_TDLS_SUPPORT                 6
<span class="lineNum">     714 </span>            : #define IWM_UCODE_TLV_CAPA_TXPOWER_INSERTION_SUPPORT    8
<span class="lineNum">     715 </span>            : #define IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT      9
<span class="lineNum">     716 </span>            : #define IWM_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT       10
<span class="lineNum">     717 </span>            : #define IWM_UCODE_TLV_CAPA_QUIET_PERIOD_SUPPORT         11
<span class="lineNum">     718 </span>            : #define IWM_UCODE_TLV_CAPA_DQA_SUPPORT                  12
<span class="lineNum">     719 </span>            : #define IWM_UCODE_TLV_CAPA_TDLS_CHANNEL_SWITCH          13
<span class="lineNum">     720 </span>            : #define IWM_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG            17
<span class="lineNum">     721 </span>            : #define IWM_UCODE_TLV_CAPA_HOTSPOT_SUPPORT              18
<span class="lineNum">     722 </span>            : #define IWM_UCODE_TLV_CAPA_DC2DC_CONFIG_SUPPORT         19
<span class="lineNum">     723 </span>            : #define IWM_UCODE_TLV_CAPA_2G_COEX_SUPPORT              20
<span class="lineNum">     724 </span>            : #define IWM_UCODE_TLV_CAPA_CSUM_SUPPORT                 21
<span class="lineNum">     725 </span>            : #define IWM_UCODE_TLV_CAPA_RADIO_BEACON_STATS           22
<span class="lineNum">     726 </span>            : #define IWM_UCODE_TLV_CAPA_P2P_STANDALONE_UAPSD         26
<span class="lineNum">     727 </span>            : #define IWM_UCODE_TLV_CAPA_BT_COEX_PLCR                 28
<span class="lineNum">     728 </span>            : #define IWM_UCODE_TLV_CAPA_LAR_MULTI_MCC                29
<span class="lineNum">     729 </span>            : #define IWM_UCODE_TLV_CAPA_BT_COEX_RRC                  30
<span class="lineNum">     730 </span>            : #define IWM_UCODE_TLV_CAPA_GSCAN_SUPPORT                31
<span class="lineNum">     731 </span>            : #define IWM_UCODE_TLV_CAPA_NAN_SUPPORT                  34
<span class="lineNum">     732 </span>            : #define IWM_UCODE_TLV_CAPA_UMAC_UPLOAD                  35
<span class="lineNum">     733 </span>            : #define IWM_UCODE_TLV_CAPA_EXTENDED_DTS_MEASURE         64
<span class="lineNum">     734 </span>            : #define IWM_UCODE_TLV_CAPA_SHORT_PM_TIMEOUTS            65
<span class="lineNum">     735 </span>            : #define IWM_UCODE_TLV_CAPA_BT_MPLUT_SUPPORT             67
<span class="lineNum">     736 </span>            : #define IWM_UCODE_TLV_CAPA_MULTI_QUEUE_RX_SUPPORT       68
<span class="lineNum">     737 </span>            : #define IWM_UCODE_TLV_CAPA_BEACON_ANT_SELECTION         71
<span class="lineNum">     738 </span>            : #define IWM_UCODE_TLV_CAPA_BEACON_STORING               72
<span class="lineNum">     739 </span>            : #define IWM_UCODE_TLV_CAPA_LAR_SUPPORT_V2               73
<span class="lineNum">     740 </span>            : #define IWM_UCODE_TLV_CAPA_CT_KILL_BY_FW                74
<span class="lineNum">     741 </span>            : #define IWM_UCODE_TLV_CAPA_TEMP_THS_REPORT_SUPPORT      75
<span class="lineNum">     742 </span>            : #define IWM_UCODE_TLV_CAPA_CTDP_SUPPORT                 76
<span class="lineNum">     743 </span>            : #define IWM_UCODE_TLV_CAPA_USNIFFER_UNIFIED             77
<span class="lineNum">     744 </span>            : #define IWM_UCODE_TLV_CAPA_LMAC_UPLOAD                  79
<span class="lineNum">     745 </span>            : #define IWM_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG        80
<span class="lineNum">     746 </span>            : #define IWM_UCODE_TLV_CAPA_LQM_SUPPORT                  81
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : #define IWM_NUM_UCODE_TLV_CAPA 128
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : /* The default calibrate table size if not specified by firmware file */
<span class="lineNum">     751 </span>            : #define IWM_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE     18
<span class="lineNum">     752 </span>            : #define IWM_MAX_STANDARD_PHY_CALIBRATE_TBL_SIZE         19
<span class="lineNum">     753 </span>            : #define IWM_MAX_PHY_CALIBRATE_TBL_SIZE                  253
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : /* The default max probe length if not specified by the firmware file */
<span class="lineNum">     756 </span>            : #define IWM_DEFAULT_MAX_PROBE_LENGTH    200
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            : /*
<span class="lineNum">     759 </span>            :  * For 16.0 uCode and above, there is no differentiation between sections,
<span class="lineNum">     760 </span>            :  * just an offset to the HW address.
<span class="lineNum">     761 </span>            :  */
<span class="lineNum">     762 </span>            : #define IWM_CPU1_CPU2_SEPARATOR_SECTION         0xFFFFCCCC
<span class="lineNum">     763 </span>            : #define IWM_PAGING_SEPARATOR_SECTION            0xAAAABBBB
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : /* uCode version contains 4 values: Major/Minor/API/Serial */
<span class="lineNum">     766 </span>            : #define IWM_UCODE_MAJOR(ver)    (((ver) &amp; 0xFF000000) &gt;&gt; 24)
<span class="lineNum">     767 </span>            : #define IWM_UCODE_MINOR(ver)    (((ver) &amp; 0x00FF0000) &gt;&gt; 16)
<span class="lineNum">     768 </span>            : #define IWM_UCODE_API(ver)      (((ver) &amp; 0x0000FF00) &gt;&gt; 8)
<span class="lineNum">     769 </span>            : #define IWM_UCODE_SERIAL(ver)   ((ver) &amp; 0x000000FF)
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            : /*
<span class="lineNum">     772 </span>            :  * Calibration control struct.
<span class="lineNum">     773 </span>            :  * Sent as part of the phy configuration command.
<span class="lineNum">     774 </span>            :  * @flow_trigger: bitmap for which calibrations to perform according to
<span class="lineNum">     775 </span>            :  *              flow triggers.
<span class="lineNum">     776 </span>            :  * @event_trigger: bitmap for which calibrations to perform according to
<span class="lineNum">     777 </span>            :  *              event triggers.
<span class="lineNum">     778 </span>            :  */
<span class="lineNum">     779 </span>            : struct iwm_tlv_calib_ctrl {
<span class="lineNum">     780 </span>            :         uint32_t flow_trigger;
<span class="lineNum">     781 </span>            :         uint32_t event_trigger;
<span class="lineNum">     782 </span>            : } __packed;
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : #define IWM_FW_PHY_CFG_RADIO_TYPE_POS   0
<span class="lineNum">     785 </span>            : #define IWM_FW_PHY_CFG_RADIO_TYPE       (0x3 &lt;&lt; IWM_FW_PHY_CFG_RADIO_TYPE_POS)
<span class="lineNum">     786 </span>            : #define IWM_FW_PHY_CFG_RADIO_STEP_POS   2
<span class="lineNum">     787 </span>            : #define IWM_FW_PHY_CFG_RADIO_STEP       (0x3 &lt;&lt; IWM_FW_PHY_CFG_RADIO_STEP_POS)
<span class="lineNum">     788 </span>            : #define IWM_FW_PHY_CFG_RADIO_DASH_POS   4
<span class="lineNum">     789 </span>            : #define IWM_FW_PHY_CFG_RADIO_DASH       (0x3 &lt;&lt; IWM_FW_PHY_CFG_RADIO_DASH_POS)
<span class="lineNum">     790 </span>            : #define IWM_FW_PHY_CFG_TX_CHAIN_POS     16
<span class="lineNum">     791 </span>            : #define IWM_FW_PHY_CFG_TX_CHAIN         (0xf &lt;&lt; IWM_FW_PHY_CFG_TX_CHAIN_POS)
<span class="lineNum">     792 </span>            : #define IWM_FW_PHY_CFG_RX_CHAIN_POS     20
<span class="lineNum">     793 </span>            : #define IWM_FW_PHY_CFG_RX_CHAIN         (0xf &lt;&lt; IWM_FW_PHY_CFG_RX_CHAIN_POS)
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            : #define IWM_UCODE_MAX_CS                1
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : /**
<span class="lineNum">     798 </span>            :  * struct iwm_fw_cipher_scheme - a cipher scheme supported by FW.
<span class="lineNum">     799 </span>            :  * @cipher: a cipher suite selector
<span class="lineNum">     800 </span>            :  * @flags: cipher scheme flags (currently reserved for a future use)
<span class="lineNum">     801 </span>            :  * @hdr_len: a size of MPDU security header
<span class="lineNum">     802 </span>            :  * @pn_len: a size of PN
<span class="lineNum">     803 </span>            :  * @pn_off: an offset of pn from the beginning of the security header
<span class="lineNum">     804 </span>            :  * @key_idx_off: an offset of key index byte in the security header
<span class="lineNum">     805 </span>            :  * @key_idx_mask: a bit mask of key_idx bits
<span class="lineNum">     806 </span>            :  * @key_idx_shift: bit shift needed to get key_idx
<span class="lineNum">     807 </span>            :  * @mic_len: mic length in bytes
<span class="lineNum">     808 </span>            :  * @hw_cipher: a HW cipher index used in host commands
<span class="lineNum">     809 </span>            :  */
<span class="lineNum">     810 </span>            : struct iwm_fw_cipher_scheme {
<span class="lineNum">     811 </span>            :         uint32_t cipher;
<span class="lineNum">     812 </span>            :         uint8_t flags;
<span class="lineNum">     813 </span>            :         uint8_t hdr_len;
<span class="lineNum">     814 </span>            :         uint8_t pn_len;
<span class="lineNum">     815 </span>            :         uint8_t pn_off;
<span class="lineNum">     816 </span>            :         uint8_t key_idx_off;
<span class="lineNum">     817 </span>            :         uint8_t key_idx_mask;
<span class="lineNum">     818 </span>            :         uint8_t key_idx_shift;
<span class="lineNum">     819 </span>            :         uint8_t mic_len;
<span class="lineNum">     820 </span>            :         uint8_t hw_cipher;
<span class="lineNum">     821 </span>            : } __packed;
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            : /**
<span class="lineNum">     824 </span>            :  * struct iwm_fw_cscheme_list - a cipher scheme list
<span class="lineNum">     825 </span>            :  * @size: a number of entries
<span class="lineNum">     826 </span>            :  * @cs: cipher scheme entries
<span class="lineNum">     827 </span>            :  */
<span class="lineNum">     828 </span>            : struct iwm_fw_cscheme_list {
<span class="lineNum">     829 </span>            :         uint8_t size;
<span class="lineNum">     830 </span>            :         struct iwm_fw_cipher_scheme cs[];
<span class="lineNum">     831 </span>            : } __packed;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : /* v1/v2 uCode file layout */
<span class="lineNum">     834 </span>            : struct iwm_ucode_header {
<span class="lineNum">     835 </span>            :         uint32_t ver;   /* major/minor/API/serial */
<span class="lineNum">     836 </span>            :         union {
<span class="lineNum">     837 </span>            :                 struct {
<span class="lineNum">     838 </span>            :                         uint32_t inst_size;     /* bytes of runtime code */
<span class="lineNum">     839 </span>            :                         uint32_t data_size;     /* bytes of runtime data */
<span class="lineNum">     840 </span>            :                         uint32_t init_size;     /* bytes of init code */
<span class="lineNum">     841 </span>            :                         uint32_t init_data_size;        /* bytes of init data */
<span class="lineNum">     842 </span>            :                         uint32_t boot_size;     /* bytes of bootstrap code */
<span class="lineNum">     843 </span>            :                         uint8_t data[0];                /* in same order as sizes */
<span class="lineNum">     844 </span>            :                 } v1;
<span class="lineNum">     845 </span>            :                 struct {
<span class="lineNum">     846 </span>            :                         uint32_t build;         /* build number */
<span class="lineNum">     847 </span>            :                         uint32_t inst_size;     /* bytes of runtime code */
<span class="lineNum">     848 </span>            :                         uint32_t data_size;     /* bytes of runtime data */
<span class="lineNum">     849 </span>            :                         uint32_t init_size;     /* bytes of init code */
<span class="lineNum">     850 </span>            :                         uint32_t init_data_size;        /* bytes of init data */
<span class="lineNum">     851 </span>            :                         uint32_t boot_size;     /* bytes of bootstrap code */
<span class="lineNum">     852 </span>            :                         uint8_t data[0];                /* in same order as sizes */
<span class="lineNum">     853 </span>            :                 } v2;
<span class="lineNum">     854 </span>            :         } u;
<span class="lineNum">     855 </span>            : };
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : /*
<span class="lineNum">     858 </span>            :  * new TLV uCode file layout
<span class="lineNum">     859 </span>            :  *
<span class="lineNum">     860 </span>            :  * The new TLV file format contains TLVs, that each specify
<span class="lineNum">     861 </span>            :  * some piece of data.
<span class="lineNum">     862 </span>            :  */
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : #define IWM_UCODE_TLV_INVALID           0 /* unused */
<span class="lineNum">     865 </span>            : #define IWM_UCODE_TLV_INST              1
<span class="lineNum">     866 </span>            : #define IWM_UCODE_TLV_DATA              2
<span class="lineNum">     867 </span>            : #define IWM_UCODE_TLV_INIT              3
<span class="lineNum">     868 </span>            : #define IWM_UCODE_TLV_INIT_DATA         4
<span class="lineNum">     869 </span>            : #define IWM_UCODE_TLV_BOOT              5
<span class="lineNum">     870 </span>            : #define IWM_UCODE_TLV_PROBE_MAX_LEN     6 /* a uint32_t value */
<span class="lineNum">     871 </span>            : #define IWM_UCODE_TLV_PAN               7
<span class="lineNum">     872 </span>            : #define IWM_UCODE_TLV_RUNT_EVTLOG_PTR   8
<span class="lineNum">     873 </span>            : #define IWM_UCODE_TLV_RUNT_EVTLOG_SIZE  9
<span class="lineNum">     874 </span>            : #define IWM_UCODE_TLV_RUNT_ERRLOG_PTR   10
<span class="lineNum">     875 </span>            : #define IWM_UCODE_TLV_INIT_EVTLOG_PTR   11
<span class="lineNum">     876 </span>            : #define IWM_UCODE_TLV_INIT_EVTLOG_SIZE  12
<span class="lineNum">     877 </span>            : #define IWM_UCODE_TLV_INIT_ERRLOG_PTR   13
<span class="lineNum">     878 </span>            : #define IWM_UCODE_TLV_ENHANCE_SENS_TBL  14
<span class="lineNum">     879 </span>            : #define IWM_UCODE_TLV_PHY_CALIBRATION_SIZE 15
<span class="lineNum">     880 </span>            : #define IWM_UCODE_TLV_WOWLAN_INST       16
<span class="lineNum">     881 </span>            : #define IWM_UCODE_TLV_WOWLAN_DATA       17
<span class="lineNum">     882 </span>            : #define IWM_UCODE_TLV_FLAGS             18
<span class="lineNum">     883 </span>            : #define IWM_UCODE_TLV_SEC_RT            19
<span class="lineNum">     884 </span>            : #define IWM_UCODE_TLV_SEC_INIT          20
<span class="lineNum">     885 </span>            : #define IWM_UCODE_TLV_SEC_WOWLAN        21
<span class="lineNum">     886 </span>            : #define IWM_UCODE_TLV_DEF_CALIB         22
<span class="lineNum">     887 </span>            : #define IWM_UCODE_TLV_PHY_SKU           23
<span class="lineNum">     888 </span>            : #define IWM_UCODE_TLV_SECURE_SEC_RT     24
<span class="lineNum">     889 </span>            : #define IWM_UCODE_TLV_SECURE_SEC_INIT   25
<span class="lineNum">     890 </span>            : #define IWM_UCODE_TLV_SECURE_SEC_WOWLAN 26
<span class="lineNum">     891 </span>            : #define IWM_UCODE_TLV_NUM_OF_CPU        27
<span class="lineNum">     892 </span>            : #define IWM_UCODE_TLV_CSCHEME           28
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :         /*
<span class="lineNum">     895 </span>            :          * Following two are not in our base tag, but allow
<span class="lineNum">     896 </span>            :          * handling ucode version 9.
<span class="lineNum">     897 </span>            :          */
<span class="lineNum">     898 </span>            : #define IWM_UCODE_TLV_API_CHANGES_SET   29
<span class="lineNum">     899 </span>            : #define IWM_UCODE_TLV_ENABLED_CAPABILITIES 30
<span class="lineNum">     900 </span>            : #define IWM_UCODE_TLV_N_SCAN_CHANNELS   31
<span class="lineNum">     901 </span>            : #define IWM_UCODE_TLV_PAGING            32
<span class="lineNum">     902 </span>            : #define IWM_UCODE_TLV_SEC_RT_USNIFFER   34
<span class="lineNum">     903 </span>            : #define IWM_UCODE_TLV_SDIO_ADMA_ADDR    35
<span class="lineNum">     904 </span>            : #define IWM_UCODE_TLV_FW_VERSION        36
<span class="lineNum">     905 </span>            : #define IWM_UCODE_TLV_FW_DBG_DEST       38
<span class="lineNum">     906 </span>            : #define IWM_UCODE_TLV_FW_DBG_CONF       39
<span class="lineNum">     907 </span>            : #define IWM_UCODE_TLV_FW_DBG_TRIGGER    40
<span class="lineNum">     908 </span>            : #define IWM_UCODE_TLV_FW_GSCAN_CAPA     50
<span class="lineNum">     909 </span>            : #define IWM_UCODE_TLV_FW_MEM_SEG        51
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : struct iwm_ucode_tlv {
<span class="lineNum">     912 </span>            :         uint32_t type;          /* see above */
<span class="lineNum">     913 </span>            :         uint32_t length;                /* not including type/length fields */
<span class="lineNum">     914 </span>            :         uint8_t data[0];
<span class="lineNum">     915 </span>            : };
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            : struct iwm_ucode_api {
<span class="lineNum">     918 </span>            :         uint32_t api_index;
<span class="lineNum">     919 </span>            :         uint32_t api_flags;
<span class="lineNum">     920 </span>            : } __packed;
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : struct iwm_ucode_capa {
<span class="lineNum">     923 </span>            :         uint32_t api_index;
<span class="lineNum">     924 </span>            :         uint32_t api_capa;
<span class="lineNum">     925 </span>            : } __packed;
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : #define IWM_TLV_UCODE_MAGIC     0x0a4c5749
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            : struct iwm_tlv_ucode_header {
<span class="lineNum">     930 </span>            :         /*
<span class="lineNum">     931 </span>            :          * The TLV style ucode header is distinguished from
<span class="lineNum">     932 </span>            :          * the v1/v2 style header by first four bytes being
<span class="lineNum">     933 </span>            :          * zero, as such is an invalid combination of
<span class="lineNum">     934 </span>            :          * major/minor/API/serial versions.
<span class="lineNum">     935 </span>            :          */
<span class="lineNum">     936 </span>            :         uint32_t zero;
<span class="lineNum">     937 </span>            :         uint32_t magic;
<span class="lineNum">     938 </span>            :         uint8_t human_readable[64];
<span class="lineNum">     939 </span>            :         uint32_t ver;           /* major/minor/API/serial */
<span class="lineNum">     940 </span>            :         uint32_t build;
<span class="lineNum">     941 </span>            :         uint64_t ignore;
<span class="lineNum">     942 </span>            :         /*
<span class="lineNum">     943 </span>            :          * The data contained herein has a TLV layout,
<span class="lineNum">     944 </span>            :          * see above for the TLV header and types.
<span class="lineNum">     945 </span>            :          * Note that each TLV is padded to a length
<span class="lineNum">     946 </span>            :          * that is a multiple of 4 for alignment.
<span class="lineNum">     947 </span>            :          */
<span class="lineNum">     948 </span>            :         uint8_t data[0];
<span class="lineNum">     949 </span>            : };
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /*
<span class="lineNum">     952 </span>            :  * Registers in this file are internal, not PCI bus memory mapped.
<span class="lineNum">     953 </span>            :  * Driver accesses these via IWM_HBUS_TARG_PRPH_* registers.
<span class="lineNum">     954 </span>            :  */
<span class="lineNum">     955 </span>            : #define IWM_PRPH_BASE   (0x00000)
<span class="lineNum">     956 </span>            : #define IWM_PRPH_END    (0xFFFFF)
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            : /* APMG (power management) constants */
<span class="lineNum">     959 </span>            : #define IWM_APMG_BASE                   (IWM_PRPH_BASE + 0x3000)
<span class="lineNum">     960 </span>            : #define IWM_APMG_CLK_CTRL_REG           (IWM_APMG_BASE + 0x0000)
<span class="lineNum">     961 </span>            : #define IWM_APMG_CLK_EN_REG             (IWM_APMG_BASE + 0x0004)
<span class="lineNum">     962 </span>            : #define IWM_APMG_CLK_DIS_REG            (IWM_APMG_BASE + 0x0008)
<span class="lineNum">     963 </span>            : #define IWM_APMG_PS_CTRL_REG            (IWM_APMG_BASE + 0x000c)
<span class="lineNum">     964 </span>            : #define IWM_APMG_PCIDEV_STT_REG         (IWM_APMG_BASE + 0x0010)
<span class="lineNum">     965 </span>            : #define IWM_APMG_RFKILL_REG             (IWM_APMG_BASE + 0x0014)
<span class="lineNum">     966 </span>            : #define IWM_APMG_RTC_INT_STT_REG        (IWM_APMG_BASE + 0x001c)
<span class="lineNum">     967 </span>            : #define IWM_APMG_RTC_INT_MSK_REG        (IWM_APMG_BASE + 0x0020)
<span class="lineNum">     968 </span>            : #define IWM_APMG_DIGITAL_SVR_REG        (IWM_APMG_BASE + 0x0058)
<span class="lineNum">     969 </span>            : #define IWM_APMG_ANALOG_SVR_REG         (IWM_APMG_BASE + 0x006C)
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            : #define IWM_APMS_CLK_VAL_MRB_FUNC_MODE  (0x00000001)
<span class="lineNum">     972 </span>            : #define IWM_APMG_CLK_VAL_DMA_CLK_RQT    (0x00000200)
<span class="lineNum">     973 </span>            : #define IWM_APMG_CLK_VAL_BSM_CLK_RQT    (0x00000800)
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : #define IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS        (0x00400000)
<span class="lineNum">     976 </span>            : #define IWM_APMG_PS_CTRL_VAL_RESET_REQ                  (0x04000000)
<span class="lineNum">     977 </span>            : #define IWM_APMG_PS_CTRL_MSK_PWR_SRC                    (0x03000000)
<span class="lineNum">     978 </span>            : #define IWM_APMG_PS_CTRL_VAL_PWR_SRC_VMAIN              (0x00000000)
<span class="lineNum">     979 </span>            : #define IWM_APMG_PS_CTRL_VAL_PWR_SRC_VAUX               (0x02000000)
<span class="lineNum">     980 </span>            : #define IWM_APMG_SVR_VOLTAGE_CONFIG_BIT_MSK             (0x000001E0) /* bit 8:5 */
<span class="lineNum">     981 </span>            : #define IWM_APMG_SVR_DIGITAL_VOLTAGE_1_32               (0x00000060)
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            : #define IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS              (0x00000800)
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : #define IWM_APMG_RTC_INT_STT_RFKILL                     (0x10000000)
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : /* Device system time */
<span class="lineNum">     988 </span>            : #define IWM_DEVICE_SYSTEM_TIME_REG 0xA0206C
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            : /* Device NMI register */
<span class="lineNum">     991 </span>            : #define IWM_DEVICE_SET_NMI_REG          0x00a01c30
<span class="lineNum">     992 </span>            : #define IWM_DEVICE_SET_NMI_VAL_HW       0x01
<span class="lineNum">     993 </span>            : #define IWM_DEVICE_SET_NMI_VAL_DRV      0x80
<span class="lineNum">     994 </span>            : #define IWM_DEVICE_SET_NMI_8000_REG     0x00a01c24
<span class="lineNum">     995 </span>            : #define IWM_DEVICE_SET_NMI_8000_VAL     0x1000000
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : /*
<span class="lineNum">     998 </span>            :  * Device reset for family 8000
<span class="lineNum">     999 </span>            :  * write to bit 24 in order to reset the CPU
<span class="lineNum">    1000 </span>            : */
<span class="lineNum">    1001 </span>            : #define IWM_RELEASE_CPU_RESET           0x300c
<span class="lineNum">    1002 </span>            : #define IWM_RELEASE_CPU_RESET_BIT       0x1000000
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : /*****************************************************************************
<span class="lineNum">    1006 </span>            :  *                        7000/3000 series SHR DTS addresses                 *
<span class="lineNum">    1007 </span>            :  *****************************************************************************/
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : #define IWM_SHR_MISC_WFM_DTS_EN         (0x00a10024)
<span class="lineNum">    1010 </span>            : #define IWM_DTSC_CFG_MODE               (0x00a10604)
<span class="lineNum">    1011 </span>            : #define IWM_DTSC_VREF_AVG               (0x00a10648)
<span class="lineNum">    1012 </span>            : #define IWM_DTSC_VREF5_AVG              (0x00a1064c)
<span class="lineNum">    1013 </span>            : #define IWM_DTSC_CFG_MODE_PERIODIC      (0x2)
<span class="lineNum">    1014 </span>            : #define IWM_DTSC_PTAT_AVG               (0x00a10650)
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : /**
<span class="lineNum">    1018 </span>            :  * Tx Scheduler
<span class="lineNum">    1019 </span>            :  *
<span class="lineNum">    1020 </span>            :  * The Tx Scheduler selects the next frame to be transmitted, choosing TFDs
<span class="lineNum">    1021 </span>            :  * (Transmit Frame Descriptors) from up to 16 circular Tx queues resident in
<span class="lineNum">    1022 </span>            :  * host DRAM.  It steers each frame's Tx command (which contains the frame
<span class="lineNum">    1023 </span>            :  * data) into one of up to 7 prioritized Tx DMA FIFO channels within the
<span class="lineNum">    1024 </span>            :  * device.  A queue maps to only one (selectable by driver) Tx DMA channel,
<span class="lineNum">    1025 </span>            :  * but one DMA channel may take input from several queues.
<span class="lineNum">    1026 </span>            :  *
<span class="lineNum">    1027 </span>            :  * Tx DMA FIFOs have dedicated purposes.
<span class="lineNum">    1028 </span>            :  *
<span class="lineNum">    1029 </span>            :  * For 5000 series and up, they are used differently
<span class="lineNum">    1030 </span>            :  * (cf. iwl5000_default_queue_to_tx_fifo in iwl-5000.c):
<span class="lineNum">    1031 </span>            :  *
<span class="lineNum">    1032 </span>            :  * 0 -- EDCA BK (background) frames, lowest priority
<span class="lineNum">    1033 </span>            :  * 1 -- EDCA BE (best effort) frames, normal priority
<span class="lineNum">    1034 </span>            :  * 2 -- EDCA VI (video) frames, higher priority
<span class="lineNum">    1035 </span>            :  * 3 -- EDCA VO (voice) and management frames, highest priority
<span class="lineNum">    1036 </span>            :  * 4 -- unused
<span class="lineNum">    1037 </span>            :  * 5 -- unused
<span class="lineNum">    1038 </span>            :  * 6 -- unused
<span class="lineNum">    1039 </span>            :  * 7 -- Commands
<span class="lineNum">    1040 </span>            :  *
<span class="lineNum">    1041 </span>            :  * Driver should normally map queues 0-6 to Tx DMA/FIFO channels 0-6.
<span class="lineNum">    1042 </span>            :  * In addition, driver can map the remaining queues to Tx DMA/FIFO
<span class="lineNum">    1043 </span>            :  * channels 0-3 to support 11n aggregation via EDCA DMA channels.
<span class="lineNum">    1044 </span>            :  *
<span class="lineNum">    1045 </span>            :  * The driver sets up each queue to work in one of two modes:
<span class="lineNum">    1046 </span>            :  *
<span class="lineNum">    1047 </span>            :  * 1)  Scheduler-Ack, in which the scheduler automatically supports a
<span class="lineNum">    1048 </span>            :  *     block-ack (BA) window of up to 64 TFDs.  In this mode, each queue
<span class="lineNum">    1049 </span>            :  *     contains TFDs for a unique combination of Recipient Address (RA)
<span class="lineNum">    1050 </span>            :  *     and Traffic Identifier (TID), that is, traffic of a given
<span class="lineNum">    1051 </span>            :  *     Quality-Of-Service (QOS) priority, destined for a single station.
<span class="lineNum">    1052 </span>            :  *
<span class="lineNum">    1053 </span>            :  *     In scheduler-ack mode, the scheduler keeps track of the Tx status of
<span class="lineNum">    1054 </span>            :  *     each frame within the BA window, including whether it's been transmitted,
<span class="lineNum">    1055 </span>            :  *     and whether it's been acknowledged by the receiving station.  The device
<span class="lineNum">    1056 </span>            :  *     automatically processes block-acks received from the receiving STA,
<span class="lineNum">    1057 </span>            :  *     and reschedules un-acked frames to be retransmitted (successful
<span class="lineNum">    1058 </span>            :  *     Tx completion may end up being out-of-order).
<span class="lineNum">    1059 </span>            :  *
<span class="lineNum">    1060 </span>            :  *     The driver must maintain the queue's Byte Count table in host DRAM
<span class="lineNum">    1061 </span>            :  *     for this mode.
<span class="lineNum">    1062 </span>            :  *     This mode does not support fragmentation.
<span class="lineNum">    1063 </span>            :  *
<span class="lineNum">    1064 </span>            :  * 2)  FIFO (a.k.a. non-Scheduler-ACK), in which each TFD is processed in order.
<span class="lineNum">    1065 </span>            :  *     The device may automatically retry Tx, but will retry only one frame
<span class="lineNum">    1066 </span>            :  *     at a time, until receiving ACK from receiving station, or reaching
<span class="lineNum">    1067 </span>            :  *     retry limit and giving up.
<span class="lineNum">    1068 </span>            :  *
<span class="lineNum">    1069 </span>            :  *     The command queue (#4/#9) must use this mode!
<span class="lineNum">    1070 </span>            :  *     This mode does not require use of the Byte Count table in host DRAM.
<span class="lineNum">    1071 </span>            :  *
<span class="lineNum">    1072 </span>            :  * Driver controls scheduler operation via 3 means:
<span class="lineNum">    1073 </span>            :  * 1)  Scheduler registers
<span class="lineNum">    1074 </span>            :  * 2)  Shared scheduler data base in internal SRAM
<span class="lineNum">    1075 </span>            :  * 3)  Shared data in host DRAM
<span class="lineNum">    1076 </span>            :  *
<span class="lineNum">    1077 </span>            :  * Initialization:
<span class="lineNum">    1078 </span>            :  *
<span class="lineNum">    1079 </span>            :  * When loading, driver should allocate memory for:
<span class="lineNum">    1080 </span>            :  * 1)  16 TFD circular buffers, each with space for (typically) 256 TFDs.
<span class="lineNum">    1081 </span>            :  * 2)  16 Byte Count circular buffers in 16 KBytes contiguous memory
<span class="lineNum">    1082 </span>            :  *     (1024 bytes for each queue).
<span class="lineNum">    1083 </span>            :  *
<span class="lineNum">    1084 </span>            :  * After receiving &quot;Alive&quot; response from uCode, driver must initialize
<span class="lineNum">    1085 </span>            :  * the scheduler (especially for queue #4/#9, the command queue, otherwise
<span class="lineNum">    1086 </span>            :  * the driver can't issue commands!):
<span class="lineNum">    1087 </span>            :  */
<span class="lineNum">    1088 </span>            : #define IWM_SCD_MEM_LOWER_BOUND         (0x0000)
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            : /**
<span class="lineNum">    1091 </span>            :  * Max Tx window size is the max number of contiguous TFDs that the scheduler
<span class="lineNum">    1092 </span>            :  * can keep track of at one time when creating block-ack chains of frames.
<span class="lineNum">    1093 </span>            :  * Note that &quot;64&quot; matches the number of ack bits in a block-ack packet.
<span class="lineNum">    1094 </span>            :  */
<span class="lineNum">    1095 </span>            : #define IWM_SCD_WIN_SIZE                                64
<span class="lineNum">    1096 </span>            : #define IWM_SCD_FRAME_LIMIT                             64
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : #define IWM_SCD_TXFIFO_POS_TID                  (0)
<span class="lineNum">    1099 </span>            : #define IWM_SCD_TXFIFO_POS_RA                   (4)
<span class="lineNum">    1100 </span>            : #define IWM_SCD_QUEUE_RA_TID_MAP_RATID_MSK      (0x01FF)
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            : /* agn SCD */
<span class="lineNum">    1103 </span>            : #define IWM_SCD_QUEUE_STTS_REG_POS_TXF          (0)
<span class="lineNum">    1104 </span>            : #define IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE       (3)
<span class="lineNum">    1105 </span>            : #define IWM_SCD_QUEUE_STTS_REG_POS_WSL          (4)
<span class="lineNum">    1106 </span>            : #define IWM_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN   (19)
<span class="lineNum">    1107 </span>            : #define IWM_SCD_QUEUE_STTS_REG_MSK              (0x017F0000)
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            : #define IWM_SCD_QUEUE_CTX_REG1_CREDIT_POS       (8)
<span class="lineNum">    1110 </span>            : #define IWM_SCD_QUEUE_CTX_REG1_CREDIT_MSK       (0x00FFFF00)
<span class="lineNum">    1111 </span>            : #define IWM_SCD_QUEUE_CTX_REG1_SUPER_CREDIT_POS (24)
<span class="lineNum">    1112 </span>            : #define IWM_SCD_QUEUE_CTX_REG1_SUPER_CREDIT_MSK (0xFF000000)
<span class="lineNum">    1113 </span>            : #define IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_POS     (0)
<span class="lineNum">    1114 </span>            : #define IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK     (0x0000007F)
<span class="lineNum">    1115 </span>            : #define IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS  (16)
<span class="lineNum">    1116 </span>            : #define IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK  (0x007F0000)
<span class="lineNum">    1117 </span>            : #define IWM_SCD_GP_CTRL_ENABLE_31_QUEUES        (1 &lt;&lt; 0)
<span class="lineNum">    1118 </span>            : #define IWM_SCD_GP_CTRL_AUTO_ACTIVE_MODE        (1 &lt;&lt; 18)
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /* Context Data */
<span class="lineNum">    1121 </span>            : #define IWM_SCD_CONTEXT_MEM_LOWER_BOUND (IWM_SCD_MEM_LOWER_BOUND + 0x600)
<span class="lineNum">    1122 </span>            : #define IWM_SCD_CONTEXT_MEM_UPPER_BOUND (IWM_SCD_MEM_LOWER_BOUND + 0x6A0)
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            : /* Tx status */
<span class="lineNum">    1125 </span>            : #define IWM_SCD_TX_STTS_MEM_LOWER_BOUND (IWM_SCD_MEM_LOWER_BOUND + 0x6A0)
<span class="lineNum">    1126 </span>            : #define IWM_SCD_TX_STTS_MEM_UPPER_BOUND (IWM_SCD_MEM_LOWER_BOUND + 0x7E0)
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            : /* Translation Data */
<span class="lineNum">    1129 </span>            : #define IWM_SCD_TRANS_TBL_MEM_LOWER_BOUND (IWM_SCD_MEM_LOWER_BOUND + 0x7E0)
<span class="lineNum">    1130 </span>            : #define IWM_SCD_TRANS_TBL_MEM_UPPER_BOUND (IWM_SCD_MEM_LOWER_BOUND + 0x808)
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            : #define IWM_SCD_CONTEXT_QUEUE_OFFSET(x)\
<span class="lineNum">    1133 </span>            :         (IWM_SCD_CONTEXT_MEM_LOWER_BOUND + ((x) * 8))
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            : #define IWM_SCD_TX_STTS_QUEUE_OFFSET(x)\
<span class="lineNum">    1136 </span>            :         (IWM_SCD_TX_STTS_MEM_LOWER_BOUND + ((x) * 16))
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : #define IWM_SCD_TRANS_TBL_OFFSET_QUEUE(x) \
<span class="lineNum">    1139 </span>            :         ((IWM_SCD_TRANS_TBL_MEM_LOWER_BOUND + ((x) * 2)) &amp; 0xfffc)
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            : #define IWM_SCD_BASE                    (IWM_PRPH_BASE + 0xa02c00)
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : #define IWM_SCD_SRAM_BASE_ADDR  (IWM_SCD_BASE + 0x0)
<span class="lineNum">    1144 </span>            : #define IWM_SCD_DRAM_BASE_ADDR  (IWM_SCD_BASE + 0x8)
<span class="lineNum">    1145 </span>            : #define IWM_SCD_AIT             (IWM_SCD_BASE + 0x0c)
<span class="lineNum">    1146 </span>            : #define IWM_SCD_TXFACT          (IWM_SCD_BASE + 0x10)
<span class="lineNum">    1147 </span>            : #define IWM_SCD_ACTIVE          (IWM_SCD_BASE + 0x14)
<span class="lineNum">    1148 </span>            : #define IWM_SCD_QUEUECHAIN_SEL  (IWM_SCD_BASE + 0xe8)
<span class="lineNum">    1149 </span>            : #define IWM_SCD_CHAINEXT_EN     (IWM_SCD_BASE + 0x244)
<span class="lineNum">    1150 </span>            : #define IWM_SCD_AGGR_SEL        (IWM_SCD_BASE + 0x248)
<span class="lineNum">    1151 </span>            : #define IWM_SCD_INTERRUPT_MASK  (IWM_SCD_BASE + 0x108)
<span class="lineNum">    1152 </span>            : #define IWM_SCD_GP_CTRL         (IWM_SCD_BASE + 0x1a8)
<span class="lineNum">    1153 </span>            : #define IWM_SCD_EN_CTRL         (IWM_SCD_BASE + 0x254)
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            : static inline unsigned int IWM_SCD_QUEUE_WRPTR(unsigned int chnl)
<span class="lineNum">    1156 </span>            : {
<span class="lineNum">    1157 </span>            :         if (chnl &lt; 20)
<span class="lineNum">    1158 </span>            :                 return IWM_SCD_BASE + 0x18 + chnl * 4;
<span class="lineNum">    1159 </span>            :         return IWM_SCD_BASE + 0x284 + (chnl - 20) * 4;
<a name="1160"><span class="lineNum">    1160 </span>            : }</a>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 : static inline unsigned int IWM_SCD_QUEUE_RDPTR(unsigned int chnl)</span>
<span class="lineNum">    1163 </span>            : {
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         if (chnl &lt; 20)</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                 return IWM_SCD_BASE + 0x68 + chnl * 4;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         return IWM_SCD_BASE + 0x2B4 + (chnl - 20) * 4;</span>
<a name="1167"><span class="lineNum">    1167 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 : static inline unsigned int IWM_SCD_QUEUE_STATUS_BITS(unsigned int chnl)</span>
<span class="lineNum">    1170 </span>            : {
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         if (chnl &lt; 20)</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :                 return IWM_SCD_BASE + 0x10c + chnl * 4;</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         return IWM_SCD_BASE + 0x384 + (chnl - 20) * 4;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            : /*********************** END TX SCHEDULER *************************************/
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            : /* Oscillator clock */
<span class="lineNum">    1179 </span>            : #define IWM_OSC_CLK                             (0xa04068)
<span class="lineNum">    1180 </span>            : #define IWM_OSC_CLK_FORCE_CONTROL               (0x8)
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            : /****************************/
<span class="lineNum">    1183 </span>            : /* Flow Handler Definitions */
<span class="lineNum">    1184 </span>            : /****************************/
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            : /**
<span class="lineNum">    1187 </span>            :  * This I/O area is directly read/writable by driver (e.g. Linux uses writel())
<span class="lineNum">    1188 </span>            :  * Addresses are offsets from device's PCI hardware base address.
<span class="lineNum">    1189 </span>            :  */
<span class="lineNum">    1190 </span>            : #define IWM_FH_MEM_LOWER_BOUND                   (0x1000)
<span class="lineNum">    1191 </span>            : #define IWM_FH_MEM_UPPER_BOUND                   (0x2000)
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            : /**
<span class="lineNum">    1194 </span>            :  * Keep-Warm (KW) buffer base address.
<span class="lineNum">    1195 </span>            :  *
<span class="lineNum">    1196 </span>            :  * Driver must allocate a 4KByte buffer that is for keeping the
<span class="lineNum">    1197 </span>            :  * host DRAM powered on (via dummy accesses to DRAM) to maintain low-latency
<span class="lineNum">    1198 </span>            :  * DRAM access when doing Txing or Rxing.  The dummy accesses prevent host
<span class="lineNum">    1199 </span>            :  * from going into a power-savings mode that would cause higher DRAM latency,
<span class="lineNum">    1200 </span>            :  * and possible data over/under-runs, before all Tx/Rx is complete.
<span class="lineNum">    1201 </span>            :  *
<span class="lineNum">    1202 </span>            :  * Driver loads IWM_FH_KW_MEM_ADDR_REG with the physical address (bits 35:4)
<span class="lineNum">    1203 </span>            :  * of the buffer, which must be 4K aligned.  Once this is set up, the device
<span class="lineNum">    1204 </span>            :  * automatically invokes keep-warm accesses when normal accesses might not
<span class="lineNum">    1205 </span>            :  * be sufficient to maintain fast DRAM response.
<span class="lineNum">    1206 </span>            :  *
<span class="lineNum">    1207 </span>            :  * Bit fields:
<span class="lineNum">    1208 </span>            :  *  31-0:  Keep-warm buffer physical base address [35:4], must be 4K aligned
<span class="lineNum">    1209 </span>            :  */
<span class="lineNum">    1210 </span>            : #define IWM_FH_KW_MEM_ADDR_REG               (IWM_FH_MEM_LOWER_BOUND + 0x97C)
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            : /**
<span class="lineNum">    1214 </span>            :  * TFD Circular Buffers Base (CBBC) addresses
<span class="lineNum">    1215 </span>            :  *
<span class="lineNum">    1216 </span>            :  * Device has 16 base pointer registers, one for each of 16 host-DRAM-resident
<span class="lineNum">    1217 </span>            :  * circular buffers (CBs/queues) containing Transmit Frame Descriptors (TFDs)
<span class="lineNum">    1218 </span>            :  * (see struct iwm_tfd_frame).  These 16 pointer registers are offset by 0x04
<span class="lineNum">    1219 </span>            :  * bytes from one another.  Each TFD circular buffer in DRAM must be 256-byte
<span class="lineNum">    1220 </span>            :  * aligned (address bits 0-7 must be 0).
<span class="lineNum">    1221 </span>            :  * Later devices have 20 (5000 series) or 30 (higher) queues, but the registers
<span class="lineNum">    1222 </span>            :  * for them are in different places.
<span class="lineNum">    1223 </span>            :  *
<span class="lineNum">    1224 </span>            :  * Bit fields in each pointer register:
<span class="lineNum">    1225 </span>            :  *  27-0: TFD CB physical base address [35:8], must be 256-byte aligned
<span class="lineNum">    1226 </span>            :  */
<span class="lineNum">    1227 </span>            : #define IWM_FH_MEM_CBBC_0_15_LOWER_BOUND        (IWM_FH_MEM_LOWER_BOUND + 0x9D0)
<span class="lineNum">    1228 </span>            : #define IWM_FH_MEM_CBBC_0_15_UPPER_BOUN         (IWM_FH_MEM_LOWER_BOUND + 0xA10)
<span class="lineNum">    1229 </span>            : #define IWM_FH_MEM_CBBC_16_19_LOWER_BOUND       (IWM_FH_MEM_LOWER_BOUND + 0xBF0)
<span class="lineNum">    1230 </span>            : #define IWM_FH_MEM_CBBC_16_19_UPPER_BOUND       (IWM_FH_MEM_LOWER_BOUND + 0xC00)
<span class="lineNum">    1231 </span>            : #define IWM_FH_MEM_CBBC_20_31_LOWER_BOUND       (IWM_FH_MEM_LOWER_BOUND + 0xB20)
<span class="lineNum">    1232 </span>            : #define IWM_FH_MEM_CBBC_20_31_UPPER_BOUND       (IWM_FH_MEM_LOWER_BOUND + 0xB80)
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<span class="lineNum">    1234 </span>            : /* Find TFD CB base pointer for given queue */
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 : static inline unsigned int IWM_FH_MEM_CBBC_QUEUE(unsigned int chnl)</span>
<span class="lineNum">    1236 </span>            : {
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         if (chnl &lt; 16)</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                 return IWM_FH_MEM_CBBC_0_15_LOWER_BOUND + 4 * chnl;</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :         if (chnl &lt; 20)</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                 return IWM_FH_MEM_CBBC_16_19_LOWER_BOUND + 4 * (chnl - 16);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :         return IWM_FH_MEM_CBBC_20_31_LOWER_BOUND + 4 * (chnl - 20);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : /**
<span class="lineNum">    1246 </span>            :  * Rx SRAM Control and Status Registers (RSCSR)
<span class="lineNum">    1247 </span>            :  *
<span class="lineNum">    1248 </span>            :  * These registers provide handshake between driver and device for the Rx queue
<span class="lineNum">    1249 </span>            :  * (this queue handles *all* command responses, notifications, Rx data, etc.
<span class="lineNum">    1250 </span>            :  * sent from uCode to host driver).  Unlike Tx, there is only one Rx
<span class="lineNum">    1251 </span>            :  * queue, and only one Rx DMA/FIFO channel.  Also unlike Tx, which can
<span class="lineNum">    1252 </span>            :  * concatenate up to 20 DRAM buffers to form a Tx frame, each Receive Buffer
<span class="lineNum">    1253 </span>            :  * Descriptor (RBD) points to only one Rx Buffer (RB); there is a 1:1
<span class="lineNum">    1254 </span>            :  * mapping between RBDs and RBs.
<span class="lineNum">    1255 </span>            :  *
<span class="lineNum">    1256 </span>            :  * Driver must allocate host DRAM memory for the following, and set the
<span class="lineNum">    1257 </span>            :  * physical address of each into device registers:
<span class="lineNum">    1258 </span>            :  *
<span class="lineNum">    1259 </span>            :  * 1)  Receive Buffer Descriptor (RBD) circular buffer (CB), typically with 256
<span class="lineNum">    1260 </span>            :  *     entries (although any power of 2, up to 4096, is selectable by driver).
<span class="lineNum">    1261 </span>            :  *     Each entry (1 dword) points to a receive buffer (RB) of consistent size
<span class="lineNum">    1262 </span>            :  *     (typically 4K, although 8K or 16K are also selectable by driver).
<span class="lineNum">    1263 </span>            :  *     Driver sets up RB size and number of RBDs in the CB via Rx config
<span class="lineNum">    1264 </span>            :  *     register IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG.
<span class="lineNum">    1265 </span>            :  *
<span class="lineNum">    1266 </span>            :  *     Bit fields within one RBD:
<span class="lineNum">    1267 </span>            :  *     27-0:  Receive Buffer physical address bits [35:8], 256-byte aligned
<span class="lineNum">    1268 </span>            :  *
<span class="lineNum">    1269 </span>            :  *     Driver sets physical address [35:8] of base of RBD circular buffer
<span class="lineNum">    1270 </span>            :  *     into IWM_FH_RSCSR_CHNL0_RBDCB_BASE_REG [27:0].
<span class="lineNum">    1271 </span>            :  *
<span class="lineNum">    1272 </span>            :  * 2)  Rx status buffer, 8 bytes, in which uCode indicates which Rx Buffers
<span class="lineNum">    1273 </span>            :  *     (RBs) have been filled, via a &quot;write pointer&quot;, actually the index of
<span class="lineNum">    1274 </span>            :  *     the RB's corresponding RBD within the circular buffer.  Driver sets
<span class="lineNum">    1275 </span>            :  *     physical address [35:4] into IWM_FH_RSCSR_CHNL0_STTS_WPTR_REG [31:0].
<span class="lineNum">    1276 </span>            :  *
<span class="lineNum">    1277 </span>            :  *     Bit fields in lower dword of Rx status buffer (upper dword not used
<span class="lineNum">    1278 </span>            :  *     by driver:
<span class="lineNum">    1279 </span>            :  *     31-12:  Not used by driver
<span class="lineNum">    1280 </span>            :  *     11- 0:  Index of last filled Rx buffer descriptor
<span class="lineNum">    1281 </span>            :  *             (device writes, driver reads this value)
<span class="lineNum">    1282 </span>            :  *
<span class="lineNum">    1283 </span>            :  * As the driver prepares Receive Buffers (RBs) for device to fill, driver must
<span class="lineNum">    1284 </span>            :  * enter pointers to these RBs into contiguous RBD circular buffer entries,
<span class="lineNum">    1285 </span>            :  * and update the device's &quot;write&quot; index register,
<span class="lineNum">    1286 </span>            :  * IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG.
<span class="lineNum">    1287 </span>            :  *
<span class="lineNum">    1288 </span>            :  * This &quot;write&quot; index corresponds to the *next* RBD that the driver will make
<span class="lineNum">    1289 </span>            :  * available, i.e. one RBD past the tail of the ready-to-fill RBDs within
<span class="lineNum">    1290 </span>            :  * the circular buffer.  This value should initially be 0 (before preparing any
<span class="lineNum">    1291 </span>            :  * RBs), should be 8 after preparing the first 8 RBs (for example), and must
<span class="lineNum">    1292 </span>            :  * wrap back to 0 at the end of the circular buffer (but don't wrap before
<span class="lineNum">    1293 </span>            :  * &quot;read&quot; index has advanced past 1!  See below).
<span class="lineNum">    1294 </span>            :  * NOTE:  DEVICE EXPECTS THE WRITE INDEX TO BE INCREMENTED IN MULTIPLES OF 8.
<span class="lineNum">    1295 </span>            :  *
<span class="lineNum">    1296 </span>            :  * As the device fills RBs (referenced from contiguous RBDs within the circular
<span class="lineNum">    1297 </span>            :  * buffer), it updates the Rx status buffer in host DRAM, 2) described above,
<span class="lineNum">    1298 </span>            :  * to tell the driver the index of the latest filled RBD.  The driver must
<span class="lineNum">    1299 </span>            :  * read this &quot;read&quot; index from DRAM after receiving an Rx interrupt from device
<span class="lineNum">    1300 </span>            :  *
<span class="lineNum">    1301 </span>            :  * The driver must also internally keep track of a third index, which is the
<span class="lineNum">    1302 </span>            :  * next RBD to process.  When receiving an Rx interrupt, driver should process
<span class="lineNum">    1303 </span>            :  * all filled but unprocessed RBs up to, but not including, the RB
<span class="lineNum">    1304 </span>            :  * corresponding to the &quot;read&quot; index.  For example, if &quot;read&quot; index becomes &quot;1&quot;,
<span class="lineNum">    1305 </span>            :  * driver may process the RB pointed to by RBD 0.  Depending on volume of
<span class="lineNum">    1306 </span>            :  * traffic, there may be many RBs to process.
<span class="lineNum">    1307 </span>            :  *
<span class="lineNum">    1308 </span>            :  * If read index == write index, device thinks there is no room to put new data.
<span class="lineNum">    1309 </span>            :  * Due to this, the maximum number of filled RBs is 255, instead of 256.  To
<span class="lineNum">    1310 </span>            :  * be safe, make sure that there is a gap of at least 2 RBDs between &quot;write&quot;
<span class="lineNum">    1311 </span>            :  * and &quot;read&quot; indexes; that is, make sure that there are no more than 254
<span class="lineNum">    1312 </span>            :  * buffers waiting to be filled.
<span class="lineNum">    1313 </span>            :  */
<span class="lineNum">    1314 </span>            : #define IWM_FH_MEM_RSCSR_LOWER_BOUND    (IWM_FH_MEM_LOWER_BOUND + 0xBC0)
<span class="lineNum">    1315 </span>            : #define IWM_FH_MEM_RSCSR_UPPER_BOUND    (IWM_FH_MEM_LOWER_BOUND + 0xC00)
<span class="lineNum">    1316 </span>            : #define IWM_FH_MEM_RSCSR_CHNL0          (IWM_FH_MEM_RSCSR_LOWER_BOUND)
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            : /**
<span class="lineNum">    1319 </span>            :  * Physical base address of 8-byte Rx Status buffer.
<span class="lineNum">    1320 </span>            :  * Bit fields:
<span class="lineNum">    1321 </span>            :  *  31-0: Rx status buffer physical base address [35:4], must 16-byte aligned.
<span class="lineNum">    1322 </span>            :  */
<span class="lineNum">    1323 </span>            : #define IWM_FH_RSCSR_CHNL0_STTS_WPTR_REG        (IWM_FH_MEM_RSCSR_CHNL0)
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : /**
<span class="lineNum">    1326 </span>            :  * Physical base address of Rx Buffer Descriptor Circular Buffer.
<span class="lineNum">    1327 </span>            :  * Bit fields:
<span class="lineNum">    1328 </span>            :  *  27-0:  RBD CD physical base address [35:8], must be 256-byte aligned.
<span class="lineNum">    1329 </span>            :  */
<span class="lineNum">    1330 </span>            : #define IWM_FH_RSCSR_CHNL0_RBDCB_BASE_REG       (IWM_FH_MEM_RSCSR_CHNL0 + 0x004)
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            : /**
<span class="lineNum">    1333 </span>            :  * Rx write pointer (index, really!).
<span class="lineNum">    1334 </span>            :  * Bit fields:
<span class="lineNum">    1335 </span>            :  *  11-0:  Index of driver's most recent prepared-to-be-filled RBD, + 1.
<span class="lineNum">    1336 </span>            :  *         NOTE:  For 256-entry circular buffer, use only bits [7:0].
<span class="lineNum">    1337 </span>            :  */
<span class="lineNum">    1338 </span>            : #define IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG       (IWM_FH_MEM_RSCSR_CHNL0 + 0x008)
<span class="lineNum">    1339 </span>            : #define IWM_FH_RSCSR_CHNL0_WPTR         (IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG)
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : #define IWM_FW_RSCSR_CHNL0_RXDCB_RDPTR_REG      (IWM_FH_MEM_RSCSR_CHNL0 + 0x00c)
<span class="lineNum">    1342 </span>            : #define IWM_FH_RSCSR_CHNL0_RDPTR                IWM_FW_RSCSR_CHNL0_RXDCB_RDPTR_REG
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            : /**
<span class="lineNum">    1345 </span>            :  * Rx Config/Status Registers (RCSR)
<span class="lineNum">    1346 </span>            :  * Rx Config Reg for channel 0 (only channel used)
<span class="lineNum">    1347 </span>            :  *
<span class="lineNum">    1348 </span>            :  * Driver must initialize IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG as follows for
<span class="lineNum">    1349 </span>            :  * normal operation (see bit fields).
<span class="lineNum">    1350 </span>            :  *
<span class="lineNum">    1351 </span>            :  * Clearing IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG to 0 turns off Rx DMA.
<span class="lineNum">    1352 </span>            :  * Driver should poll IWM_FH_MEM_RSSR_RX_STATUS_REG     for
<span class="lineNum">    1353 </span>            :  * IWM_FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE (bit 24) before continuing.
<span class="lineNum">    1354 </span>            :  *
<span class="lineNum">    1355 </span>            :  * Bit fields:
<span class="lineNum">    1356 </span>            :  * 31-30: Rx DMA channel enable: '00' off/pause, '01' pause at end of frame,
<span class="lineNum">    1357 </span>            :  *        '10' operate normally
<span class="lineNum">    1358 </span>            :  * 29-24: reserved
<span class="lineNum">    1359 </span>            :  * 23-20: # RBDs in circular buffer = 2^value; use &quot;8&quot; for 256 RBDs (normal),
<span class="lineNum">    1360 </span>            :  *        min &quot;5&quot; for 32 RBDs, max &quot;12&quot; for 4096 RBDs.
<span class="lineNum">    1361 </span>            :  * 19-18: reserved
<span class="lineNum">    1362 </span>            :  * 17-16: size of each receive buffer; '00' 4K (normal), '01' 8K,
<span class="lineNum">    1363 </span>            :  *        '10' 12K, '11' 16K.
<span class="lineNum">    1364 </span>            :  * 15-14: reserved
<span class="lineNum">    1365 </span>            :  * 13-12: IRQ destination; '00' none, '01' host driver (normal operation)
<span class="lineNum">    1366 </span>            :  * 11- 4: timeout for closing Rx buffer and interrupting host (units 32 usec)
<span class="lineNum">    1367 </span>            :  *        typical value 0x10 (about 1/2 msec)
<span class="lineNum">    1368 </span>            :  *  3- 0: reserved
<span class="lineNum">    1369 </span>            :  */
<span class="lineNum">    1370 </span>            : #define IWM_FH_MEM_RCSR_LOWER_BOUND      (IWM_FH_MEM_LOWER_BOUND + 0xC00)
<span class="lineNum">    1371 </span>            : #define IWM_FH_MEM_RCSR_UPPER_BOUND      (IWM_FH_MEM_LOWER_BOUND + 0xCC0)
<span class="lineNum">    1372 </span>            : #define IWM_FH_MEM_RCSR_CHNL0            (IWM_FH_MEM_RCSR_LOWER_BOUND)
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            : #define IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG        (IWM_FH_MEM_RCSR_CHNL0)
<span class="lineNum">    1375 </span>            : #define IWM_FH_MEM_RCSR_CHNL0_RBDCB_WPTR        (IWM_FH_MEM_RCSR_CHNL0 + 0x8)
<span class="lineNum">    1376 </span>            : #define IWM_FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ      (IWM_FH_MEM_RCSR_CHNL0 + 0x10)
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_RB_TIMEOUT_MSK (0x00000FF0) /* bits 4-11 */
<span class="lineNum">    1379 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_MSK   (0x00001000) /* bits 12 */
<span class="lineNum">    1380 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK (0x00008000) /* bit 15 */
<span class="lineNum">    1381 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_RB_SIZE_MSK   (0x00030000) /* bits 16-17 */
<span class="lineNum">    1382 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_RBDBC_SIZE_MSK (0x00F00000) /* bits 20-23 */
<span class="lineNum">    1383 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_DMA_CHNL_EN_MSK (0xC0000000) /* bits 30-31*/
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            : #define IWM_FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS    (20)
<span class="lineNum">    1386 </span>            : #define IWM_FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS  (4)
<span class="lineNum">    1387 </span>            : #define IWM_RX_RB_TIMEOUT       (0x11)
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            : #define IWM_FH_RCSR_RX_CONFIG_CHNL_EN_PAUSE_VAL         (0x00000000)
<span class="lineNum">    1390 </span>            : #define IWM_FH_RCSR_RX_CONFIG_CHNL_EN_PAUSE_EOF_VAL     (0x40000000)
<span class="lineNum">    1391 </span>            : #define IWM_FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL        (0x80000000)
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            : #define IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K    (0x00000000)
<span class="lineNum">    1394 </span>            : #define IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K    (0x00010000)
<span class="lineNum">    1395 </span>            : #define IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_12K   (0x00020000)
<span class="lineNum">    1396 </span>            : #define IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_16K   (0x00030000)
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            : #define IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY              (0x00000004)
<span class="lineNum">    1399 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_NO_INT_VAL    (0x00000000)
<span class="lineNum">    1400 </span>            : #define IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL  (0x00001000)
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            : /**
<span class="lineNum">    1403 </span>            :  * Rx Shared Status Registers (RSSR)
<span class="lineNum">    1404 </span>            :  *
<span class="lineNum">    1405 </span>            :  * After stopping Rx DMA channel (writing 0 to
<span class="lineNum">    1406 </span>            :  * IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG), driver must poll
<span class="lineNum">    1407 </span>            :  * IWM_FH_MEM_RSSR_RX_STATUS_REG until Rx channel is idle.
<span class="lineNum">    1408 </span>            :  *
<span class="lineNum">    1409 </span>            :  * Bit fields:
<span class="lineNum">    1410 </span>            :  *  24:  1 = Channel 0 is idle
<span class="lineNum">    1411 </span>            :  *
<span class="lineNum">    1412 </span>            :  * IWM_FH_MEM_RSSR_SHARED_CTRL_REG and IWM_FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV
<span class="lineNum">    1413 </span>            :  * contain default values that should not be altered by the driver.
<span class="lineNum">    1414 </span>            :  */
<span class="lineNum">    1415 </span>            : #define IWM_FH_MEM_RSSR_LOWER_BOUND     (IWM_FH_MEM_LOWER_BOUND + 0xC40)
<span class="lineNum">    1416 </span>            : #define IWM_FH_MEM_RSSR_UPPER_BOUND     (IWM_FH_MEM_LOWER_BOUND + 0xD00)
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : #define IWM_FH_MEM_RSSR_SHARED_CTRL_REG (IWM_FH_MEM_RSSR_LOWER_BOUND)
<span class="lineNum">    1419 </span>            : #define IWM_FH_MEM_RSSR_RX_STATUS_REG   (IWM_FH_MEM_RSSR_LOWER_BOUND + 0x004)
<span class="lineNum">    1420 </span>            : #define IWM_FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV\
<span class="lineNum">    1421 </span>            :                                         (IWM_FH_MEM_RSSR_LOWER_BOUND + 0x008)
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            : #define IWM_FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE   (0x01000000)
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span>            : #define IWM_FH_MEM_TFDIB_REG1_ADDR_BITSHIFT     28
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            : /* TFDB  Area - TFDs buffer table */
<span class="lineNum">    1428 </span>            : #define IWM_FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK      (0xFFFFFFFF)
<span class="lineNum">    1429 </span>            : #define IWM_FH_TFDIB_LOWER_BOUND       (IWM_FH_MEM_LOWER_BOUND + 0x900)
<span class="lineNum">    1430 </span>            : #define IWM_FH_TFDIB_UPPER_BOUND       (IWM_FH_MEM_LOWER_BOUND + 0x958)
<span class="lineNum">    1431 </span>            : #define IWM_FH_TFDIB_CTRL0_REG(_chnl)  (IWM_FH_TFDIB_LOWER_BOUND + 0x8 * (_chnl))
<span class="lineNum">    1432 </span>            : #define IWM_FH_TFDIB_CTRL1_REG(_chnl)  (IWM_FH_TFDIB_LOWER_BOUND + 0x8 * (_chnl) + 0x4)
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            : /**
<span class="lineNum">    1435 </span>            :  * Transmit DMA Channel Control/Status Registers (TCSR)
<span class="lineNum">    1436 </span>            :  *
<span class="lineNum">    1437 </span>            :  * Device has one configuration register for each of 8 Tx DMA/FIFO channels
<span class="lineNum">    1438 </span>            :  * supported in hardware (don't confuse these with the 16 Tx queues in DRAM,
<span class="lineNum">    1439 </span>            :  * which feed the DMA/FIFO channels); config regs are separated by 0x20 bytes.
<span class="lineNum">    1440 </span>            :  *
<span class="lineNum">    1441 </span>            :  * To use a Tx DMA channel, driver must initialize its
<span class="lineNum">    1442 </span>            :  * IWM_FH_TCSR_CHNL_TX_CONFIG_REG(chnl) with:
<span class="lineNum">    1443 </span>            :  *
<span class="lineNum">    1444 </span>            :  * IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |
<span class="lineNum">    1445 </span>            :  * IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE_VAL
<span class="lineNum">    1446 </span>            :  *
<span class="lineNum">    1447 </span>            :  * All other bits should be 0.
<span class="lineNum">    1448 </span>            :  *
<span class="lineNum">    1449 </span>            :  * Bit fields:
<span class="lineNum">    1450 </span>            :  * 31-30: Tx DMA channel enable: '00' off/pause, '01' pause at end of frame,
<span class="lineNum">    1451 </span>            :  *        '10' operate normally
<span class="lineNum">    1452 </span>            :  * 29- 4: Reserved, set to &quot;0&quot;
<span class="lineNum">    1453 </span>            :  *     3: Enable internal DMA requests (1, normal operation), disable (0)
<span class="lineNum">    1454 </span>            :  *  2- 0: Reserved, set to &quot;0&quot;
<span class="lineNum">    1455 </span>            :  */
<span class="lineNum">    1456 </span>            : #define IWM_FH_TCSR_LOWER_BOUND  (IWM_FH_MEM_LOWER_BOUND + 0xD00)
<span class="lineNum">    1457 </span>            : #define IWM_FH_TCSR_UPPER_BOUND  (IWM_FH_MEM_LOWER_BOUND + 0xE60)
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            : /* Find Control/Status reg for given Tx DMA/FIFO channel */
<span class="lineNum">    1460 </span>            : #define IWM_FH_TCSR_CHNL_NUM                            (8)
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            : /* TCSR: tx_config register values */
<span class="lineNum">    1463 </span>            : #define IWM_FH_TCSR_CHNL_TX_CONFIG_REG(_chnl)   \
<span class="lineNum">    1464 </span>            :                 (IWM_FH_TCSR_LOWER_BOUND + 0x20 * (_chnl))
<span class="lineNum">    1465 </span>            : #define IWM_FH_TCSR_CHNL_TX_CREDIT_REG(_chnl)   \
<span class="lineNum">    1466 </span>            :                 (IWM_FH_TCSR_LOWER_BOUND + 0x20 * (_chnl) + 0x4)
<span class="lineNum">    1467 </span>            : #define IWM_FH_TCSR_CHNL_TX_BUF_STS_REG(_chnl)  \
<span class="lineNum">    1468 </span>            :                 (IWM_FH_TCSR_LOWER_BOUND + 0x20 * (_chnl) + 0x8)
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_TXF      (0x00000000)
<span class="lineNum">    1471 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_DRV      (0x00000001)
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE        (0x00000000)
<span class="lineNum">    1474 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE         (0x00000008)
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_NOINT   (0x00000000)
<span class="lineNum">    1477 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD  (0x00100000)
<span class="lineNum">    1478 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_IFTFD   (0x00200000)
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_NOINT    (0x00000000)
<span class="lineNum">    1481 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_ENDTFD   (0x00400000)
<span class="lineNum">    1482 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_IFTFD    (0x00800000)
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE            (0x00000000)
<span class="lineNum">    1485 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE_EOF        (0x40000000)
<span class="lineNum">    1486 </span>            : #define IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE           (0x80000000)
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            : #define IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_EMPTY  (0x00000000)
<span class="lineNum">    1489 </span>            : #define IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_WAIT   (0x00002000)
<span class="lineNum">    1490 </span>            : #define IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID  (0x00000003)
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            : #define IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM              (20)
<span class="lineNum">    1493 </span>            : #define IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX              (12)
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            : /**
<span class="lineNum">    1496 </span>            :  * Tx Shared Status Registers (TSSR)
<span class="lineNum">    1497 </span>            :  *
<span class="lineNum">    1498 </span>            :  * After stopping Tx DMA channel (writing 0 to
<span class="lineNum">    1499 </span>            :  * IWM_FH_TCSR_CHNL_TX_CONFIG_REG(chnl)), driver must poll
<span class="lineNum">    1500 </span>            :  * IWM_FH_TSSR_TX_STATUS_REG until selected Tx channel is idle
<span class="lineNum">    1501 </span>            :  * (channel's buffers empty | no pending requests).
<span class="lineNum">    1502 </span>            :  *
<span class="lineNum">    1503 </span>            :  * Bit fields:
<span class="lineNum">    1504 </span>            :  * 31-24:  1 = Channel buffers empty (channel 7:0)
<span class="lineNum">    1505 </span>            :  * 23-16:  1 = No pending requests (channel 7:0)
<span class="lineNum">    1506 </span>            :  */
<span class="lineNum">    1507 </span>            : #define IWM_FH_TSSR_LOWER_BOUND         (IWM_FH_MEM_LOWER_BOUND + 0xEA0)
<span class="lineNum">    1508 </span>            : #define IWM_FH_TSSR_UPPER_BOUND         (IWM_FH_MEM_LOWER_BOUND + 0xEC0)
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span>            : #define IWM_FH_TSSR_TX_STATUS_REG       (IWM_FH_TSSR_LOWER_BOUND + 0x010)
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            : /**
<span class="lineNum">    1513 </span>            :  * Bit fields for TSSR(Tx Shared Status &amp; Control) error status register:
<span class="lineNum">    1514 </span>            :  * 31:  Indicates an address error when accessed to internal memory
<span class="lineNum">    1515 </span>            :  *      uCode/driver must write &quot;1&quot; in order to clear this flag
<span class="lineNum">    1516 </span>            :  * 30:  Indicates that Host did not send the expected number of dwords to FH
<span class="lineNum">    1517 </span>            :  *      uCode/driver must write &quot;1&quot; in order to clear this flag
<span class="lineNum">    1518 </span>            :  * 16-9:Each status bit is for one channel. Indicates that an (Error) ActDMA
<span class="lineNum">    1519 </span>            :  *      command was received from the scheduler while the TRB was already full
<span class="lineNum">    1520 </span>            :  *      with previous command
<span class="lineNum">    1521 </span>            :  *      uCode/driver must write &quot;1&quot; in order to clear this flag
<span class="lineNum">    1522 </span>            :  * 7-0: Each status bit indicates a channel's TxCredit error. When an error
<span class="lineNum">    1523 </span>            :  *      bit is set, it indicates that the FH has received a full indication
<span class="lineNum">    1524 </span>            :  *      from the RTC TxFIFO and the current value of the TxCredit counter was
<span class="lineNum">    1525 </span>            :  *      not equal to zero. This mean that the credit mechanism was not
<span class="lineNum">    1526 </span>            :  *      synchronized to the TxFIFO status
<span class="lineNum">    1527 </span>            :  *      uCode/driver must write &quot;1&quot; in order to clear this flag
<span class="lineNum">    1528 </span>            :  */
<span class="lineNum">    1529 </span>            : #define IWM_FH_TSSR_TX_ERROR_REG        (IWM_FH_TSSR_LOWER_BOUND + 0x018)
<span class="lineNum">    1530 </span>            : #define IWM_FH_TSSR_TX_MSG_CONFIG_REG   (IWM_FH_TSSR_LOWER_BOUND + 0x008)
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            : #define IWM_FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(_chnl) ((1 &lt;&lt; (_chnl)) &lt;&lt; 16)
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            : /* Tx service channels */
<span class="lineNum">    1535 </span>            : #define IWM_FH_SRVC_CHNL                (9)
<span class="lineNum">    1536 </span>            : #define IWM_FH_SRVC_LOWER_BOUND (IWM_FH_MEM_LOWER_BOUND + 0x9C8)
<span class="lineNum">    1537 </span>            : #define IWM_FH_SRVC_UPPER_BOUND (IWM_FH_MEM_LOWER_BOUND + 0x9D0)
<span class="lineNum">    1538 </span>            : #define IWM_FH_SRVC_CHNL_SRAM_ADDR_REG(_chnl) \
<span class="lineNum">    1539 </span>            :                 (IWM_FH_SRVC_LOWER_BOUND + ((_chnl) - 9) * 0x4)
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            : #define IWM_FH_TX_CHICKEN_BITS_REG      (IWM_FH_MEM_LOWER_BOUND + 0xE98)
<span class="lineNum">    1542 </span>            : #define IWM_FH_TX_TRB_REG(_chan)        (IWM_FH_MEM_LOWER_BOUND + 0x958 + \
<span class="lineNum">    1543 </span>            :                                         (_chan) * 4)
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            : /* Instruct FH to increment the retry count of a packet when
<span class="lineNum">    1546 </span>            :  * it is brought from the memory to TX-FIFO
<span class="lineNum">    1547 </span>            :  */
<span class="lineNum">    1548 </span>            : #define IWM_FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN        (0x00000002)
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            : #define IWM_RX_QUEUE_SIZE                         256
<span class="lineNum">    1551 </span>            : #define IWM_RX_QUEUE_MASK                         255
<span class="lineNum">    1552 </span>            : #define IWM_RX_QUEUE_SIZE_LOG                     8
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            : /*
<span class="lineNum">    1555 </span>            :  * RX related structures and functions
<span class="lineNum">    1556 </span>            :  */
<span class="lineNum">    1557 </span>            : #define IWM_RX_FREE_BUFFERS 64
<span class="lineNum">    1558 </span>            : #define IWM_RX_LOW_WATERMARK 8
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span>            : /**
<span class="lineNum">    1561 </span>            :  * struct iwm_rb_status - reseve buffer status
<span class="lineNum">    1562 </span>            :  *      host memory mapped FH registers
<span class="lineNum">    1563 </span>            :  * @closed_rb_num [0:11] - Indicates the index of the RB which was closed
<span class="lineNum">    1564 </span>            :  * @closed_fr_num [0:11] - Indicates the index of the RX Frame which was closed
<span class="lineNum">    1565 </span>            :  * @finished_rb_num [0:11] - Indicates the index of the current RB
<span class="lineNum">    1566 </span>            :  *      in which the last frame was written to
<span class="lineNum">    1567 </span>            :  * @finished_fr_num [0:11] - Indicates the index of the RX Frame
<span class="lineNum">    1568 </span>            :  *      which was transferred
<span class="lineNum">    1569 </span>            :  */
<span class="lineNum">    1570 </span>            : struct iwm_rb_status {
<span class="lineNum">    1571 </span>            :         uint16_t closed_rb_num;
<span class="lineNum">    1572 </span>            :         uint16_t closed_fr_num;
<span class="lineNum">    1573 </span>            :         uint16_t finished_rb_num;
<span class="lineNum">    1574 </span>            :         uint16_t finished_fr_nam;
<span class="lineNum">    1575 </span>            :         uint32_t unused;
<span class="lineNum">    1576 </span>            : } __packed;
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span>            : #define IWM_TFD_QUEUE_SIZE_MAX          (256)
<span class="lineNum">    1580 </span>            : #define IWM_TFD_QUEUE_SIZE_BC_DUP       (64)
<span class="lineNum">    1581 </span>            : #define IWM_TFD_QUEUE_BC_SIZE           (IWM_TFD_QUEUE_SIZE_MAX + \
<span class="lineNum">    1582 </span>            :                                         IWM_TFD_QUEUE_SIZE_BC_DUP)
<span class="lineNum">    1583 </span>            : #define IWM_TX_DMA_MASK        DMA_BIT_MASK(36)
<a name="1584"><span class="lineNum">    1584 </span>            : #define IWM_NUM_OF_TBS          20</a>
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 : static inline uint8_t iwm_get_dma_hi_addr(bus_addr_t addr)</span>
<span class="lineNum">    1587 </span>            : {
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :         return (sizeof(addr) &gt; sizeof(uint32_t) ? (addr &gt;&gt; 16) &gt;&gt; 16 : 0) &amp; 0xF;</span>
<span class="lineNum">    1589 </span>            : }
<span class="lineNum">    1590 </span>            : /**
<span class="lineNum">    1591 </span>            :  * struct iwm_tfd_tb transmit buffer descriptor within transmit frame descriptor
<span class="lineNum">    1592 </span>            :  *
<span class="lineNum">    1593 </span>            :  * This structure contains dma address and length of transmission address
<span class="lineNum">    1594 </span>            :  *
<span class="lineNum">    1595 </span>            :  * @lo: low [31:0] portion of the dma address of TX buffer
<span class="lineNum">    1596 </span>            :  *      every even is unaligned on 16 bit boundary
<span class="lineNum">    1597 </span>            :  * @hi_n_len 0-3 [35:32] portion of dma
<span class="lineNum">    1598 </span>            :  *           4-15 length of the tx buffer
<span class="lineNum">    1599 </span>            :  */
<span class="lineNum">    1600 </span>            : struct iwm_tfd_tb {
<span class="lineNum">    1601 </span>            :         uint32_t lo;
<span class="lineNum">    1602 </span>            :         uint16_t hi_n_len;
<span class="lineNum">    1603 </span>            : } __packed;
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span>            : /**
<span class="lineNum">    1606 </span>            :  * struct iwm_tfd
<span class="lineNum">    1607 </span>            :  *
<span class="lineNum">    1608 </span>            :  * Transmit Frame Descriptor (TFD)
<span class="lineNum">    1609 </span>            :  *
<span class="lineNum">    1610 </span>            :  * @ __reserved1[3] reserved
<span class="lineNum">    1611 </span>            :  * @ num_tbs 0-4 number of active tbs
<span class="lineNum">    1612 </span>            :  *           5   reserved
<span class="lineNum">    1613 </span>            :  *           6-7 padding (not used)
<span class="lineNum">    1614 </span>            :  * @ tbs[20]    transmit frame buffer descriptors
<span class="lineNum">    1615 </span>            :  * @ __pad      padding
<span class="lineNum">    1616 </span>            :  *
<span class="lineNum">    1617 </span>            :  * Each Tx queue uses a circular buffer of 256 TFDs stored in host DRAM.
<span class="lineNum">    1618 </span>            :  * Both driver and device share these circular buffers, each of which must be
<span class="lineNum">    1619 </span>            :  * contiguous 256 TFDs x 128 bytes-per-TFD = 32 KBytes
<span class="lineNum">    1620 </span>            :  *
<span class="lineNum">    1621 </span>            :  * Driver must indicate the physical address of the base of each
<span class="lineNum">    1622 </span>            :  * circular buffer via the IWM_FH_MEM_CBBC_QUEUE registers.
<span class="lineNum">    1623 </span>            :  *
<span class="lineNum">    1624 </span>            :  * Each TFD contains pointer/size information for up to 20 data buffers
<span class="lineNum">    1625 </span>            :  * in host DRAM.  These buffers collectively contain the (one) frame described
<span class="lineNum">    1626 </span>            :  * by the TFD.  Each buffer must be a single contiguous block of memory within
<span class="lineNum">    1627 </span>            :  * itself, but buffers may be scattered in host DRAM.  Each buffer has max size
<span class="lineNum">    1628 </span>            :  * of (4K - 4).  The concatenates all of a TFD's buffers into a single
<span class="lineNum">    1629 </span>            :  * Tx frame, up to 8 KBytes in size.
<span class="lineNum">    1630 </span>            :  *
<span class="lineNum">    1631 </span>            :  * A maximum of 255 (not 256!) TFDs may be on a queue waiting for Tx.
<span class="lineNum">    1632 </span>            :  */
<span class="lineNum">    1633 </span>            : struct iwm_tfd {
<span class="lineNum">    1634 </span>            :         uint8_t __reserved1[3];
<span class="lineNum">    1635 </span>            :         uint8_t num_tbs;
<span class="lineNum">    1636 </span>            :         struct iwm_tfd_tb tbs[IWM_NUM_OF_TBS];
<span class="lineNum">    1637 </span>            :         uint32_t __pad;
<span class="lineNum">    1638 </span>            : } __packed;
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            : /* Keep Warm Size */
<span class="lineNum">    1641 </span>            : #define IWM_KW_SIZE 0x1000      /* 4k */
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            : /* Fixed (non-configurable) rx data from phy */
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span>            : /**
<span class="lineNum">    1646 </span>            :  * struct iwm_agn_schedq_bc_tbl scheduler byte count table
<span class="lineNum">    1647 </span>            :  *      base physical address provided by IWM_SCD_DRAM_BASE_ADDR
<span class="lineNum">    1648 </span>            :  * @tfd_offset  0-12 - tx command byte count
<span class="lineNum">    1649 </span>            :  *             12-16 - station index
<span class="lineNum">    1650 </span>            :  */
<span class="lineNum">    1651 </span>            : struct iwm_agn_scd_bc_tbl {
<span class="lineNum">    1652 </span>            :         uint16_t tfd_offset[IWM_TFD_QUEUE_BC_SIZE];
<span class="lineNum">    1653 </span>            : } __packed;
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            : /* Maximum number of Tx queues. */
<span class="lineNum">    1656 </span>            : #define IWM_MAX_QUEUES  31
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span>            : /* Tx queue numbers */
<span class="lineNum">    1659 </span>            : #define IWM_OFFCHANNEL_QUEUE    8
<span class="lineNum">    1660 </span>            : #define IWM_CMD_QUEUE           9
<span class="lineNum">    1661 </span>            : #define IWM_AUX_QUEUE           15
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span>            : #define IWM_TX_FIFO_BK  0
<span class="lineNum">    1664 </span>            : #define IWM_TX_FIFO_BE  1
<span class="lineNum">    1665 </span>            : #define IWM_TX_FIFO_VI  2
<span class="lineNum">    1666 </span>            : #define IWM_TX_FIFO_VO  3
<span class="lineNum">    1667 </span>            : #define IWM_TX_FIFO_MCAST       5
<span class="lineNum">    1668 </span>            : #define IWM_TX_FIFO_CMD 7
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            : #define IWM_STATION_COUNT       16
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            : /*
<span class="lineNum">    1673 </span>            :  * Commands
<span class="lineNum">    1674 </span>            :  */
<span class="lineNum">    1675 </span>            : #define IWM_ALIVE               0x1
<span class="lineNum">    1676 </span>            : #define IWM_REPLY_ERROR         0x2
<span class="lineNum">    1677 </span>            : #define IWM_INIT_COMPLETE_NOTIF 0x4
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            : /* PHY context commands */
<span class="lineNum">    1680 </span>            : #define IWM_PHY_CONTEXT_CMD     0x8
<span class="lineNum">    1681 </span>            : #define IWM_DBG_CFG             0x9
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            : /* UMAC scan commands */
<span class="lineNum">    1684 </span>            : #define IWM_SCAN_ITERATION_COMPLETE_UMAC        0xb5
<span class="lineNum">    1685 </span>            : #define IWM_SCAN_CFG_CMD                        0xc
<span class="lineNum">    1686 </span>            : #define IWM_SCAN_REQ_UMAC                       0xd
<span class="lineNum">    1687 </span>            : #define IWM_SCAN_ABORT_UMAC                     0xe
<span class="lineNum">    1688 </span>            : #define IWM_SCAN_COMPLETE_UMAC                  0xf
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            : /* station table */
<span class="lineNum">    1691 </span>            : #define IWM_ADD_STA_KEY 0x17
<span class="lineNum">    1692 </span>            : #define IWM_ADD_STA     0x18
<span class="lineNum">    1693 </span>            : #define IWM_REMOVE_STA  0x19
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span>            : /* TX */
<span class="lineNum">    1696 </span>            : #define IWM_TX_CMD              0x1c
<span class="lineNum">    1697 </span>            : #define IWM_TXPATH_FLUSH        0x1e
<span class="lineNum">    1698 </span>            : #define IWM_MGMT_MCAST_KEY      0x1f
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            : /* scheduler config */
<span class="lineNum">    1701 </span>            : #define IWM_SCD_QUEUE_CFG       0x1d
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            : /* global key */
<span class="lineNum">    1704 </span>            : #define IWM_WEP_KEY     0x20
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            : /* MAC and Binding commands */
<span class="lineNum">    1707 </span>            : #define IWM_MAC_CONTEXT_CMD             0x28
<span class="lineNum">    1708 </span>            : #define IWM_TIME_EVENT_CMD              0x29 /* both CMD and response */
<span class="lineNum">    1709 </span>            : #define IWM_TIME_EVENT_NOTIFICATION     0x2a
<span class="lineNum">    1710 </span>            : #define IWM_BINDING_CONTEXT_CMD         0x2b
<span class="lineNum">    1711 </span>            : #define IWM_TIME_QUOTA_CMD              0x2c
<span class="lineNum">    1712 </span>            : #define IWM_NON_QOS_TX_COUNTER_CMD      0x2d
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            : #define IWM_LQ_CMD      0x4e
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span>            : /* Calibration */
<span class="lineNum">    1717 </span>            : #define IWM_TEMPERATURE_NOTIFICATION            0x62
<span class="lineNum">    1718 </span>            : #define IWM_CALIBRATION_CFG_CMD                 0x65
<span class="lineNum">    1719 </span>            : #define IWM_CALIBRATION_RES_NOTIFICATION        0x66
<span class="lineNum">    1720 </span>            : #define IWM_CALIBRATION_COMPLETE_NOTIFICATION   0x67
<span class="lineNum">    1721 </span>            : #define IWM_RADIO_VERSION_NOTIFICATION          0x68
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            : /* Scan offload */
<span class="lineNum">    1724 </span>            : #define IWM_SCAN_OFFLOAD_REQUEST_CMD            0x51
<span class="lineNum">    1725 </span>            : #define IWM_SCAN_OFFLOAD_ABORT_CMD              0x52
<span class="lineNum">    1726 </span>            : #define IWM_HOT_SPOT_CMD                        0x53
<span class="lineNum">    1727 </span>            : #define IWM_SCAN_OFFLOAD_COMPLETE               0x6d
<span class="lineNum">    1728 </span>            : #define IWM_SCAN_OFFLOAD_UPDATE_PROFILES_CMD    0x6e
<span class="lineNum">    1729 </span>            : #define IWM_SCAN_OFFLOAD_CONFIG_CMD             0x6f
<span class="lineNum">    1730 </span>            : #define IWM_MATCH_FOUND_NOTIFICATION            0xd9
<span class="lineNum">    1731 </span>            : #define IWM_SCAN_ITERATION_COMPLETE             0xe7
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span>            : /* Phy */
<span class="lineNum">    1734 </span>            : #define IWM_PHY_CONFIGURATION_CMD               0x6a
<span class="lineNum">    1735 </span>            : #define IWM_CALIB_RES_NOTIF_PHY_DB              0x6b
<span class="lineNum">    1736 </span>            : /* IWM_PHY_DB_CMD       0x6c */
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            : /* Power - legacy power table command */
<span class="lineNum">    1739 </span>            : #define IWM_POWER_TABLE_CMD                             0x77
<span class="lineNum">    1740 </span>            : #define IWM_PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION       0x78
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            : /* Thermal Throttling*/
<span class="lineNum">    1743 </span>            : #define IWM_REPLY_THERMAL_MNG_BACKOFF   0x7e
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            : /* NVM */
<span class="lineNum">    1746 </span>            : #define IWM_NVM_ACCESS_CMD      0x88
<span class="lineNum">    1747 </span>            : 
<span class="lineNum">    1748 </span>            : #define IWM_SET_CALIB_DEFAULT_CMD       0x8e
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            : #define IWM_BEACON_NOTIFICATION         0x90
<span class="lineNum">    1751 </span>            : #define IWM_BEACON_TEMPLATE_CMD         0x91
<span class="lineNum">    1752 </span>            : #define IWM_TX_ANT_CONFIGURATION_CMD    0x98
<span class="lineNum">    1753 </span>            : #define IWM_BT_CONFIG                   0x9b
<span class="lineNum">    1754 </span>            : #define IWM_STATISTICS_NOTIFICATION     0x9d
<span class="lineNum">    1755 </span>            : #define IWM_REDUCE_TX_POWER_CMD         0x9f
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            : /* RF-KILL commands and notifications */
<span class="lineNum">    1758 </span>            : #define IWM_CARD_STATE_CMD              0xa0
<span class="lineNum">    1759 </span>            : #define IWM_CARD_STATE_NOTIFICATION     0xa1
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            : #define IWM_MISSED_BEACONS_NOTIFICATION 0xa2
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span>            : #define IWM_MFUART_LOAD_NOTIFICATION    0xb1
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            : /* Power - new power table command */
<span class="lineNum">    1766 </span>            : #define IWM_MAC_PM_POWER_TABLE  0xa9
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            : #define IWM_REPLY_RX_PHY_CMD    0xc0
<span class="lineNum">    1769 </span>            : #define IWM_REPLY_RX_MPDU_CMD   0xc1
<span class="lineNum">    1770 </span>            : #define IWM_BA_NOTIF            0xc5
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            : /* Location Aware Regulatory */
<span class="lineNum">    1773 </span>            : #define IWM_MCC_UPDATE_CMD      0xc8
<span class="lineNum">    1774 </span>            : #define IWM_MCC_CHUB_UPDATE_CMD 0xc9
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            : /* BT Coex */
<span class="lineNum">    1777 </span>            : #define IWM_BT_COEX_PRIO_TABLE  0xcc
<span class="lineNum">    1778 </span>            : #define IWM_BT_COEX_PROT_ENV    0xcd
<span class="lineNum">    1779 </span>            : #define IWM_BT_PROFILE_NOTIFICATION     0xce
<span class="lineNum">    1780 </span>            : #define IWM_BT_COEX_CI  0x5d
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            : #define IWM_REPLY_SF_CFG_CMD            0xd1
<span class="lineNum">    1783 </span>            : #define IWM_REPLY_BEACON_FILTERING_CMD  0xd2
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span>            : /* DTS measurements */
<span class="lineNum">    1786 </span>            : #define IWM_CMD_DTS_MEASUREMENT_TRIGGER         0xdc
<span class="lineNum">    1787 </span>            : #define IWM_DTS_MEASUREMENT_NOTIFICATION        0xdd
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            : #define IWM_REPLY_DEBUG_CMD     0xf0
<span class="lineNum">    1790 </span>            : #define IWM_DEBUG_LOG_MSG       0xf7
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span>            : #define IWM_MCAST_FILTER_CMD    0xd0
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span>            : /* D3 commands/notifications */
<span class="lineNum">    1795 </span>            : #define IWM_D3_CONFIG_CMD               0xd3
<span class="lineNum">    1796 </span>            : #define IWM_PROT_OFFLOAD_CONFIG_CMD     0xd4
<span class="lineNum">    1797 </span>            : #define IWM_OFFLOADS_QUERY_CMD          0xd5
<span class="lineNum">    1798 </span>            : #define IWM_REMOTE_WAKE_CONFIG_CMD      0xd6
<span class="lineNum">    1799 </span>            : 
<span class="lineNum">    1800 </span>            : /* for WoWLAN in particular */
<span class="lineNum">    1801 </span>            : #define IWM_WOWLAN_PATTERNS             0xe0
<span class="lineNum">    1802 </span>            : #define IWM_WOWLAN_CONFIGURATION        0xe1
<span class="lineNum">    1803 </span>            : #define IWM_WOWLAN_TSC_RSC_PARAM        0xe2
<span class="lineNum">    1804 </span>            : #define IWM_WOWLAN_TKIP_PARAM           0xe3
<span class="lineNum">    1805 </span>            : #define IWM_WOWLAN_KEK_KCK_MATERIAL     0xe4
<span class="lineNum">    1806 </span>            : #define IWM_WOWLAN_GET_STATUSES         0xe5
<span class="lineNum">    1807 </span>            : #define IWM_WOWLAN_TX_POWER_PER_DB      0xe6
<span class="lineNum">    1808 </span>            : 
<span class="lineNum">    1809 </span>            : /* and for NetDetect */
<span class="lineNum">    1810 </span>            : #define IWM_NET_DETECT_CONFIG_CMD               0x54
<span class="lineNum">    1811 </span>            : #define IWM_NET_DETECT_PROFILES_QUERY_CMD       0x56
<span class="lineNum">    1812 </span>            : #define IWM_NET_DETECT_PROFILES_CMD             0x57
<span class="lineNum">    1813 </span>            : #define IWM_NET_DETECT_HOTSPOTS_CMD             0x58
<span class="lineNum">    1814 </span>            : #define IWM_NET_DETECT_HOTSPOTS_QUERY_CMD       0x59
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span>            : /* system group command IDs */
<span class="lineNum">    1817 </span>            : #define IWM_FSEQ_VER_MISMATCH_NOTIFICATION      0xff
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span>            : #define IWM_REPLY_MAX   0xff
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            : /**
<span class="lineNum">    1822 </span>            :  * struct iwm_cmd_response - generic response struct for most commands
<span class="lineNum">    1823 </span>            :  * @status: status of the command asked, changes for each one
<span class="lineNum">    1824 </span>            :  */
<span class="lineNum">    1825 </span>            : struct iwm_cmd_response {
<span class="lineNum">    1826 </span>            :         uint32_t status;
<span class="lineNum">    1827 </span>            : };
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span>            : /*
<span class="lineNum">    1830 </span>            :  * struct iwm_tx_ant_cfg_cmd
<span class="lineNum">    1831 </span>            :  * @valid: valid antenna configuration
<span class="lineNum">    1832 </span>            :  */
<span class="lineNum">    1833 </span>            : struct iwm_tx_ant_cfg_cmd {
<span class="lineNum">    1834 </span>            :         uint32_t valid;
<span class="lineNum">    1835 </span>            : } __packed;
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            : /**
<span class="lineNum">    1838 </span>            :  * struct iwm_reduce_tx_power_cmd - TX power reduction command
<span class="lineNum">    1839 </span>            :  * IWM_REDUCE_TX_POWER_CMD = 0x9f
<span class="lineNum">    1840 </span>            :  * @flags: (reserved for future implementation)
<span class="lineNum">    1841 </span>            :  * @mac_context_id: id of the mac ctx for which we are reducing TX power.
<span class="lineNum">    1842 </span>            :  * @pwr_restriction: TX power restriction in dBms.
<span class="lineNum">    1843 </span>            :  */
<span class="lineNum">    1844 </span>            : struct iwm_reduce_tx_power_cmd {
<span class="lineNum">    1845 </span>            :         uint8_t flags;
<span class="lineNum">    1846 </span>            :         uint8_t mac_context_id;
<span class="lineNum">    1847 </span>            :         uint16_t pwr_restriction;
<span class="lineNum">    1848 </span>            : } __packed; /* IWM_TX_REDUCED_POWER_API_S_VER_1 */
<span class="lineNum">    1849 </span>            : 
<span class="lineNum">    1850 </span>            : /*
<span class="lineNum">    1851 </span>            :  * Calibration control struct.
<span class="lineNum">    1852 </span>            :  * Sent as part of the phy configuration command.
<span class="lineNum">    1853 </span>            :  * @flow_trigger: bitmap for which calibrations to perform according to
<span class="lineNum">    1854 </span>            :  *              flow triggers.
<span class="lineNum">    1855 </span>            :  * @event_trigger: bitmap for which calibrations to perform according to
<span class="lineNum">    1856 </span>            :  *              event triggers.
<span class="lineNum">    1857 </span>            :  */
<span class="lineNum">    1858 </span>            : struct iwm_calib_ctrl {
<span class="lineNum">    1859 </span>            :         uint32_t flow_trigger;
<span class="lineNum">    1860 </span>            :         uint32_t event_trigger;
<span class="lineNum">    1861 </span>            : } __packed;
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : /* This defines the bitmap of various calibrations to enable in both
<span class="lineNum">    1864 </span>            :  * init ucode and runtime ucode through IWM_CALIBRATION_CFG_CMD.
<span class="lineNum">    1865 </span>            :  */
<span class="lineNum">    1866 </span>            : #define IWM_CALIB_CFG_XTAL_IDX                  (1 &lt;&lt; 0)
<span class="lineNum">    1867 </span>            : #define IWM_CALIB_CFG_TEMPERATURE_IDX           (1 &lt;&lt; 1)
<span class="lineNum">    1868 </span>            : #define IWM_CALIB_CFG_VOLTAGE_READ_IDX          (1 &lt;&lt; 2)
<span class="lineNum">    1869 </span>            : #define IWM_CALIB_CFG_PAPD_IDX                  (1 &lt;&lt; 3)
<span class="lineNum">    1870 </span>            : #define IWM_CALIB_CFG_TX_PWR_IDX                (1 &lt;&lt; 4)
<span class="lineNum">    1871 </span>            : #define IWM_CALIB_CFG_DC_IDX                    (1 &lt;&lt; 5)
<span class="lineNum">    1872 </span>            : #define IWM_CALIB_CFG_BB_FILTER_IDX             (1 &lt;&lt; 6)
<span class="lineNum">    1873 </span>            : #define IWM_CALIB_CFG_LO_LEAKAGE_IDX            (1 &lt;&lt; 7)
<span class="lineNum">    1874 </span>            : #define IWM_CALIB_CFG_TX_IQ_IDX                 (1 &lt;&lt; 8)
<span class="lineNum">    1875 </span>            : #define IWM_CALIB_CFG_TX_IQ_SKEW_IDX            (1 &lt;&lt; 9)
<span class="lineNum">    1876 </span>            : #define IWM_CALIB_CFG_RX_IQ_IDX                 (1 &lt;&lt; 10)
<span class="lineNum">    1877 </span>            : #define IWM_CALIB_CFG_RX_IQ_SKEW_IDX            (1 &lt;&lt; 11)
<span class="lineNum">    1878 </span>            : #define IWM_CALIB_CFG_SENSITIVITY_IDX           (1 &lt;&lt; 12)
<span class="lineNum">    1879 </span>            : #define IWM_CALIB_CFG_CHAIN_NOISE_IDX           (1 &lt;&lt; 13)
<span class="lineNum">    1880 </span>            : #define IWM_CALIB_CFG_DISCONNECTED_ANT_IDX      (1 &lt;&lt; 14)
<span class="lineNum">    1881 </span>            : #define IWM_CALIB_CFG_ANT_COUPLING_IDX          (1 &lt;&lt; 15)
<span class="lineNum">    1882 </span>            : #define IWM_CALIB_CFG_DAC_IDX                   (1 &lt;&lt; 16)
<span class="lineNum">    1883 </span>            : #define IWM_CALIB_CFG_ABS_IDX                   (1 &lt;&lt; 17)
<span class="lineNum">    1884 </span>            : #define IWM_CALIB_CFG_AGC_IDX                   (1 &lt;&lt; 18)
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            : /*
<span class="lineNum">    1887 </span>            :  * Phy configuration command.
<span class="lineNum">    1888 </span>            :  */
<span class="lineNum">    1889 </span>            : struct iwm_phy_cfg_cmd {
<span class="lineNum">    1890 </span>            :         uint32_t        phy_cfg;
<span class="lineNum">    1891 </span>            :         struct iwm_calib_ctrl calib_control;
<span class="lineNum">    1892 </span>            : } __packed;
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            : #define IWM_PHY_CFG_RADIO_TYPE  ((1 &lt;&lt; 0) | (1 &lt;&lt; 1))
<span class="lineNum">    1895 </span>            : #define IWM_PHY_CFG_RADIO_STEP  ((1 &lt;&lt; 2) | (1 &lt;&lt; 3))
<span class="lineNum">    1896 </span>            : #define IWM_PHY_CFG_RADIO_DASH  ((1 &lt;&lt; 4) | (1 &lt;&lt; 5))
<span class="lineNum">    1897 </span>            : #define IWM_PHY_CFG_PRODUCT_NUMBER      ((1 &lt;&lt; 6) | (1 &lt;&lt; 7))
<span class="lineNum">    1898 </span>            : #define IWM_PHY_CFG_TX_CHAIN_A  (1 &lt;&lt; 8)
<span class="lineNum">    1899 </span>            : #define IWM_PHY_CFG_TX_CHAIN_B  (1 &lt;&lt; 9)
<span class="lineNum">    1900 </span>            : #define IWM_PHY_CFG_TX_CHAIN_C  (1 &lt;&lt; 10)
<span class="lineNum">    1901 </span>            : #define IWM_PHY_CFG_RX_CHAIN_A  (1 &lt;&lt; 12)
<span class="lineNum">    1902 </span>            : #define IWM_PHY_CFG_RX_CHAIN_B  (1 &lt;&lt; 13)
<span class="lineNum">    1903 </span>            : #define IWM_PHY_CFG_RX_CHAIN_C  (1 &lt;&lt; 14)
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            : /*
<span class="lineNum">    1906 </span>            :  * PHY db
<span class="lineNum">    1907 </span>            :  */
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            : #define IWM_PHY_DB_CFG                  1
<span class="lineNum">    1910 </span>            : #define IWM_PHY_DB_CALIB_NCH            2
<span class="lineNum">    1911 </span>            : #define IWM_PHY_DB_UNUSED               3
<span class="lineNum">    1912 </span>            : #define IWM_PHY_DB_CALIB_CHG_PAPD       4
<span class="lineNum">    1913 </span>            : #define IWM_PHY_DB_CALIB_CHG_TXP        5
<span class="lineNum">    1914 </span>            : #define IWM_PHY_DB_MAX                  6
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            : #define IWM_PHY_DB_CMD 0x6c /* TEMP API - The actual is 0x8c */
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            : /*
<span class="lineNum">    1919 </span>            :  * phy db - configure operational ucode
<span class="lineNum">    1920 </span>            :  */
<span class="lineNum">    1921 </span>            : struct iwm_phy_db_cmd {
<span class="lineNum">    1922 </span>            :         uint16_t type;
<span class="lineNum">    1923 </span>            :         uint16_t length;
<span class="lineNum">    1924 </span>            :         uint8_t data[];
<span class="lineNum">    1925 </span>            : } __packed;
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            : /* for parsing of tx power channel group data that comes from the firmware*/
<span class="lineNum">    1928 </span>            : struct iwm_phy_db_chg_txp {
<span class="lineNum">    1929 </span>            :         uint32_t space;
<span class="lineNum">    1930 </span>            :         uint16_t max_channel_idx;
<span class="lineNum">    1931 </span>            : } __packed;
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span>            : /*
<span class="lineNum">    1934 </span>            :  * phy db - Receive phy db chunk after calibrations
<span class="lineNum">    1935 </span>            :  */
<span class="lineNum">    1936 </span>            : struct iwm_calib_res_notif_phy_db {
<span class="lineNum">    1937 </span>            :         uint16_t type;
<span class="lineNum">    1938 </span>            :         uint16_t length;
<span class="lineNum">    1939 </span>            :         uint8_t data[];
<span class="lineNum">    1940 </span>            : } __packed;
<span class="lineNum">    1941 </span>            : 
<span class="lineNum">    1942 </span>            : /* 7k family NVM HW-Section offset (in words) definitions */
<span class="lineNum">    1943 </span>            : #define IWM_HW_ADDR     0x15
<span class="lineNum">    1944 </span>            : /* 7k family NVM SW-Section offset (in words) definitions */
<span class="lineNum">    1945 </span>            : #define IWM_NVM_SW_SECTION      0x1C0
<span class="lineNum">    1946 </span>            : #define IWM_NVM_VERSION         0
<span class="lineNum">    1947 </span>            : #define IWM_RADIO_CFG           1
<span class="lineNum">    1948 </span>            : #define IWM_SKU                 2
<span class="lineNum">    1949 </span>            : #define IWM_N_HW_ADDRS          3
<span class="lineNum">    1950 </span>            : #define IWM_NVM_CHANNELS        0x1E0 - IWM_NVM_SW_SECTION
<span class="lineNum">    1951 </span>            : /* 7k family NVM calibration section offset (in words) definitions */
<span class="lineNum">    1952 </span>            : #define IWM_NVM_CALIB_SECTION   0x2B8
<span class="lineNum">    1953 </span>            : #define IWM_XTAL_CALIB          (0x316 - IWM_NVM_CALIB_SECTION)
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span>            : /* 8k family NVM HW-Section offset (in words) definitions */
<span class="lineNum">    1956 </span>            : #define IWM_HW_ADDR0_WFPM_8000          0x12
<span class="lineNum">    1957 </span>            : #define IWM_HW_ADDR1_WFPM_8000          0x16
<span class="lineNum">    1958 </span>            : #define IWM_HW_ADDR0_PCIE_8000          0x8A
<span class="lineNum">    1959 </span>            : #define IWM_HW_ADDR1_PCIE_8000          0x8E
<span class="lineNum">    1960 </span>            : #define IWM_MAC_ADDRESS_OVERRIDE_8000   1
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span>            : /* 8k family NVM SW-Section offset (in words) definitions */
<span class="lineNum">    1963 </span>            : #define IWM_NVM_SW_SECTION_8000 0x1C0
<span class="lineNum">    1964 </span>            : #define IWM_NVM_VERSION_8000    0
<span class="lineNum">    1965 </span>            : #define IWM_RADIO_CFG_8000      0
<span class="lineNum">    1966 </span>            : #define IWM_SKU_8000            2
<span class="lineNum">    1967 </span>            : #define IWM_N_HW_ADDRS_8000     3
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span>            : /* 8k family NVM REGULATORY -Section offset (in words) definitions */
<span class="lineNum">    1970 </span>            : #define IWM_NVM_CHANNELS_8000           0
<span class="lineNum">    1971 </span>            : #define IWM_NVM_LAR_OFFSET_8000_OLD     0x4C7
<span class="lineNum">    1972 </span>            : #define IWM_NVM_LAR_OFFSET_8000         0x507
<span class="lineNum">    1973 </span>            : #define IWM_NVM_LAR_ENABLED_8000        0x7
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            : /* 8k family NVM calibration section offset (in words) definitions */
<span class="lineNum">    1976 </span>            : #define IWM_NVM_CALIB_SECTION_8000      0x2B8
<span class="lineNum">    1977 </span>            : #define IWM_XTAL_CALIB_8000             (0x316 - IWM_NVM_CALIB_SECTION_8000)
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            : /* SKU Capabilities (actual values from NVM definition) */
<span class="lineNum">    1980 </span>            : #define IWM_NVM_SKU_CAP_BAND_24GHZ      (1 &lt;&lt; 0)
<span class="lineNum">    1981 </span>            : #define IWM_NVM_SKU_CAP_BAND_52GHZ      (1 &lt;&lt; 1)
<span class="lineNum">    1982 </span>            : #define IWM_NVM_SKU_CAP_11N_ENABLE      (1 &lt;&lt; 2)
<span class="lineNum">    1983 </span>            : #define IWM_NVM_SKU_CAP_11AC_ENABLE     (1 &lt;&lt; 3)
<span class="lineNum">    1984 </span>            : #define IWM_NVM_SKU_CAP_MIMO_DISABLE    (1 &lt;&lt; 5)
<span class="lineNum">    1985 </span>            : 
<span class="lineNum">    1986 </span>            : /* radio config bits (actual values from NVM definition) */
<span class="lineNum">    1987 </span>            : #define IWM_NVM_RF_CFG_DASH_MSK(x)   (x &amp; 0x3)         /* bits 0-1   */
<span class="lineNum">    1988 </span>            : #define IWM_NVM_RF_CFG_STEP_MSK(x)   ((x &gt;&gt; 2)  &amp; 0x3) /* bits 2-3   */
<span class="lineNum">    1989 </span>            : #define IWM_NVM_RF_CFG_TYPE_MSK(x)   ((x &gt;&gt; 4)  &amp; 0x3) /* bits 4-5   */
<span class="lineNum">    1990 </span>            : #define IWM_NVM_RF_CFG_PNUM_MSK(x)   ((x &gt;&gt; 6)  &amp; 0x3) /* bits 6-7   */
<span class="lineNum">    1991 </span>            : #define IWM_NVM_RF_CFG_TX_ANT_MSK(x) ((x &gt;&gt; 8)  &amp; 0xF) /* bits 8-11  */
<span class="lineNum">    1992 </span>            : #define IWM_NVM_RF_CFG_RX_ANT_MSK(x) ((x &gt;&gt; 12) &amp; 0xF) /* bits 12-15 */
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span>            : #define IWM_NVM_RF_CFG_PNUM_MSK_8000(x)         (x &amp; 0xF)
<span class="lineNum">    1995 </span>            : #define IWM_NVM_RF_CFG_DASH_MSK_8000(x)         ((x &gt;&gt; 4) &amp; 0xF)
<span class="lineNum">    1996 </span>            : #define IWM_NVM_RF_CFG_STEP_MSK_8000(x)         ((x &gt;&gt; 8) &amp; 0xF)
<span class="lineNum">    1997 </span>            : #define IWM_NVM_RF_CFG_TYPE_MSK_8000(x)         ((x &gt;&gt; 12) &amp; 0xFFF)
<span class="lineNum">    1998 </span>            : #define IWM_NVM_RF_CFG_TX_ANT_MSK_8000(x)       ((x &gt;&gt; 24) &amp; 0xF)
<span class="lineNum">    1999 </span>            : #define IWM_NVM_RF_CFG_RX_ANT_MSK_8000(x)       ((x &gt;&gt; 28) &amp; 0xF)
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            : #define DEFAULT_MAX_TX_POWER 16
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span>            : /*
<span class="lineNum">    2004 </span>            :  * channel flags in NVM
<span class="lineNum">    2005 </span>            :  * @IWM_NVM_CHANNEL_VALID: channel is usable for this SKU/geo
<span class="lineNum">    2006 </span>            :  * @IWM_NVM_CHANNEL_IBSS: usable as an IBSS channel
<span class="lineNum">    2007 </span>            :  * @IWM_NVM_CHANNEL_ACTIVE: active scanning allowed
<span class="lineNum">    2008 </span>            :  * @IWM_NVM_CHANNEL_RADAR: radar detection required
<span class="lineNum">    2009 </span>            :  * @IWM_NVM_CHANNEL_DFS: dynamic freq selection candidate
<span class="lineNum">    2010 </span>            :  * @IWM_NVM_CHANNEL_WIDE: 20 MHz channel okay (?)
<span class="lineNum">    2011 </span>            :  * @IWM_NVM_CHANNEL_40MHZ: 40 MHz channel okay (?)
<span class="lineNum">    2012 </span>            :  * @IWM_NVM_CHANNEL_80MHZ: 80 MHz channel okay (?)
<span class="lineNum">    2013 </span>            :  * @IWM_NVM_CHANNEL_160MHZ: 160 MHz channel okay (?)
<span class="lineNum">    2014 </span>            :  */
<span class="lineNum">    2015 </span>            : #define IWM_NVM_CHANNEL_VALID   (1 &lt;&lt; 0)
<span class="lineNum">    2016 </span>            : #define IWM_NVM_CHANNEL_IBSS    (1 &lt;&lt; 1)
<span class="lineNum">    2017 </span>            : #define IWM_NVM_CHANNEL_ACTIVE  (1 &lt;&lt; 3)
<span class="lineNum">    2018 </span>            : #define IWM_NVM_CHANNEL_RADAR   (1 &lt;&lt; 4)
<span class="lineNum">    2019 </span>            : #define IWM_NVM_CHANNEL_DFS     (1 &lt;&lt; 7)
<span class="lineNum">    2020 </span>            : #define IWM_NVM_CHANNEL_WIDE    (1 &lt;&lt; 8)
<span class="lineNum">    2021 </span>            : #define IWM_NVM_CHANNEL_40MHZ   (1 &lt;&lt; 9)
<span class="lineNum">    2022 </span>            : #define IWM_NVM_CHANNEL_80MHZ   (1 &lt;&lt; 10)
<span class="lineNum">    2023 </span>            : #define IWM_NVM_CHANNEL_160MHZ  (1 &lt;&lt; 11)
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            : /* Target of the IWM_NVM_ACCESS_CMD */
<span class="lineNum">    2026 </span>            : #define IWM_NVM_ACCESS_TARGET_CACHE     0
<span class="lineNum">    2027 </span>            : #define IWM_NVM_ACCESS_TARGET_OTP       1
<span class="lineNum">    2028 </span>            : #define IWM_NVM_ACCESS_TARGET_EEPROM    2
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span>            : /* Section types for IWM_NVM_ACCESS_CMD */
<span class="lineNum">    2031 </span>            : #define IWM_NVM_SECTION_TYPE_HW                 0
<span class="lineNum">    2032 </span>            : #define IWM_NVM_SECTION_TYPE_SW                 1
<span class="lineNum">    2033 </span>            : #define IWM_NVM_SECTION_TYPE_PAPD               2
<span class="lineNum">    2034 </span>            : #define IWM_NVM_SECTION_TYPE_REGULATORY         3
<span class="lineNum">    2035 </span>            : #define IWM_NVM_SECTION_TYPE_CALIBRATION        4
<span class="lineNum">    2036 </span>            : #define IWM_NVM_SECTION_TYPE_PRODUCTION         5
<span class="lineNum">    2037 </span>            : #define IWM_NVM_SECTION_TYPE_POST_FCS_CALIB     6
<span class="lineNum">    2038 </span>            : /* 7, 8, 9 unknown */
<span class="lineNum">    2039 </span>            : #define IWM_NVM_SECTION_TYPE_HW_8000            10
<span class="lineNum">    2040 </span>            : #define IWM_NVM_SECTION_TYPE_MAC_OVERRIDE       11
<span class="lineNum">    2041 </span>            : #define IWM_NVM_SECTION_TYPE_PHY_SKU            12
<span class="lineNum">    2042 </span>            : #define IWM_NVM_NUM_OF_SECTIONS                 13
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span>            : /**
<span class="lineNum">    2045 </span>            :  * struct iwm_nvm_access_cmd_ver2 - Request the device to send an NVM section
<span class="lineNum">    2046 </span>            :  * @op_code: 0 - read, 1 - write
<span class="lineNum">    2047 </span>            :  * @target: IWM_NVM_ACCESS_TARGET_*
<span class="lineNum">    2048 </span>            :  * @type: IWM_NVM_SECTION_TYPE_*
<span class="lineNum">    2049 </span>            :  * @offset: offset in bytes into the section
<span class="lineNum">    2050 </span>            :  * @length: in bytes, to read/write
<span class="lineNum">    2051 </span>            :  * @data: if write operation, the data to write. On read its empty
<span class="lineNum">    2052 </span>            :  */
<span class="lineNum">    2053 </span>            : struct iwm_nvm_access_cmd {
<span class="lineNum">    2054 </span>            :         uint8_t op_code;
<span class="lineNum">    2055 </span>            :         uint8_t target;
<span class="lineNum">    2056 </span>            :         uint16_t type;
<span class="lineNum">    2057 </span>            :         uint16_t offset;
<span class="lineNum">    2058 </span>            :         uint16_t length;
<span class="lineNum">    2059 </span>            :         uint8_t data[];
<span class="lineNum">    2060 </span>            : } __packed; /* IWM_NVM_ACCESS_CMD_API_S_VER_2 */
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span>            : /**
<span class="lineNum">    2063 </span>            :  * struct iwm_nvm_access_resp_ver2 - response to IWM_NVM_ACCESS_CMD
<span class="lineNum">    2064 </span>            :  * @offset: offset in bytes into the section
<span class="lineNum">    2065 </span>            :  * @length: in bytes, either how much was written or read
<span class="lineNum">    2066 </span>            :  * @type: IWM_NVM_SECTION_TYPE_*
<span class="lineNum">    2067 </span>            :  * @status: 0 for success, fail otherwise
<span class="lineNum">    2068 </span>            :  * @data: if read operation, the data returned. Empty on write.
<span class="lineNum">    2069 </span>            :  */
<span class="lineNum">    2070 </span>            : struct iwm_nvm_access_resp {
<span class="lineNum">    2071 </span>            :         uint16_t offset;
<span class="lineNum">    2072 </span>            :         uint16_t length;
<span class="lineNum">    2073 </span>            :         uint16_t type;
<span class="lineNum">    2074 </span>            :         uint16_t status;
<span class="lineNum">    2075 </span>            :         uint8_t data[];
<span class="lineNum">    2076 </span>            : } __packed; /* IWM_NVM_ACCESS_CMD_RESP_API_S_VER_2 */
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            : /* IWM_ALIVE 0x1 */
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span>            : /* alive response is_valid values */
<span class="lineNum">    2081 </span>            : #define IWM_ALIVE_RESP_UCODE_OK (1 &lt;&lt; 0)
<span class="lineNum">    2082 </span>            : #define IWM_ALIVE_RESP_RFKILL   (1 &lt;&lt; 1)
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            : /* alive response ver_type values */
<span class="lineNum">    2085 </span>            : #define IWM_FW_TYPE_HW          0
<span class="lineNum">    2086 </span>            : #define IWM_FW_TYPE_PROT        1
<span class="lineNum">    2087 </span>            : #define IWM_FW_TYPE_AP          2
<span class="lineNum">    2088 </span>            : #define IWM_FW_TYPE_WOWLAN      3
<span class="lineNum">    2089 </span>            : #define IWM_FW_TYPE_TIMING      4
<span class="lineNum">    2090 </span>            : #define IWM_FW_TYPE_WIPAN       5
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : /* alive response ver_subtype values */
<span class="lineNum">    2093 </span>            : #define IWM_FW_SUBTYPE_FULL_FEATURE     0
<span class="lineNum">    2094 </span>            : #define IWM_FW_SUBTYPE_BOOTSRAP         1 /* Not valid */
<span class="lineNum">    2095 </span>            : #define IWM_FW_SUBTYPE_REDUCED          2
<span class="lineNum">    2096 </span>            : #define IWM_FW_SUBTYPE_ALIVE_ONLY       3
<span class="lineNum">    2097 </span>            : #define IWM_FW_SUBTYPE_WOWLAN           4
<span class="lineNum">    2098 </span>            : #define IWM_FW_SUBTYPE_AP_SUBTYPE       5
<span class="lineNum">    2099 </span>            : #define IWM_FW_SUBTYPE_WIPAN            6
<span class="lineNum">    2100 </span>            : #define IWM_FW_SUBTYPE_INITIALIZE       9
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            : #define IWM_ALIVE_STATUS_ERR 0xDEAD
<span class="lineNum">    2103 </span>            : #define IWM_ALIVE_STATUS_OK 0xCAFE
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span>            : #define IWM_ALIVE_FLG_RFKILL    (1 &lt;&lt; 0)
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span>            : struct iwm_alive_resp_v1 {
<span class="lineNum">    2108 </span>            :         uint16_t status;
<span class="lineNum">    2109 </span>            :         uint16_t flags;
<span class="lineNum">    2110 </span>            :         uint8_t ucode_minor;
<span class="lineNum">    2111 </span>            :         uint8_t ucode_major;
<span class="lineNum">    2112 </span>            :         uint16_t id;
<span class="lineNum">    2113 </span>            :         uint8_t api_minor;
<span class="lineNum">    2114 </span>            :         uint8_t api_major;
<span class="lineNum">    2115 </span>            :         uint8_t ver_subtype;
<span class="lineNum">    2116 </span>            :         uint8_t ver_type;
<span class="lineNum">    2117 </span>            :         uint8_t mac;
<span class="lineNum">    2118 </span>            :         uint8_t opt;
<span class="lineNum">    2119 </span>            :         uint16_t reserved2;
<span class="lineNum">    2120 </span>            :         uint32_t timestamp;
<span class="lineNum">    2121 </span>            :         uint32_t error_event_table_ptr; /* SRAM address for error log */
<span class="lineNum">    2122 </span>            :         uint32_t log_event_table_ptr;   /* SRAM address for event log */
<span class="lineNum">    2123 </span>            :         uint32_t cpu_register_ptr;
<span class="lineNum">    2124 </span>            :         uint32_t dbgm_config_ptr;
<span class="lineNum">    2125 </span>            :         uint32_t alive_counter_ptr;
<span class="lineNum">    2126 </span>            :         uint32_t scd_base_ptr;          /* SRAM address for SCD */
<span class="lineNum">    2127 </span>            : } __packed; /* IWM_ALIVE_RES_API_S_VER_1 */
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span>            : struct iwm_alive_resp_v2 {
<span class="lineNum">    2130 </span>            :         uint16_t status;
<span class="lineNum">    2131 </span>            :         uint16_t flags;
<span class="lineNum">    2132 </span>            :         uint8_t ucode_minor;
<span class="lineNum">    2133 </span>            :         uint8_t ucode_major;
<span class="lineNum">    2134 </span>            :         uint16_t id;
<span class="lineNum">    2135 </span>            :         uint8_t api_minor;
<span class="lineNum">    2136 </span>            :         uint8_t api_major;
<span class="lineNum">    2137 </span>            :         uint8_t ver_subtype;
<span class="lineNum">    2138 </span>            :         uint8_t ver_type;
<span class="lineNum">    2139 </span>            :         uint8_t mac;
<span class="lineNum">    2140 </span>            :         uint8_t opt;
<span class="lineNum">    2141 </span>            :         uint16_t reserved2;
<span class="lineNum">    2142 </span>            :         uint32_t timestamp;
<span class="lineNum">    2143 </span>            :         uint32_t error_event_table_ptr; /* SRAM address for error log */
<span class="lineNum">    2144 </span>            :         uint32_t log_event_table_ptr;   /* SRAM address for LMAC event log */
<span class="lineNum">    2145 </span>            :         uint32_t cpu_register_ptr;
<span class="lineNum">    2146 </span>            :         uint32_t dbgm_config_ptr;
<span class="lineNum">    2147 </span>            :         uint32_t alive_counter_ptr;
<span class="lineNum">    2148 </span>            :         uint32_t scd_base_ptr;          /* SRAM address for SCD */
<span class="lineNum">    2149 </span>            :         uint32_t st_fwrd_addr;          /* pointer to Store and forward */
<span class="lineNum">    2150 </span>            :         uint32_t st_fwrd_size;
<span class="lineNum">    2151 </span>            :         uint8_t umac_minor;                     /* UMAC version: minor */
<span class="lineNum">    2152 </span>            :         uint8_t umac_major;                     /* UMAC version: major */
<span class="lineNum">    2153 </span>            :         uint16_t umac_id;                       /* UMAC version: id */
<span class="lineNum">    2154 </span>            :         uint32_t error_info_addr;               /* SRAM address for UMAC error log */
<span class="lineNum">    2155 </span>            :         uint32_t dbg_print_buff_addr;
<span class="lineNum">    2156 </span>            : } __packed; /* ALIVE_RES_API_S_VER_2 */
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span>            : struct iwm_alive_resp_v3 {
<span class="lineNum">    2159 </span>            :         uint16_t status;
<span class="lineNum">    2160 </span>            :         uint16_t flags;
<span class="lineNum">    2161 </span>            :         uint32_t ucode_minor;
<span class="lineNum">    2162 </span>            :         uint32_t ucode_major;
<span class="lineNum">    2163 </span>            :         uint8_t ver_subtype;
<span class="lineNum">    2164 </span>            :         uint8_t ver_type;
<span class="lineNum">    2165 </span>            :         uint8_t mac;
<span class="lineNum">    2166 </span>            :         uint8_t opt;
<span class="lineNum">    2167 </span>            :         uint32_t timestamp;
<span class="lineNum">    2168 </span>            :         uint32_t error_event_table_ptr; /* SRAM address for error log */
<span class="lineNum">    2169 </span>            :         uint32_t log_event_table_ptr;   /* SRAM address for LMAC event log */
<span class="lineNum">    2170 </span>            :         uint32_t cpu_register_ptr;
<span class="lineNum">    2171 </span>            :         uint32_t dbgm_config_ptr;
<span class="lineNum">    2172 </span>            :         uint32_t alive_counter_ptr;
<span class="lineNum">    2173 </span>            :         uint32_t scd_base_ptr;          /* SRAM address for SCD */
<span class="lineNum">    2174 </span>            :         uint32_t st_fwrd_addr;          /* pointer to Store and forward */
<span class="lineNum">    2175 </span>            :         uint32_t st_fwrd_size;
<span class="lineNum">    2176 </span>            :         uint32_t umac_minor;            /* UMAC version: minor */
<span class="lineNum">    2177 </span>            :         uint32_t umac_major;            /* UMAC version: major */
<span class="lineNum">    2178 </span>            :         uint32_t error_info_addr;               /* SRAM address for UMAC error log */
<span class="lineNum">    2179 </span>            :         uint32_t dbg_print_buff_addr;
<span class="lineNum">    2180 </span>            : } __packed; /* ALIVE_RES_API_S_VER_3 */
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            : /* Error response/notification */
<span class="lineNum">    2183 </span>            : #define IWM_FW_ERR_UNKNOWN_CMD          0x0
<span class="lineNum">    2184 </span>            : #define IWM_FW_ERR_INVALID_CMD_PARAM    0x1
<span class="lineNum">    2185 </span>            : #define IWM_FW_ERR_SERVICE              0x2
<span class="lineNum">    2186 </span>            : #define IWM_FW_ERR_ARC_MEMORY           0x3
<span class="lineNum">    2187 </span>            : #define IWM_FW_ERR_ARC_CODE             0x4
<span class="lineNum">    2188 </span>            : #define IWM_FW_ERR_WATCH_DOG            0x5
<span class="lineNum">    2189 </span>            : #define IWM_FW_ERR_WEP_GRP_KEY_INDX     0x10
<span class="lineNum">    2190 </span>            : #define IWM_FW_ERR_WEP_KEY_SIZE         0x11
<span class="lineNum">    2191 </span>            : #define IWM_FW_ERR_OBSOLETE_FUNC        0x12
<span class="lineNum">    2192 </span>            : #define IWM_FW_ERR_UNEXPECTED           0xFE
<span class="lineNum">    2193 </span>            : #define IWM_FW_ERR_FATAL                0xFF
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span>            : /**
<span class="lineNum">    2196 </span>            :  * struct iwm_error_resp - FW error indication
<span class="lineNum">    2197 </span>            :  * ( IWM_REPLY_ERROR = 0x2 )
<span class="lineNum">    2198 </span>            :  * @error_type: one of IWM_FW_ERR_*
<span class="lineNum">    2199 </span>            :  * @cmd_id: the command ID for which the error occured
<span class="lineNum">    2200 </span>            :  * @bad_cmd_seq_num: sequence number of the erroneous command
<span class="lineNum">    2201 </span>            :  * @error_service: which service created the error, applicable only if
<span class="lineNum">    2202 </span>            :  *      error_type = 2, otherwise 0
<span class="lineNum">    2203 </span>            :  * @timestamp: TSF in usecs.
<span class="lineNum">    2204 </span>            :  */
<span class="lineNum">    2205 </span>            : struct iwm_error_resp {
<span class="lineNum">    2206 </span>            :         uint32_t error_type;
<span class="lineNum">    2207 </span>            :         uint8_t cmd_id;
<span class="lineNum">    2208 </span>            :         uint8_t reserved1;
<span class="lineNum">    2209 </span>            :         uint16_t bad_cmd_seq_num;
<span class="lineNum">    2210 </span>            :         uint32_t error_service;
<span class="lineNum">    2211 </span>            :         uint64_t timestamp;
<span class="lineNum">    2212 </span>            : } __packed;
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            : /* Common PHY, MAC and Bindings definitions */
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span>            : #define IWM_MAX_MACS_IN_BINDING (3)
<span class="lineNum">    2218 </span>            : #define IWM_MAX_BINDINGS        (4)
<span class="lineNum">    2219 </span>            : #define IWM_AUX_BINDING_INDEX   (3)
<span class="lineNum">    2220 </span>            : #define IWM_MAX_PHYS            (4)
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            : /* Used to extract ID and color from the context dword */
<span class="lineNum">    2223 </span>            : #define IWM_FW_CTXT_ID_POS      (0)
<span class="lineNum">    2224 </span>            : #define IWM_FW_CTXT_ID_MSK      (0xff &lt;&lt; IWM_FW_CTXT_ID_POS)
<span class="lineNum">    2225 </span>            : #define IWM_FW_CTXT_COLOR_POS   (8)
<span class="lineNum">    2226 </span>            : #define IWM_FW_CTXT_COLOR_MSK   (0xff &lt;&lt; IWM_FW_CTXT_COLOR_POS)
<span class="lineNum">    2227 </span>            : #define IWM_FW_CTXT_INVALID     (0xffffffff)
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            : #define IWM_FW_CMD_ID_AND_COLOR(_id, _color) ((_id &lt;&lt; IWM_FW_CTXT_ID_POS) |\
<span class="lineNum">    2230 </span>            :                                           (_color &lt;&lt; IWM_FW_CTXT_COLOR_POS))
<span class="lineNum">    2231 </span>            : 
<span class="lineNum">    2232 </span>            : /* Possible actions on PHYs, MACs and Bindings */
<span class="lineNum">    2233 </span>            : #define IWM_FW_CTXT_ACTION_STUB         0
<span class="lineNum">    2234 </span>            : #define IWM_FW_CTXT_ACTION_ADD          1
<span class="lineNum">    2235 </span>            : #define IWM_FW_CTXT_ACTION_MODIFY       2
<span class="lineNum">    2236 </span>            : #define IWM_FW_CTXT_ACTION_REMOVE       3
<span class="lineNum">    2237 </span>            : #define IWM_FW_CTXT_ACTION_NUM          4
<span class="lineNum">    2238 </span>            : /* COMMON_CONTEXT_ACTION_API_E_VER_1 */
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span>            : /* Time Events */
<span class="lineNum">    2241 </span>            : 
<span class="lineNum">    2242 </span>            : /* Time Event types, according to MAC type */
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            : /* BSS Station Events */
<span class="lineNum">    2245 </span>            : #define IWM_TE_BSS_STA_AGGRESSIVE_ASSOC 0
<span class="lineNum">    2246 </span>            : #define IWM_TE_BSS_STA_ASSOC            1
<span class="lineNum">    2247 </span>            : #define IWM_TE_BSS_EAP_DHCP_PROT        2
<span class="lineNum">    2248 </span>            : #define IWM_TE_BSS_QUIET_PERIOD         3
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span>            : /* P2P Device Events */
<span class="lineNum">    2251 </span>            : #define IWM_TE_P2P_DEVICE_DISCOVERABLE  4
<span class="lineNum">    2252 </span>            : #define IWM_TE_P2P_DEVICE_LISTEN        5
<span class="lineNum">    2253 </span>            : #define IWM_TE_P2P_DEVICE_ACTION_SCAN   6
<span class="lineNum">    2254 </span>            : #define IWM_TE_P2P_DEVICE_FULL_SCAN     7
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span>            : /* P2P Client Events */
<span class="lineNum">    2257 </span>            : #define IWM_TE_P2P_CLIENT_AGGRESSIVE_ASSOC      8
<span class="lineNum">    2258 </span>            : #define IWM_TE_P2P_CLIENT_ASSOC                 9
<span class="lineNum">    2259 </span>            : #define IWM_TE_P2P_CLIENT_QUIET_PERIOD          10
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span>            : /* P2P GO Events */
<span class="lineNum">    2262 </span>            : #define IWM_TE_P2P_GO_ASSOC_PROT        11
<span class="lineNum">    2263 </span>            : #define IWM_TE_P2P_GO_REPETITIVE_NOA    12
<span class="lineNum">    2264 </span>            : #define IWM_TE_P2P_GO_CT_WINDOW         13
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span>            : /* WiDi Sync Events */
<span class="lineNum">    2267 </span>            : #define IWM_TE_WIDI_TX_SYNC     14
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span>            : #define IWM_TE_MAX      15
<span class="lineNum">    2270 </span>            : /* IWM_MAC_EVENT_TYPE_API_E_VER_1 */
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            : 
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span>            : /* Time event - defines for command API v1 */
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span>            : /*
<span class="lineNum">    2277 </span>            :  * @IWM_TE_V1_FRAG_NONE: fragmentation of the time event is NOT allowed.
<span class="lineNum">    2278 </span>            :  * @IWM_TE_V1_FRAG_SINGLE: fragmentation of the time event is allowed, but only
<span class="lineNum">    2279 </span>            :  *      the first fragment is scheduled.
<span class="lineNum">    2280 </span>            :  * @IWM_TE_V1_FRAG_DUAL: fragmentation of the time event is allowed, but only
<span class="lineNum">    2281 </span>            :  *      the first 2 fragments are scheduled.
<span class="lineNum">    2282 </span>            :  * @IWM_TE_V1_FRAG_ENDLESS: fragmentation of the time event is allowed, and any
<span class="lineNum">    2283 </span>            :  *      number of fragments are valid.
<span class="lineNum">    2284 </span>            :  *
<span class="lineNum">    2285 </span>            :  * Other than the constant defined above, specifying a fragmentation value 'x'
<span class="lineNum">    2286 </span>            :  * means that the event can be fragmented but only the first 'x' will be
<span class="lineNum">    2287 </span>            :  * scheduled.
<span class="lineNum">    2288 </span>            :  */
<span class="lineNum">    2289 </span>            : #define IWM_TE_V1_FRAG_NONE     0
<span class="lineNum">    2290 </span>            : #define IWM_TE_V1_FRAG_SINGLE   1
<span class="lineNum">    2291 </span>            : #define IWM_TE_V1_FRAG_DUAL     2
<span class="lineNum">    2292 </span>            : #define IWM_TE_V1_FRAG_ENDLESS  0xffffffff
<span class="lineNum">    2293 </span>            : 
<span class="lineNum">    2294 </span>            : /* If a Time Event can be fragmented, this is the max number of fragments */
<span class="lineNum">    2295 </span>            : #define IWM_TE_V1_FRAG_MAX_MSK          0x0fffffff
<span class="lineNum">    2296 </span>            : /* Repeat the time event endlessly (until removed) */
<span class="lineNum">    2297 </span>            : #define IWM_TE_V1_REPEAT_ENDLESS        0xffffffff
<span class="lineNum">    2298 </span>            : /* If a Time Event has bounded repetitions, this is the maximal value */
<span class="lineNum">    2299 </span>            : #define IWM_TE_V1_REPEAT_MAX_MSK_V1     0x0fffffff
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span>            : /* Time Event dependencies: none, on another TE, or in a specific time */
<span class="lineNum">    2302 </span>            : #define IWM_TE_V1_INDEPENDENT           0
<span class="lineNum">    2303 </span>            : #define IWM_TE_V1_DEP_OTHER             (1 &lt;&lt; 0)
<span class="lineNum">    2304 </span>            : #define IWM_TE_V1_DEP_TSF               (1 &lt;&lt; 1)
<span class="lineNum">    2305 </span>            : #define IWM_TE_V1_EVENT_SOCIOPATHIC     (1 &lt;&lt; 2)
<span class="lineNum">    2306 </span>            : /* IWM_MAC_EVENT_DEPENDENCY_POLICY_API_E_VER_2 */
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span>            : /*
<span class="lineNum">    2309 </span>            :  * @IWM_TE_V1_NOTIF_NONE: no notifications
<span class="lineNum">    2310 </span>            :  * @IWM_TE_V1_NOTIF_HOST_EVENT_START: request/receive notification on event start
<span class="lineNum">    2311 </span>            :  * @IWM_TE_V1_NOTIF_HOST_EVENT_END:request/receive notification on event end
<span class="lineNum">    2312 </span>            :  * @IWM_TE_V1_NOTIF_INTERNAL_EVENT_START: internal FW use
<span class="lineNum">    2313 </span>            :  * @IWM_TE_V1_NOTIF_INTERNAL_EVENT_END: internal FW use.
<span class="lineNum">    2314 </span>            :  * @IWM_TE_V1_NOTIF_HOST_FRAG_START: request/receive notification on frag start
<span class="lineNum">    2315 </span>            :  * @IWM_TE_V1_NOTIF_HOST_FRAG_END:request/receive notification on frag end
<span class="lineNum">    2316 </span>            :  * @IWM_TE_V1_NOTIF_INTERNAL_FRAG_START: internal FW use.
<span class="lineNum">    2317 </span>            :  * @IWM_TE_V1_NOTIF_INTERNAL_FRAG_END: internal FW use.
<span class="lineNum">    2318 </span>            :  *
<span class="lineNum">    2319 </span>            :  * Supported Time event notifications configuration.
<span class="lineNum">    2320 </span>            :  * A notification (both event and fragment) includes a status indicating weather
<span class="lineNum">    2321 </span>            :  * the FW was able to schedule the event or not. For fragment start/end
<span class="lineNum">    2322 </span>            :  * notification the status is always success. There is no start/end fragment
<span class="lineNum">    2323 </span>            :  * notification for monolithic events.
<span class="lineNum">    2324 </span>            :  */
<span class="lineNum">    2325 </span>            : #define IWM_TE_V1_NOTIF_NONE                    0
<span class="lineNum">    2326 </span>            : #define IWM_TE_V1_NOTIF_HOST_EVENT_START        (1 &lt;&lt; 0)
<span class="lineNum">    2327 </span>            : #define IWM_TE_V1_NOTIF_HOST_EVENT_END          (1 &lt;&lt; 1)
<span class="lineNum">    2328 </span>            : #define IWM_TE_V1_NOTIF_INTERNAL_EVENT_START    (1 &lt;&lt; 2)
<span class="lineNum">    2329 </span>            : #define IWM_TE_V1_NOTIF_INTERNAL_EVENT_END      (1 &lt;&lt; 3)
<span class="lineNum">    2330 </span>            : #define IWM_TE_V1_NOTIF_HOST_FRAG_START         (1 &lt;&lt; 4)
<span class="lineNum">    2331 </span>            : #define IWM_TE_V1_NOTIF_HOST_FRAG_END           (1 &lt;&lt; 5)
<span class="lineNum">    2332 </span>            : #define IWM_TE_V1_NOTIF_INTERNAL_FRAG_START     (1 &lt;&lt; 6)
<span class="lineNum">    2333 </span>            : #define IWM_TE_V1_NOTIF_INTERNAL_FRAG_END       (1 &lt;&lt; 7)
<span class="lineNum">    2334 </span>            : /* IWM_MAC_EVENT_ACTION_API_E_VER_2 */
<span class="lineNum">    2335 </span>            : 
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span>            : /**
<span class="lineNum">    2338 </span>            :  * struct iwm_time_event_cmd_api_v1 - configuring Time Events
<span class="lineNum">    2339 </span>            :  * with struct IWM_MAC_TIME_EVENT_DATA_API_S_VER_1 (see also
<span class="lineNum">    2340 </span>            :  * with version 2. determined by IWM_UCODE_TLV_FLAGS)
<span class="lineNum">    2341 </span>            :  * ( IWM_TIME_EVENT_CMD = 0x29 )
<span class="lineNum">    2342 </span>            :  * @id_and_color: ID and color of the relevant MAC
<span class="lineNum">    2343 </span>            :  * @action: action to perform, one of IWM_FW_CTXT_ACTION_*
<span class="lineNum">    2344 </span>            :  * @id: this field has two meanings, depending on the action:
<span class="lineNum">    2345 </span>            :  *      If the action is ADD, then it means the type of event to add.
<span class="lineNum">    2346 </span>            :  *      For all other actions it is the unique event ID assigned when the
<span class="lineNum">    2347 </span>            :  *      event was added by the FW.
<span class="lineNum">    2348 </span>            :  * @apply_time: When to start the Time Event (in GP2)
<span class="lineNum">    2349 </span>            :  * @max_delay: maximum delay to event's start (apply time), in TU
<span class="lineNum">    2350 </span>            :  * @depends_on: the unique ID of the event we depend on (if any)
<span class="lineNum">    2351 </span>            :  * @interval: interval between repetitions, in TU
<span class="lineNum">    2352 </span>            :  * @interval_reciprocal: 2^32 / interval
<span class="lineNum">    2353 </span>            :  * @duration: duration of event in TU
<span class="lineNum">    2354 </span>            :  * @repeat: how many repetitions to do, can be IWM_TE_REPEAT_ENDLESS
<span class="lineNum">    2355 </span>            :  * @dep_policy: one of IWM_TE_V1_INDEPENDENT, IWM_TE_V1_DEP_OTHER, IWM_TE_V1_DEP_TSF
<span class="lineNum">    2356 </span>            :  *      and IWM_TE_V1_EVENT_SOCIOPATHIC
<span class="lineNum">    2357 </span>            :  * @is_present: 0 or 1, are we present or absent during the Time Event
<span class="lineNum">    2358 </span>            :  * @max_frags: maximal number of fragments the Time Event can be divided to
<span class="lineNum">    2359 </span>            :  * @notify: notifications using IWM_TE_V1_NOTIF_* (whom to notify when)
<span class="lineNum">    2360 </span>            :  */
<span class="lineNum">    2361 </span>            : struct iwm_time_event_cmd_v1 {
<span class="lineNum">    2362 </span>            :         /* COMMON_INDEX_HDR_API_S_VER_1 */
<span class="lineNum">    2363 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2364 </span>            :         uint32_t action;
<span class="lineNum">    2365 </span>            :         uint32_t id;
<span class="lineNum">    2366 </span>            :         /* IWM_MAC_TIME_EVENT_DATA_API_S_VER_1 */
<span class="lineNum">    2367 </span>            :         uint32_t apply_time;
<span class="lineNum">    2368 </span>            :         uint32_t max_delay;
<span class="lineNum">    2369 </span>            :         uint32_t dep_policy;
<span class="lineNum">    2370 </span>            :         uint32_t depends_on;
<span class="lineNum">    2371 </span>            :         uint32_t is_present;
<span class="lineNum">    2372 </span>            :         uint32_t max_frags;
<span class="lineNum">    2373 </span>            :         uint32_t interval;
<span class="lineNum">    2374 </span>            :         uint32_t interval_reciprocal;
<span class="lineNum">    2375 </span>            :         uint32_t duration;
<span class="lineNum">    2376 </span>            :         uint32_t repeat;
<span class="lineNum">    2377 </span>            :         uint32_t notify;
<span class="lineNum">    2378 </span>            : } __packed; /* IWM_MAC_TIME_EVENT_CMD_API_S_VER_1 */
<span class="lineNum">    2379 </span>            : 
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            : /* Time event - defines for command API v2 */
<span class="lineNum">    2382 </span>            : 
<span class="lineNum">    2383 </span>            : /**
<span class="lineNum">    2384 </span>            :  * DOC: Time Events - what is it?
<span class="lineNum">    2385 </span>            :  *
<span class="lineNum">    2386 </span>            :  * Time Events are a fw feature that allows the driver to control the presence
<span class="lineNum">    2387 </span>            :  * of the device on the channel. Since the fw supports multiple channels
<span class="lineNum">    2388 </span>            :  * concurrently, the fw may choose to jump to another channel at any time.
<span class="lineNum">    2389 </span>            :  * In order to make sure that the fw is on a specific channel at a certain time
<span class="lineNum">    2390 </span>            :  * and for a certain duration, the driver needs to issue a time event.
<span class="lineNum">    2391 </span>            :  *
<span class="lineNum">    2392 </span>            :  * The simplest example is for BSS association. The driver issues a time event,
<span class="lineNum">    2393 </span>            :  * waits for it to start, and only then tells mac80211 that we can start the
<span class="lineNum">    2394 </span>            :  * association. This way, we make sure that the association will be done
<span class="lineNum">    2395 </span>            :  * smoothly and won't be interrupted by channel switch decided within the fw.
<span class="lineNum">    2396 </span>            :  */
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            :  /**
<span class="lineNum">    2399 </span>            :  * DOC: The flow against the fw
<span class="lineNum">    2400 </span>            :  *
<span class="lineNum">    2401 </span>            :  * When the driver needs to make sure we are in a certain channel, at a certain
<span class="lineNum">    2402 </span>            :  * time and for a certain duration, it sends a Time Event. The flow against the
<span class="lineNum">    2403 </span>            :  * fw goes like this:
<span class="lineNum">    2404 </span>            :  *      1) Driver sends a TIME_EVENT_CMD to the fw
<span class="lineNum">    2405 </span>            :  *      2) Driver gets the response for that command. This response contains the
<span class="lineNum">    2406 </span>            :  *         Unique ID (UID) of the event.
<span class="lineNum">    2407 </span>            :  *      3) The fw sends notification when the event starts.
<span class="lineNum">    2408 </span>            :  *
<span class="lineNum">    2409 </span>            :  * Of course the API provides various options that allow to cover parameters
<span class="lineNum">    2410 </span>            :  * of the flow.
<span class="lineNum">    2411 </span>            :  *      What is the duration of the event?
<span class="lineNum">    2412 </span>            :  *      What is the start time of the event?
<span class="lineNum">    2413 </span>            :  *      Is there an end-time for the event?
<span class="lineNum">    2414 </span>            :  *      How much can the event be delayed?
<span class="lineNum">    2415 </span>            :  *      Can the event be split?
<span class="lineNum">    2416 </span>            :  *      If yes what is the maximal number of chunks?
<span class="lineNum">    2417 </span>            :  *      etc...
<span class="lineNum">    2418 </span>            :  */
<span class="lineNum">    2419 </span>            : 
<span class="lineNum">    2420 </span>            : /*
<span class="lineNum">    2421 </span>            :  * @IWM_TE_V2_FRAG_NONE: fragmentation of the time event is NOT allowed.
<span class="lineNum">    2422 </span>            :  * @IWM_TE_V2_FRAG_SINGLE: fragmentation of the time event is allowed, but only
<span class="lineNum">    2423 </span>            :  *  the first fragment is scheduled.
<span class="lineNum">    2424 </span>            :  * @IWM_TE_V2_FRAG_DUAL: fragmentation of the time event is allowed, but only
<span class="lineNum">    2425 </span>            :  *  the first 2 fragments are scheduled.
<span class="lineNum">    2426 </span>            :  * @IWM_TE_V2_FRAG_ENDLESS: fragmentation of the time event is allowed, and any
<span class="lineNum">    2427 </span>            :  *  number of fragments are valid.
<span class="lineNum">    2428 </span>            :  *
<span class="lineNum">    2429 </span>            :  * Other than the constant defined above, specifying a fragmentation value 'x'
<span class="lineNum">    2430 </span>            :  * means that the event can be fragmented but only the first 'x' will be
<span class="lineNum">    2431 </span>            :  * scheduled.
<span class="lineNum">    2432 </span>            :  */
<span class="lineNum">    2433 </span>            : #define IWM_TE_V2_FRAG_NONE             0
<span class="lineNum">    2434 </span>            : #define IWM_TE_V2_FRAG_SINGLE           1
<span class="lineNum">    2435 </span>            : #define IWM_TE_V2_FRAG_DUAL             2
<span class="lineNum">    2436 </span>            : #define IWM_TE_V2_FRAG_MAX              0xfe
<span class="lineNum">    2437 </span>            : #define IWM_TE_V2_FRAG_ENDLESS          0xff
<span class="lineNum">    2438 </span>            : 
<span class="lineNum">    2439 </span>            : /* Repeat the time event endlessly (until removed) */
<span class="lineNum">    2440 </span>            : #define IWM_TE_V2_REPEAT_ENDLESS        0xff
<span class="lineNum">    2441 </span>            : /* If a Time Event has bounded repetitions, this is the maximal value */
<span class="lineNum">    2442 </span>            : #define IWM_TE_V2_REPEAT_MAX    0xfe
<span class="lineNum">    2443 </span>            : 
<span class="lineNum">    2444 </span>            : #define IWM_TE_V2_PLACEMENT_POS 12
<span class="lineNum">    2445 </span>            : #define IWM_TE_V2_ABSENCE_POS   15
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span>            : /* Time event policy values (for time event cmd api v2)
<span class="lineNum">    2448 </span>            :  * A notification (both event and fragment) includes a status indicating weather
<span class="lineNum">    2449 </span>            :  * the FW was able to schedule the event or not. For fragment start/end
<span class="lineNum">    2450 </span>            :  * notification the status is always success. There is no start/end fragment
<span class="lineNum">    2451 </span>            :  * notification for monolithic events.
<span class="lineNum">    2452 </span>            :  *
<span class="lineNum">    2453 </span>            :  * @IWM_TE_V2_DEFAULT_POLICY: independent, social, present, unoticable
<span class="lineNum">    2454 </span>            :  * @IWM_TE_V2_NOTIF_HOST_EVENT_START: request/receive notification on event start
<span class="lineNum">    2455 </span>            :  * @IWM_TE_V2_NOTIF_HOST_EVENT_END:request/receive notification on event end
<span class="lineNum">    2456 </span>            :  * @IWM_TE_V2_NOTIF_INTERNAL_EVENT_START: internal FW use
<span class="lineNum">    2457 </span>            :  * @IWM_TE_V2_NOTIF_INTERNAL_EVENT_END: internal FW use.
<span class="lineNum">    2458 </span>            :  * @IWM_TE_V2_NOTIF_HOST_FRAG_START: request/receive notification on frag start
<span class="lineNum">    2459 </span>            :  * @IWM_TE_V2_NOTIF_HOST_FRAG_END:request/receive notification on frag end
<span class="lineNum">    2460 </span>            :  * @IWM_TE_V2_NOTIF_INTERNAL_FRAG_START: internal FW use.
<span class="lineNum">    2461 </span>            :  * @IWM_TE_V2_NOTIF_INTERNAL_FRAG_END: internal FW use.
<span class="lineNum">    2462 </span>            :  * @IWM_TE_V2_DEP_OTHER: depends on another time event
<span class="lineNum">    2463 </span>            :  * @IWM_TE_V2_DEP_TSF: depends on a specific time
<span class="lineNum">    2464 </span>            :  * @IWM_TE_V2_EVENT_SOCIOPATHIC: can't co-exist with other events of tha same MAC
<span class="lineNum">    2465 </span>            :  * @IWM_TE_V2_ABSENCE: are we present or absent during the Time Event.
<span class="lineNum">    2466 </span>            :  */
<span class="lineNum">    2467 </span>            : #define IWM_TE_V2_DEFAULT_POLICY                0x0
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span>            : /* notifications (event start/stop, fragment start/stop) */
<span class="lineNum">    2470 </span>            : #define IWM_TE_V2_NOTIF_HOST_EVENT_START        (1 &lt;&lt; 0)
<span class="lineNum">    2471 </span>            : #define IWM_TE_V2_NOTIF_HOST_EVENT_END          (1 &lt;&lt; 1)
<span class="lineNum">    2472 </span>            : #define IWM_TE_V2_NOTIF_INTERNAL_EVENT_START    (1 &lt;&lt; 2)
<span class="lineNum">    2473 </span>            : #define IWM_TE_V2_NOTIF_INTERNAL_EVENT_END      (1 &lt;&lt; 3)
<span class="lineNum">    2474 </span>            : 
<span class="lineNum">    2475 </span>            : #define IWM_TE_V2_NOTIF_HOST_FRAG_START         (1 &lt;&lt; 4)
<span class="lineNum">    2476 </span>            : #define IWM_TE_V2_NOTIF_HOST_FRAG_END           (1 &lt;&lt; 5)
<span class="lineNum">    2477 </span>            : #define IWM_TE_V2_NOTIF_INTERNAL_FRAG_START     (1 &lt;&lt; 6)
<span class="lineNum">    2478 </span>            : #define IWM_TE_V2_NOTIF_INTERNAL_FRAG_END       (1 &lt;&lt; 7)
<span class="lineNum">    2479 </span>            : #define IWM_T2_V2_START_IMMEDIATELY             (1 &lt;&lt; 11)
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span>            : #define IWM_TE_V2_NOTIF_MSK     0xff
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span>            : /* placement characteristics */
<span class="lineNum">    2484 </span>            : #define IWM_TE_V2_DEP_OTHER             (1 &lt;&lt; IWM_TE_V2_PLACEMENT_POS)
<span class="lineNum">    2485 </span>            : #define IWM_TE_V2_DEP_TSF               (1 &lt;&lt; (IWM_TE_V2_PLACEMENT_POS + 1))
<span class="lineNum">    2486 </span>            : #define IWM_TE_V2_EVENT_SOCIOPATHIC     (1 &lt;&lt; (IWM_TE_V2_PLACEMENT_POS + 2))
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span>            : /* are we present or absent during the Time Event. */
<span class="lineNum">    2489 </span>            : #define IWM_TE_V2_ABSENCE               (1 &lt;&lt; IWM_TE_V2_ABSENCE_POS)
<span class="lineNum">    2490 </span>            : 
<span class="lineNum">    2491 </span>            : /**
<span class="lineNum">    2492 </span>            :  * struct iwm_time_event_cmd_api_v2 - configuring Time Events
<span class="lineNum">    2493 </span>            :  * with struct IWM_MAC_TIME_EVENT_DATA_API_S_VER_2 (see also
<span class="lineNum">    2494 </span>            :  * with version 1. determined by IWM_UCODE_TLV_FLAGS)
<span class="lineNum">    2495 </span>            :  * ( IWM_TIME_EVENT_CMD = 0x29 )
<span class="lineNum">    2496 </span>            :  * @id_and_color: ID and color of the relevant MAC
<span class="lineNum">    2497 </span>            :  * @action: action to perform, one of IWM_FW_CTXT_ACTION_*
<span class="lineNum">    2498 </span>            :  * @id: this field has two meanings, depending on the action:
<span class="lineNum">    2499 </span>            :  *      If the action is ADD, then it means the type of event to add.
<span class="lineNum">    2500 </span>            :  *      For all other actions it is the unique event ID assigned when the
<span class="lineNum">    2501 </span>            :  *      event was added by the FW.
<span class="lineNum">    2502 </span>            :  * @apply_time: When to start the Time Event (in GP2)
<span class="lineNum">    2503 </span>            :  * @max_delay: maximum delay to event's start (apply time), in TU
<span class="lineNum">    2504 </span>            :  * @depends_on: the unique ID of the event we depend on (if any)
<span class="lineNum">    2505 </span>            :  * @interval: interval between repetitions, in TU
<span class="lineNum">    2506 </span>            :  * @duration: duration of event in TU
<span class="lineNum">    2507 </span>            :  * @repeat: how many repetitions to do, can be IWM_TE_REPEAT_ENDLESS
<span class="lineNum">    2508 </span>            :  * @max_frags: maximal number of fragments the Time Event can be divided to
<span class="lineNum">    2509 </span>            :  * @policy: defines whether uCode shall notify the host or other uCode modules
<span class="lineNum">    2510 </span>            :  *      on event and/or fragment start and/or end
<span class="lineNum">    2511 </span>            :  *      using one of IWM_TE_INDEPENDENT, IWM_TE_DEP_OTHER, IWM_TE_DEP_TSF
<span class="lineNum">    2512 </span>            :  *      IWM_TE_EVENT_SOCIOPATHIC
<span class="lineNum">    2513 </span>            :  *      using IWM_TE_ABSENCE and using IWM_TE_NOTIF_*
<span class="lineNum">    2514 </span>            :  */
<span class="lineNum">    2515 </span>            : struct iwm_time_event_cmd_v2 {
<span class="lineNum">    2516 </span>            :         /* COMMON_INDEX_HDR_API_S_VER_1 */
<span class="lineNum">    2517 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2518 </span>            :         uint32_t action;
<span class="lineNum">    2519 </span>            :         uint32_t id;
<span class="lineNum">    2520 </span>            :         /* IWM_MAC_TIME_EVENT_DATA_API_S_VER_2 */
<span class="lineNum">    2521 </span>            :         uint32_t apply_time;
<span class="lineNum">    2522 </span>            :         uint32_t max_delay;
<span class="lineNum">    2523 </span>            :         uint32_t depends_on;
<span class="lineNum">    2524 </span>            :         uint32_t interval;
<span class="lineNum">    2525 </span>            :         uint32_t duration;
<span class="lineNum">    2526 </span>            :         uint8_t repeat;
<span class="lineNum">    2527 </span>            :         uint8_t max_frags;
<span class="lineNum">    2528 </span>            :         uint16_t policy;
<span class="lineNum">    2529 </span>            : } __packed; /* IWM_MAC_TIME_EVENT_CMD_API_S_VER_2 */
<span class="lineNum">    2530 </span>            : 
<span class="lineNum">    2531 </span>            : /**
<span class="lineNum">    2532 </span>            :  * struct iwm_time_event_resp - response structure to iwm_time_event_cmd
<span class="lineNum">    2533 </span>            :  * @status: bit 0 indicates success, all others specify errors
<span class="lineNum">    2534 </span>            :  * @id: the Time Event type
<span class="lineNum">    2535 </span>            :  * @unique_id: the unique ID assigned (in ADD) or given (others) to the TE
<span class="lineNum">    2536 </span>            :  * @id_and_color: ID and color of the relevant MAC
<span class="lineNum">    2537 </span>            :  */
<span class="lineNum">    2538 </span>            : struct iwm_time_event_resp {
<span class="lineNum">    2539 </span>            :         uint32_t status;
<span class="lineNum">    2540 </span>            :         uint32_t id;
<span class="lineNum">    2541 </span>            :         uint32_t unique_id;
<span class="lineNum">    2542 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2543 </span>            : } __packed; /* IWM_MAC_TIME_EVENT_RSP_API_S_VER_1 */
<span class="lineNum">    2544 </span>            : 
<span class="lineNum">    2545 </span>            : /**
<span class="lineNum">    2546 </span>            :  * struct iwm_time_event_notif - notifications of time event start/stop
<span class="lineNum">    2547 </span>            :  * ( IWM_TIME_EVENT_NOTIFICATION = 0x2a )
<span class="lineNum">    2548 </span>            :  * @timestamp: action timestamp in GP2
<span class="lineNum">    2549 </span>            :  * @session_id: session's unique id
<span class="lineNum">    2550 </span>            :  * @unique_id: unique id of the Time Event itself
<span class="lineNum">    2551 </span>            :  * @id_and_color: ID and color of the relevant MAC
<span class="lineNum">    2552 </span>            :  * @action: one of IWM_TE_NOTIF_START or IWM_TE_NOTIF_END
<span class="lineNum">    2553 </span>            :  * @status: true if scheduled, false otherwise (not executed)
<span class="lineNum">    2554 </span>            :  */
<span class="lineNum">    2555 </span>            : struct iwm_time_event_notif {
<span class="lineNum">    2556 </span>            :         uint32_t timestamp;
<span class="lineNum">    2557 </span>            :         uint32_t session_id;
<span class="lineNum">    2558 </span>            :         uint32_t unique_id;
<span class="lineNum">    2559 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2560 </span>            :         uint32_t action;
<span class="lineNum">    2561 </span>            :         uint32_t status;
<span class="lineNum">    2562 </span>            : } __packed; /* IWM_MAC_TIME_EVENT_NTFY_API_S_VER_1 */
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span>            : 
<span class="lineNum">    2565 </span>            : /* Bindings and Time Quota */
<span class="lineNum">    2566 </span>            : 
<span class="lineNum">    2567 </span>            : /**
<span class="lineNum">    2568 </span>            :  * struct iwm_binding_cmd - configuring bindings
<span class="lineNum">    2569 </span>            :  * ( IWM_BINDING_CONTEXT_CMD = 0x2b )
<span class="lineNum">    2570 </span>            :  * @id_and_color: ID and color of the relevant Binding
<span class="lineNum">    2571 </span>            :  * @action: action to perform, one of IWM_FW_CTXT_ACTION_*
<span class="lineNum">    2572 </span>            :  * @macs: array of MAC id and colors which belong to the binding
<span class="lineNum">    2573 </span>            :  * @phy: PHY id and color which belongs to the binding
<span class="lineNum">    2574 </span>            :  */
<span class="lineNum">    2575 </span>            : struct iwm_binding_cmd {
<span class="lineNum">    2576 </span>            :         /* COMMON_INDEX_HDR_API_S_VER_1 */
<span class="lineNum">    2577 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2578 </span>            :         uint32_t action;
<span class="lineNum">    2579 </span>            :         /* IWM_BINDING_DATA_API_S_VER_1 */
<span class="lineNum">    2580 </span>            :         uint32_t macs[IWM_MAX_MACS_IN_BINDING];
<span class="lineNum">    2581 </span>            :         uint32_t phy;
<span class="lineNum">    2582 </span>            : } __packed; /* IWM_BINDING_CMD_API_S_VER_1 */
<span class="lineNum">    2583 </span>            : 
<span class="lineNum">    2584 </span>            : /* The maximal number of fragments in the FW's schedule session */
<span class="lineNum">    2585 </span>            : #define IWM_MAX_QUOTA 128
<span class="lineNum">    2586 </span>            : 
<span class="lineNum">    2587 </span>            : /**
<span class="lineNum">    2588 </span>            :  * struct iwm_time_quota_data - configuration of time quota per binding
<span class="lineNum">    2589 </span>            :  * @id_and_color: ID and color of the relevant Binding
<span class="lineNum">    2590 </span>            :  * @quota: absolute time quota in TU. The scheduler will try to divide the
<span class="lineNum">    2591 </span>            :  *      remainig quota (after Time Events) according to this quota.
<span class="lineNum">    2592 </span>            :  * @max_duration: max uninterrupted context duration in TU
<span class="lineNum">    2593 </span>            :  */
<span class="lineNum">    2594 </span>            : struct iwm_time_quota_data {
<span class="lineNum">    2595 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2596 </span>            :         uint32_t quota;
<span class="lineNum">    2597 </span>            :         uint32_t max_duration;
<span class="lineNum">    2598 </span>            : } __packed; /* IWM_TIME_QUOTA_DATA_API_S_VER_1 */
<span class="lineNum">    2599 </span>            : 
<span class="lineNum">    2600 </span>            : /**
<span class="lineNum">    2601 </span>            :  * struct iwm_time_quota_cmd - configuration of time quota between bindings
<span class="lineNum">    2602 </span>            :  * ( IWM_TIME_QUOTA_CMD = 0x2c )
<span class="lineNum">    2603 </span>            :  * @quotas: allocations per binding
<span class="lineNum">    2604 </span>            :  */
<span class="lineNum">    2605 </span>            : struct iwm_time_quota_cmd {
<span class="lineNum">    2606 </span>            :         struct iwm_time_quota_data quotas[IWM_MAX_BINDINGS];
<span class="lineNum">    2607 </span>            : } __packed; /* IWM_TIME_QUOTA_ALLOCATION_CMD_API_S_VER_1 */
<span class="lineNum">    2608 </span>            : 
<span class="lineNum">    2609 </span>            : 
<span class="lineNum">    2610 </span>            : /* PHY context */
<span class="lineNum">    2611 </span>            : 
<span class="lineNum">    2612 </span>            : /* Supported bands */
<span class="lineNum">    2613 </span>            : #define IWM_PHY_BAND_5  (0)
<span class="lineNum">    2614 </span>            : #define IWM_PHY_BAND_24 (1)
<span class="lineNum">    2615 </span>            : 
<span class="lineNum">    2616 </span>            : /* Supported channel width, vary if there is VHT support */
<span class="lineNum">    2617 </span>            : #define IWM_PHY_VHT_CHANNEL_MODE20      (0x0)
<span class="lineNum">    2618 </span>            : #define IWM_PHY_VHT_CHANNEL_MODE40      (0x1)
<span class="lineNum">    2619 </span>            : #define IWM_PHY_VHT_CHANNEL_MODE80      (0x2)
<span class="lineNum">    2620 </span>            : #define IWM_PHY_VHT_CHANNEL_MODE160     (0x3)
<span class="lineNum">    2621 </span>            : 
<span class="lineNum">    2622 </span>            : /*
<span class="lineNum">    2623 </span>            :  * Control channel position:
<span class="lineNum">    2624 </span>            :  * For legacy set bit means upper channel, otherwise lower.
<span class="lineNum">    2625 </span>            :  * For VHT - bit-2 marks if the control is lower/upper relative to center-freq
<span class="lineNum">    2626 </span>            :  *   bits-1:0 mark the distance from the center freq. for 20Mhz, offset is 0.
<span class="lineNum">    2627 </span>            :  *                                   center_freq
<span class="lineNum">    2628 </span>            :  *                                        |
<span class="lineNum">    2629 </span>            :  * 40Mhz                          |_______|_______|
<span class="lineNum">    2630 </span>            :  * 80Mhz                  |_______|_______|_______|_______|
<span class="lineNum">    2631 </span>            :  * 160Mhz |_______|_______|_______|_______|_______|_______|_______|_______|
<span class="lineNum">    2632 </span>            :  * code      011     010     001     000  |  100     101     110    111
<span class="lineNum">    2633 </span>            :  */
<span class="lineNum">    2634 </span>            : #define IWM_PHY_VHT_CTRL_POS_1_BELOW  (0x0)
<span class="lineNum">    2635 </span>            : #define IWM_PHY_VHT_CTRL_POS_2_BELOW  (0x1)
<span class="lineNum">    2636 </span>            : #define IWM_PHY_VHT_CTRL_POS_3_BELOW  (0x2)
<span class="lineNum">    2637 </span>            : #define IWM_PHY_VHT_CTRL_POS_4_BELOW  (0x3)
<span class="lineNum">    2638 </span>            : #define IWM_PHY_VHT_CTRL_POS_1_ABOVE  (0x4)
<span class="lineNum">    2639 </span>            : #define IWM_PHY_VHT_CTRL_POS_2_ABOVE  (0x5)
<span class="lineNum">    2640 </span>            : #define IWM_PHY_VHT_CTRL_POS_3_ABOVE  (0x6)
<span class="lineNum">    2641 </span>            : #define IWM_PHY_VHT_CTRL_POS_4_ABOVE  (0x7)
<span class="lineNum">    2642 </span>            : 
<span class="lineNum">    2643 </span>            : /*
<span class="lineNum">    2644 </span>            :  * @band: IWM_PHY_BAND_*
<span class="lineNum">    2645 </span>            :  * @channel: channel number
<span class="lineNum">    2646 </span>            :  * @width: PHY_[VHT|LEGACY]_CHANNEL_*
<span class="lineNum">    2647 </span>            :  * @ctrl channel: PHY_[VHT|LEGACY]_CTRL_*
<span class="lineNum">    2648 </span>            :  */
<span class="lineNum">    2649 </span>            : struct iwm_fw_channel_info {
<span class="lineNum">    2650 </span>            :         uint8_t band;
<span class="lineNum">    2651 </span>            :         uint8_t channel;
<span class="lineNum">    2652 </span>            :         uint8_t width;
<span class="lineNum">    2653 </span>            :         uint8_t ctrl_pos;
<span class="lineNum">    2654 </span>            : } __packed;
<span class="lineNum">    2655 </span>            : 
<span class="lineNum">    2656 </span>            : #define IWM_PHY_RX_CHAIN_DRIVER_FORCE_POS       (0)
<span class="lineNum">    2657 </span>            : #define IWM_PHY_RX_CHAIN_DRIVER_FORCE_MSK \
<span class="lineNum">    2658 </span>            :         (0x1 &lt;&lt; IWM_PHY_RX_CHAIN_DRIVER_FORCE_POS)
<span class="lineNum">    2659 </span>            : #define IWM_PHY_RX_CHAIN_VALID_POS              (1)
<span class="lineNum">    2660 </span>            : #define IWM_PHY_RX_CHAIN_VALID_MSK \
<span class="lineNum">    2661 </span>            :         (0x7 &lt;&lt; IWM_PHY_RX_CHAIN_VALID_POS)
<span class="lineNum">    2662 </span>            : #define IWM_PHY_RX_CHAIN_FORCE_SEL_POS  (4)
<span class="lineNum">    2663 </span>            : #define IWM_PHY_RX_CHAIN_FORCE_SEL_MSK \
<span class="lineNum">    2664 </span>            :         (0x7 &lt;&lt; IWM_PHY_RX_CHAIN_FORCE_SEL_POS)
<span class="lineNum">    2665 </span>            : #define IWM_PHY_RX_CHAIN_FORCE_MIMO_SEL_POS     (7)
<span class="lineNum">    2666 </span>            : #define IWM_PHY_RX_CHAIN_FORCE_MIMO_SEL_MSK \
<span class="lineNum">    2667 </span>            :         (0x7 &lt;&lt; IWM_PHY_RX_CHAIN_FORCE_MIMO_SEL_POS)
<span class="lineNum">    2668 </span>            : #define IWM_PHY_RX_CHAIN_CNT_POS                (10)
<span class="lineNum">    2669 </span>            : #define IWM_PHY_RX_CHAIN_CNT_MSK \
<span class="lineNum">    2670 </span>            :         (0x3 &lt;&lt; IWM_PHY_RX_CHAIN_CNT_POS)
<span class="lineNum">    2671 </span>            : #define IWM_PHY_RX_CHAIN_MIMO_CNT_POS   (12)
<span class="lineNum">    2672 </span>            : #define IWM_PHY_RX_CHAIN_MIMO_CNT_MSK \
<span class="lineNum">    2673 </span>            :         (0x3 &lt;&lt; IWM_PHY_RX_CHAIN_MIMO_CNT_POS)
<span class="lineNum">    2674 </span>            : #define IWM_PHY_RX_CHAIN_MIMO_FORCE_POS (14)
<span class="lineNum">    2675 </span>            : #define IWM_PHY_RX_CHAIN_MIMO_FORCE_MSK \
<span class="lineNum">    2676 </span>            :         (0x1 &lt;&lt; IWM_PHY_RX_CHAIN_MIMO_FORCE_POS)
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            : /* TODO: fix the value, make it depend on firmware at runtime? */
<span class="lineNum">    2679 </span>            : #define IWM_NUM_PHY_CTX 3
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span>            : /* TODO: complete missing documentation */
<span class="lineNum">    2682 </span>            : /**
<span class="lineNum">    2683 </span>            :  * struct iwm_phy_context_cmd - config of the PHY context
<span class="lineNum">    2684 </span>            :  * ( IWM_PHY_CONTEXT_CMD = 0x8 )
<span class="lineNum">    2685 </span>            :  * @id_and_color: ID and color of the relevant Binding
<span class="lineNum">    2686 </span>            :  * @action: action to perform, one of IWM_FW_CTXT_ACTION_*
<span class="lineNum">    2687 </span>            :  * @apply_time: 0 means immediate apply and context switch.
<span class="lineNum">    2688 </span>            :  *      other value means apply new params after X usecs
<span class="lineNum">    2689 </span>            :  * @tx_param_color: ???
<span class="lineNum">    2690 </span>            :  * @channel_info:
<span class="lineNum">    2691 </span>            :  * @txchain_info: ???
<span class="lineNum">    2692 </span>            :  * @rxchain_info: ???
<span class="lineNum">    2693 </span>            :  * @acquisition_data: ???
<span class="lineNum">    2694 </span>            :  * @dsp_cfg_flags: set to 0
<span class="lineNum">    2695 </span>            :  */
<span class="lineNum">    2696 </span>            : struct iwm_phy_context_cmd {
<span class="lineNum">    2697 </span>            :         /* COMMON_INDEX_HDR_API_S_VER_1 */
<span class="lineNum">    2698 </span>            :         uint32_t id_and_color;
<span class="lineNum">    2699 </span>            :         uint32_t action;
<span class="lineNum">    2700 </span>            :         /* IWM_PHY_CONTEXT_DATA_API_S_VER_1 */
<span class="lineNum">    2701 </span>            :         uint32_t apply_time;
<span class="lineNum">    2702 </span>            :         uint32_t tx_param_color;
<span class="lineNum">    2703 </span>            :         struct iwm_fw_channel_info ci;
<span class="lineNum">    2704 </span>            :         uint32_t txchain_info;
<span class="lineNum">    2705 </span>            :         uint32_t rxchain_info;
<span class="lineNum">    2706 </span>            :         uint32_t acquisition_data;
<span class="lineNum">    2707 </span>            :         uint32_t dsp_cfg_flags;
<span class="lineNum">    2708 </span>            : } __packed; /* IWM_PHY_CONTEXT_CMD_API_VER_1 */
<span class="lineNum">    2709 </span>            : 
<span class="lineNum">    2710 </span>            : #define IWM_RX_INFO_PHY_CNT 8
<span class="lineNum">    2711 </span>            : #define IWM_RX_INFO_ENERGY_ANT_ABC_IDX 1
<span class="lineNum">    2712 </span>            : #define IWM_RX_INFO_ENERGY_ANT_A_MSK 0x000000ff
<span class="lineNum">    2713 </span>            : #define IWM_RX_INFO_ENERGY_ANT_B_MSK 0x0000ff00
<span class="lineNum">    2714 </span>            : #define IWM_RX_INFO_ENERGY_ANT_C_MSK 0x00ff0000
<span class="lineNum">    2715 </span>            : #define IWM_RX_INFO_ENERGY_ANT_A_POS 0
<span class="lineNum">    2716 </span>            : #define IWM_RX_INFO_ENERGY_ANT_B_POS 8
<span class="lineNum">    2717 </span>            : #define IWM_RX_INFO_ENERGY_ANT_C_POS 16
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span>            : #define IWM_RX_INFO_AGC_IDX 1
<span class="lineNum">    2720 </span>            : #define IWM_RX_INFO_RSSI_AB_IDX 2
<span class="lineNum">    2721 </span>            : #define IWM_OFDM_AGC_A_MSK 0x0000007f
<span class="lineNum">    2722 </span>            : #define IWM_OFDM_AGC_A_POS 0
<span class="lineNum">    2723 </span>            : #define IWM_OFDM_AGC_B_MSK 0x00003f80
<span class="lineNum">    2724 </span>            : #define IWM_OFDM_AGC_B_POS 7
<span class="lineNum">    2725 </span>            : #define IWM_OFDM_AGC_CODE_MSK 0x3fe00000
<span class="lineNum">    2726 </span>            : #define IWM_OFDM_AGC_CODE_POS 20
<span class="lineNum">    2727 </span>            : #define IWM_OFDM_RSSI_INBAND_A_MSK 0x00ff
<span class="lineNum">    2728 </span>            : #define IWM_OFDM_RSSI_A_POS 0
<span class="lineNum">    2729 </span>            : #define IWM_OFDM_RSSI_ALLBAND_A_MSK 0xff00
<span class="lineNum">    2730 </span>            : #define IWM_OFDM_RSSI_ALLBAND_A_POS 8
<span class="lineNum">    2731 </span>            : #define IWM_OFDM_RSSI_INBAND_B_MSK 0xff0000
<span class="lineNum">    2732 </span>            : #define IWM_OFDM_RSSI_B_POS 16
<span class="lineNum">    2733 </span>            : #define IWM_OFDM_RSSI_ALLBAND_B_MSK 0xff000000
<span class="lineNum">    2734 </span>            : #define IWM_OFDM_RSSI_ALLBAND_B_POS 24
<span class="lineNum">    2735 </span>            : 
<span class="lineNum">    2736 </span>            : /**
<span class="lineNum">    2737 </span>            :  * struct iwm_rx_phy_info - phy info
<span class="lineNum">    2738 </span>            :  * (IWM_REPLY_RX_PHY_CMD = 0xc0)
<span class="lineNum">    2739 </span>            :  * @non_cfg_phy_cnt: non configurable DSP phy data byte count
<span class="lineNum">    2740 </span>            :  * @cfg_phy_cnt: configurable DSP phy data byte count
<span class="lineNum">    2741 </span>            :  * @stat_id: configurable DSP phy data set ID
<span class="lineNum">    2742 </span>            :  * @reserved1:
<span class="lineNum">    2743 </span>            :  * @system_timestamp: GP2  at on air rise
<span class="lineNum">    2744 </span>            :  * @timestamp: TSF at on air rise
<span class="lineNum">    2745 </span>            :  * @beacon_time_stamp: beacon at on-air rise
<span class="lineNum">    2746 </span>            :  * @phy_flags: general phy flags: band, modulation, ...
<span class="lineNum">    2747 </span>            :  * @channel: channel number
<span class="lineNum">    2748 </span>            :  * @non_cfg_phy_buf: for various implementations of non_cfg_phy
<span class="lineNum">    2749 </span>            :  * @rate_n_flags: IWM_RATE_MCS_*
<span class="lineNum">    2750 </span>            :  * @byte_count: frame's byte-count
<span class="lineNum">    2751 </span>            :  * @frame_time: frame's time on the air, based on byte count and frame rate
<span class="lineNum">    2752 </span>            :  *      calculation
<span class="lineNum">    2753 </span>            :  * @mac_active_msk: what MACs were active when the frame was received
<span class="lineNum">    2754 </span>            :  *
<span class="lineNum">    2755 </span>            :  * Before each Rx, the device sends this data. It contains PHY information
<span class="lineNum">    2756 </span>            :  * about the reception of the packet.
<span class="lineNum">    2757 </span>            :  */
<span class="lineNum">    2758 </span>            : struct iwm_rx_phy_info {
<span class="lineNum">    2759 </span>            :         uint8_t non_cfg_phy_cnt;
<span class="lineNum">    2760 </span>            :         uint8_t cfg_phy_cnt;
<span class="lineNum">    2761 </span>            :         uint8_t stat_id;
<span class="lineNum">    2762 </span>            :         uint8_t reserved1;
<span class="lineNum">    2763 </span>            :         uint32_t system_timestamp;
<span class="lineNum">    2764 </span>            :         uint64_t timestamp;
<span class="lineNum">    2765 </span>            :         uint32_t beacon_time_stamp;
<span class="lineNum">    2766 </span>            :         uint16_t phy_flags;
<span class="lineNum">    2767 </span>            : #define IWM_PHY_INFO_FLAG_SHPREAMBLE    (1 &lt;&lt; 2)
<span class="lineNum">    2768 </span>            :         uint16_t channel;
<span class="lineNum">    2769 </span>            :         uint32_t non_cfg_phy[IWM_RX_INFO_PHY_CNT];
<span class="lineNum">    2770 </span>            :         uint32_t rate_n_flags;
<span class="lineNum">    2771 </span>            :         uint32_t byte_count;
<span class="lineNum">    2772 </span>            :         uint16_t mac_active_msk;
<span class="lineNum">    2773 </span>            :         uint16_t frame_time;
<span class="lineNum">    2774 </span>            : } __packed;
<span class="lineNum">    2775 </span>            : 
<span class="lineNum">    2776 </span>            : struct iwm_rx_mpdu_res_start {
<span class="lineNum">    2777 </span>            :         uint16_t byte_count;
<span class="lineNum">    2778 </span>            :         uint16_t reserved;
<span class="lineNum">    2779 </span>            : } __packed;
<span class="lineNum">    2780 </span>            : 
<span class="lineNum">    2781 </span>            : /**
<span class="lineNum">    2782 </span>            :  * Values to parse %iwm_rx_phy_info phy_flags
<span class="lineNum">    2783 </span>            :  * @IWM_RX_RES_PHY_FLAGS_BAND_24: true if the packet was received on 2.4 band
<span class="lineNum">    2784 </span>            :  * @IWM_RX_RES_PHY_FLAGS_MOD_CCK:
<span class="lineNum">    2785 </span>            :  * @IWM_RX_RES_PHY_FLAGS_SHORT_PREAMBLE: true if packet's preamble was short
<span class="lineNum">    2786 </span>            :  * @IWM_RX_RES_PHY_FLAGS_NARROW_BAND:
<span class="lineNum">    2787 </span>            :  * @IWM_RX_RES_PHY_FLAGS_ANTENNA: antenna on which the packet was received
<span class="lineNum">    2788 </span>            :  * @IWM_RX_RES_PHY_FLAGS_AGG: set if the packet was part of an A-MPDU
<span class="lineNum">    2789 </span>            :  * @IWM_RX_RES_PHY_FLAGS_OFDM_HT: The frame was an HT frame
<span class="lineNum">    2790 </span>            :  * @IWM_RX_RES_PHY_FLAGS_OFDM_GF: The frame used GF preamble
<span class="lineNum">    2791 </span>            :  * @IWM_RX_RES_PHY_FLAGS_OFDM_VHT: The frame was a VHT frame
<span class="lineNum">    2792 </span>            :  */
<span class="lineNum">    2793 </span>            : #define IWM_RX_RES_PHY_FLAGS_BAND_24            (1 &lt;&lt; 0)
<span class="lineNum">    2794 </span>            : #define IWM_RX_RES_PHY_FLAGS_MOD_CCK            (1 &lt;&lt; 1)
<span class="lineNum">    2795 </span>            : #define IWM_RX_RES_PHY_FLAGS_SHORT_PREAMBLE     (1 &lt;&lt; 2)
<span class="lineNum">    2796 </span>            : #define IWM_RX_RES_PHY_FLAGS_NARROW_BAND        (1 &lt;&lt; 3)
<span class="lineNum">    2797 </span>            : #define IWM_RX_RES_PHY_FLAGS_ANTENNA            (0x7 &lt;&lt; 4)
<span class="lineNum">    2798 </span>            : #define IWM_RX_RES_PHY_FLAGS_ANTENNA_POS        4
<span class="lineNum">    2799 </span>            : #define IWM_RX_RES_PHY_FLAGS_AGG                (1 &lt;&lt; 7)
<span class="lineNum">    2800 </span>            : #define IWM_RX_RES_PHY_FLAGS_OFDM_HT            (1 &lt;&lt; 8)
<span class="lineNum">    2801 </span>            : #define IWM_RX_RES_PHY_FLAGS_OFDM_GF            (1 &lt;&lt; 9)
<span class="lineNum">    2802 </span>            : #define IWM_RX_RES_PHY_FLAGS_OFDM_VHT           (1 &lt;&lt; 10)
<span class="lineNum">    2803 </span>            : 
<span class="lineNum">    2804 </span>            : /**
<span class="lineNum">    2805 </span>            :  * Values written by fw for each Rx packet
<span class="lineNum">    2806 </span>            :  * @IWM_RX_MPDU_RES_STATUS_CRC_OK: CRC is fine
<span class="lineNum">    2807 </span>            :  * @IWM_RX_MPDU_RES_STATUS_OVERRUN_OK: there was no RXE overflow
<span class="lineNum">    2808 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SRC_STA_FOUND:
<span class="lineNum">    2809 </span>            :  * @IWM_RX_MPDU_RES_STATUS_KEY_VALID:
<span class="lineNum">    2810 </span>            :  * @IWM_RX_MPDU_RES_STATUS_KEY_PARAM_OK:
<span class="lineNum">    2811 </span>            :  * @IWM_RX_MPDU_RES_STATUS_ICV_OK: ICV is fine, if not, the packet is destroyed
<span class="lineNum">    2812 </span>            :  * @IWM_RX_MPDU_RES_STATUS_MIC_OK: used for CCM alg only. TKIP MIC is checked
<span class="lineNum">    2813 </span>            :  *      in the driver.
<span class="lineNum">    2814 </span>            :  * @IWM_RX_MPDU_RES_STATUS_TTAK_OK: TTAK is fine
<span class="lineNum">    2815 </span>            :  * @IWM_RX_MPDU_RES_STATUS_MNG_FRAME_REPLAY_ERR:  valid for alg = CCM_CMAC or
<span class="lineNum">    2816 </span>            :  *      alg = CCM only. Checks replay attack for 11w frames. Relevant only if
<span class="lineNum">    2817 </span>            :  *      %IWM_RX_MPDU_RES_STATUS_ROBUST_MNG_FRAME is set.
<span class="lineNum">    2818 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_NO_ENC: this frame is not encrypted
<span class="lineNum">    2819 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_WEP_ENC: this frame is encrypted using WEP
<span class="lineNum">    2820 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_CCM_ENC: this frame is encrypted using CCM
<span class="lineNum">    2821 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_TKIP_ENC: this frame is encrypted using TKIP
<span class="lineNum">    2822 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_CCM_CMAC_ENC: this frame is encrypted using CCM_CMAC
<span class="lineNum">    2823 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_ENC_ERR: this frame couldn't be decrypted
<span class="lineNum">    2824 </span>            :  * @IWM_RX_MPDU_RES_STATUS_SEC_ENC_MSK: bitmask of the encryption algorithm
<span class="lineNum">    2825 </span>            :  * @IWM_RX_MPDU_RES_STATUS_DEC_DONE: this frame has been successfully decrypted
<span class="lineNum">    2826 </span>            :  * @IWM_RX_MPDU_RES_STATUS_PROTECT_FRAME_BIT_CMP:
<span class="lineNum">    2827 </span>            :  * @IWM_RX_MPDU_RES_STATUS_EXT_IV_BIT_CMP:
<span class="lineNum">    2828 </span>            :  * @IWM_RX_MPDU_RES_STATUS_KEY_ID_CMP_BIT:
<span class="lineNum">    2829 </span>            :  * @IWM_RX_MPDU_RES_STATUS_ROBUST_MNG_FRAME: this frame is an 11w management frame
<span class="lineNum">    2830 </span>            :  * @IWM_RX_MPDU_RES_STATUS_HASH_INDEX_MSK:
<span class="lineNum">    2831 </span>            :  * @IWM_RX_MPDU_RES_STATUS_STA_ID_MSK:
<span class="lineNum">    2832 </span>            :  * @IWM_RX_MPDU_RES_STATUS_RRF_KILL:
<span class="lineNum">    2833 </span>            :  * @IWM_RX_MPDU_RES_STATUS_FILTERING_MSK:
<span class="lineNum">    2834 </span>            :  * @IWM_RX_MPDU_RES_STATUS2_FILTERING_MSK:
<span class="lineNum">    2835 </span>            :  */
<span class="lineNum">    2836 </span>            : #define IWM_RX_MPDU_RES_STATUS_CRC_OK                   (1 &lt;&lt; 0)
<span class="lineNum">    2837 </span>            : #define IWM_RX_MPDU_RES_STATUS_OVERRUN_OK               (1 &lt;&lt; 1)
<span class="lineNum">    2838 </span>            : #define IWM_RX_MPDU_RES_STATUS_SRC_STA_FOUND            (1 &lt;&lt; 2)
<span class="lineNum">    2839 </span>            : #define IWM_RX_MPDU_RES_STATUS_KEY_VALID                (1 &lt;&lt; 3)
<span class="lineNum">    2840 </span>            : #define IWM_RX_MPDU_RES_STATUS_KEY_PARAM_OK             (1 &lt;&lt; 4)
<span class="lineNum">    2841 </span>            : #define IWM_RX_MPDU_RES_STATUS_ICV_OK                   (1 &lt;&lt; 5)
<span class="lineNum">    2842 </span>            : #define IWM_RX_MPDU_RES_STATUS_MIC_OK                   (1 &lt;&lt; 6)
<span class="lineNum">    2843 </span>            : #define IWM_RX_MPDU_RES_STATUS_TTAK_OK                  (1 &lt;&lt; 7)
<span class="lineNum">    2844 </span>            : #define IWM_RX_MPDU_RES_STATUS_MNG_FRAME_REPLAY_ERR     (1 &lt;&lt; 7)
<span class="lineNum">    2845 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_NO_ENC               (0 &lt;&lt; 8)
<span class="lineNum">    2846 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_WEP_ENC              (1 &lt;&lt; 8)
<span class="lineNum">    2847 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_CCM_ENC              (2 &lt;&lt; 8)
<span class="lineNum">    2848 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_TKIP_ENC             (3 &lt;&lt; 8)
<span class="lineNum">    2849 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_EXT_ENC              (4 &lt;&lt; 8)
<span class="lineNum">    2850 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_CCM_CMAC_ENC         (6 &lt;&lt; 8)
<span class="lineNum">    2851 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_ENC_ERR              (7 &lt;&lt; 8)
<span class="lineNum">    2852 </span>            : #define IWM_RX_MPDU_RES_STATUS_SEC_ENC_MSK              (7 &lt;&lt; 8)
<span class="lineNum">    2853 </span>            : #define IWM_RX_MPDU_RES_STATUS_DEC_DONE                 (1 &lt;&lt; 11)
<span class="lineNum">    2854 </span>            : #define IWM_RX_MPDU_RES_STATUS_PROTECT_FRAME_BIT_CMP    (1 &lt;&lt; 12)
<span class="lineNum">    2855 </span>            : #define IWM_RX_MPDU_RES_STATUS_EXT_IV_BIT_CMP           (1 &lt;&lt; 13)
<span class="lineNum">    2856 </span>            : #define IWM_RX_MPDU_RES_STATUS_KEY_ID_CMP_BIT           (1 &lt;&lt; 14)
<span class="lineNum">    2857 </span>            : #define IWM_RX_MPDU_RES_STATUS_ROBUST_MNG_FRAME         (1 &lt;&lt; 15)
<span class="lineNum">    2858 </span>            : #define IWM_RX_MPDU_RES_STATUS_HASH_INDEX_MSK           (0x3F0000)
<span class="lineNum">    2859 </span>            : #define IWM_RX_MPDU_RES_STATUS_STA_ID_MSK               (0x1f000000)
<span class="lineNum">    2860 </span>            : #define IWM_RX_MPDU_RES_STATUS_RRF_KILL                 (1 &lt;&lt; 29)
<span class="lineNum">    2861 </span>            : #define IWM_RX_MPDU_RES_STATUS_FILTERING_MSK            (0xc00000)
<span class="lineNum">    2862 </span>            : #define IWM_RX_MPDU_RES_STATUS2_FILTERING_MSK           (0xc0000000)
<span class="lineNum">    2863 </span>            : 
<span class="lineNum">    2864 </span>            : /**
<span class="lineNum">    2865 </span>            :  * struct iwm_radio_version_notif - information on the radio version
<span class="lineNum">    2866 </span>            :  * ( IWM_RADIO_VERSION_NOTIFICATION = 0x68 )
<span class="lineNum">    2867 </span>            :  * @radio_flavor:
<span class="lineNum">    2868 </span>            :  * @radio_step:
<span class="lineNum">    2869 </span>            :  * @radio_dash:
<span class="lineNum">    2870 </span>            :  */
<span class="lineNum">    2871 </span>            : struct iwm_radio_version_notif {
<span class="lineNum">    2872 </span>            :         uint32_t radio_flavor;
<span class="lineNum">    2873 </span>            :         uint32_t radio_step;
<span class="lineNum">    2874 </span>            :         uint32_t radio_dash;
<span class="lineNum">    2875 </span>            : } __packed; /* IWM_RADIO_VERSION_NOTOFICATION_S_VER_1 */
<span class="lineNum">    2876 </span>            : 
<span class="lineNum">    2877 </span>            : #define IWM_CARD_ENABLED                0x00
<span class="lineNum">    2878 </span>            : #define IWM_HW_CARD_DISABLED            0x01
<span class="lineNum">    2879 </span>            : #define IWM_SW_CARD_DISABLED            0x02
<span class="lineNum">    2880 </span>            : #define IWM_CT_KILL_CARD_DISABLED       0x04
<span class="lineNum">    2881 </span>            : #define IWM_HALT_CARD_DISABLED          0x08
<span class="lineNum">    2882 </span>            : #define IWM_CARD_DISABLED_MSK           0x0f
<span class="lineNum">    2883 </span>            : #define IWM_CARD_IS_RX_ON               0x10
<span class="lineNum">    2884 </span>            : 
<span class="lineNum">    2885 </span>            : /**
<span class="lineNum">    2886 </span>            :  * struct iwm_radio_version_notif - information on the radio version
<span class="lineNum">    2887 </span>            :  * (IWM_CARD_STATE_NOTIFICATION = 0xa1 )
<span class="lineNum">    2888 </span>            :  * @flags: %iwm_card_state_flags
<span class="lineNum">    2889 </span>            :  */
<span class="lineNum">    2890 </span>            : struct iwm_card_state_notif {
<span class="lineNum">    2891 </span>            :         uint32_t flags;
<span class="lineNum">    2892 </span>            : } __packed; /* CARD_STATE_NTFY_API_S_VER_1 */
<span class="lineNum">    2893 </span>            : 
<span class="lineNum">    2894 </span>            : /**
<span class="lineNum">    2895 </span>            :  * struct iwm_missed_beacons_notif - information on missed beacons
<span class="lineNum">    2896 </span>            :  * ( IWM_MISSED_BEACONS_NOTIFICATION = 0xa2 )
<span class="lineNum">    2897 </span>            :  * @mac_id: interface ID
<span class="lineNum">    2898 </span>            :  * @consec_missed_beacons_since_last_rx: number of consecutive missed
<span class="lineNum">    2899 </span>            :  *      beacons since last RX.
<span class="lineNum">    2900 </span>            :  * @consec_missed_beacons: number of consecutive missed beacons
<span class="lineNum">    2901 </span>            :  * @num_expected_beacons:
<span class="lineNum">    2902 </span>            :  * @num_recvd_beacons:
<span class="lineNum">    2903 </span>            :  */
<span class="lineNum">    2904 </span>            : struct iwm_missed_beacons_notif {
<span class="lineNum">    2905 </span>            :         uint32_t mac_id;
<span class="lineNum">    2906 </span>            :         uint32_t consec_missed_beacons_since_last_rx;
<span class="lineNum">    2907 </span>            :         uint32_t consec_missed_beacons;
<span class="lineNum">    2908 </span>            :         uint32_t num_expected_beacons;
<span class="lineNum">    2909 </span>            :         uint32_t num_recvd_beacons;
<span class="lineNum">    2910 </span>            : } __packed; /* IWM_MISSED_BEACON_NTFY_API_S_VER_3 */
<span class="lineNum">    2911 </span>            : 
<span class="lineNum">    2912 </span>            : /**
<span class="lineNum">    2913 </span>            :  * struct iwm_mfuart_load_notif - mfuart image version &amp; status
<span class="lineNum">    2914 </span>            :  * ( IWM_MFUART_LOAD_NOTIFICATION = 0xb1 )
<span class="lineNum">    2915 </span>            :  * @installed_ver: installed image version
<span class="lineNum">    2916 </span>            :  * @external_ver: external image version
<span class="lineNum">    2917 </span>            :  * @status: MFUART loading status
<span class="lineNum">    2918 </span>            :  * @duration: MFUART loading time
<span class="lineNum">    2919 </span>            : */
<span class="lineNum">    2920 </span>            : struct iwm_mfuart_load_notif {
<span class="lineNum">    2921 </span>            :         uint32_t installed_ver;
<span class="lineNum">    2922 </span>            :         uint32_t external_ver;
<span class="lineNum">    2923 </span>            :         uint32_t status;
<span class="lineNum">    2924 </span>            :         uint32_t duration;
<span class="lineNum">    2925 </span>            : } __packed; /*MFU_LOADER_NTFY_API_S_VER_1*/
<span class="lineNum">    2926 </span>            : 
<span class="lineNum">    2927 </span>            : /**
<span class="lineNum">    2928 </span>            :  * struct iwm_set_calib_default_cmd - set default value for calibration.
<span class="lineNum">    2929 </span>            :  * ( IWM_SET_CALIB_DEFAULT_CMD = 0x8e )
<span class="lineNum">    2930 </span>            :  * @calib_index: the calibration to set value for
<span class="lineNum">    2931 </span>            :  * @length: of data
<span class="lineNum">    2932 </span>            :  * @data: the value to set for the calibration result
<span class="lineNum">    2933 </span>            :  */
<span class="lineNum">    2934 </span>            : struct iwm_set_calib_default_cmd {
<span class="lineNum">    2935 </span>            :         uint16_t calib_index;
<span class="lineNum">    2936 </span>            :         uint16_t length;
<span class="lineNum">    2937 </span>            :         uint8_t data[0];
<span class="lineNum">    2938 </span>            : } __packed; /* IWM_PHY_CALIB_OVERRIDE_VALUES_S */
<span class="lineNum">    2939 </span>            : 
<span class="lineNum">    2940 </span>            : #define IWM_MAX_PORT_ID_NUM     2
<span class="lineNum">    2941 </span>            : #define IWM_MAX_MCAST_FILTERING_ADDRESSES 256
<span class="lineNum">    2942 </span>            : 
<span class="lineNum">    2943 </span>            : /**
<span class="lineNum">    2944 </span>            :  * struct iwm_mcast_filter_cmd - configure multicast filter.
<span class="lineNum">    2945 </span>            :  * @filter_own: Set 1 to filter out multicast packets sent by station itself
<span class="lineNum">    2946 </span>            :  * @port_id:    Multicast MAC addresses array specifier. This is a strange way
<span class="lineNum">    2947 </span>            :  *              to identify network interface adopted in host-device IF.
<span class="lineNum">    2948 </span>            :  *              It is used by FW as index in array of addresses. This array has
<span class="lineNum">    2949 </span>            :  *              IWM_MAX_PORT_ID_NUM members.
<span class="lineNum">    2950 </span>            :  * @count:      Number of MAC addresses in the array
<span class="lineNum">    2951 </span>            :  * @pass_all:   Set 1 to pass all multicast packets.
<span class="lineNum">    2952 </span>            :  * @bssid:      current association BSSID.
<span class="lineNum">    2953 </span>            :  * @addr_list:  Place holder for array of MAC addresses.
<span class="lineNum">    2954 </span>            :  *              IMPORTANT: add padding if necessary to ensure DWORD alignment.
<span class="lineNum">    2955 </span>            :  */
<span class="lineNum">    2956 </span>            : struct iwm_mcast_filter_cmd {
<span class="lineNum">    2957 </span>            :         uint8_t filter_own;
<span class="lineNum">    2958 </span>            :         uint8_t port_id;
<span class="lineNum">    2959 </span>            :         uint8_t count;
<span class="lineNum">    2960 </span>            :         uint8_t pass_all;
<span class="lineNum">    2961 </span>            :         uint8_t bssid[6];
<span class="lineNum">    2962 </span>            :         uint8_t reserved[2];
<span class="lineNum">    2963 </span>            :         uint8_t addr_list[0];
<span class="lineNum">    2964 </span>            : } __packed; /* IWM_MCAST_FILTERING_CMD_API_S_VER_1 */
<span class="lineNum">    2965 </span>            : 
<span class="lineNum">    2966 </span>            : struct iwm_statistics_dbg {
<span class="lineNum">    2967 </span>            :         uint32_t burst_check;
<span class="lineNum">    2968 </span>            :         uint32_t burst_count;
<span class="lineNum">    2969 </span>            :         uint32_t wait_for_silence_timeout_cnt;
<span class="lineNum">    2970 </span>            :         uint32_t reserved[3];
<span class="lineNum">    2971 </span>            : } __packed; /* IWM_STATISTICS_DEBUG_API_S_VER_2 */
<span class="lineNum">    2972 </span>            : 
<span class="lineNum">    2973 </span>            : struct iwm_statistics_div {
<span class="lineNum">    2974 </span>            :         uint32_t tx_on_a;
<span class="lineNum">    2975 </span>            :         uint32_t tx_on_b;
<span class="lineNum">    2976 </span>            :         uint32_t exec_time;
<span class="lineNum">    2977 </span>            :         uint32_t probe_time;
<span class="lineNum">    2978 </span>            :         uint32_t rssi_ant;
<span class="lineNum">    2979 </span>            :         uint32_t reserved2;
<span class="lineNum">    2980 </span>            : } __packed; /* IWM_STATISTICS_SLOW_DIV_API_S_VER_2 */
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span>            : struct iwm_statistics_general_common {
<span class="lineNum">    2983 </span>            :         uint32_t temperature;   /* radio temperature */
<span class="lineNum">    2984 </span>            :         uint32_t temperature_m; /* radio voltage */
<span class="lineNum">    2985 </span>            :         struct iwm_statistics_dbg dbg;
<span class="lineNum">    2986 </span>            :         uint32_t sleep_time;
<span class="lineNum">    2987 </span>            :         uint32_t slots_out;
<span class="lineNum">    2988 </span>            :         uint32_t slots_idle;
<span class="lineNum">    2989 </span>            :         uint32_t ttl_timestamp;
<span class="lineNum">    2990 </span>            :         struct iwm_statistics_div div;
<span class="lineNum">    2991 </span>            :         uint32_t rx_enable_counter;
<span class="lineNum">    2992 </span>            :         /*
<span class="lineNum">    2993 </span>            :          * num_of_sos_states:
<span class="lineNum">    2994 </span>            :          *  count the number of times we have to re-tune
<span class="lineNum">    2995 </span>            :          *  in order to get out of bad PHY status
<span class="lineNum">    2996 </span>            :          */
<span class="lineNum">    2997 </span>            :         uint32_t num_of_sos_states;
<span class="lineNum">    2998 </span>            : } __packed; /* IWM_STATISTICS_GENERAL_API_S_VER_5 */
<span class="lineNum">    2999 </span>            : 
<span class="lineNum">    3000 </span>            : struct iwm_statistics_rx_non_phy {
<span class="lineNum">    3001 </span>            :         uint32_t bogus_cts;     /* CTS received when not expecting CTS */
<span class="lineNum">    3002 </span>            :         uint32_t bogus_ack;     /* ACK received when not expecting ACK */
<span class="lineNum">    3003 </span>            :         uint32_t non_bssid_frames;      /* number of frames with BSSID that
<span class="lineNum">    3004 </span>            :                                          * doesn't belong to the STA BSSID */
<span class="lineNum">    3005 </span>            :         uint32_t filtered_frames;       /* count frames that were dumped in the
<span class="lineNum">    3006 </span>            :                                  * filtering process */
<span class="lineNum">    3007 </span>            :         uint32_t non_channel_beacons;   /* beacons with our bss id but not on
<span class="lineNum">    3008 </span>            :                                          * our serving channel */
<span class="lineNum">    3009 </span>            :         uint32_t channel_beacons;       /* beacons with our bss id and in our
<span class="lineNum">    3010 </span>            :                                  * serving channel */
<span class="lineNum">    3011 </span>            :         uint32_t num_missed_bcon;       /* number of missed beacons */
<span class="lineNum">    3012 </span>            :         uint32_t adc_rx_saturation_time;        /* count in 0.8us units the time the
<span class="lineNum">    3013 </span>            :                                          * ADC was in saturation */
<span class="lineNum">    3014 </span>            :         uint32_t ina_detection_search_time;/* total time (in 0.8us) searched
<span class="lineNum">    3015 </span>            :                                           * for INA */
<span class="lineNum">    3016 </span>            :         uint32_t beacon_silence_rssi[3];/* RSSI silence after beacon frame */
<span class="lineNum">    3017 </span>            :         uint32_t interference_data_flag;        /* flag for interference data
<span class="lineNum">    3018 </span>            :                                          * availability. 1 when data is
<span class="lineNum">    3019 </span>            :                                          * available. */
<span class="lineNum">    3020 </span>            :         uint32_t channel_load;          /* counts RX Enable time in uSec */
<span class="lineNum">    3021 </span>            :         uint32_t dsp_false_alarms;      /* DSP false alarm (both OFDM
<span class="lineNum">    3022 </span>            :                                          * and CCK) counter */
<span class="lineNum">    3023 </span>            :         uint32_t beacon_rssi_a;
<span class="lineNum">    3024 </span>            :         uint32_t beacon_rssi_b;
<span class="lineNum">    3025 </span>            :         uint32_t beacon_rssi_c;
<span class="lineNum">    3026 </span>            :         uint32_t beacon_energy_a;
<span class="lineNum">    3027 </span>            :         uint32_t beacon_energy_b;
<span class="lineNum">    3028 </span>            :         uint32_t beacon_energy_c;
<span class="lineNum">    3029 </span>            :         uint32_t num_bt_kills;
<span class="lineNum">    3030 </span>            :         uint32_t mac_id;
<span class="lineNum">    3031 </span>            :         uint32_t directed_data_mpdu;
<span class="lineNum">    3032 </span>            : } __packed; /* IWM_STATISTICS_RX_NON_PHY_API_S_VER_3 */
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span>            : struct iwm_statistics_rx_phy {
<span class="lineNum">    3035 </span>            :         uint32_t ina_cnt;
<span class="lineNum">    3036 </span>            :         uint32_t fina_cnt;
<span class="lineNum">    3037 </span>            :         uint32_t plcp_err;
<span class="lineNum">    3038 </span>            :         uint32_t crc32_err;
<span class="lineNum">    3039 </span>            :         uint32_t overrun_err;
<span class="lineNum">    3040 </span>            :         uint32_t early_overrun_err;
<span class="lineNum">    3041 </span>            :         uint32_t crc32_good;
<span class="lineNum">    3042 </span>            :         uint32_t false_alarm_cnt;
<span class="lineNum">    3043 </span>            :         uint32_t fina_sync_err_cnt;
<span class="lineNum">    3044 </span>            :         uint32_t sfd_timeout;
<span class="lineNum">    3045 </span>            :         uint32_t fina_timeout;
<span class="lineNum">    3046 </span>            :         uint32_t unresponded_rts;
<span class="lineNum">    3047 </span>            :         uint32_t rxe_frame_limit_overrun;
<span class="lineNum">    3048 </span>            :         uint32_t sent_ack_cnt;
<span class="lineNum">    3049 </span>            :         uint32_t sent_cts_cnt;
<span class="lineNum">    3050 </span>            :         uint32_t sent_ba_rsp_cnt;
<span class="lineNum">    3051 </span>            :         uint32_t dsp_self_kill;
<span class="lineNum">    3052 </span>            :         uint32_t mh_format_err;
<span class="lineNum">    3053 </span>            :         uint32_t re_acq_main_rssi_sum;
<span class="lineNum">    3054 </span>            :         uint32_t reserved;
<span class="lineNum">    3055 </span>            : } __packed; /* IWM_STATISTICS_RX_PHY_API_S_VER_2 */
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span>            : struct iwm_statistics_rx_ht_phy {
<span class="lineNum">    3058 </span>            :         uint32_t plcp_err;
<span class="lineNum">    3059 </span>            :         uint32_t overrun_err;
<span class="lineNum">    3060 </span>            :         uint32_t early_overrun_err;
<span class="lineNum">    3061 </span>            :         uint32_t crc32_good;
<span class="lineNum">    3062 </span>            :         uint32_t crc32_err;
<span class="lineNum">    3063 </span>            :         uint32_t mh_format_err;
<span class="lineNum">    3064 </span>            :         uint32_t agg_crc32_good;
<span class="lineNum">    3065 </span>            :         uint32_t agg_mpdu_cnt;
<span class="lineNum">    3066 </span>            :         uint32_t agg_cnt;
<span class="lineNum">    3067 </span>            :         uint32_t unsupport_mcs;
<span class="lineNum">    3068 </span>            : } __packed;  /* IWM_STATISTICS_HT_RX_PHY_API_S_VER_1 */
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span>            : #define IWM_MAX_CHAINS 3
<span class="lineNum">    3071 </span>            : 
<span class="lineNum">    3072 </span>            : struct iwm_statistics_tx_non_phy_agg {
<span class="lineNum">    3073 </span>            :         uint32_t ba_timeout;
<span class="lineNum">    3074 </span>            :         uint32_t ba_reschedule_frames;
<span class="lineNum">    3075 </span>            :         uint32_t scd_query_agg_frame_cnt;
<span class="lineNum">    3076 </span>            :         uint32_t scd_query_no_agg;
<span class="lineNum">    3077 </span>            :         uint32_t scd_query_agg;
<span class="lineNum">    3078 </span>            :         uint32_t scd_query_mismatch;
<span class="lineNum">    3079 </span>            :         uint32_t frame_not_ready;
<span class="lineNum">    3080 </span>            :         uint32_t underrun;
<span class="lineNum">    3081 </span>            :         uint32_t bt_prio_kill;
<span class="lineNum">    3082 </span>            :         uint32_t rx_ba_rsp_cnt;
<span class="lineNum">    3083 </span>            :         int8_t txpower[IWM_MAX_CHAINS];
<span class="lineNum">    3084 </span>            :         int8_t reserved;
<span class="lineNum">    3085 </span>            :         uint32_t reserved2;
<span class="lineNum">    3086 </span>            : } __packed; /* IWM_STATISTICS_TX_NON_PHY_AGG_API_S_VER_1 */
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span>            : struct iwm_statistics_tx_channel_width {
<span class="lineNum">    3089 </span>            :         uint32_t ext_cca_narrow_ch20[1];
<span class="lineNum">    3090 </span>            :         uint32_t ext_cca_narrow_ch40[2];
<span class="lineNum">    3091 </span>            :         uint32_t ext_cca_narrow_ch80[3];
<span class="lineNum">    3092 </span>            :         uint32_t ext_cca_narrow_ch160[4];
<span class="lineNum">    3093 </span>            :         uint32_t last_tx_ch_width_indx;
<span class="lineNum">    3094 </span>            :         uint32_t rx_detected_per_ch_width[4];
<span class="lineNum">    3095 </span>            :         uint32_t success_per_ch_width[4];
<span class="lineNum">    3096 </span>            :         uint32_t fail_per_ch_width[4];
<span class="lineNum">    3097 </span>            : }; /* IWM_STATISTICS_TX_CHANNEL_WIDTH_API_S_VER_1 */
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span>            : struct iwm_statistics_tx {
<span class="lineNum">    3100 </span>            :         uint32_t preamble_cnt;
<span class="lineNum">    3101 </span>            :         uint32_t rx_detected_cnt;
<span class="lineNum">    3102 </span>            :         uint32_t bt_prio_defer_cnt;
<span class="lineNum">    3103 </span>            :         uint32_t bt_prio_kill_cnt;
<span class="lineNum">    3104 </span>            :         uint32_t few_bytes_cnt;
<span class="lineNum">    3105 </span>            :         uint32_t cts_timeout;
<span class="lineNum">    3106 </span>            :         uint32_t ack_timeout;
<span class="lineNum">    3107 </span>            :         uint32_t expected_ack_cnt;
<span class="lineNum">    3108 </span>            :         uint32_t actual_ack_cnt;
<span class="lineNum">    3109 </span>            :         uint32_t dump_msdu_cnt;
<span class="lineNum">    3110 </span>            :         uint32_t burst_abort_next_frame_mismatch_cnt;
<span class="lineNum">    3111 </span>            :         uint32_t burst_abort_missing_next_frame_cnt;
<span class="lineNum">    3112 </span>            :         uint32_t cts_timeout_collision;
<span class="lineNum">    3113 </span>            :         uint32_t ack_or_ba_timeout_collision;
<span class="lineNum">    3114 </span>            :         struct iwm_statistics_tx_non_phy_agg agg;
<span class="lineNum">    3115 </span>            :         struct iwm_statistics_tx_channel_width channel_width;
<span class="lineNum">    3116 </span>            : } __packed; /* IWM_STATISTICS_TX_API_S_VER_4 */
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span>            : 
<span class="lineNum">    3119 </span>            : struct iwm_statistics_bt_activity {
<span class="lineNum">    3120 </span>            :         uint32_t hi_priority_tx_req_cnt;
<span class="lineNum">    3121 </span>            :         uint32_t hi_priority_tx_denied_cnt;
<span class="lineNum">    3122 </span>            :         uint32_t lo_priority_tx_req_cnt;
<span class="lineNum">    3123 </span>            :         uint32_t lo_priority_tx_denied_cnt;
<span class="lineNum">    3124 </span>            :         uint32_t hi_priority_rx_req_cnt;
<span class="lineNum">    3125 </span>            :         uint32_t hi_priority_rx_denied_cnt;
<span class="lineNum">    3126 </span>            :         uint32_t lo_priority_rx_req_cnt;
<span class="lineNum">    3127 </span>            :         uint32_t lo_priority_rx_denied_cnt;
<span class="lineNum">    3128 </span>            : } __packed;  /* IWM_STATISTICS_BT_ACTIVITY_API_S_VER_1 */
<span class="lineNum">    3129 </span>            : 
<span class="lineNum">    3130 </span>            : struct iwm_statistics_general {
<span class="lineNum">    3131 </span>            :         struct iwm_statistics_general_common common;
<span class="lineNum">    3132 </span>            :         uint32_t beacon_filtered;
<span class="lineNum">    3133 </span>            :         uint32_t missed_beacons;
<span class="lineNum">    3134 </span>            :         int8_t beacon_filter_average_energy;
<span class="lineNum">    3135 </span>            :         int8_t beacon_filter_reason;
<span class="lineNum">    3136 </span>            :         int8_t beacon_filter_current_energy;
<span class="lineNum">    3137 </span>            :         int8_t beacon_filter_reserved;
<span class="lineNum">    3138 </span>            :         uint32_t beacon_filter_delta_time;
<span class="lineNum">    3139 </span>            :         struct iwm_statistics_bt_activity bt_activity;
<span class="lineNum">    3140 </span>            : } __packed; /* IWM_STATISTICS_GENERAL_API_S_VER_5 */
<span class="lineNum">    3141 </span>            : 
<span class="lineNum">    3142 </span>            : struct iwm_statistics_rx {
<span class="lineNum">    3143 </span>            :         struct iwm_statistics_rx_phy ofdm;
<span class="lineNum">    3144 </span>            :         struct iwm_statistics_rx_phy cck;
<span class="lineNum">    3145 </span>            :         struct iwm_statistics_rx_non_phy general;
<span class="lineNum">    3146 </span>            :         struct iwm_statistics_rx_ht_phy ofdm_ht;
<span class="lineNum">    3147 </span>            : } __packed; /* IWM_STATISTICS_RX_API_S_VER_3 */
<span class="lineNum">    3148 </span>            : 
<span class="lineNum">    3149 </span>            : /*
<span class="lineNum">    3150 </span>            :  * IWM_STATISTICS_NOTIFICATION = 0x9d (notification only, not a command)
<span class="lineNum">    3151 </span>            :  *
<span class="lineNum">    3152 </span>            :  * By default, uCode issues this notification after receiving a beacon
<span class="lineNum">    3153 </span>            :  * while associated.  To disable this behavior, set DISABLE_NOTIF flag in the
<span class="lineNum">    3154 </span>            :  * IWM_REPLY_STATISTICS_CMD 0x9c, above.
<span class="lineNum">    3155 </span>            :  *
<span class="lineNum">    3156 </span>            :  * Statistics counters continue to increment beacon after beacon, but are
<span class="lineNum">    3157 </span>            :  * cleared when changing channels or when driver issues IWM_REPLY_STATISTICS_CMD
<span class="lineNum">    3158 </span>            :  * 0x9c with CLEAR_STATS bit set (see above).
<span class="lineNum">    3159 </span>            :  *
<span class="lineNum">    3160 </span>            :  * uCode also issues this notification during scans.  uCode clears statistics
<span class="lineNum">    3161 </span>            :  * appropriately so that each notification contains statistics for only the
<span class="lineNum">    3162 </span>            :  * one channel that has just been scanned.
<span class="lineNum">    3163 </span>            :  */
<span class="lineNum">    3164 </span>            : 
<span class="lineNum">    3165 </span>            : struct iwm_notif_statistics { /* IWM_STATISTICS_NTFY_API_S_VER_8 */
<span class="lineNum">    3166 </span>            :         uint32_t flag;
<span class="lineNum">    3167 </span>            :         struct iwm_statistics_rx rx;
<span class="lineNum">    3168 </span>            :         struct iwm_statistics_tx tx;
<span class="lineNum">    3169 </span>            :         struct iwm_statistics_general general;
<span class="lineNum">    3170 </span>            : } __packed;
<span class="lineNum">    3171 </span>            : 
<span class="lineNum">    3172 </span>            : /***********************************
<span class="lineNum">    3173 </span>            :  * Smart Fifo API
<span class="lineNum">    3174 </span>            :  ***********************************/
<span class="lineNum">    3175 </span>            : /* Smart Fifo state */
<span class="lineNum">    3176 </span>            : #define IWM_SF_LONG_DELAY_ON    0 /* should never be called by driver */
<span class="lineNum">    3177 </span>            : #define IWM_SF_FULL_ON          1
<span class="lineNum">    3178 </span>            : #define IWM_SF_UNINIT           2
<span class="lineNum">    3179 </span>            : #define IWM_SF_INIT_OFF         3
<span class="lineNum">    3180 </span>            : #define IWM_SF_HW_NUM_STATES    4
<span class="lineNum">    3181 </span>            : 
<span class="lineNum">    3182 </span>            : /* Smart Fifo possible scenario */
<span class="lineNum">    3183 </span>            : #define IWM_SF_SCENARIO_SINGLE_UNICAST  0
<span class="lineNum">    3184 </span>            : #define IWM_SF_SCENARIO_AGG_UNICAST     1
<span class="lineNum">    3185 </span>            : #define IWM_SF_SCENARIO_MULTICAST       2
<span class="lineNum">    3186 </span>            : #define IWM_SF_SCENARIO_BA_RESP         3
<span class="lineNum">    3187 </span>            : #define IWM_SF_SCENARIO_TX_RESP         4
<span class="lineNum">    3188 </span>            : #define IWM_SF_NUM_SCENARIO             5
<span class="lineNum">    3189 </span>            : 
<span class="lineNum">    3190 </span>            : #define IWM_SF_TRANSIENT_STATES_NUMBER 2 /* IWM_SF_LONG_DELAY_ON and IWM_SF_FULL_ON */
<span class="lineNum">    3191 </span>            : #define IWM_SF_NUM_TIMEOUT_TYPES 2      /* Aging timer and Idle timer */
<span class="lineNum">    3192 </span>            : 
<span class="lineNum">    3193 </span>            : /* smart FIFO default values */
<span class="lineNum">    3194 </span>            : #define IWM_SF_W_MARK_SISO 4096
<span class="lineNum">    3195 </span>            : #define IWM_SF_W_MARK_MIMO2 8192
<span class="lineNum">    3196 </span>            : #define IWM_SF_W_MARK_MIMO3 6144
<span class="lineNum">    3197 </span>            : #define IWM_SF_W_MARK_LEGACY 4096
<span class="lineNum">    3198 </span>            : #define IWM_SF_W_MARK_SCAN 4096
<span class="lineNum">    3199 </span>            : 
<span class="lineNum">    3200 </span>            : /* SF Scenarios timers for default configuration (aligned to 32 uSec) */
<span class="lineNum">    3201 </span>            : #define IWM_SF_SINGLE_UNICAST_IDLE_TIMER_DEF 160        /* 150 uSec  */
<span class="lineNum">    3202 </span>            : #define IWM_SF_SINGLE_UNICAST_AGING_TIMER_DEF 400       /* 0.4 mSec */
<span class="lineNum">    3203 </span>            : #define IWM_SF_AGG_UNICAST_IDLE_TIMER_DEF 160           /* 150 uSec */
<span class="lineNum">    3204 </span>            : #define IWM_SF_AGG_UNICAST_AGING_TIMER_DEF 400          /* 0.4 mSec */
<span class="lineNum">    3205 </span>            : #define IWM_SF_MCAST_IDLE_TIMER_DEF 160                 /* 150 mSec */
<span class="lineNum">    3206 </span>            : #define IWM_SF_MCAST_AGING_TIMER_DEF 400                /* 0.4 mSec */
<span class="lineNum">    3207 </span>            : #define IWM_SF_BA_IDLE_TIMER_DEF 160                    /* 150 uSec */
<span class="lineNum">    3208 </span>            : #define IWM_SF_BA_AGING_TIMER_DEF 400                   /* 0.4 mSec */
<span class="lineNum">    3209 </span>            : #define IWM_SF_TX_RE_IDLE_TIMER_DEF 160                 /* 150 uSec */
<span class="lineNum">    3210 </span>            : #define IWM_SF_TX_RE_AGING_TIMER_DEF 400                /* 0.4 mSec */
<span class="lineNum">    3211 </span>            : 
<span class="lineNum">    3212 </span>            : /* SF Scenarios timers for FULL_ON state (aligned to 32 uSec) */
<span class="lineNum">    3213 </span>            : #define IWM_SF_SINGLE_UNICAST_IDLE_TIMER 320    /* 300 uSec  */
<span class="lineNum">    3214 </span>            : #define IWM_SF_SINGLE_UNICAST_AGING_TIMER 2016  /* 2 mSec */
<span class="lineNum">    3215 </span>            : #define IWM_SF_AGG_UNICAST_IDLE_TIMER 320       /* 300 uSec */
<span class="lineNum">    3216 </span>            : #define IWM_SF_AGG_UNICAST_AGING_TIMER 2016     /* 2 mSec */
<span class="lineNum">    3217 </span>            : #define IWM_SF_MCAST_IDLE_TIMER 2016            /* 2 mSec */
<span class="lineNum">    3218 </span>            : #define IWM_SF_MCAST_AGING_TIMER 10016          /* 10 mSec */
<span class="lineNum">    3219 </span>            : #define IWM_SF_BA_IDLE_TIMER 320                /* 300 uSec */
<span class="lineNum">    3220 </span>            : #define IWM_SF_BA_AGING_TIMER 2016              /* 2 mSec */
<span class="lineNum">    3221 </span>            : #define IWM_SF_TX_RE_IDLE_TIMER 320             /* 300 uSec */
<span class="lineNum">    3222 </span>            : #define IWM_SF_TX_RE_AGING_TIMER 2016           /* 2 mSec */
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span>            : #define IWM_SF_LONG_DELAY_AGING_TIMER 1000000   /* 1 Sec */
<span class="lineNum">    3225 </span>            : 
<span class="lineNum">    3226 </span>            : #define IWM_SF_CFG_DUMMY_NOTIF_OFF      (1 &lt;&lt; 16)
<span class="lineNum">    3227 </span>            : 
<span class="lineNum">    3228 </span>            : /**
<span class="lineNum">    3229 </span>            :  * Smart Fifo configuration command.
<span class="lineNum">    3230 </span>            :  * @state: smart fifo state, types listed in enum %iwm_sf_state.
<span class="lineNum">    3231 </span>            :  * @watermark: Minimum allowed availabe free space in RXF for transient state.
<span class="lineNum">    3232 </span>            :  * @long_delay_timeouts: aging and idle timer values for each scenario
<span class="lineNum">    3233 </span>            :  * in long delay state.
<span class="lineNum">    3234 </span>            :  * @full_on_timeouts: timer values for each scenario in full on state.
<span class="lineNum">    3235 </span>            :  */
<span class="lineNum">    3236 </span>            : struct iwm_sf_cfg_cmd {
<span class="lineNum">    3237 </span>            :         uint32_t state;
<span class="lineNum">    3238 </span>            :         uint32_t watermark[IWM_SF_TRANSIENT_STATES_NUMBER];
<span class="lineNum">    3239 </span>            :         uint32_t long_delay_timeouts[IWM_SF_NUM_SCENARIO][IWM_SF_NUM_TIMEOUT_TYPES];
<span class="lineNum">    3240 </span>            :         uint32_t full_on_timeouts[IWM_SF_NUM_SCENARIO][IWM_SF_NUM_TIMEOUT_TYPES];
<span class="lineNum">    3241 </span>            : } __packed; /* IWM_SF_CFG_API_S_VER_2 */
<span class="lineNum">    3242 </span>            : 
<span class="lineNum">    3243 </span>            : /*
<span class="lineNum">    3244 </span>            :  * The first MAC indices (starting from 0)
<span class="lineNum">    3245 </span>            :  * are available to the driver, AUX follows
<span class="lineNum">    3246 </span>            :  */
<span class="lineNum">    3247 </span>            : #define IWM_MAC_INDEX_AUX               4
<span class="lineNum">    3248 </span>            : #define IWM_MAC_INDEX_MIN_DRIVER        0
<span class="lineNum">    3249 </span>            : #define IWM_NUM_MAC_INDEX_DRIVER        IWM_MAC_INDEX_AUX
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span>            : #define IWM_AC_BK       0
<span class="lineNum">    3252 </span>            : #define IWM_AC_BE       1
<span class="lineNum">    3253 </span>            : #define IWM_AC_VI       2
<span class="lineNum">    3254 </span>            : #define IWM_AC_VO       3
<span class="lineNum">    3255 </span>            : #define IWM_AC_NUM      4
<span class="lineNum">    3256 </span>            : 
<span class="lineNum">    3257 </span>            : /**
<span class="lineNum">    3258 </span>            :  * MAC context flags
<span class="lineNum">    3259 </span>            :  * @IWM_MAC_PROT_FLG_TGG_PROTECT: 11g protection when transmitting OFDM frames,
<span class="lineNum">    3260 </span>            :  *      this will require CCK RTS/CTS2self.
<span class="lineNum">    3261 </span>            :  *      RTS/CTS will protect full burst time.
<span class="lineNum">    3262 </span>            :  * @IWM_MAC_PROT_FLG_HT_PROT: enable HT protection
<span class="lineNum">    3263 </span>            :  * @IWM_MAC_PROT_FLG_FAT_PROT: protect 40 MHz transmissions
<span class="lineNum">    3264 </span>            :  * @IWM_MAC_PROT_FLG_SELF_CTS_EN: allow CTS2self
<span class="lineNum">    3265 </span>            :  */
<span class="lineNum">    3266 </span>            : #define IWM_MAC_PROT_FLG_TGG_PROTECT    (1 &lt;&lt; 3)
<span class="lineNum">    3267 </span>            : #define IWM_MAC_PROT_FLG_HT_PROT        (1 &lt;&lt; 23)
<span class="lineNum">    3268 </span>            : #define IWM_MAC_PROT_FLG_FAT_PROT       (1 &lt;&lt; 24)
<span class="lineNum">    3269 </span>            : #define IWM_MAC_PROT_FLG_SELF_CTS_EN    (1 &lt;&lt; 30)
<span class="lineNum">    3270 </span>            : 
<span class="lineNum">    3271 </span>            : #define IWM_MAC_FLG_SHORT_SLOT          (1 &lt;&lt; 4)
<span class="lineNum">    3272 </span>            : #define IWM_MAC_FLG_SHORT_PREAMBLE      (1 &lt;&lt; 5)
<span class="lineNum">    3273 </span>            : 
<span class="lineNum">    3274 </span>            : /**
<span class="lineNum">    3275 </span>            :  * Supported MAC types
<span class="lineNum">    3276 </span>            :  * @IWM_FW_MAC_TYPE_FIRST: lowest supported MAC type
<span class="lineNum">    3277 </span>            :  * @IWM_FW_MAC_TYPE_AUX: Auxiliary MAC (internal)
<span class="lineNum">    3278 </span>            :  * @IWM_FW_MAC_TYPE_LISTENER: monitor MAC type (?)
<span class="lineNum">    3279 </span>            :  * @IWM_FW_MAC_TYPE_PIBSS: Pseudo-IBSS
<span class="lineNum">    3280 </span>            :  * @IWM_FW_MAC_TYPE_IBSS: IBSS
<span class="lineNum">    3281 </span>            :  * @IWM_FW_MAC_TYPE_BSS_STA: BSS (managed) station
<span class="lineNum">    3282 </span>            :  * @IWM_FW_MAC_TYPE_P2P_DEVICE: P2P Device
<span class="lineNum">    3283 </span>            :  * @IWM_FW_MAC_TYPE_P2P_STA: P2P client
<span class="lineNum">    3284 </span>            :  * @IWM_FW_MAC_TYPE_GO: P2P GO
<span class="lineNum">    3285 </span>            :  * @IWM_FW_MAC_TYPE_TEST: ?
<span class="lineNum">    3286 </span>            :  * @IWM_FW_MAC_TYPE_MAX: highest support MAC type
<span class="lineNum">    3287 </span>            :  */
<span class="lineNum">    3288 </span>            : #define IWM_FW_MAC_TYPE_FIRST           1
<span class="lineNum">    3289 </span>            : #define IWM_FW_MAC_TYPE_AUX             IWM_FW_MAC_TYPE_FIRST
<span class="lineNum">    3290 </span>            : #define IWM_FW_MAC_TYPE_LISTENER        2
<span class="lineNum">    3291 </span>            : #define IWM_FW_MAC_TYPE_PIBSS           3
<span class="lineNum">    3292 </span>            : #define IWM_FW_MAC_TYPE_IBSS            4
<span class="lineNum">    3293 </span>            : #define IWM_FW_MAC_TYPE_BSS_STA         5
<span class="lineNum">    3294 </span>            : #define IWM_FW_MAC_TYPE_P2P_DEVICE      6
<span class="lineNum">    3295 </span>            : #define IWM_FW_MAC_TYPE_P2P_STA         7
<span class="lineNum">    3296 </span>            : #define IWM_FW_MAC_TYPE_GO              8
<span class="lineNum">    3297 </span>            : #define IWM_FW_MAC_TYPE_TEST            9
<span class="lineNum">    3298 </span>            : #define IWM_FW_MAC_TYPE_MAX             IWM_FW_MAC_TYPE_TEST
<span class="lineNum">    3299 </span>            : /* IWM_MAC_CONTEXT_TYPE_API_E_VER_1 */
<span class="lineNum">    3300 </span>            : 
<span class="lineNum">    3301 </span>            : /**
<span class="lineNum">    3302 </span>            :  * TSF hw timer ID
<span class="lineNum">    3303 </span>            :  * @IWM_TSF_ID_A: use TSF A
<span class="lineNum">    3304 </span>            :  * @IWM_TSF_ID_B: use TSF B
<span class="lineNum">    3305 </span>            :  * @IWM_TSF_ID_C: use TSF C
<span class="lineNum">    3306 </span>            :  * @IWM_TSF_ID_D: use TSF D
<span class="lineNum">    3307 </span>            :  * @IWM_NUM_TSF_IDS: number of TSF timers available
<span class="lineNum">    3308 </span>            :  */
<span class="lineNum">    3309 </span>            : #define IWM_TSF_ID_A    0
<span class="lineNum">    3310 </span>            : #define IWM_TSF_ID_B    1
<span class="lineNum">    3311 </span>            : #define IWM_TSF_ID_C    2
<span class="lineNum">    3312 </span>            : #define IWM_TSF_ID_D    3
<span class="lineNum">    3313 </span>            : #define IWM_NUM_TSF_IDS 4
<span class="lineNum">    3314 </span>            : /* IWM_TSF_ID_API_E_VER_1 */
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span>            : /**
<span class="lineNum">    3317 </span>            :  * struct iwm_mac_data_ap - configuration data for AP MAC context
<span class="lineNum">    3318 </span>            :  * @beacon_time: beacon transmit time in system time
<span class="lineNum">    3319 </span>            :  * @beacon_tsf: beacon transmit time in TSF
<span class="lineNum">    3320 </span>            :  * @bi: beacon interval in TU
<span class="lineNum">    3321 </span>            :  * @bi_reciprocal: 2^32 / bi
<span class="lineNum">    3322 </span>            :  * @dtim_interval: dtim transmit time in TU
<span class="lineNum">    3323 </span>            :  * @dtim_reciprocal: 2^32 / dtim_interval
<span class="lineNum">    3324 </span>            :  * @mcast_qid: queue ID for multicast traffic
<span class="lineNum">    3325 </span>            :  * @beacon_template: beacon template ID
<span class="lineNum">    3326 </span>            :  */
<span class="lineNum">    3327 </span>            : struct iwm_mac_data_ap {
<span class="lineNum">    3328 </span>            :         uint32_t beacon_time;
<span class="lineNum">    3329 </span>            :         uint64_t beacon_tsf;
<span class="lineNum">    3330 </span>            :         uint32_t bi;
<span class="lineNum">    3331 </span>            :         uint32_t bi_reciprocal;
<span class="lineNum">    3332 </span>            :         uint32_t dtim_interval;
<span class="lineNum">    3333 </span>            :         uint32_t dtim_reciprocal;
<span class="lineNum">    3334 </span>            :         uint32_t mcast_qid;
<span class="lineNum">    3335 </span>            :         uint32_t beacon_template;
<span class="lineNum">    3336 </span>            : } __packed; /* AP_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3337 </span>            : 
<span class="lineNum">    3338 </span>            : /**
<span class="lineNum">    3339 </span>            :  * struct iwm_mac_data_ibss - configuration data for IBSS MAC context
<span class="lineNum">    3340 </span>            :  * @beacon_time: beacon transmit time in system time
<span class="lineNum">    3341 </span>            :  * @beacon_tsf: beacon transmit time in TSF
<span class="lineNum">    3342 </span>            :  * @bi: beacon interval in TU
<span class="lineNum">    3343 </span>            :  * @bi_reciprocal: 2^32 / bi
<span class="lineNum">    3344 </span>            :  * @beacon_template: beacon template ID
<span class="lineNum">    3345 </span>            :  */
<span class="lineNum">    3346 </span>            : struct iwm_mac_data_ibss {
<span class="lineNum">    3347 </span>            :         uint32_t beacon_time;
<span class="lineNum">    3348 </span>            :         uint64_t beacon_tsf;
<span class="lineNum">    3349 </span>            :         uint32_t bi;
<span class="lineNum">    3350 </span>            :         uint32_t bi_reciprocal;
<span class="lineNum">    3351 </span>            :         uint32_t beacon_template;
<span class="lineNum">    3352 </span>            : } __packed; /* IBSS_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3353 </span>            : 
<span class="lineNum">    3354 </span>            : /**
<span class="lineNum">    3355 </span>            :  * struct iwm_mac_data_sta - configuration data for station MAC context
<span class="lineNum">    3356 </span>            :  * @is_assoc: 1 for associated state, 0 otherwise
<span class="lineNum">    3357 </span>            :  * @dtim_time: DTIM arrival time in system time
<span class="lineNum">    3358 </span>            :  * @dtim_tsf: DTIM arrival time in TSF
<span class="lineNum">    3359 </span>            :  * @bi: beacon interval in TU, applicable only when associated
<span class="lineNum">    3360 </span>            :  * @bi_reciprocal: 2^32 / bi , applicable only when associated
<span class="lineNum">    3361 </span>            :  * @dtim_interval: DTIM interval in TU, applicable only when associated
<span class="lineNum">    3362 </span>            :  * @dtim_reciprocal: 2^32 / dtim_interval , applicable only when associated
<span class="lineNum">    3363 </span>            :  * @listen_interval: in beacon intervals, applicable only when associated
<span class="lineNum">    3364 </span>            :  * @assoc_id: unique ID assigned by the AP during association
<span class="lineNum">    3365 </span>            :  */
<span class="lineNum">    3366 </span>            : struct iwm_mac_data_sta {
<span class="lineNum">    3367 </span>            :         uint32_t is_assoc;
<span class="lineNum">    3368 </span>            :         uint32_t dtim_time;
<span class="lineNum">    3369 </span>            :         uint64_t dtim_tsf;
<span class="lineNum">    3370 </span>            :         uint32_t bi;
<span class="lineNum">    3371 </span>            :         uint32_t bi_reciprocal;
<span class="lineNum">    3372 </span>            :         uint32_t dtim_interval;
<span class="lineNum">    3373 </span>            :         uint32_t dtim_reciprocal;
<span class="lineNum">    3374 </span>            :         uint32_t listen_interval;
<span class="lineNum">    3375 </span>            :         uint32_t assoc_id;
<span class="lineNum">    3376 </span>            :         uint32_t assoc_beacon_arrive_time;
<span class="lineNum">    3377 </span>            : } __packed; /* IWM_STA_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3378 </span>            : 
<span class="lineNum">    3379 </span>            : /**
<span class="lineNum">    3380 </span>            :  * struct iwm_mac_data_go - configuration data for P2P GO MAC context
<span class="lineNum">    3381 </span>            :  * @ap: iwm_mac_data_ap struct with most config data
<span class="lineNum">    3382 </span>            :  * @ctwin: client traffic window in TU (period after TBTT when GO is present).
<span class="lineNum">    3383 </span>            :  *      0 indicates that there is no CT window.
<span class="lineNum">    3384 </span>            :  * @opp_ps_enabled: indicate that opportunistic PS allowed
<span class="lineNum">    3385 </span>            :  */
<span class="lineNum">    3386 </span>            : struct iwm_mac_data_go {
<span class="lineNum">    3387 </span>            :         struct iwm_mac_data_ap ap;
<span class="lineNum">    3388 </span>            :         uint32_t ctwin;
<span class="lineNum">    3389 </span>            :         uint32_t opp_ps_enabled;
<span class="lineNum">    3390 </span>            : } __packed; /* GO_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span>            : /**
<span class="lineNum">    3393 </span>            :  * struct iwm_mac_data_p2p_sta - configuration data for P2P client MAC context
<span class="lineNum">    3394 </span>            :  * @sta: iwm_mac_data_sta struct with most config data
<span class="lineNum">    3395 </span>            :  * @ctwin: client traffic window in TU (period after TBTT when GO is present).
<span class="lineNum">    3396 </span>            :  *      0 indicates that there is no CT window.
<span class="lineNum">    3397 </span>            :  */
<span class="lineNum">    3398 </span>            : struct iwm_mac_data_p2p_sta {
<span class="lineNum">    3399 </span>            :         struct iwm_mac_data_sta sta;
<span class="lineNum">    3400 </span>            :         uint32_t ctwin;
<span class="lineNum">    3401 </span>            : } __packed; /* P2P_STA_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3402 </span>            : 
<span class="lineNum">    3403 </span>            : /**
<span class="lineNum">    3404 </span>            :  * struct iwm_mac_data_pibss - Pseudo IBSS config data
<span class="lineNum">    3405 </span>            :  * @stats_interval: interval in TU between statistics notifications to host.
<span class="lineNum">    3406 </span>            :  */
<span class="lineNum">    3407 </span>            : struct iwm_mac_data_pibss {
<span class="lineNum">    3408 </span>            :         uint32_t stats_interval;
<span class="lineNum">    3409 </span>            : } __packed; /* PIBSS_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3410 </span>            : 
<span class="lineNum">    3411 </span>            : /*
<span class="lineNum">    3412 </span>            :  * struct iwm_mac_data_p2p_dev - configuration data for the P2P Device MAC
<span class="lineNum">    3413 </span>            :  * context.
<span class="lineNum">    3414 </span>            :  * @is_disc_extended: if set to true, P2P Device discoverability is enabled on
<span class="lineNum">    3415 </span>            :  *      other channels as well. This should be to true only in case that the
<span class="lineNum">    3416 </span>            :  *      device is discoverable and there is an active GO. Note that setting this
<span class="lineNum">    3417 </span>            :  *      field when not needed, will increase the number of interrupts and have
<span class="lineNum">    3418 </span>            :  *      effect on the platform power, as this setting opens the Rx filters on
<span class="lineNum">    3419 </span>            :  *      all macs.
<span class="lineNum">    3420 </span>            :  */
<span class="lineNum">    3421 </span>            : struct iwm_mac_data_p2p_dev {
<span class="lineNum">    3422 </span>            :         uint32_t is_disc_extended;
<span class="lineNum">    3423 </span>            : } __packed; /* _P2P_DEV_MAC_DATA_API_S_VER_1 */
<span class="lineNum">    3424 </span>            : 
<span class="lineNum">    3425 </span>            : /**
<span class="lineNum">    3426 </span>            :  * MAC context filter flags
<span class="lineNum">    3427 </span>            :  * @IWM_MAC_FILTER_IN_PROMISC: accept all data frames
<span class="lineNum">    3428 </span>            :  * @IWM_MAC_FILTER_IN_CONTROL_AND_MGMT: pass all mangement and
<span class="lineNum">    3429 </span>            :  *      control frames to the host
<span class="lineNum">    3430 </span>            :  * @IWM_MAC_FILTER_ACCEPT_GRP: accept multicast frames
<span class="lineNum">    3431 </span>            :  * @IWM_MAC_FILTER_DIS_DECRYPT: don't decrypt unicast frames
<span class="lineNum">    3432 </span>            :  * @IWM_MAC_FILTER_DIS_GRP_DECRYPT: don't decrypt multicast frames
<span class="lineNum">    3433 </span>            :  * @IWM_MAC_FILTER_IN_BEACON: transfer foreign BSS's beacons to host
<span class="lineNum">    3434 </span>            :  *      (in station mode when associated)
<span class="lineNum">    3435 </span>            :  * @IWM_MAC_FILTER_OUT_BCAST: filter out all broadcast frames
<span class="lineNum">    3436 </span>            :  * @IWM_MAC_FILTER_IN_CRC32: extract FCS and append it to frames
<span class="lineNum">    3437 </span>            :  * @IWM_MAC_FILTER_IN_PROBE_REQUEST: pass probe requests to host
<span class="lineNum">    3438 </span>            :  */
<span class="lineNum">    3439 </span>            : #define IWM_MAC_FILTER_IN_PROMISC               (1 &lt;&lt; 0)
<span class="lineNum">    3440 </span>            : #define IWM_MAC_FILTER_IN_CONTROL_AND_MGMT      (1 &lt;&lt; 1)
<span class="lineNum">    3441 </span>            : #define IWM_MAC_FILTER_ACCEPT_GRP               (1 &lt;&lt; 2)
<span class="lineNum">    3442 </span>            : #define IWM_MAC_FILTER_DIS_DECRYPT              (1 &lt;&lt; 3)
<span class="lineNum">    3443 </span>            : #define IWM_MAC_FILTER_DIS_GRP_DECRYPT          (1 &lt;&lt; 4)
<span class="lineNum">    3444 </span>            : #define IWM_MAC_FILTER_IN_BEACON                (1 &lt;&lt; 6)
<span class="lineNum">    3445 </span>            : #define IWM_MAC_FILTER_OUT_BCAST                (1 &lt;&lt; 8)
<span class="lineNum">    3446 </span>            : #define IWM_MAC_FILTER_IN_CRC32                 (1 &lt;&lt; 11)
<span class="lineNum">    3447 </span>            : #define IWM_MAC_FILTER_IN_PROBE_REQUEST         (1 &lt;&lt; 12)
<span class="lineNum">    3448 </span>            : 
<span class="lineNum">    3449 </span>            : /**
<span class="lineNum">    3450 </span>            :  * QoS flags
<span class="lineNum">    3451 </span>            :  * @IWM_MAC_QOS_FLG_UPDATE_EDCA: ?
<span class="lineNum">    3452 </span>            :  * @IWM_MAC_QOS_FLG_TGN: HT is enabled
<span class="lineNum">    3453 </span>            :  * @IWM_MAC_QOS_FLG_TXOP_TYPE: ?
<span class="lineNum">    3454 </span>            :  *
<span class="lineNum">    3455 </span>            :  */
<span class="lineNum">    3456 </span>            : #define IWM_MAC_QOS_FLG_UPDATE_EDCA     (1 &lt;&lt; 0)
<span class="lineNum">    3457 </span>            : #define IWM_MAC_QOS_FLG_TGN             (1 &lt;&lt; 1)
<span class="lineNum">    3458 </span>            : #define IWM_MAC_QOS_FLG_TXOP_TYPE       (1 &lt;&lt; 4)
<span class="lineNum">    3459 </span>            : 
<span class="lineNum">    3460 </span>            : /**
<span class="lineNum">    3461 </span>            :  * struct iwm_ac_qos - QOS timing params for IWM_MAC_CONTEXT_CMD
<span class="lineNum">    3462 </span>            :  * @cw_min: Contention window, start value in numbers of slots.
<span class="lineNum">    3463 </span>            :  *      Should be a power-of-2, minus 1.  Device's default is 0x0f.
<span class="lineNum">    3464 </span>            :  * @cw_max: Contention window, max value in numbers of slots.
<span class="lineNum">    3465 </span>            :  *      Should be a power-of-2, minus 1.  Device's default is 0x3f.
<span class="lineNum">    3466 </span>            :  * @aifsn:  Number of slots in Arbitration Interframe Space (before
<span class="lineNum">    3467 </span>            :  *      performing random backoff timing prior to Tx).  Device default 1.
<span class="lineNum">    3468 </span>            :  * @fifos_mask: FIFOs used by this MAC for this AC
<span class="lineNum">    3469 </span>            :  * @edca_txop:  Length of Tx opportunity, in uSecs.  Device default is 0.
<span class="lineNum">    3470 </span>            :  *
<span class="lineNum">    3471 </span>            :  * One instance of this config struct for each of 4 EDCA access categories
<span class="lineNum">    3472 </span>            :  * in struct iwm_qosparam_cmd.
<span class="lineNum">    3473 </span>            :  *
<span class="lineNum">    3474 </span>            :  * Device will automatically increase contention window by (2*CW) + 1 for each
<span class="lineNum">    3475 </span>            :  * transmission retry.  Device uses cw_max as a bit mask, ANDed with new CW
<span class="lineNum">    3476 </span>            :  * value, to cap the CW value.
<span class="lineNum">    3477 </span>            :  */
<span class="lineNum">    3478 </span>            : struct iwm_ac_qos {
<span class="lineNum">    3479 </span>            :         uint16_t cw_min;
<span class="lineNum">    3480 </span>            :         uint16_t cw_max;
<span class="lineNum">    3481 </span>            :         uint8_t aifsn;
<span class="lineNum">    3482 </span>            :         uint8_t fifos_mask;
<span class="lineNum">    3483 </span>            :         uint16_t edca_txop;
<span class="lineNum">    3484 </span>            : } __packed; /* IWM_AC_QOS_API_S_VER_2 */
<span class="lineNum">    3485 </span>            : 
<span class="lineNum">    3486 </span>            : /**
<span class="lineNum">    3487 </span>            :  * struct iwm_mac_ctx_cmd - command structure to configure MAC contexts
<span class="lineNum">    3488 </span>            :  * ( IWM_MAC_CONTEXT_CMD = 0x28 )
<span class="lineNum">    3489 </span>            :  * @id_and_color: ID and color of the MAC
<span class="lineNum">    3490 </span>            :  * @action: action to perform, one of IWM_FW_CTXT_ACTION_*
<span class="lineNum">    3491 </span>            :  * @mac_type: one of IWM_FW_MAC_TYPE_*
<span class="lineNum">    3492 </span>            :  * @tsf_id: TSF HW timer, one of IWM_TSF_ID_*
<span class="lineNum">    3493 </span>            :  * @node_addr: MAC address
<span class="lineNum">    3494 </span>            :  * @bssid_addr: BSSID
<span class="lineNum">    3495 </span>            :  * @cck_rates: basic rates available for CCK
<span class="lineNum">    3496 </span>            :  * @ofdm_rates: basic rates available for OFDM
<span class="lineNum">    3497 </span>            :  * @protection_flags: combination of IWM_MAC_PROT_FLG_FLAG_*
<span class="lineNum">    3498 </span>            :  * @cck_short_preamble: 0x20 for enabling short preamble, 0 otherwise
<span class="lineNum">    3499 </span>            :  * @short_slot: 0x10 for enabling short slots, 0 otherwise
<span class="lineNum">    3500 </span>            :  * @filter_flags: combination of IWM_MAC_FILTER_*
<span class="lineNum">    3501 </span>            :  * @qos_flags: from IWM_MAC_QOS_FLG_*
<span class="lineNum">    3502 </span>            :  * @ac: one iwm_mac_qos configuration for each AC
<span class="lineNum">    3503 </span>            :  * @mac_specific: one of struct iwm_mac_data_*, according to mac_type
<span class="lineNum">    3504 </span>            :  */
<span class="lineNum">    3505 </span>            : struct iwm_mac_ctx_cmd {
<span class="lineNum">    3506 </span>            :         /* COMMON_INDEX_HDR_API_S_VER_1 */
<span class="lineNum">    3507 </span>            :         uint32_t id_and_color;
<span class="lineNum">    3508 </span>            :         uint32_t action;
<span class="lineNum">    3509 </span>            :         /* IWM_MAC_CONTEXT_COMMON_DATA_API_S_VER_1 */
<span class="lineNum">    3510 </span>            :         uint32_t mac_type;
<span class="lineNum">    3511 </span>            :         uint32_t tsf_id;
<span class="lineNum">    3512 </span>            :         uint8_t node_addr[6];
<span class="lineNum">    3513 </span>            :         uint16_t reserved_for_node_addr;
<span class="lineNum">    3514 </span>            :         uint8_t bssid_addr[6];
<span class="lineNum">    3515 </span>            :         uint16_t reserved_for_bssid_addr;
<span class="lineNum">    3516 </span>            :         uint32_t cck_rates;
<span class="lineNum">    3517 </span>            :         uint32_t ofdm_rates;
<span class="lineNum">    3518 </span>            :         uint32_t protection_flags;
<span class="lineNum">    3519 </span>            :         uint32_t cck_short_preamble;
<span class="lineNum">    3520 </span>            :         uint32_t short_slot;
<span class="lineNum">    3521 </span>            :         uint32_t filter_flags;
<span class="lineNum">    3522 </span>            :         /* IWM_MAC_QOS_PARAM_API_S_VER_1 */
<span class="lineNum">    3523 </span>            :         uint32_t qos_flags;
<span class="lineNum">    3524 </span>            :         struct iwm_ac_qos ac[IWM_AC_NUM+1];
<span class="lineNum">    3525 </span>            :         /* IWM_MAC_CONTEXT_COMMON_DATA_API_S */
<span class="lineNum">    3526 </span>            :         union {
<span class="lineNum">    3527 </span>            :                 struct iwm_mac_data_ap ap;
<span class="lineNum">    3528 </span>            :                 struct iwm_mac_data_go go;
<span class="lineNum">    3529 </span>            :                 struct iwm_mac_data_sta sta;
<span class="lineNum">    3530 </span>            :                 struct iwm_mac_data_p2p_sta p2p_sta;
<span class="lineNum">    3531 </span>            :                 struct iwm_mac_data_p2p_dev p2p_dev;
<span class="lineNum">    3532 </span>            :                 struct iwm_mac_data_pibss pibss;
<span class="lineNum">    3533 </span>            :                 struct iwm_mac_data_ibss ibss;
<span class="lineNum">    3534 </span>            :         };
<a name="3535"><span class="lineNum">    3535 </span>            : } __packed; /* IWM_MAC_CONTEXT_CMD_API_S_VER_1 */</a>
<span class="lineNum">    3536 </span>            : 
<span class="lineNum">    3537 </span><span class="lineNoCov">          0 : static inline uint32_t iwm_reciprocal(uint32_t v)</span>
<span class="lineNum">    3538 </span>            : {
<span class="lineNum">    3539 </span><span class="lineNoCov">          0 :         if (!v)</span>
<span class="lineNum">    3540 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    3541 </span><span class="lineNoCov">          0 :         return 0xFFFFFFFF / v;</span>
<span class="lineNum">    3542 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3543 </span>            : 
<span class="lineNum">    3544 </span>            : #define IWM_NONQOS_SEQ_GET      0x1
<span class="lineNum">    3545 </span>            : #define IWM_NONQOS_SEQ_SET      0x2
<span class="lineNum">    3546 </span>            : struct iwm_nonqos_seq_query_cmd {
<span class="lineNum">    3547 </span>            :         uint32_t get_set_flag;
<span class="lineNum">    3548 </span>            :         uint32_t mac_id_n_color;
<span class="lineNum">    3549 </span>            :         uint16_t value;
<span class="lineNum">    3550 </span>            :         uint16_t reserved;
<span class="lineNum">    3551 </span>            : } __packed; /* IWM_NON_QOS_TX_COUNTER_GET_SET_API_S_VER_1 */
<span class="lineNum">    3552 </span>            : 
<span class="lineNum">    3553 </span>            : /* Power Management Commands, Responses, Notifications */
<span class="lineNum">    3554 </span>            : 
<span class="lineNum">    3555 </span>            : /* Radio LP RX Energy Threshold measured in dBm */
<span class="lineNum">    3556 </span>            : #define IWM_POWER_LPRX_RSSI_THRESHOLD   75
<span class="lineNum">    3557 </span>            : #define IWM_POWER_LPRX_RSSI_THRESHOLD_MAX       94
<span class="lineNum">    3558 </span>            : #define IWM_POWER_LPRX_RSSI_THRESHOLD_MIN       30
<span class="lineNum">    3559 </span>            : 
<span class="lineNum">    3560 </span>            : /**
<span class="lineNum">    3561 </span>            :  * Masks for iwm_mac_power_cmd command flags
<span class="lineNum">    3562 </span>            :  * @IWM_POWER_FLAGS_POWER_SAVE_ENA_MSK: '1' Allow to save power by turning off
<span class="lineNum">    3563 </span>            :  *              receiver and transmitter. '0' - does not allow.
<span class="lineNum">    3564 </span>            :  * @IWM_POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK: '0' Driver disables power management,
<span class="lineNum">    3565 </span>            :  *              '1' Driver enables PM (use rest of parameters)
<span class="lineNum">    3566 </span>            :  * @IWM_POWER_FLAGS_SKIP_OVER_DTIM_MSK: '0' PM have to walk up every DTIM,
<span class="lineNum">    3567 </span>            :  *              '1' PM could sleep over DTIM till listen Interval.
<span class="lineNum">    3568 </span>            :  * @IWM_POWER_FLAGS_SNOOZE_ENA_MSK: Enable snoozing only if uAPSD is enabled and all
<span class="lineNum">    3569 </span>            :  *              access categories are both delivery and trigger enabled.
<span class="lineNum">    3570 </span>            :  * @IWM_POWER_FLAGS_BT_SCO_ENA: Enable BT SCO coex only if uAPSD and
<span class="lineNum">    3571 </span>            :  *              PBW Snoozing enabled
<span class="lineNum">    3572 </span>            :  * @IWM_POWER_FLAGS_ADVANCE_PM_ENA_MSK: Advanced PM (uAPSD) enable mask
<span class="lineNum">    3573 </span>            :  * @IWM_POWER_FLAGS_LPRX_ENA_MSK: Low Power RX enable.
<span class="lineNum">    3574 </span>            :  * @IWM_POWER_FLAGS_AP_UAPSD_MISBEHAVING_ENA_MSK: AP/GO's uAPSD misbehaving
<span class="lineNum">    3575 </span>            :  *              detection enablement
<span class="lineNum">    3576 </span>            : */
<span class="lineNum">    3577 </span>            : #define IWM_POWER_FLAGS_POWER_SAVE_ENA_MSK              (1 &lt;&lt; 0)
<span class="lineNum">    3578 </span>            : #define IWM_POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK        (1 &lt;&lt; 1)
<span class="lineNum">    3579 </span>            : #define IWM_POWER_FLAGS_SKIP_OVER_DTIM_MSK              (1 &lt;&lt; 2)
<span class="lineNum">    3580 </span>            : #define IWM_POWER_FLAGS_SNOOZE_ENA_MSK                  (1 &lt;&lt; 5)
<span class="lineNum">    3581 </span>            : #define IWM_POWER_FLAGS_BT_SCO_ENA                      (1 &lt;&lt; 8)
<span class="lineNum">    3582 </span>            : #define IWM_POWER_FLAGS_ADVANCE_PM_ENA_MSK              (1 &lt;&lt; 9)
<span class="lineNum">    3583 </span>            : #define IWM_POWER_FLAGS_LPRX_ENA_MSK                    (1 &lt;&lt; 11)
<span class="lineNum">    3584 </span>            : #define IWM_POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK       (1 &lt;&lt; 12)
<span class="lineNum">    3585 </span>            : 
<span class="lineNum">    3586 </span>            : #define IWM_POWER_VEC_SIZE 5
<span class="lineNum">    3587 </span>            : 
<span class="lineNum">    3588 </span>            : /**
<span class="lineNum">    3589 </span>            :  * Masks for device power command flags
<span class="lineNum">    3590 </span>            :  * @IWM_DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK:
<span class="lineNum">    3591 </span>            :  *   '1' Allow to save power by turning off receiver and transmitter.
<span class="lineNum">    3592 </span>            :  *   '0' Do not allow. This flag should be always set to '1' unless
<span class="lineNum">    3593 </span>            :  *       one needs to disable actual power down for debug purposes.
<span class="lineNum">    3594 </span>            :  * @IWM_DEVICE_POWER_FLAGS_CAM_MSK:
<span class="lineNum">    3595 </span>            :  *   '1' CAM (Continuous Active Mode) is set, power management is disabled.
<span class="lineNum">    3596 </span>            :  *   '0' Power management is enabled, one of the power schemes is applied.
<span class="lineNum">    3597 </span>            :  */
<span class="lineNum">    3598 </span>            : #define IWM_DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK       (1 &lt;&lt; 0)
<span class="lineNum">    3599 </span>            : #define IWM_DEVICE_POWER_FLAGS_CAM_MSK                  (1 &lt;&lt; 13)
<span class="lineNum">    3600 </span>            : 
<span class="lineNum">    3601 </span>            : /**
<span class="lineNum">    3602 </span>            :  * struct iwm_device_power_cmd - device wide power command.
<span class="lineNum">    3603 </span>            :  * IWM_POWER_TABLE_CMD = 0x77 (command, has simple generic response)
<span class="lineNum">    3604 </span>            :  *
<span class="lineNum">    3605 </span>            :  * @flags:      Power table command flags from IWM_DEVICE_POWER_FLAGS_*
<span class="lineNum">    3606 </span>            :  */
<span class="lineNum">    3607 </span>            : struct iwm_device_power_cmd {
<span class="lineNum">    3608 </span>            :         /* PM_POWER_TABLE_CMD_API_S_VER_6 */
<span class="lineNum">    3609 </span>            :         uint16_t flags;
<span class="lineNum">    3610 </span>            :         uint16_t reserved;
<span class="lineNum">    3611 </span>            : } __packed;
<span class="lineNum">    3612 </span>            : 
<span class="lineNum">    3613 </span>            : /**
<span class="lineNum">    3614 </span>            :  * struct iwm_mac_power_cmd - New power command containing uAPSD support
<span class="lineNum">    3615 </span>            :  * IWM_MAC_PM_POWER_TABLE = 0xA9 (command, has simple generic response)
<span class="lineNum">    3616 </span>            :  * @id_and_color:       MAC contex identifier
<span class="lineNum">    3617 </span>            :  * @flags:              Power table command flags from POWER_FLAGS_*
<span class="lineNum">    3618 </span>            :  * @keep_alive_seconds: Keep alive period in seconds. Default - 25 sec.
<span class="lineNum">    3619 </span>            :  *                      Minimum allowed:- 3 * DTIM. Keep alive period must be
<span class="lineNum">    3620 </span>            :  *                      set regardless of power scheme or current power state.
<span class="lineNum">    3621 </span>            :  *                      FW use this value also when PM is disabled.
<span class="lineNum">    3622 </span>            :  * @rx_data_timeout:    Minimum time (usec) from last Rx packet for AM to
<span class="lineNum">    3623 </span>            :  *                      PSM transition - legacy PM
<span class="lineNum">    3624 </span>            :  * @tx_data_timeout:    Minimum time (usec) from last Tx packet for AM to
<span class="lineNum">    3625 </span>            :  *                      PSM transition - legacy PM
<span class="lineNum">    3626 </span>            :  * @sleep_interval:     not in use
<span class="lineNum">    3627 </span>            :  * @skip_dtim_periods:  Number of DTIM periods to skip if Skip over DTIM flag
<span class="lineNum">    3628 </span>            :  *                      is set. For example, if it is required to skip over
<span class="lineNum">    3629 </span>            :  *                      one DTIM, this value need to be set to 2 (DTIM periods).
<span class="lineNum">    3630 </span>            :  * @rx_data_timeout_uapsd: Minimum time (usec) from last Rx packet for AM to
<span class="lineNum">    3631 </span>            :  *                      PSM transition - uAPSD
<span class="lineNum">    3632 </span>            :  * @tx_data_timeout_uapsd: Minimum time (usec) from last Tx packet for AM to
<span class="lineNum">    3633 </span>            :  *                      PSM transition - uAPSD
<span class="lineNum">    3634 </span>            :  * @lprx_rssi_threshold: Signal strength up to which LP RX can be enabled.
<span class="lineNum">    3635 </span>            :  *                      Default: 80dbm
<span class="lineNum">    3636 </span>            :  * @num_skip_dtim:      Number of DTIMs to skip if Skip over DTIM flag is set
<span class="lineNum">    3637 </span>            :  * @snooze_interval:    Maximum time between attempts to retrieve buffered data
<span class="lineNum">    3638 </span>            :  *                      from the AP [msec]
<span class="lineNum">    3639 </span>            :  * @snooze_window:      A window of time in which PBW snoozing insures that all
<span class="lineNum">    3640 </span>            :  *                      packets received. It is also the minimum time from last
<span class="lineNum">    3641 </span>            :  *                      received unicast RX packet, before client stops snoozing
<span class="lineNum">    3642 </span>            :  *                      for data. [msec]
<span class="lineNum">    3643 </span>            :  * @snooze_step:        TBD
<span class="lineNum">    3644 </span>            :  * @qndp_tid:           TID client shall use for uAPSD QNDP triggers
<span class="lineNum">    3645 </span>            :  * @uapsd_ac_flags:     Set trigger-enabled and delivery-enabled indication for
<span class="lineNum">    3646 </span>            :  *                      each corresponding AC.
<span class="lineNum">    3647 </span>            :  *                      Use IEEE80211_WMM_IE_STA_QOSINFO_AC* for correct values.
<span class="lineNum">    3648 </span>            :  * @uapsd_max_sp:       Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct
<span class="lineNum">    3649 </span>            :  *                      values.
<span class="lineNum">    3650 </span>            :  * @heavy_tx_thld_packets:      TX threshold measured in number of packets
<span class="lineNum">    3651 </span>            :  * @heavy_rx_thld_packets:      RX threshold measured in number of packets
<span class="lineNum">    3652 </span>            :  * @heavy_tx_thld_percentage:   TX threshold measured in load's percentage
<span class="lineNum">    3653 </span>            :  * @heavy_rx_thld_percentage:   RX threshold measured in load's percentage
<span class="lineNum">    3654 </span>            :  * @limited_ps_threshold:
<span class="lineNum">    3655 </span>            : */
<span class="lineNum">    3656 </span>            : struct iwm_mac_power_cmd {
<span class="lineNum">    3657 </span>            :         /* CONTEXT_DESC_API_T_VER_1 */
<span class="lineNum">    3658 </span>            :         uint32_t id_and_color;
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span>            :         /* CLIENT_PM_POWER_TABLE_S_VER_1 */
<span class="lineNum">    3661 </span>            :         uint16_t flags;
<span class="lineNum">    3662 </span>            :         uint16_t keep_alive_seconds;
<span class="lineNum">    3663 </span>            :         uint32_t rx_data_timeout;
<span class="lineNum">    3664 </span>            :         uint32_t tx_data_timeout;
<span class="lineNum">    3665 </span>            :         uint32_t rx_data_timeout_uapsd;
<span class="lineNum">    3666 </span>            :         uint32_t tx_data_timeout_uapsd;
<span class="lineNum">    3667 </span>            :         uint8_t lprx_rssi_threshold;
<span class="lineNum">    3668 </span>            :         uint8_t skip_dtim_periods;
<span class="lineNum">    3669 </span>            :         uint16_t snooze_interval;
<span class="lineNum">    3670 </span>            :         uint16_t snooze_window;
<span class="lineNum">    3671 </span>            :         uint8_t snooze_step;
<span class="lineNum">    3672 </span>            :         uint8_t qndp_tid;
<span class="lineNum">    3673 </span>            :         uint8_t uapsd_ac_flags;
<span class="lineNum">    3674 </span>            :         uint8_t uapsd_max_sp;
<span class="lineNum">    3675 </span>            :         uint8_t heavy_tx_thld_packets;
<span class="lineNum">    3676 </span>            :         uint8_t heavy_rx_thld_packets;
<span class="lineNum">    3677 </span>            :         uint8_t heavy_tx_thld_percentage;
<span class="lineNum">    3678 </span>            :         uint8_t heavy_rx_thld_percentage;
<span class="lineNum">    3679 </span>            :         uint8_t limited_ps_threshold;
<span class="lineNum">    3680 </span>            :         uint8_t reserved;
<span class="lineNum">    3681 </span>            : } __packed;
<span class="lineNum">    3682 </span>            : 
<span class="lineNum">    3683 </span>            : #define IWM_DEFAULT_PS_TX_DATA_TIMEOUT      (100 * 1000)
<span class="lineNum">    3684 </span>            : #define IWM_DEFAULT_PS_RX_DATA_TIMEOUT      (100 * 1000)
<span class="lineNum">    3685 </span>            : 
<span class="lineNum">    3686 </span>            : /*
<span class="lineNum">    3687 </span>            :  * struct iwm_uapsd_misbehaving_ap_notif - FW sends this notification when
<span class="lineNum">    3688 </span>            :  * associated AP is identified as improperly implementing uAPSD protocol.
<span class="lineNum">    3689 </span>            :  * IWM_PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION = 0x78
<span class="lineNum">    3690 </span>            :  * @sta_id: index of station in uCode's station table - associated AP ID in
<span class="lineNum">    3691 </span>            :  *          this context.
<span class="lineNum">    3692 </span>            :  */
<span class="lineNum">    3693 </span>            : struct iwm_uapsd_misbehaving_ap_notif {
<span class="lineNum">    3694 </span>            :         uint32_t sta_id;
<span class="lineNum">    3695 </span>            :         uint8_t mac_id;
<span class="lineNum">    3696 </span>            :         uint8_t reserved[3];
<span class="lineNum">    3697 </span>            : } __packed;
<span class="lineNum">    3698 </span>            : 
<span class="lineNum">    3699 </span>            : /**
<span class="lineNum">    3700 </span>            :  * struct iwm_beacon_filter_cmd
<span class="lineNum">    3701 </span>            :  * IWM_REPLY_BEACON_FILTERING_CMD = 0xd2 (command)
<span class="lineNum">    3702 </span>            :  * @id_and_color: MAC contex identifier
<span class="lineNum">    3703 </span>            :  * @bf_energy_delta: Used for RSSI filtering, if in 'normal' state. Send beacon
<span class="lineNum">    3704 </span>            :  *      to driver if delta in Energy values calculated for this and last
<span class="lineNum">    3705 </span>            :  *      passed beacon is greater than this threshold. Zero value means that
<span class="lineNum">    3706 </span>            :  *      the Energy change is ignored for beacon filtering, and beacon will
<span class="lineNum">    3707 </span>            :  *      not be forced to be sent to driver regardless of this delta. Typical
<span class="lineNum">    3708 </span>            :  *      energy delta 5dB.
<span class="lineNum">    3709 </span>            :  * @bf_roaming_energy_delta: Used for RSSI filtering, if in 'roaming' state.
<span class="lineNum">    3710 </span>            :  *      Send beacon to driver if delta in Energy values calculated for this
<span class="lineNum">    3711 </span>            :  *      and last passed beacon is greater than this threshold. Zero value
<span class="lineNum">    3712 </span>            :  *      means that the Energy change is ignored for beacon filtering while in
<span class="lineNum">    3713 </span>            :  *      Roaming state, typical energy delta 1dB.
<span class="lineNum">    3714 </span>            :  * @bf_roaming_state: Used for RSSI filtering. If absolute Energy values
<span class="lineNum">    3715 </span>            :  *      calculated for current beacon is less than the threshold, use
<span class="lineNum">    3716 </span>            :  *      Roaming Energy Delta Threshold, otherwise use normal Energy Delta
<span class="lineNum">    3717 </span>            :  *      Threshold. Typical energy threshold is -72dBm.
<span class="lineNum">    3718 </span>            :  * @bf_temp_threshold: This threshold determines the type of temperature
<span class="lineNum">    3719 </span>            :  *      filtering (Slow or Fast) that is selected (Units are in Celsuis):
<span class="lineNum">    3720 </span>            :  *      If the current temperature is above this threshold - Fast filter
<span class="lineNum">    3721 </span>            :  *      will be used, If the current temperature is below this threshold -
<span class="lineNum">    3722 </span>            :  *      Slow filter will be used.
<span class="lineNum">    3723 </span>            :  * @bf_temp_fast_filter: Send Beacon to driver if delta in temperature values
<span class="lineNum">    3724 </span>            :  *      calculated for this and the last passed beacon is greater than this
<span class="lineNum">    3725 </span>            :  *      threshold. Zero value means that the temperature change is ignored for
<span class="lineNum">    3726 </span>            :  *      beacon filtering; beacons will not be  forced to be sent to driver
<span class="lineNum">    3727 </span>            :  *      regardless of whether its temerature has been changed.
<span class="lineNum">    3728 </span>            :  * @bf_temp_slow_filter: Send Beacon to driver if delta in temperature values
<span class="lineNum">    3729 </span>            :  *      calculated for this and the last passed beacon is greater than this
<span class="lineNum">    3730 </span>            :  *      threshold. Zero value means that the temperature change is ignored for
<span class="lineNum">    3731 </span>            :  *      beacon filtering; beacons will not be forced to be sent to driver
<span class="lineNum">    3732 </span>            :  *      regardless of whether its temerature has been changed.
<span class="lineNum">    3733 </span>            :  * @bf_enable_beacon_filter: 1, beacon filtering is enabled; 0, disabled.
<span class="lineNum">    3734 </span>            :  * @bf_escape_timer: Send beacons to driver if no beacons were passed
<span class="lineNum">    3735 </span>            :  *      for a specific period of time. Units: Beacons.
<span class="lineNum">    3736 </span>            :  * @ba_escape_timer: Fully receive and parse beacon if no beacons were passed
<span class="lineNum">    3737 </span>            :  *      for a longer period of time then this escape-timeout. Units: Beacons.
<span class="lineNum">    3738 </span>            :  * @ba_enable_beacon_abort: 1, beacon abort is enabled; 0, disabled.
<span class="lineNum">    3739 </span>            :  */
<span class="lineNum">    3740 </span>            : struct iwm_beacon_filter_cmd {
<span class="lineNum">    3741 </span>            :         uint32_t bf_energy_delta;
<span class="lineNum">    3742 </span>            :         uint32_t bf_roaming_energy_delta;
<span class="lineNum">    3743 </span>            :         uint32_t bf_roaming_state;
<span class="lineNum">    3744 </span>            :         uint32_t bf_temp_threshold;
<span class="lineNum">    3745 </span>            :         uint32_t bf_temp_fast_filter;
<span class="lineNum">    3746 </span>            :         uint32_t bf_temp_slow_filter;
<span class="lineNum">    3747 </span>            :         uint32_t bf_enable_beacon_filter;
<span class="lineNum">    3748 </span>            :         uint32_t bf_debug_flag;
<span class="lineNum">    3749 </span>            :         uint32_t bf_escape_timer;
<span class="lineNum">    3750 </span>            :         uint32_t ba_escape_timer;
<span class="lineNum">    3751 </span>            :         uint32_t ba_enable_beacon_abort;
<span class="lineNum">    3752 </span>            : } __packed;
<span class="lineNum">    3753 </span>            : 
<span class="lineNum">    3754 </span>            : /* Beacon filtering and beacon abort */
<span class="lineNum">    3755 </span>            : #define IWM_BF_ENERGY_DELTA_DEFAULT 5
<span class="lineNum">    3756 </span>            : #define IWM_BF_ENERGY_DELTA_MAX 255
<span class="lineNum">    3757 </span>            : #define IWM_BF_ENERGY_DELTA_MIN 0
<span class="lineNum">    3758 </span>            : 
<span class="lineNum">    3759 </span>            : #define IWM_BF_ROAMING_ENERGY_DELTA_DEFAULT 1
<span class="lineNum">    3760 </span>            : #define IWM_BF_ROAMING_ENERGY_DELTA_MAX 255
<span class="lineNum">    3761 </span>            : #define IWM_BF_ROAMING_ENERGY_DELTA_MIN 0
<span class="lineNum">    3762 </span>            : 
<span class="lineNum">    3763 </span>            : #define IWM_BF_ROAMING_STATE_DEFAULT 72
<span class="lineNum">    3764 </span>            : #define IWM_BF_ROAMING_STATE_MAX 255
<span class="lineNum">    3765 </span>            : #define IWM_BF_ROAMING_STATE_MIN 0
<span class="lineNum">    3766 </span>            : 
<span class="lineNum">    3767 </span>            : #define IWM_BF_TEMP_THRESHOLD_DEFAULT 112
<span class="lineNum">    3768 </span>            : #define IWM_BF_TEMP_THRESHOLD_MAX 255
<span class="lineNum">    3769 </span>            : #define IWM_BF_TEMP_THRESHOLD_MIN 0
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span>            : #define IWM_BF_TEMP_FAST_FILTER_DEFAULT 1
<span class="lineNum">    3772 </span>            : #define IWM_BF_TEMP_FAST_FILTER_MAX 255
<span class="lineNum">    3773 </span>            : #define IWM_BF_TEMP_FAST_FILTER_MIN 0
<span class="lineNum">    3774 </span>            : 
<span class="lineNum">    3775 </span>            : #define IWM_BF_TEMP_SLOW_FILTER_DEFAULT 5
<span class="lineNum">    3776 </span>            : #define IWM_BF_TEMP_SLOW_FILTER_MAX 255
<span class="lineNum">    3777 </span>            : #define IWM_BF_TEMP_SLOW_FILTER_MIN 0
<span class="lineNum">    3778 </span>            : 
<span class="lineNum">    3779 </span>            : #define IWM_BF_ENABLE_BEACON_FILTER_DEFAULT 1
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span>            : #define IWM_BF_DEBUG_FLAG_DEFAULT 0
<span class="lineNum">    3782 </span>            : 
<span class="lineNum">    3783 </span>            : #define IWM_BF_ESCAPE_TIMER_DEFAULT 50
<span class="lineNum">    3784 </span>            : #define IWM_BF_ESCAPE_TIMER_MAX 1024
<span class="lineNum">    3785 </span>            : #define IWM_BF_ESCAPE_TIMER_MIN 0
<span class="lineNum">    3786 </span>            : 
<span class="lineNum">    3787 </span>            : #define IWM_BA_ESCAPE_TIMER_DEFAULT 6
<span class="lineNum">    3788 </span>            : #define IWM_BA_ESCAPE_TIMER_D3 9
<span class="lineNum">    3789 </span>            : #define IWM_BA_ESCAPE_TIMER_MAX 1024
<span class="lineNum">    3790 </span>            : #define IWM_BA_ESCAPE_TIMER_MIN 0
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            : #define IWM_BA_ENABLE_BEACON_ABORT_DEFAULT 1
<span class="lineNum">    3793 </span>            : 
<span class="lineNum">    3794 </span>            : #define IWM_BF_CMD_CONFIG_DEFAULTS                                           \
<span class="lineNum">    3795 </span>            :         .bf_energy_delta = htole32(IWM_BF_ENERGY_DELTA_DEFAULT),             \
<span class="lineNum">    3796 </span>            :         .bf_roaming_energy_delta =                                           \
<span class="lineNum">    3797 </span>            :                 htole32(IWM_BF_ROAMING_ENERGY_DELTA_DEFAULT),        \
<span class="lineNum">    3798 </span>            :         .bf_roaming_state = htole32(IWM_BF_ROAMING_STATE_DEFAULT),           \
<span class="lineNum">    3799 </span>            :         .bf_temp_threshold = htole32(IWM_BF_TEMP_THRESHOLD_DEFAULT),     \
<span class="lineNum">    3800 </span>            :         .bf_temp_fast_filter = htole32(IWM_BF_TEMP_FAST_FILTER_DEFAULT), \
<span class="lineNum">    3801 </span>            :         .bf_temp_slow_filter = htole32(IWM_BF_TEMP_SLOW_FILTER_DEFAULT), \
<span class="lineNum">    3802 </span>            :         .bf_debug_flag = htole32(IWM_BF_DEBUG_FLAG_DEFAULT),         \
<span class="lineNum">    3803 </span>            :         .bf_escape_timer = htole32(IWM_BF_ESCAPE_TIMER_DEFAULT),             \
<span class="lineNum">    3804 </span>            :         .ba_escape_timer = htole32(IWM_BA_ESCAPE_TIMER_DEFAULT)
<span class="lineNum">    3805 </span>            : 
<span class="lineNum">    3806 </span>            : /* uCode API values for HT/VHT bit rates */
<span class="lineNum">    3807 </span>            : #define IWM_RATE_HT_SISO_MCS_0_PLCP     0
<span class="lineNum">    3808 </span>            : #define IWM_RATE_HT_SISO_MCS_1_PLCP     1
<span class="lineNum">    3809 </span>            : #define IWM_RATE_HT_SISO_MCS_2_PLCP     2
<span class="lineNum">    3810 </span>            : #define IWM_RATE_HT_SISO_MCS_3_PLCP     3
<span class="lineNum">    3811 </span>            : #define IWM_RATE_HT_SISO_MCS_4_PLCP     4
<span class="lineNum">    3812 </span>            : #define IWM_RATE_HT_SISO_MCS_5_PLCP     5
<span class="lineNum">    3813 </span>            : #define IWM_RATE_HT_SISO_MCS_6_PLCP     6
<span class="lineNum">    3814 </span>            : #define IWM_RATE_HT_SISO_MCS_7_PLCP     7
<span class="lineNum">    3815 </span>            : #define IWM_RATE_HT_MIMO2_MCS_8_PLCP    0x8
<span class="lineNum">    3816 </span>            : #define IWM_RATE_HT_MIMO2_MCS_9_PLCP    0x9
<span class="lineNum">    3817 </span>            : #define IWM_RATE_HT_MIMO2_MCS_10_PLCP   0xA
<span class="lineNum">    3818 </span>            : #define IWM_RATE_HT_MIMO2_MCS_11_PLCP   0xB
<span class="lineNum">    3819 </span>            : #define IWM_RATE_HT_MIMO2_MCS_12_PLCP   0xC
<span class="lineNum">    3820 </span>            : #define IWM_RATE_HT_MIMO2_MCS_13_PLCP   0xD
<span class="lineNum">    3821 </span>            : #define IWM_RATE_HT_MIMO2_MCS_14_PLCP   0xE
<span class="lineNum">    3822 </span>            : #define IWM_RATE_HT_MIMO2_MCS_15_PLCP   0xF
<span class="lineNum">    3823 </span>            : #define IWM_RATE_VHT_SISO_MCS_0_PLCP    0
<span class="lineNum">    3824 </span>            : #define IWM_RATE_VHT_SISO_MCS_1_PLCP    1
<span class="lineNum">    3825 </span>            : #define IWM_RATE_VHT_SISO_MCS_2_PLCP    2
<span class="lineNum">    3826 </span>            : #define IWM_RATE_VHT_SISO_MCS_3_PLCP    3
<span class="lineNum">    3827 </span>            : #define IWM_RATE_VHT_SISO_MCS_4_PLCP    4
<span class="lineNum">    3828 </span>            : #define IWM_RATE_VHT_SISO_MCS_5_PLCP    5
<span class="lineNum">    3829 </span>            : #define IWM_RATE_VHT_SISO_MCS_6_PLCP    6
<span class="lineNum">    3830 </span>            : #define IWM_RATE_VHT_SISO_MCS_7_PLCP    7
<span class="lineNum">    3831 </span>            : #define IWM_RATE_VHT_SISO_MCS_8_PLCP    8
<span class="lineNum">    3832 </span>            : #define IWM_RATE_VHT_SISO_MCS_9_PLCP    9
<span class="lineNum">    3833 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_0_PLCP   0x10
<span class="lineNum">    3834 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_1_PLCP   0x11
<span class="lineNum">    3835 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_2_PLCP   0x12
<span class="lineNum">    3836 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_3_PLCP   0x13
<span class="lineNum">    3837 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_4_PLCP   0x14
<span class="lineNum">    3838 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_5_PLCP   0x15
<span class="lineNum">    3839 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_6_PLCP   0x16
<span class="lineNum">    3840 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_7_PLCP   0x17
<span class="lineNum">    3841 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_8_PLCP   0x18
<span class="lineNum">    3842 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_9_PLCP   0x19
<span class="lineNum">    3843 </span>            : #define IWM_RATE_HT_SISO_MCS_INV_PLCP   0x20
<span class="lineNum">    3844 </span>            : #define IWM_RATE_HT_MIMO2_MCS_INV_PLCP  IWM_RATE_HT_SISO_MCS_INV_PLCP
<span class="lineNum">    3845 </span>            : #define IWM_RATE_VHT_SISO_MCS_INV_PLCP  IWM_RATE_HT_SISO_MCS_INV_PLCP
<span class="lineNum">    3846 </span>            : #define IWM_RATE_VHT_MIMO2_MCS_INV_PLCP IWM_RATE_HT_SISO_MCS_INV_PLCP
<span class="lineNum">    3847 </span>            : #define IWM_RATE_HT_SISO_MCS_8_PLCP     IWM_RATE_HT_SISO_MCS_INV_PLCP
<span class="lineNum">    3848 </span>            : #define IWM_RATE_HT_SISO_MCS_9_PLCP     IWM_RATE_HT_SISO_MCS_INV_PLCP
<span class="lineNum">    3849 </span>            : 
<span class="lineNum">    3850 </span>            : /*
<span class="lineNum">    3851 </span>            :  * These serve as indexes into struct iwm_rate iwm_rates[IWM_RIDX_MAX].
<span class="lineNum">    3852 </span>            :  */
<span class="lineNum">    3853 </span>            : enum {
<span class="lineNum">    3854 </span>            :         IWM_RATE_1M_INDEX = 0,
<span class="lineNum">    3855 </span>            :         IWM_FIRST_CCK_RATE = IWM_RATE_1M_INDEX,
<span class="lineNum">    3856 </span>            :         IWM_RATE_2M_INDEX,
<span class="lineNum">    3857 </span>            :         IWM_RATE_5M_INDEX,
<span class="lineNum">    3858 </span>            :         IWM_RATE_11M_INDEX,
<span class="lineNum">    3859 </span>            :         IWM_LAST_CCK_RATE = IWM_RATE_11M_INDEX,
<span class="lineNum">    3860 </span>            :         IWM_RATE_6M_INDEX,
<span class="lineNum">    3861 </span>            :         IWM_FIRST_OFDM_RATE = IWM_RATE_6M_INDEX,
<span class="lineNum">    3862 </span>            :         IWM_RATE_MCS_0_INDEX = IWM_RATE_6M_INDEX,
<span class="lineNum">    3863 </span>            :         IWM_FIRST_HT_RATE = IWM_RATE_MCS_0_INDEX,
<span class="lineNum">    3864 </span>            :         IWM_FIRST_VHT_RATE = IWM_RATE_MCS_0_INDEX,
<span class="lineNum">    3865 </span>            :         IWM_RATE_9M_INDEX,
<span class="lineNum">    3866 </span>            :         IWM_RATE_12M_INDEX,
<span class="lineNum">    3867 </span>            :         IWM_RATE_MCS_1_INDEX = IWM_RATE_12M_INDEX,
<span class="lineNum">    3868 </span>            :         IWM_RATE_MCS_8_INDEX,
<span class="lineNum">    3869 </span>            :         IWM_FIRST_HT_MIMO2_RATE = IWM_RATE_MCS_8_INDEX,
<span class="lineNum">    3870 </span>            :         IWM_RATE_18M_INDEX,
<span class="lineNum">    3871 </span>            :         IWM_RATE_MCS_2_INDEX = IWM_RATE_18M_INDEX,
<span class="lineNum">    3872 </span>            :         IWM_RATE_24M_INDEX,
<span class="lineNum">    3873 </span>            :         IWM_RATE_MCS_3_INDEX = IWM_RATE_24M_INDEX,
<span class="lineNum">    3874 </span>            :         IWM_RATE_MCS_9_INDEX,
<span class="lineNum">    3875 </span>            :         IWM_RATE_36M_INDEX,
<span class="lineNum">    3876 </span>            :         IWM_RATE_MCS_4_INDEX = IWM_RATE_36M_INDEX,
<span class="lineNum">    3877 </span>            :         IWM_RATE_MCS_10_INDEX,
<span class="lineNum">    3878 </span>            :         IWM_RATE_48M_INDEX,
<span class="lineNum">    3879 </span>            :         IWM_RATE_MCS_5_INDEX = IWM_RATE_48M_INDEX,
<span class="lineNum">    3880 </span>            :         IWM_RATE_MCS_11_INDEX,
<span class="lineNum">    3881 </span>            :         IWM_RATE_54M_INDEX,
<span class="lineNum">    3882 </span>            :         IWM_RATE_MCS_6_INDEX = IWM_RATE_54M_INDEX,
<span class="lineNum">    3883 </span>            :         IWM_LAST_NON_HT_RATE = IWM_RATE_54M_INDEX,
<span class="lineNum">    3884 </span>            :         IWM_RATE_MCS_7_INDEX,
<span class="lineNum">    3885 </span>            :         IWM_LAST_HT_SISO_RATE = IWM_RATE_MCS_7_INDEX,
<span class="lineNum">    3886 </span>            :         IWM_RATE_MCS_12_INDEX,
<span class="lineNum">    3887 </span>            :         IWM_RATE_MCS_13_INDEX,
<span class="lineNum">    3888 </span>            :         IWM_RATE_MCS_14_INDEX,
<span class="lineNum">    3889 </span>            :         IWM_RATE_MCS_15_INDEX,
<span class="lineNum">    3890 </span>            :         IWM_LAST_HT_RATE = IWM_RATE_MCS_15_INDEX,
<span class="lineNum">    3891 </span>            :         IWM_LAST_VHT_RATE = IWM_RATE_MCS_9_INDEX,
<span class="lineNum">    3892 </span>            :         IWM_RATE_COUNT_LEGACY = IWM_LAST_NON_HT_RATE + 1,
<span class="lineNum">    3893 </span>            :         IWM_RATE_COUNT = IWM_LAST_HT_RATE + 1,
<span class="lineNum">    3894 </span>            : };
<span class="lineNum">    3895 </span>            : 
<span class="lineNum">    3896 </span>            : #define IWM_RATE_BIT_MSK(r) (1 &lt;&lt; (IWM_RATE_##r##M_INDEX))
<span class="lineNum">    3897 </span>            : 
<span class="lineNum">    3898 </span>            : /* fw API values for legacy bit rates, both OFDM and CCK */
<span class="lineNum">    3899 </span>            : #define IWM_RATE_6M_PLCP        13
<span class="lineNum">    3900 </span>            : #define IWM_RATE_9M_PLCP        15
<span class="lineNum">    3901 </span>            : #define IWM_RATE_12M_PLCP       5
<span class="lineNum">    3902 </span>            : #define IWM_RATE_18M_PLCP       7
<span class="lineNum">    3903 </span>            : #define IWM_RATE_24M_PLCP       9
<span class="lineNum">    3904 </span>            : #define IWM_RATE_36M_PLCP       11
<span class="lineNum">    3905 </span>            : #define IWM_RATE_48M_PLCP       1
<span class="lineNum">    3906 </span>            : #define IWM_RATE_54M_PLCP       3
<span class="lineNum">    3907 </span>            : #define IWM_RATE_1M_PLCP        10
<span class="lineNum">    3908 </span>            : #define IWM_RATE_2M_PLCP        20
<span class="lineNum">    3909 </span>            : #define IWM_RATE_5M_PLCP        55
<span class="lineNum">    3910 </span>            : #define IWM_RATE_11M_PLCP       110
<span class="lineNum">    3911 </span>            : #define IWM_RATE_INVM_PLCP      0xff
<span class="lineNum">    3912 </span>            : 
<span class="lineNum">    3913 </span>            : /*
<span class="lineNum">    3914 </span>            :  * rate_n_flags bit fields
<span class="lineNum">    3915 </span>            :  *
<span class="lineNum">    3916 </span>            :  * The 32-bit value has different layouts in the low 8 bites depending on the
<span class="lineNum">    3917 </span>            :  * format. There are three formats, HT, VHT and legacy (11abg, with subformats
<span class="lineNum">    3918 </span>            :  * for CCK and OFDM).
<span class="lineNum">    3919 </span>            :  *
<span class="lineNum">    3920 </span>            :  * High-throughput (HT) rate format
<span class="lineNum">    3921 </span>            :  *      bit 8 is 1, bit 26 is 0, bit 9 is 0 (OFDM)
<span class="lineNum">    3922 </span>            :  * Very High-throughput (VHT) rate format
<span class="lineNum">    3923 </span>            :  *      bit 8 is 0, bit 26 is 1, bit 9 is 0 (OFDM)
<span class="lineNum">    3924 </span>            :  * Legacy OFDM rate format for bits 7:0
<span class="lineNum">    3925 </span>            :  *      bit 8 is 0, bit 26 is 0, bit 9 is 0 (OFDM)
<span class="lineNum">    3926 </span>            :  * Legacy CCK rate format for bits 7:0:
<span class="lineNum">    3927 </span>            :  *      bit 8 is 0, bit 26 is 0, bit 9 is 1 (CCK)
<span class="lineNum">    3928 </span>            :  */
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span>            : /* Bit 8: (1) HT format, (0) legacy or VHT format */
<span class="lineNum">    3931 </span>            : #define IWM_RATE_MCS_HT_POS 8
<span class="lineNum">    3932 </span>            : #define IWM_RATE_MCS_HT_MSK (1 &lt;&lt; IWM_RATE_MCS_HT_POS)
<span class="lineNum">    3933 </span>            : 
<span class="lineNum">    3934 </span>            : /* Bit 9: (1) CCK, (0) OFDM.  HT (bit 8) must be &quot;0&quot; for this bit to be valid */
<span class="lineNum">    3935 </span>            : #define IWM_RATE_MCS_CCK_POS 9
<span class="lineNum">    3936 </span>            : #define IWM_RATE_MCS_CCK_MSK (1 &lt;&lt; IWM_RATE_MCS_CCK_POS)
<span class="lineNum">    3937 </span>            : 
<span class="lineNum">    3938 </span>            : /* Bit 26: (1) VHT format, (0) legacy format in bits 8:0 */
<span class="lineNum">    3939 </span>            : #define IWM_RATE_MCS_VHT_POS 26
<span class="lineNum">    3940 </span>            : #define IWM_RATE_MCS_VHT_MSK (1 &lt;&lt; IWM_RATE_MCS_VHT_POS)
<span class="lineNum">    3941 </span>            : 
<span class="lineNum">    3942 </span>            : 
<span class="lineNum">    3943 </span>            : /*
<span class="lineNum">    3944 </span>            :  * High-throughput (HT) rate format for bits 7:0
<span class="lineNum">    3945 </span>            :  *
<span class="lineNum">    3946 </span>            :  *  2-0:  MCS rate base
<span class="lineNum">    3947 </span>            :  *        0)   6 Mbps
<span class="lineNum">    3948 </span>            :  *        1)  12 Mbps
<span class="lineNum">    3949 </span>            :  *        2)  18 Mbps
<span class="lineNum">    3950 </span>            :  *        3)  24 Mbps
<span class="lineNum">    3951 </span>            :  *        4)  36 Mbps
<span class="lineNum">    3952 </span>            :  *        5)  48 Mbps
<span class="lineNum">    3953 </span>            :  *        6)  54 Mbps
<span class="lineNum">    3954 </span>            :  *        7)  60 Mbps
<span class="lineNum">    3955 </span>            :  *  4-3:  0)  Single stream (SISO)
<span class="lineNum">    3956 </span>            :  *        1)  Dual stream (MIMO)
<span class="lineNum">    3957 </span>            :  *        2)  Triple stream (MIMO)
<span class="lineNum">    3958 </span>            :  *    5:  Value of 0x20 in bits 7:0 indicates 6 Mbps HT40 duplicate data
<span class="lineNum">    3959 </span>            :  *  (bits 7-6 are zero)
<span class="lineNum">    3960 </span>            :  *
<span class="lineNum">    3961 </span>            :  * Together the low 5 bits work out to the MCS index because we don't
<span class="lineNum">    3962 </span>            :  * support MCSes above 15/23, and 0-7 have one stream, 8-15 have two
<span class="lineNum">    3963 </span>            :  * streams and 16-23 have three streams. We could also support MCS 32
<span class="lineNum">    3964 </span>            :  * which is the duplicate 20 MHz MCS (bit 5 set, all others zero.)
<span class="lineNum">    3965 </span>            :  */
<span class="lineNum">    3966 </span>            : #define IWM_RATE_HT_MCS_RATE_CODE_MSK   0x7
<span class="lineNum">    3967 </span>            : #define IWM_RATE_HT_MCS_NSS_POS             3
<span class="lineNum">    3968 </span>            : #define IWM_RATE_HT_MCS_NSS_MSK             (3 &lt;&lt; IWM_RATE_HT_MCS_NSS_POS)
<span class="lineNum">    3969 </span>            : 
<span class="lineNum">    3970 </span>            : /* Bit 10: (1) Use Green Field preamble */
<span class="lineNum">    3971 </span>            : #define IWM_RATE_HT_MCS_GF_POS          10
<span class="lineNum">    3972 </span>            : #define IWM_RATE_HT_MCS_GF_MSK          (1 &lt;&lt; IWM_RATE_HT_MCS_GF_POS)
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span>            : #define IWM_RATE_HT_MCS_INDEX_MSK               0x3f
<span class="lineNum">    3975 </span>            : 
<span class="lineNum">    3976 </span>            : /*
<span class="lineNum">    3977 </span>            :  * Very High-throughput (VHT) rate format for bits 7:0
<span class="lineNum">    3978 </span>            :  *
<span class="lineNum">    3979 </span>            :  *  3-0:  VHT MCS (0-9)
<span class="lineNum">    3980 </span>            :  *  5-4:  number of streams - 1:
<span class="lineNum">    3981 </span>            :  *        0)  Single stream (SISO)
<span class="lineNum">    3982 </span>            :  *        1)  Dual stream (MIMO)
<span class="lineNum">    3983 </span>            :  *        2)  Triple stream (MIMO)
<span class="lineNum">    3984 </span>            :  */
<span class="lineNum">    3985 </span>            : 
<span class="lineNum">    3986 </span>            : /* Bit 4-5: (0) SISO, (1) MIMO2 (2) MIMO3 */
<span class="lineNum">    3987 </span>            : #define IWM_RATE_VHT_MCS_RATE_CODE_MSK  0xf
<span class="lineNum">    3988 </span>            : #define IWM_RATE_VHT_MCS_NSS_POS                4
<span class="lineNum">    3989 </span>            : #define IWM_RATE_VHT_MCS_NSS_MSK                (3 &lt;&lt; IWM_RATE_VHT_MCS_NSS_POS)
<span class="lineNum">    3990 </span>            : 
<span class="lineNum">    3991 </span>            : /*
<span class="lineNum">    3992 </span>            :  * Legacy OFDM rate format for bits 7:0
<span class="lineNum">    3993 </span>            :  *
<span class="lineNum">    3994 </span>            :  *  3-0:  0xD)   6 Mbps
<span class="lineNum">    3995 </span>            :  *        0xF)   9 Mbps
<span class="lineNum">    3996 </span>            :  *        0x5)  12 Mbps
<span class="lineNum">    3997 </span>            :  *        0x7)  18 Mbps
<span class="lineNum">    3998 </span>            :  *        0x9)  24 Mbps
<span class="lineNum">    3999 </span>            :  *        0xB)  36 Mbps
<span class="lineNum">    4000 </span>            :  *        0x1)  48 Mbps
<span class="lineNum">    4001 </span>            :  *        0x3)  54 Mbps
<span class="lineNum">    4002 </span>            :  * (bits 7-4 are 0)
<span class="lineNum">    4003 </span>            :  *
<span class="lineNum">    4004 </span>            :  * Legacy CCK rate format for bits 7:0:
<span class="lineNum">    4005 </span>            :  * bit 8 is 0, bit 26 is 0, bit 9 is 1 (CCK):
<span class="lineNum">    4006 </span>            :  *
<span class="lineNum">    4007 </span>            :  *  6-0:   10)  1 Mbps
<span class="lineNum">    4008 </span>            :  *         20)  2 Mbps
<span class="lineNum">    4009 </span>            :  *         55)  5.5 Mbps
<span class="lineNum">    4010 </span>            :  *        110)  11 Mbps
<span class="lineNum">    4011 </span>            :  * (bit 7 is 0)
<span class="lineNum">    4012 </span>            :  */
<span class="lineNum">    4013 </span>            : #define IWM_RATE_LEGACY_RATE_MSK 0xff
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span>            : 
<span class="lineNum">    4016 </span>            : /*
<span class="lineNum">    4017 </span>            :  * Bit 11-12: (0) 20MHz, (1) 40MHz, (2) 80MHz, (3) 160MHz
<span class="lineNum">    4018 </span>            :  * 0 and 1 are valid for HT and VHT, 2 and 3 only for VHT
<span class="lineNum">    4019 </span>            :  */
<span class="lineNum">    4020 </span>            : #define IWM_RATE_MCS_CHAN_WIDTH_POS             11
<span class="lineNum">    4021 </span>            : #define IWM_RATE_MCS_CHAN_WIDTH_MSK             (3 &lt;&lt; IWM_RATE_MCS_CHAN_WIDTH_POS)
<span class="lineNum">    4022 </span>            : #define IWM_RATE_MCS_CHAN_WIDTH_20              (0 &lt;&lt; IWM_RATE_MCS_CHAN_WIDTH_POS)
<span class="lineNum">    4023 </span>            : #define IWM_RATE_MCS_CHAN_WIDTH_40              (1 &lt;&lt; IWM_RATE_MCS_CHAN_WIDTH_POS)
<span class="lineNum">    4024 </span>            : #define IWM_RATE_MCS_CHAN_WIDTH_80              (2 &lt;&lt; IWM_RATE_MCS_CHAN_WIDTH_POS)
<span class="lineNum">    4025 </span>            : #define IWM_RATE_MCS_CHAN_WIDTH_160             (3 &lt;&lt; IWM_RATE_MCS_CHAN_WIDTH_POS)
<span class="lineNum">    4026 </span>            : 
<span class="lineNum">    4027 </span>            : /* Bit 13: (1) Short guard interval (0.4 usec), (0) normal GI (0.8 usec) */
<span class="lineNum">    4028 </span>            : #define IWM_RATE_MCS_SGI_POS            13
<span class="lineNum">    4029 </span>            : #define IWM_RATE_MCS_SGI_MSK            (1 &lt;&lt; IWM_RATE_MCS_SGI_POS)
<span class="lineNum">    4030 </span>            : 
<span class="lineNum">    4031 </span>            : /* Bit 14-16: Antenna selection (1) Ant A, (2) Ant B, (4) Ant C */
<span class="lineNum">    4032 </span>            : #define IWM_RATE_MCS_ANT_POS            14
<span class="lineNum">    4033 </span>            : #define IWM_RATE_MCS_ANT_A_MSK          (1 &lt;&lt; IWM_RATE_MCS_ANT_POS)
<span class="lineNum">    4034 </span>            : #define IWM_RATE_MCS_ANT_B_MSK          (2 &lt;&lt; IWM_RATE_MCS_ANT_POS)
<span class="lineNum">    4035 </span>            : #define IWM_RATE_MCS_ANT_C_MSK          (4 &lt;&lt; IWM_RATE_MCS_ANT_POS)
<span class="lineNum">    4036 </span>            : #define IWM_RATE_MCS_ANT_AB_MSK         (IWM_RATE_MCS_ANT_A_MSK | \
<span class="lineNum">    4037 </span>            :                                          IWM_RATE_MCS_ANT_B_MSK)
<span class="lineNum">    4038 </span>            : #define IWM_RATE_MCS_ANT_ABC_MSK                (IWM_RATE_MCS_ANT_AB_MSK | \
<span class="lineNum">    4039 </span>            :                                          IWM_RATE_MCS_ANT_C_MSK)
<span class="lineNum">    4040 </span>            : #define IWM_RATE_MCS_ANT_MSK            IWM_RATE_MCS_ANT_ABC_MSK
<span class="lineNum">    4041 </span>            : #define IWM_RATE_MCS_ANT_NUM 3
<span class="lineNum">    4042 </span>            : 
<span class="lineNum">    4043 </span>            : /* Bit 17-18: (0) SS, (1) SS*2 */
<span class="lineNum">    4044 </span>            : #define IWM_RATE_MCS_STBC_POS           17
<span class="lineNum">    4045 </span>            : #define IWM_RATE_MCS_STBC_MSK           (1 &lt;&lt; IWM_RATE_MCS_STBC_POS)
<span class="lineNum">    4046 </span>            : 
<span class="lineNum">    4047 </span>            : /* Bit 19: (0) Beamforming is off, (1) Beamforming is on */
<span class="lineNum">    4048 </span>            : #define IWM_RATE_MCS_BF_POS                     19
<span class="lineNum">    4049 </span>            : #define IWM_RATE_MCS_BF_MSK                     (1 &lt;&lt; IWM_RATE_MCS_BF_POS)
<span class="lineNum">    4050 </span>            : 
<span class="lineNum">    4051 </span>            : /* Bit 20: (0) ZLF is off, (1) ZLF is on */
<span class="lineNum">    4052 </span>            : #define IWM_RATE_MCS_ZLF_POS            20
<span class="lineNum">    4053 </span>            : #define IWM_RATE_MCS_ZLF_MSK            (1 &lt;&lt; IWM_RATE_MCS_ZLF_POS)
<span class="lineNum">    4054 </span>            : 
<span class="lineNum">    4055 </span>            : /* Bit 24-25: (0) 20MHz (no dup), (1) 2x20MHz, (2) 4x20MHz, 3 8x20MHz */
<span class="lineNum">    4056 </span>            : #define IWM_RATE_MCS_DUP_POS            24
<span class="lineNum">    4057 </span>            : #define IWM_RATE_MCS_DUP_MSK            (3 &lt;&lt; IWM_RATE_MCS_DUP_POS)
<span class="lineNum">    4058 </span>            : 
<span class="lineNum">    4059 </span>            : /* Bit 27: (1) LDPC enabled, (0) LDPC disabled */
<span class="lineNum">    4060 </span>            : #define IWM_RATE_MCS_LDPC_POS           27
<span class="lineNum">    4061 </span>            : #define IWM_RATE_MCS_LDPC_MSK           (1 &lt;&lt; IWM_RATE_MCS_LDPC_POS)
<span class="lineNum">    4062 </span>            : 
<span class="lineNum">    4063 </span>            : 
<span class="lineNum">    4064 </span>            : /* Link Quality definitions */
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span>            : /* # entries in rate scale table to support Tx retries */
<span class="lineNum">    4067 </span>            : #define  IWM_LQ_MAX_RETRY_NUM 16
<span class="lineNum">    4068 </span>            : 
<span class="lineNum">    4069 </span>            : /* Link quality command flags bit fields */
<span class="lineNum">    4070 </span>            : 
<span class="lineNum">    4071 </span>            : /* Bit 0: (0) Don't use RTS (1) Use RTS */
<span class="lineNum">    4072 </span>            : #define IWM_LQ_FLAG_USE_RTS_POS             0
<span class="lineNum">    4073 </span>            : #define IWM_LQ_FLAG_USE_RTS_MSK         (1 &lt;&lt; IWM_LQ_FLAG_USE_RTS_POS)
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span>            : /* Bit 1-3: LQ command color. Used to match responses to LQ commands */
<span class="lineNum">    4076 </span>            : #define IWM_LQ_FLAG_COLOR_POS               1
<span class="lineNum">    4077 </span>            : #define IWM_LQ_FLAG_COLOR_MSK               (7 &lt;&lt; IWM_LQ_FLAG_COLOR_POS)
<span class="lineNum">    4078 </span>            : 
<span class="lineNum">    4079 </span>            : /* Bit 4-5: Tx RTS BW Signalling
<span class="lineNum">    4080 </span>            :  * (0) No RTS BW signalling
<span class="lineNum">    4081 </span>            :  * (1) Static BW signalling
<span class="lineNum">    4082 </span>            :  * (2) Dynamic BW signalling
<span class="lineNum">    4083 </span>            :  */
<span class="lineNum">    4084 </span>            : #define IWM_LQ_FLAG_RTS_BW_SIG_POS          4
<span class="lineNum">    4085 </span>            : #define IWM_LQ_FLAG_RTS_BW_SIG_NONE         (0 &lt;&lt; IWM_LQ_FLAG_RTS_BW_SIG_POS)
<span class="lineNum">    4086 </span>            : #define IWM_LQ_FLAG_RTS_BW_SIG_STATIC       (1 &lt;&lt; IWM_LQ_FLAG_RTS_BW_SIG_POS)
<span class="lineNum">    4087 </span>            : #define IWM_LQ_FLAG_RTS_BW_SIG_DYNAMIC      (2 &lt;&lt; IWM_LQ_FLAG_RTS_BW_SIG_POS)
<span class="lineNum">    4088 </span>            : 
<span class="lineNum">    4089 </span>            : /* Bit 6: (0) No dynamic BW selection (1) Allow dynamic BW selection
<span class="lineNum">    4090 </span>            :  * Dyanmic BW selection allows Tx with narrower BW then requested in rates
<span class="lineNum">    4091 </span>            :  */
<span class="lineNum">    4092 </span>            : #define IWM_LQ_FLAG_DYNAMIC_BW_POS          6
<span class="lineNum">    4093 </span>            : #define IWM_LQ_FLAG_DYNAMIC_BW_MSK          (1 &lt;&lt; IWM_LQ_FLAG_DYNAMIC_BW_POS)
<span class="lineNum">    4094 </span>            : 
<span class="lineNum">    4095 </span>            : /* Antenna flags. */
<span class="lineNum">    4096 </span>            : #define IWM_ANT_A       (1 &lt;&lt; 0)
<span class="lineNum">    4097 </span>            : #define IWM_ANT_B       (1 &lt;&lt; 1)
<span class="lineNum">    4098 </span>            : #define IWM_ANT_C       (1 &lt;&lt; 2)
<span class="lineNum">    4099 </span>            : /* Shortcuts. */
<span class="lineNum">    4100 </span>            : #define IWM_ANT_AB      (IWM_ANT_A | IWM_ANT_B)
<span class="lineNum">    4101 </span>            : #define IWM_ANT_BC      (IWM_ANT_B | IWM_ANT_C)
<span class="lineNum">    4102 </span>            : #define IWM_ANT_ABC     (IWM_ANT_A | IWM_ANT_B | IWM_ANT_C)
<span class="lineNum">    4103 </span>            : 
<span class="lineNum">    4104 </span>            : /**
<span class="lineNum">    4105 </span>            :  * struct iwm_lq_cmd - link quality command
<span class="lineNum">    4106 </span>            :  * @sta_id: station to update
<span class="lineNum">    4107 </span>            :  * @control: not used
<span class="lineNum">    4108 </span>            :  * @flags: combination of IWM_LQ_FLAG_*
<span class="lineNum">    4109 </span>            :  * @mimo_delim: the first SISO index in rs_table, which separates MIMO
<span class="lineNum">    4110 </span>            :  *      and SISO rates
<span class="lineNum">    4111 </span>            :  * @single_stream_ant_msk: best antenna for SISO (can be dual in CDD).
<span class="lineNum">    4112 </span>            :  *      Should be IWM_ANT_[ABC]
<span class="lineNum">    4113 </span>            :  * @dual_stream_ant_msk: best antennas for MIMO, combination of IWM_ANT_[ABC]
<span class="lineNum">    4114 </span>            :  * @initial_rate_index: first index from rs_table per AC category
<span class="lineNum">    4115 </span>            :  * @agg_time_limit: aggregation max time threshold in usec/100, meaning
<span class="lineNum">    4116 </span>            :  *      value of 100 is one usec. Range is 100 to 8000
<span class="lineNum">    4117 </span>            :  * @agg_disable_start_th: try-count threshold for starting aggregation.
<span class="lineNum">    4118 </span>            :  *      If a frame has higher try-count, it should not be selected for
<span class="lineNum">    4119 </span>            :  *      starting an aggregation sequence.
<span class="lineNum">    4120 </span>            :  * @agg_frame_cnt_limit: max frame count in an aggregation.
<span class="lineNum">    4121 </span>            :  *      0: no limit
<span class="lineNum">    4122 </span>            :  *      1: no aggregation (one frame per aggregation)
<span class="lineNum">    4123 </span>            :  *      2 - 0x3f: maximal number of frames (up to 3f == 63)
<span class="lineNum">    4124 </span>            :  * @rs_table: array of rates for each TX try, each is rate_n_flags,
<span class="lineNum">    4125 </span>            :  *      meaning it is a combination of IWM_RATE_MCS_* and IWM_RATE_*_PLCP
<span class="lineNum">    4126 </span>            :  * @bf_params: beam forming params, currently not used
<span class="lineNum">    4127 </span>            :  */
<span class="lineNum">    4128 </span>            : struct iwm_lq_cmd {
<span class="lineNum">    4129 </span>            :         uint8_t sta_id;
<span class="lineNum">    4130 </span>            :         uint8_t reserved1;
<span class="lineNum">    4131 </span>            :         uint16_t control;
<span class="lineNum">    4132 </span>            :         /* LINK_QUAL_GENERAL_PARAMS_API_S_VER_1 */
<span class="lineNum">    4133 </span>            :         uint8_t flags;
<span class="lineNum">    4134 </span>            :         uint8_t mimo_delim;
<span class="lineNum">    4135 </span>            :         uint8_t single_stream_ant_msk;
<span class="lineNum">    4136 </span>            :         uint8_t dual_stream_ant_msk;
<span class="lineNum">    4137 </span>            :         uint8_t initial_rate_index[IWM_AC_NUM];
<span class="lineNum">    4138 </span>            :         /* LINK_QUAL_AGG_PARAMS_API_S_VER_1 */
<span class="lineNum">    4139 </span>            :         uint16_t agg_time_limit;
<span class="lineNum">    4140 </span>            :         uint8_t agg_disable_start_th;
<span class="lineNum">    4141 </span>            :         uint8_t agg_frame_cnt_limit;
<span class="lineNum">    4142 </span>            :         uint32_t reserved2;
<span class="lineNum">    4143 </span>            :         uint32_t rs_table[IWM_LQ_MAX_RETRY_NUM];
<span class="lineNum">    4144 </span>            :         uint32_t bf_params;
<span class="lineNum">    4145 </span>            : }; /* LINK_QUALITY_CMD_API_S_VER_1 */
<span class="lineNum">    4146 </span>            : 
<span class="lineNum">    4147 </span>            : /**
<span class="lineNum">    4148 </span>            :  * bitmasks for tx_flags in TX command
<span class="lineNum">    4149 </span>            :  * @IWM_TX_CMD_FLG_PROT_REQUIRE: use RTS or CTS-to-self to protect the frame
<span class="lineNum">    4150 </span>            :  * @IWM_TX_CMD_FLG_ACK: expect ACK from receiving station
<span class="lineNum">    4151 </span>            :  * @IWM_TX_CMD_FLG_STA_RATE: use RS table with initial index from the TX command.
<span class="lineNum">    4152 </span>            :  *      Otherwise, use rate_n_flags from the TX command
<span class="lineNum">    4153 </span>            :  * @IWM_TX_CMD_FLG_BA: this frame is a block ack
<span class="lineNum">    4154 </span>            :  * @IWM_TX_CMD_FLG_BAR: this frame is a BA request, immediate BAR is expected
<span class="lineNum">    4155 </span>            :  *      Must set IWM_TX_CMD_FLG_ACK with this flag.
<span class="lineNum">    4156 </span>            :  * @IWM_TX_CMD_FLG_TXOP_PROT: protect frame with full TXOP protection
<span class="lineNum">    4157 </span>            :  * @IWM_TX_CMD_FLG_VHT_NDPA: mark frame is NDPA for VHT beamformer sequence
<span class="lineNum">    4158 </span>            :  * @IWM_TX_CMD_FLG_HT_NDPA: mark frame is NDPA for HT beamformer sequence
<span class="lineNum">    4159 </span>            :  * @IWM_TX_CMD_FLG_CSI_FDBK2HOST: mark to send feedback to host (only if good CRC)
<span class="lineNum">    4160 </span>            :  * @IWM_TX_CMD_FLG_BT_DIS: disable BT priority for this frame
<span class="lineNum">    4161 </span>            :  * @IWM_TX_CMD_FLG_SEQ_CTL: set if FW should override the sequence control.
<span class="lineNum">    4162 </span>            :  *      Should be set for mgmt, non-QOS data, mcast, bcast and in scan command
<span class="lineNum">    4163 </span>            :  * @IWM_TX_CMD_FLG_MORE_FRAG: this frame is non-last MPDU
<span class="lineNum">    4164 </span>            :  * @IWM_TX_CMD_FLG_NEXT_FRAME: this frame includes information of the next frame
<span class="lineNum">    4165 </span>            :  * @IWM_TX_CMD_FLG_TSF: FW should calculate and insert TSF in the frame
<span class="lineNum">    4166 </span>            :  *      Should be set for beacons and probe responses
<span class="lineNum">    4167 </span>            :  * @IWM_TX_CMD_FLG_CALIB: activate PA TX power calibrations
<span class="lineNum">    4168 </span>            :  * @IWM_TX_CMD_FLG_KEEP_SEQ_CTL: if seq_ctl is set, don't increase inner seq count
<span class="lineNum">    4169 </span>            :  * @IWM_TX_CMD_FLG_AGG_START: allow this frame to start aggregation
<span class="lineNum">    4170 </span>            :  * @IWM_TX_CMD_FLG_MH_PAD: driver inserted 2 byte padding after MAC header.
<span class="lineNum">    4171 </span>            :  *      Should be set for 26/30 length MAC headers
<span class="lineNum">    4172 </span>            :  * @IWM_TX_CMD_FLG_RESP_TO_DRV: zero this if the response should go only to FW
<span class="lineNum">    4173 </span>            :  * @IWM_TX_CMD_FLG_CCMP_AGG: this frame uses CCMP for aggregation acceleration
<span class="lineNum">    4174 </span>            :  * @IWM_TX_CMD_FLG_TKIP_MIC_DONE: FW already performed TKIP MIC calculation
<span class="lineNum">    4175 </span>            :  * @IWM_TX_CMD_FLG_DUR: disable duration overwriting used in PS-Poll Assoc-id
<span class="lineNum">    4176 </span>            :  * @IWM_TX_CMD_FLG_FW_DROP: FW should mark frame to be dropped
<span class="lineNum">    4177 </span>            :  * @IWM_TX_CMD_FLG_EXEC_PAPD: execute PAPD
<span class="lineNum">    4178 </span>            :  * @IWM_TX_CMD_FLG_PAPD_TYPE: 0 for reference power, 1 for nominal power
<span class="lineNum">    4179 </span>            :  * @IWM_TX_CMD_FLG_HCCA_CHUNK: mark start of TSPEC chunk
<span class="lineNum">    4180 </span>            :  */
<span class="lineNum">    4181 </span>            : #define IWM_TX_CMD_FLG_PROT_REQUIRE     (1 &lt;&lt; 0)
<span class="lineNum">    4182 </span>            : #define IWM_TX_CMD_FLG_ACK              (1 &lt;&lt; 3)
<span class="lineNum">    4183 </span>            : #define IWM_TX_CMD_FLG_STA_RATE         (1 &lt;&lt; 4)
<span class="lineNum">    4184 </span>            : #define IWM_TX_CMD_FLG_BA               (1 &lt;&lt; 5)
<span class="lineNum">    4185 </span>            : #define IWM_TX_CMD_FLG_BAR              (1 &lt;&lt; 6)
<span class="lineNum">    4186 </span>            : #define IWM_TX_CMD_FLG_TXOP_PROT        (1 &lt;&lt; 7)
<span class="lineNum">    4187 </span>            : #define IWM_TX_CMD_FLG_VHT_NDPA         (1 &lt;&lt; 8)
<span class="lineNum">    4188 </span>            : #define IWM_TX_CMD_FLG_HT_NDPA          (1 &lt;&lt; 9)
<span class="lineNum">    4189 </span>            : #define IWM_TX_CMD_FLG_CSI_FDBK2HOST    (1 &lt;&lt; 10)
<span class="lineNum">    4190 </span>            : #define IWM_TX_CMD_FLG_BT_DIS           (1 &lt;&lt; 12)
<span class="lineNum">    4191 </span>            : #define IWM_TX_CMD_FLG_SEQ_CTL          (1 &lt;&lt; 13)
<span class="lineNum">    4192 </span>            : #define IWM_TX_CMD_FLG_MORE_FRAG        (1 &lt;&lt; 14)
<span class="lineNum">    4193 </span>            : #define IWM_TX_CMD_FLG_NEXT_FRAME       (1 &lt;&lt; 15)
<span class="lineNum">    4194 </span>            : #define IWM_TX_CMD_FLG_TSF              (1 &lt;&lt; 16)
<span class="lineNum">    4195 </span>            : #define IWM_TX_CMD_FLG_CALIB            (1 &lt;&lt; 17)
<span class="lineNum">    4196 </span>            : #define IWM_TX_CMD_FLG_KEEP_SEQ_CTL     (1 &lt;&lt; 18)
<span class="lineNum">    4197 </span>            : #define IWM_TX_CMD_FLG_AGG_START        (1 &lt;&lt; 19)
<span class="lineNum">    4198 </span>            : #define IWM_TX_CMD_FLG_MH_PAD           (1 &lt;&lt; 20)
<span class="lineNum">    4199 </span>            : #define IWM_TX_CMD_FLG_RESP_TO_DRV      (1 &lt;&lt; 21)
<span class="lineNum">    4200 </span>            : #define IWM_TX_CMD_FLG_CCMP_AGG         (1 &lt;&lt; 22)
<span class="lineNum">    4201 </span>            : #define IWM_TX_CMD_FLG_TKIP_MIC_DONE    (1 &lt;&lt; 23)
<span class="lineNum">    4202 </span>            : #define IWM_TX_CMD_FLG_DUR              (1 &lt;&lt; 25)
<span class="lineNum">    4203 </span>            : #define IWM_TX_CMD_FLG_FW_DROP          (1 &lt;&lt; 26)
<span class="lineNum">    4204 </span>            : #define IWM_TX_CMD_FLG_EXEC_PAPD        (1 &lt;&lt; 27)
<span class="lineNum">    4205 </span>            : #define IWM_TX_CMD_FLG_PAPD_TYPE        (1 &lt;&lt; 28)
<span class="lineNum">    4206 </span>            : #define IWM_TX_CMD_FLG_HCCA_CHUNK       (1 &lt;&lt; 31)
<span class="lineNum">    4207 </span>            : /* IWM_TX_FLAGS_BITS_API_S_VER_1 */
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span>            : /*
<span class="lineNum">    4210 </span>            :  * TX command security control
<span class="lineNum">    4211 </span>            :  */
<span class="lineNum">    4212 </span>            : #define IWM_TX_CMD_SEC_WEP              0x01
<span class="lineNum">    4213 </span>            : #define IWM_TX_CMD_SEC_CCM              0x02
<span class="lineNum">    4214 </span>            : #define IWM_TX_CMD_SEC_TKIP             0x03
<span class="lineNum">    4215 </span>            : #define IWM_TX_CMD_SEC_EXT              0x04
<span class="lineNum">    4216 </span>            : #define IWM_TX_CMD_SEC_MSK              0x07
<span class="lineNum">    4217 </span>            : #define IWM_TX_CMD_SEC_WEP_KEY_IDX_POS  6
<span class="lineNum">    4218 </span>            : #define IWM_TX_CMD_SEC_WEP_KEY_IDX_MSK  0xc0
<span class="lineNum">    4219 </span>            : #define IWM_TX_CMD_SEC_KEY128           0x08
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span>            : /* TODO: how does these values are OK with only 16 bit variable??? */
<span class="lineNum">    4222 </span>            : /*
<span class="lineNum">    4223 </span>            :  * TX command next frame info
<span class="lineNum">    4224 </span>            :  *
<span class="lineNum">    4225 </span>            :  * bits 0:2 - security control (IWM_TX_CMD_SEC_*)
<span class="lineNum">    4226 </span>            :  * bit 3 - immediate ACK required
<span class="lineNum">    4227 </span>            :  * bit 4 - rate is taken from STA table
<span class="lineNum">    4228 </span>            :  * bit 5 - frame belongs to BA stream
<span class="lineNum">    4229 </span>            :  * bit 6 - immediate BA response expected
<span class="lineNum">    4230 </span>            :  * bit 7 - unused
<span class="lineNum">    4231 </span>            :  * bits 8:15 - Station ID
<span class="lineNum">    4232 </span>            :  * bits 16:31 - rate
<span class="lineNum">    4233 </span>            :  */
<span class="lineNum">    4234 </span>            : #define IWM_TX_CMD_NEXT_FRAME_ACK_MSK           (0x8)
<span class="lineNum">    4235 </span>            : #define IWM_TX_CMD_NEXT_FRAME_STA_RATE_MSK      (0x10)
<span class="lineNum">    4236 </span>            : #define IWM_TX_CMD_NEXT_FRAME_BA_MSK            (0x20)
<span class="lineNum">    4237 </span>            : #define IWM_TX_CMD_NEXT_FRAME_IMM_BA_RSP_MSK    (0x40)
<span class="lineNum">    4238 </span>            : #define IWM_TX_CMD_NEXT_FRAME_FLAGS_MSK         (0xf8)
<span class="lineNum">    4239 </span>            : #define IWM_TX_CMD_NEXT_FRAME_STA_ID_MSK        (0xff00)
<span class="lineNum">    4240 </span>            : #define IWM_TX_CMD_NEXT_FRAME_STA_ID_POS        (8)
<span class="lineNum">    4241 </span>            : #define IWM_TX_CMD_NEXT_FRAME_RATE_MSK          (0xffff0000)
<span class="lineNum">    4242 </span>            : #define IWM_TX_CMD_NEXT_FRAME_RATE_POS          (16)
<span class="lineNum">    4243 </span>            : 
<span class="lineNum">    4244 </span>            : /*
<span class="lineNum">    4245 </span>            :  * TX command Frame life time in us - to be written in pm_frame_timeout
<span class="lineNum">    4246 </span>            :  */
<span class="lineNum">    4247 </span>            : #define IWM_TX_CMD_LIFE_TIME_INFINITE   0xFFFFFFFF
<span class="lineNum">    4248 </span>            : #define IWM_TX_CMD_LIFE_TIME_DEFAULT    2000000 /* 2000 ms*/
<span class="lineNum">    4249 </span>            : #define IWM_TX_CMD_LIFE_TIME_PROBE_RESP 40000 /* 40 ms */
<span class="lineNum">    4250 </span>            : #define IWM_TX_CMD_LIFE_TIME_EXPIRED_FRAME      0
<span class="lineNum">    4251 </span>            : 
<span class="lineNum">    4252 </span>            : /*
<span class="lineNum">    4253 </span>            :  * TID for non QoS frames - to be written in tid_tspec
<span class="lineNum">    4254 </span>            :  */
<span class="lineNum">    4255 </span>            : #define IWM_TID_NON_QOS IWM_MAX_TID_COUNT
<span class="lineNum">    4256 </span>            : 
<span class="lineNum">    4257 </span>            : /*
<span class="lineNum">    4258 </span>            :  * Limits on the retransmissions - to be written in {data,rts}_retry_limit
<span class="lineNum">    4259 </span>            :  */
<span class="lineNum">    4260 </span>            : #define IWM_DEFAULT_TX_RETRY                    15
<span class="lineNum">    4261 </span>            : #define IWM_MGMT_DFAULT_RETRY_LIMIT             3
<span class="lineNum">    4262 </span>            : #define IWM_RTS_DFAULT_RETRY_LIMIT              3
<span class="lineNum">    4263 </span>            : #define IWM_BAR_DFAULT_RETRY_LIMIT              60
<span class="lineNum">    4264 </span>            : #define IWM_LOW_RETRY_LIMIT                     7
<span class="lineNum">    4265 </span>            : 
<span class="lineNum">    4266 </span>            : /* TODO: complete documentation for try_cnt and btkill_cnt */
<span class="lineNum">    4267 </span>            : /**
<span class="lineNum">    4268 </span>            :  * struct iwm_tx_cmd - TX command struct to FW
<span class="lineNum">    4269 </span>            :  * ( IWM_TX_CMD = 0x1c )
<span class="lineNum">    4270 </span>            :  * @len: in bytes of the payload, see below for details
<span class="lineNum">    4271 </span>            :  * @next_frame_len: same as len, but for next frame (0 if not applicable)
<span class="lineNum">    4272 </span>            :  *      Used for fragmentation and bursting, but not in 11n aggregation.
<span class="lineNum">    4273 </span>            :  * @tx_flags: combination of IWM_TX_CMD_FLG_*
<span class="lineNum">    4274 </span>            :  * @rate_n_flags: rate for *all* Tx attempts, if IWM_TX_CMD_FLG_STA_RATE_MSK is
<span class="lineNum">    4275 </span>            :  *      cleared. Combination of IWM_RATE_MCS_*
<span class="lineNum">    4276 </span>            :  * @sta_id: index of destination station in FW station table
<span class="lineNum">    4277 </span>            :  * @sec_ctl: security control, IWM_TX_CMD_SEC_*
<span class="lineNum">    4278 </span>            :  * @initial_rate_index: index into the rate table for initial TX attempt.
<span class="lineNum">    4279 </span>            :  *      Applied if IWM_TX_CMD_FLG_STA_RATE_MSK is set, normally 0 for data frames.
<span class="lineNum">    4280 </span>            :  * @key: security key
<span class="lineNum">    4281 </span>            :  * @next_frame_flags: IWM_TX_CMD_SEC_* and IWM_TX_CMD_NEXT_FRAME_*
<span class="lineNum">    4282 </span>            :  * @life_time: frame life time (usecs??)
<span class="lineNum">    4283 </span>            :  * @dram_lsb_ptr: Physical address of scratch area in the command (try_cnt +
<span class="lineNum">    4284 </span>            :  *      btkill_cnd + reserved), first 32 bits. &quot;0&quot; disables usage.
<span class="lineNum">    4285 </span>            :  * @dram_msb_ptr: upper bits of the scratch physical address
<span class="lineNum">    4286 </span>            :  * @rts_retry_limit: max attempts for RTS
<span class="lineNum">    4287 </span>            :  * @data_retry_limit: max attempts to send the data packet
<span class="lineNum">    4288 </span>            :  * @tid_spec: TID/tspec
<span class="lineNum">    4289 </span>            :  * @pm_frame_timeout: PM TX frame timeout
<span class="lineNum">    4290 </span>            :  * @driver_txop: duration od EDCA TXOP, in 32-usec units. Set this if not
<span class="lineNum">    4291 </span>            :  *      specified by HCCA protocol
<span class="lineNum">    4292 </span>            :  *
<span class="lineNum">    4293 </span>            :  * The byte count (both len and next_frame_len) includes MAC header
<span class="lineNum">    4294 </span>            :  * (24/26/30/32 bytes)
<span class="lineNum">    4295 </span>            :  * + 2 bytes pad if 26/30 header size
<span class="lineNum">    4296 </span>            :  * + 8 byte IV for CCM or TKIP (not used for WEP)
<span class="lineNum">    4297 </span>            :  * + Data payload
<span class="lineNum">    4298 </span>            :  * + 8-byte MIC (not used for CCM/WEP)
<span class="lineNum">    4299 </span>            :  * It does not include post-MAC padding, i.e.,
<span class="lineNum">    4300 </span>            :  * MIC (CCM) 8 bytes, ICV (WEP/TKIP/CKIP) 4 bytes, CRC 4 bytes.
<span class="lineNum">    4301 </span>            :  * Range of len: 14-2342 bytes.
<span class="lineNum">    4302 </span>            :  *
<span class="lineNum">    4303 </span>            :  * After the struct fields the MAC header is placed, plus any padding,
<span class="lineNum">    4304 </span>            :  * and then the actial payload.
<span class="lineNum">    4305 </span>            :  */
<span class="lineNum">    4306 </span>            : struct iwm_tx_cmd {
<span class="lineNum">    4307 </span>            :         uint16_t len;
<span class="lineNum">    4308 </span>            :         uint16_t next_frame_len;
<span class="lineNum">    4309 </span>            :         uint32_t tx_flags;
<span class="lineNum">    4310 </span>            :         struct {
<span class="lineNum">    4311 </span>            :                 uint8_t try_cnt;
<span class="lineNum">    4312 </span>            :                 uint8_t btkill_cnt;
<span class="lineNum">    4313 </span>            :                 uint16_t reserved;
<span class="lineNum">    4314 </span>            :         } scratch; /* DRAM_SCRATCH_API_U_VER_1 */
<span class="lineNum">    4315 </span>            :         uint32_t rate_n_flags;
<span class="lineNum">    4316 </span>            :         uint8_t sta_id;
<span class="lineNum">    4317 </span>            :         uint8_t sec_ctl;
<span class="lineNum">    4318 </span>            :         uint8_t initial_rate_index;
<span class="lineNum">    4319 </span>            :         uint8_t reserved2;
<span class="lineNum">    4320 </span>            :         uint8_t key[16];
<span class="lineNum">    4321 </span>            :         uint16_t next_frame_flags;
<span class="lineNum">    4322 </span>            :         uint16_t reserved3;
<span class="lineNum">    4323 </span>            :         uint32_t life_time;
<span class="lineNum">    4324 </span>            :         uint32_t dram_lsb_ptr;
<span class="lineNum">    4325 </span>            :         uint8_t dram_msb_ptr;
<span class="lineNum">    4326 </span>            :         uint8_t rts_retry_limit;
<span class="lineNum">    4327 </span>            :         uint8_t data_retry_limit;
<span class="lineNum">    4328 </span>            :         uint8_t tid_tspec;
<span class="lineNum">    4329 </span>            :         uint16_t pm_frame_timeout;
<span class="lineNum">    4330 </span>            :         uint16_t driver_txop;
<span class="lineNum">    4331 </span>            :         uint8_t payload[0];
<span class="lineNum">    4332 </span>            :         struct ieee80211_frame hdr[0];
<span class="lineNum">    4333 </span>            : } __packed; /* IWM_TX_CMD_API_S_VER_3 */
<span class="lineNum">    4334 </span>            : 
<span class="lineNum">    4335 </span>            : /*
<span class="lineNum">    4336 </span>            :  * TX response related data
<span class="lineNum">    4337 </span>            :  */
<span class="lineNum">    4338 </span>            : 
<span class="lineNum">    4339 </span>            : /*
<span class="lineNum">    4340 </span>            :  * status that is returned by the fw after attempts to Tx
<span class="lineNum">    4341 </span>            :  * @IWM_TX_STATUS_FAIL_STA_COLOR_MISMATCH: mismatch between color of Tx cmd and
<span class="lineNum">    4342 </span>            :  *      STA table
<span class="lineNum">    4343 </span>            :  * Valid only if frame_count =1
<span class="lineNum">    4344 </span>            :  */
<span class="lineNum">    4345 </span>            : #define IWM_TX_STATUS_MSK               0x000000ff
<span class="lineNum">    4346 </span>            : #define IWM_TX_STATUS_SUCCESS           0x01
<span class="lineNum">    4347 </span>            : #define IWM_TX_STATUS_DIRECT_DONE       0x02
<span class="lineNum">    4348 </span>            : /* postpone TX */
<span class="lineNum">    4349 </span>            : #define IWM_TX_STATUS_POSTPONE_DELAY            0x40
<span class="lineNum">    4350 </span>            : #define IWM_TX_STATUS_POSTPONE_FEW_BYTES        0x41
<span class="lineNum">    4351 </span>            : #define IWM_TX_STATUS_POSTPONE_BT_PRIO          0x42
<span class="lineNum">    4352 </span>            : #define IWM_TX_STATUS_POSTPONE_QUIET_PERIOD     0x43
<span class="lineNum">    4353 </span>            : #define IWM_TX_STATUS_POSTPONE_CALC_TTAK        0x44
<span class="lineNum">    4354 </span>            : /* abort TX */
<span class="lineNum">    4355 </span>            : #define IWM_TX_STATUS_FAIL_INTERNAL_CROSSED_RETRY       0x81
<span class="lineNum">    4356 </span>            : #define IWM_TX_STATUS_FAIL_SHORT_LIMIT                  0x82
<span class="lineNum">    4357 </span>            : #define IWM_TX_STATUS_FAIL_LONG_LIMIT                   0x83
<span class="lineNum">    4358 </span>            : #define IWM_TX_STATUS_FAIL_UNDERRUN                     0x84
<span class="lineNum">    4359 </span>            : #define IWM_TX_STATUS_FAIL_DRAIN_FLOW                   0x85
<span class="lineNum">    4360 </span>            : #define IWM_TX_STATUS_FAIL_RFKILL_FLUSH                 0x86
<span class="lineNum">    4361 </span>            : #define IWM_TX_STATUS_FAIL_LIFE_EXPIRE                  0x87
<span class="lineNum">    4362 </span>            : #define IWM_TX_STATUS_FAIL_DEST_PS                      0x88
<span class="lineNum">    4363 </span>            : #define IWM_TX_STATUS_FAIL_HOST_ABORTED                 0x89
<span class="lineNum">    4364 </span>            : #define IWM_TX_STATUS_FAIL_BT_RETRY                     0x8a
<span class="lineNum">    4365 </span>            : #define IWM_TX_STATUS_FAIL_STA_INVALID                  0x8b
<span class="lineNum">    4366 </span>            : #define IWM_TX_STATUS_FAIL_FRAG_DROPPED                 0x8c
<span class="lineNum">    4367 </span>            : #define IWM_TX_STATUS_FAIL_TID_DISABLE                  0x8d
<span class="lineNum">    4368 </span>            : #define IWM_TX_STATUS_FAIL_FIFO_FLUSHED                 0x8e
<span class="lineNum">    4369 </span>            : #define IWM_TX_STATUS_FAIL_SMALL_CF_POLL                0x8f
<span class="lineNum">    4370 </span>            : #define IWM_TX_STATUS_FAIL_FW_DROP                      0x90
<span class="lineNum">    4371 </span>            : #define IWM_TX_STATUS_FAIL_STA_COLOR_MISMATCH           0x91
<span class="lineNum">    4372 </span>            : #define IWM_TX_STATUS_INTERNAL_ABORT                    0x92
<span class="lineNum">    4373 </span>            : #define IWM_TX_MODE_MSK                 0x00000f00
<span class="lineNum">    4374 </span>            : #define IWM_TX_MODE_NO_BURST            0x00000000
<span class="lineNum">    4375 </span>            : #define IWM_TX_MODE_IN_BURST_SEQ        0x00000100
<span class="lineNum">    4376 </span>            : #define IWM_TX_MODE_FIRST_IN_BURST      0x00000200
<span class="lineNum">    4377 </span>            : #define IWM_TX_QUEUE_NUM_MSK            0x0001f000
<span class="lineNum">    4378 </span>            : #define IWM_TX_NARROW_BW_MSK            0x00060000
<span class="lineNum">    4379 </span>            : #define IWM_TX_NARROW_BW_1DIV2          0x00020000
<span class="lineNum">    4380 </span>            : #define IWM_TX_NARROW_BW_1DIV4          0x00040000
<span class="lineNum">    4381 </span>            : #define IWM_TX_NARROW_BW_1DIV8          0x00060000
<span class="lineNum">    4382 </span>            : 
<span class="lineNum">    4383 </span>            : /*
<span class="lineNum">    4384 </span>            :  * TX aggregation status
<span class="lineNum">    4385 </span>            :  * @IWM_AGG_TX_STATE_TRY_CNT_MSK: Retry count for 1st frame in aggregation (retries
<span class="lineNum">    4386 </span>            :  *      occur if tx failed for this frame when it was a member of a previous
<span class="lineNum">    4387 </span>            :  *      aggregation block). If rate scaling is used, retry count indicates the
<span class="lineNum">    4388 </span>            :  *      rate table entry used for all frames in the new agg.
<span class="lineNum">    4389 </span>            :  * @IWM_AGG_TX_STATE_SEQ_NUM_MSK: Command ID and sequence number of Tx command for
<span class="lineNum">    4390 </span>            :  *      this frame
<span class="lineNum">    4391 </span>            :  */
<span class="lineNum">    4392 </span>            : #define IWM_AGG_TX_STATE_STATUS_MSK             0x0fff
<span class="lineNum">    4393 </span>            : #define IWM_AGG_TX_STATE_TRANSMITTED            0x0000
<span class="lineNum">    4394 </span>            : #define IWM_AGG_TX_STATE_UNDERRUN               0x0001
<span class="lineNum">    4395 </span>            : #define IWM_AGG_TX_STATE_BT_PRIO                0x0002
<span class="lineNum">    4396 </span>            : #define IWM_AGG_TX_STATE_FEW_BYTES              0x0004
<span class="lineNum">    4397 </span>            : #define IWM_AGG_TX_STATE_ABORT                  0x0008
<span class="lineNum">    4398 </span>            : #define IWM_AGG_TX_STATE_LAST_SENT_TTL          0x0010
<span class="lineNum">    4399 </span>            : #define IWM_AGG_TX_STATE_LAST_SENT_TRY_CNT      0x0020
<span class="lineNum">    4400 </span>            : #define IWM_AGG_TX_STATE_LAST_SENT_BT_KILL      0x0040
<span class="lineNum">    4401 </span>            : #define IWM_AGG_TX_STATE_SCD_QUERY              0x0080
<span class="lineNum">    4402 </span>            : #define IWM_AGG_TX_STATE_TEST_BAD_CRC32         0x0100
<span class="lineNum">    4403 </span>            : #define IWM_AGG_TX_STATE_RESPONSE               0x01ff
<span class="lineNum">    4404 </span>            : #define IWM_AGG_TX_STATE_DUMP_TX                0x0200
<span class="lineNum">    4405 </span>            : #define IWM_AGG_TX_STATE_DELAY_TX               0x0400
<span class="lineNum">    4406 </span>            : #define IWM_AGG_TX_STATE_TRY_CNT_POS    12
<span class="lineNum">    4407 </span>            : #define IWM_AGG_TX_STATE_TRY_CNT_MSK    (0xf &lt;&lt; IWM_AGG_TX_STATE_TRY_CNT_POS)
<span class="lineNum">    4408 </span>            : 
<span class="lineNum">    4409 </span>            : #define IWM_AGG_TX_STATE_LAST_SENT_MSK  (IWM_AGG_TX_STATE_LAST_SENT_TTL| \
<span class="lineNum">    4410 </span>            :                                      IWM_AGG_TX_STATE_LAST_SENT_TRY_CNT| \
<span class="lineNum">    4411 </span>            :                                      IWM_AGG_TX_STATE_LAST_SENT_BT_KILL)
<span class="lineNum">    4412 </span>            : 
<span class="lineNum">    4413 </span>            : /*
<span class="lineNum">    4414 </span>            :  * The mask below describes a status where we are absolutely sure that the MPDU
<span class="lineNum">    4415 </span>            :  * wasn't sent. For BA/Underrun we cannot be that sure. All we know that we've
<span class="lineNum">    4416 </span>            :  * written the bytes to the TXE, but we know nothing about what the DSP did.
<span class="lineNum">    4417 </span>            :  */
<span class="lineNum">    4418 </span>            : #define IWM_AGG_TX_STAT_FRAME_NOT_SENT (IWM_AGG_TX_STATE_FEW_BYTES | \
<span class="lineNum">    4419 </span>            :                                     IWM_AGG_TX_STATE_ABORT | \
<span class="lineNum">    4420 </span>            :                                     IWM_AGG_TX_STATE_SCD_QUERY)
<span class="lineNum">    4421 </span>            : 
<span class="lineNum">    4422 </span>            : /*
<span class="lineNum">    4423 </span>            :  * IWM_REPLY_TX = 0x1c (response)
<span class="lineNum">    4424 </span>            :  *
<span class="lineNum">    4425 </span>            :  * This response may be in one of two slightly different formats, indicated
<span class="lineNum">    4426 </span>            :  * by the frame_count field:
<span class="lineNum">    4427 </span>            :  *
<span class="lineNum">    4428 </span>            :  * 1)   No aggregation (frame_count == 1).  This reports Tx results for a single
<span class="lineNum">    4429 </span>            :  *      frame. Multiple attempts, at various bit rates, may have been made for
<span class="lineNum">    4430 </span>            :  *      this frame.
<span class="lineNum">    4431 </span>            :  *
<span class="lineNum">    4432 </span>            :  * 2)   Aggregation (frame_count &gt; 1).  This reports Tx results for two or more
<span class="lineNum">    4433 </span>            :  *      frames that used block-acknowledge.  All frames were transmitted at
<span class="lineNum">    4434 </span>            :  *      same rate. Rate scaling may have been used if first frame in this new
<span class="lineNum">    4435 </span>            :  *      agg block failed in previous agg block(s).
<span class="lineNum">    4436 </span>            :  *
<span class="lineNum">    4437 </span>            :  *      Note that, for aggregation, ACK (block-ack) status is not delivered
<span class="lineNum">    4438 </span>            :  *      here; block-ack has not been received by the time the device records
<span class="lineNum">    4439 </span>            :  *      this status.
<span class="lineNum">    4440 </span>            :  *      This status relates to reasons the tx might have been blocked or aborted
<span class="lineNum">    4441 </span>            :  *      within the device, rather than whether it was received successfully by
<span class="lineNum">    4442 </span>            :  *      the destination station.
<span class="lineNum">    4443 </span>            :  */
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span>            : /**
<span class="lineNum">    4446 </span>            :  * struct iwm_agg_tx_status - per packet TX aggregation status
<span class="lineNum">    4447 </span>            :  * @status: enum iwm_tx_agg_status
<span class="lineNum">    4448 </span>            :  * @sequence: Sequence # for this frame's Tx cmd (not SSN!)
<span class="lineNum">    4449 </span>            :  */
<span class="lineNum">    4450 </span>            : struct iwm_agg_tx_status {
<span class="lineNum">    4451 </span>            :         uint16_t status;
<span class="lineNum">    4452 </span>            :         uint16_t sequence;
<span class="lineNum">    4453 </span>            : } __packed;
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span>            : /*
<span class="lineNum">    4456 </span>            :  * definitions for initial rate index field
<span class="lineNum">    4457 </span>            :  * bits [3:0] initial rate index
<span class="lineNum">    4458 </span>            :  * bits [6:4] rate table color, used for the initial rate
<span class="lineNum">    4459 </span>            :  * bit-7 invalid rate indication
<span class="lineNum">    4460 </span>            :  */
<span class="lineNum">    4461 </span>            : #define IWM_TX_RES_INIT_RATE_INDEX_MSK 0x0f
<span class="lineNum">    4462 </span>            : #define IWM_TX_RES_RATE_TABLE_COLOR_MSK 0x70
<span class="lineNum">    4463 </span>            : #define IWM_TX_RES_INV_RATE_INDEX_MSK 0x80
<span class="lineNum">    4464 </span>            : 
<span class="lineNum">    4465 </span>            : #define IWM_TX_RES_GET_TID(_ra_tid) ((_ra_tid) &amp; 0x0f)
<span class="lineNum">    4466 </span>            : #define IWM_TX_RES_GET_RA(_ra_tid) ((_ra_tid) &gt;&gt; 4)
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span>            : /**
<span class="lineNum">    4469 </span>            :  * struct iwm_tx_resp - notifies that fw is TXing a packet
<span class="lineNum">    4470 </span>            :  * ( IWM_REPLY_TX = 0x1c )
<span class="lineNum">    4471 </span>            :  * @frame_count: 1 no aggregation, &gt;1 aggregation
<span class="lineNum">    4472 </span>            :  * @bt_kill_count: num of times blocked by bluetooth (unused for agg)
<span class="lineNum">    4473 </span>            :  * @failure_rts: num of failures due to unsuccessful RTS
<span class="lineNum">    4474 </span>            :  * @failure_frame: num failures due to no ACK (unused for agg)
<span class="lineNum">    4475 </span>            :  * @initial_rate: for non-agg: rate of the successful Tx. For agg: rate of the
<span class="lineNum">    4476 </span>            :  *      Tx of all the batch. IWM_RATE_MCS_*
<span class="lineNum">    4477 </span>            :  * @wireless_media_time: for non-agg: RTS + CTS + frame tx attempts time + ACK.
<span class="lineNum">    4478 </span>            :  *      for agg: RTS + CTS + aggregation tx time + block-ack time.
<span class="lineNum">    4479 </span>            :  *      in usec.
<span class="lineNum">    4480 </span>            :  * @pa_status: tx power info
<span class="lineNum">    4481 </span>            :  * @pa_integ_res_a: tx power info
<span class="lineNum">    4482 </span>            :  * @pa_integ_res_b: tx power info
<span class="lineNum">    4483 </span>            :  * @pa_integ_res_c: tx power info
<span class="lineNum">    4484 </span>            :  * @measurement_req_id: tx power info
<span class="lineNum">    4485 </span>            :  * @tfd_info: TFD information set by the FH
<span class="lineNum">    4486 </span>            :  * @seq_ctl: sequence control from the Tx cmd
<span class="lineNum">    4487 </span>            :  * @byte_cnt: byte count from the Tx cmd
<span class="lineNum">    4488 </span>            :  * @tlc_info: TLC rate info
<span class="lineNum">    4489 </span>            :  * @ra_tid: bits [3:0] = ra, bits [7:4] = tid
<span class="lineNum">    4490 </span>            :  * @frame_ctrl: frame control
<span class="lineNum">    4491 </span>            :  * @status: for non-agg:  frame status IWM_TX_STATUS_*
<span class="lineNum">    4492 </span>            :  *      for agg: status of 1st frame, IWM_AGG_TX_STATE_*; other frame status fields
<span class="lineNum">    4493 </span>            :  *      follow this one, up to frame_count.
<span class="lineNum">    4494 </span>            :  *
<span class="lineNum">    4495 </span>            :  * After the array of statuses comes the SSN of the SCD. Look at
<span class="lineNum">    4496 </span>            :  * %iwm_get_scd_ssn for more details.
<span class="lineNum">    4497 </span>            :  */
<span class="lineNum">    4498 </span>            : struct iwm_tx_resp {
<span class="lineNum">    4499 </span>            :         uint8_t frame_count;
<span class="lineNum">    4500 </span>            :         uint8_t bt_kill_count;
<span class="lineNum">    4501 </span>            :         uint8_t failure_rts;
<span class="lineNum">    4502 </span>            :         uint8_t failure_frame;
<span class="lineNum">    4503 </span>            :         uint32_t initial_rate;
<span class="lineNum">    4504 </span>            :         uint16_t wireless_media_time;
<span class="lineNum">    4505 </span>            : 
<span class="lineNum">    4506 </span>            :         uint8_t pa_status;
<span class="lineNum">    4507 </span>            :         uint8_t pa_integ_res_a[3];
<span class="lineNum">    4508 </span>            :         uint8_t pa_integ_res_b[3];
<span class="lineNum">    4509 </span>            :         uint8_t pa_integ_res_c[3];
<span class="lineNum">    4510 </span>            :         uint16_t measurement_req_id;
<span class="lineNum">    4511 </span>            :         uint16_t reserved;
<span class="lineNum">    4512 </span>            : 
<span class="lineNum">    4513 </span>            :         uint32_t tfd_info;
<span class="lineNum">    4514 </span>            :         uint16_t seq_ctl;
<span class="lineNum">    4515 </span>            :         uint16_t byte_cnt;
<span class="lineNum">    4516 </span>            :         uint8_t tlc_info;
<span class="lineNum">    4517 </span>            :         uint8_t ra_tid;
<span class="lineNum">    4518 </span>            :         uint16_t frame_ctrl;
<span class="lineNum">    4519 </span>            : 
<span class="lineNum">    4520 </span>            :         struct iwm_agg_tx_status status;
<span class="lineNum">    4521 </span>            : } __packed; /* IWM_TX_RSP_API_S_VER_3 */
<span class="lineNum">    4522 </span>            : 
<span class="lineNum">    4523 </span>            : /**
<span class="lineNum">    4524 </span>            :  * struct iwm_ba_notif - notifies about reception of BA
<span class="lineNum">    4525 </span>            :  * ( IWM_BA_NOTIF = 0xc5 )
<span class="lineNum">    4526 </span>            :  * @sta_addr_lo32: lower 32 bits of the MAC address
<span class="lineNum">    4527 </span>            :  * @sta_addr_hi16: upper 16 bits of the MAC address
<span class="lineNum">    4528 </span>            :  * @sta_id: Index of recipient (BA-sending) station in fw's station table
<span class="lineNum">    4529 </span>            :  * @tid: tid of the session
<span class="lineNum">    4530 </span>            :  * @seq_ctl:
<span class="lineNum">    4531 </span>            :  * @bitmap: the bitmap of the BA notification as seen in the air
<span class="lineNum">    4532 </span>            :  * @scd_flow: the tx queue this BA relates to
<span class="lineNum">    4533 </span>            :  * @scd_ssn: the index of the last contiguously sent packet
<span class="lineNum">    4534 </span>            :  * @txed: number of Txed frames in this batch
<span class="lineNum">    4535 </span>            :  * @txed_2_done: number of Acked frames in this batch
<span class="lineNum">    4536 </span>            :  */
<span class="lineNum">    4537 </span>            : struct iwm_ba_notif {
<span class="lineNum">    4538 </span>            :         uint32_t sta_addr_lo32;
<span class="lineNum">    4539 </span>            :         uint16_t sta_addr_hi16;
<span class="lineNum">    4540 </span>            :         uint16_t reserved;
<span class="lineNum">    4541 </span>            : 
<span class="lineNum">    4542 </span>            :         uint8_t sta_id;
<span class="lineNum">    4543 </span>            :         uint8_t tid;
<span class="lineNum">    4544 </span>            :         uint16_t seq_ctl;
<span class="lineNum">    4545 </span>            :         uint64_t bitmap;
<span class="lineNum">    4546 </span>            :         uint16_t scd_flow;
<span class="lineNum">    4547 </span>            :         uint16_t scd_ssn;
<span class="lineNum">    4548 </span>            :         uint8_t txed;
<span class="lineNum">    4549 </span>            :         uint8_t txed_2_done;
<span class="lineNum">    4550 </span>            :         uint16_t reserved1;
<span class="lineNum">    4551 </span>            : } __packed;
<span class="lineNum">    4552 </span>            : 
<span class="lineNum">    4553 </span>            : /*
<span class="lineNum">    4554 </span>            :  * struct iwm_mac_beacon_cmd - beacon template command
<span class="lineNum">    4555 </span>            :  * @tx: the tx commands associated with the beacon frame
<span class="lineNum">    4556 </span>            :  * @template_id: currently equal to the mac context id of the coresponding
<span class="lineNum">    4557 </span>            :  *  mac.
<span class="lineNum">    4558 </span>            :  * @tim_idx: the offset of the tim IE in the beacon
<span class="lineNum">    4559 </span>            :  * @tim_size: the length of the tim IE
<span class="lineNum">    4560 </span>            :  * @frame: the template of the beacon frame
<span class="lineNum">    4561 </span>            :  */
<span class="lineNum">    4562 </span>            : struct iwm_mac_beacon_cmd {
<span class="lineNum">    4563 </span>            :         struct iwm_tx_cmd tx;
<span class="lineNum">    4564 </span>            :         uint32_t template_id;
<span class="lineNum">    4565 </span>            :         uint32_t tim_idx;
<span class="lineNum">    4566 </span>            :         uint32_t tim_size;
<span class="lineNum">    4567 </span>            :         struct ieee80211_frame frame[0];
<span class="lineNum">    4568 </span>            : } __packed;
<span class="lineNum">    4569 </span>            : 
<span class="lineNum">    4570 </span>            : struct iwm_beacon_notif {
<span class="lineNum">    4571 </span>            :         struct iwm_tx_resp beacon_notify_hdr;
<span class="lineNum">    4572 </span>            :         uint64_t tsf;
<span class="lineNum">    4573 </span>            :         uint32_t ibss_mgr_status;
<span class="lineNum">    4574 </span>            : } __packed;
<span class="lineNum">    4575 </span>            : 
<span class="lineNum">    4576 </span>            : /**
<span class="lineNum">    4577 </span>            :  * dump (flush) control flags
<span class="lineNum">    4578 </span>            :  * @IWM_DUMP_TX_FIFO_FLUSH: Dump MSDUs until the FIFO is empty
<span class="lineNum">    4579 </span>            :  *      and the TFD queues are empty.
<span class="lineNum">    4580 </span>            :  */
<span class="lineNum">    4581 </span>            : #define IWM_DUMP_TX_FIFO_FLUSH  (1 &lt;&lt; 1)
<span class="lineNum">    4582 </span>            : 
<span class="lineNum">    4583 </span>            : /**
<span class="lineNum">    4584 </span>            :  * struct iwm_tx_path_flush_cmd -- queue/FIFO flush command
<span class="lineNum">    4585 </span>            :  * @queues_ctl: bitmap of queues to flush
<span class="lineNum">    4586 </span>            :  * @flush_ctl: control flags
<span class="lineNum">    4587 </span>            :  * @reserved: reserved
<span class="lineNum">    4588 </span>            :  */
<span class="lineNum">    4589 </span>            : struct iwm_tx_path_flush_cmd {
<span class="lineNum">    4590 </span>            :         uint32_t queues_ctl;
<span class="lineNum">    4591 </span>            :         uint16_t flush_ctl;
<span class="lineNum">    4592 </span>            :         uint16_t reserved;
<span class="lineNum">    4593 </span>            : } __packed; /* IWM_TX_PATH_FLUSH_CMD_API_S_VER_1 */
<span class="lineNum">    4594 </span>            : 
<span class="lineNum">    4595 </span>            : /**
<span class="lineNum">    4596 </span>            :  * iwm_get_scd_ssn - returns the SSN of the SCD
<span class="lineNum">    4597 </span>            :  * @tx_resp: the Tx response from the fw (agg or non-agg)
<span class="lineNum">    4598 </span>            :  *
<span class="lineNum">    4599 </span>            :  * When the fw sends an AMPDU, it fetches the MPDUs one after the other. Since
<span class="lineNum">    4600 </span>            :  * it can't know that everything will go well until the end of the AMPDU, it
<span class="lineNum">    4601 </span>            :  * can't know in advance the number of MPDUs that will be sent in the current
<span class="lineNum">    4602 </span>            :  * batch. This is why it writes the agg Tx response while it fetches the MPDUs.
<span class="lineNum">    4603 </span>            :  * Hence, it can't know in advance what the SSN of the SCD will be at the end
<span class="lineNum">    4604 </span>            :  * of the batch. This is why the SSN of the SCD is written at the end of the
<span class="lineNum">    4605 </span>            :  * whole struct at a variable offset. This function knows how to cope with the
<span class="lineNum">    4606 </span>            :  * variable offset and returns the SSN of the SCD.
<span class="lineNum">    4607 </span>            :  */
<span class="lineNum">    4608 </span>            : static inline uint32_t iwm_get_scd_ssn(struct iwm_tx_resp *tx_resp)
<span class="lineNum">    4609 </span>            : {
<span class="lineNum">    4610 </span>            :         return le32_to_cpup((uint32_t *)&amp;tx_resp-&gt;status +
<span class="lineNum">    4611 </span>            :                             tx_resp-&gt;frame_count) &amp; 0xfff;
<span class="lineNum">    4612 </span>            : }
<span class="lineNum">    4613 </span>            : 
<span class="lineNum">    4614 </span>            : /**
<span class="lineNum">    4615 </span>            :  * struct iwm_scd_txq_cfg_cmd - New txq hw scheduler config command
<span class="lineNum">    4616 </span>            :  * @token:
<span class="lineNum">    4617 </span>            :  * @sta_id: station id
<span class="lineNum">    4618 </span>            :  * @tid:
<span class="lineNum">    4619 </span>            :  * @scd_queue: scheduler queue to confiug
<span class="lineNum">    4620 </span>            :  * @enable: 1 queue enable, 0 queue disable
<span class="lineNum">    4621 </span>            :  * @aggregate: 1 aggregated queue, 0 otherwise
<span class="lineNum">    4622 </span>            :  * @tx_fifo: %enum iwm_tx_fifo
<span class="lineNum">    4623 </span>            :  * @window: BA window size
<span class="lineNum">    4624 </span>            :  * @ssn: SSN for the BA agreement
<span class="lineNum">    4625 </span>            :  */
<span class="lineNum">    4626 </span>            : struct iwm_scd_txq_cfg_cmd {
<span class="lineNum">    4627 </span>            :         uint8_t token;
<span class="lineNum">    4628 </span>            :         uint8_t sta_id;
<span class="lineNum">    4629 </span>            :         uint8_t tid;
<span class="lineNum">    4630 </span>            :         uint8_t scd_queue;
<span class="lineNum">    4631 </span>            :         uint8_t enable;
<span class="lineNum">    4632 </span>            :         uint8_t aggregate;
<span class="lineNum">    4633 </span>            :         uint8_t tx_fifo;
<span class="lineNum">    4634 </span>            :         uint8_t window;
<span class="lineNum">    4635 </span>            :         uint16_t ssn;
<span class="lineNum">    4636 </span>            :         uint16_t reserved;
<span class="lineNum">    4637 </span>            : } __packed; /* SCD_QUEUE_CFG_CMD_API_S_VER_1 */
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span>            : /**
<span class="lineNum">    4640 </span>            :  * struct iwm_scd_txq_cfg_rsp
<span class="lineNum">    4641 </span>            :  * @token: taken from the command
<span class="lineNum">    4642 </span>            :  * @sta_id: station id from the command
<span class="lineNum">    4643 </span>            :  * @tid: tid from the command
<span class="lineNum">    4644 </span>            :  * @scd_queue: scd_queue from the command
<span class="lineNum">    4645 </span>            :  */
<span class="lineNum">    4646 </span>            : struct iwm_scd_txq_cfg_rsp {
<span class="lineNum">    4647 </span>            :         uint8_t token;
<span class="lineNum">    4648 </span>            :         uint8_t sta_id;
<span class="lineNum">    4649 </span>            :         uint8_t tid;
<span class="lineNum">    4650 </span>            :         uint8_t scd_queue;
<span class="lineNum">    4651 </span>            : } __packed; /* SCD_QUEUE_CFG_RSP_API_S_VER_1 */
<span class="lineNum">    4652 </span>            : 
<span class="lineNum">    4653 </span>            : 
<span class="lineNum">    4654 </span>            : /* Scan Commands, Responses, Notifications */
<span class="lineNum">    4655 </span>            : 
<span class="lineNum">    4656 </span>            : /* Max number of IEs for direct SSID scans in a command */
<span class="lineNum">    4657 </span>            : #define IWM_PROBE_OPTION_MAX            20
<span class="lineNum">    4658 </span>            : 
<span class="lineNum">    4659 </span>            : /**
<span class="lineNum">    4660 </span>            :  * struct iwm_ssid_ie - directed scan network information element
<span class="lineNum">    4661 </span>            :  *
<span class="lineNum">    4662 </span>            :  * Up to 20 of these may appear in IWM_REPLY_SCAN_CMD,
<span class="lineNum">    4663 </span>            :  * selected by &quot;type&quot; bit field in struct iwm_scan_channel;
<span class="lineNum">    4664 </span>            :  * each channel may select different ssids from among the 20 entries.
<span class="lineNum">    4665 </span>            :  * SSID IEs get transmitted in reverse order of entry.
<span class="lineNum">    4666 </span>            :  */
<span class="lineNum">    4667 </span>            : struct iwm_ssid_ie {
<span class="lineNum">    4668 </span>            :         uint8_t id;
<span class="lineNum">    4669 </span>            :         uint8_t len;
<span class="lineNum">    4670 </span>            :         uint8_t ssid[IEEE80211_NWID_LEN];
<span class="lineNum">    4671 </span>            : } __packed; /* IWM_SCAN_DIRECT_SSID_IE_API_S_VER_1 */
<span class="lineNum">    4672 </span>            : 
<span class="lineNum">    4673 </span>            : /* scan offload */
<span class="lineNum">    4674 </span>            : #define IWM_SCAN_MAX_BLACKLIST_LEN      64
<span class="lineNum">    4675 </span>            : #define IWM_SCAN_SHORT_BLACKLIST_LEN    16
<span class="lineNum">    4676 </span>            : #define IWM_SCAN_MAX_PROFILES           11
<span class="lineNum">    4677 </span>            : #define IWM_SCAN_OFFLOAD_PROBE_REQ_SIZE 512
<span class="lineNum">    4678 </span>            : 
<span class="lineNum">    4679 </span>            : /* Default watchdog (in MS) for scheduled scan iteration */
<span class="lineNum">    4680 </span>            : #define IWM_SCHED_SCAN_WATCHDOG cpu_to_le16(15000)
<span class="lineNum">    4681 </span>            : 
<span class="lineNum">    4682 </span>            : #define IWM_GOOD_CRC_TH_DEFAULT cpu_to_le16(1)
<span class="lineNum">    4683 </span>            : #define IWM_CAN_ABORT_STATUS 1
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span>            : #define IWM_FULL_SCAN_MULTIPLIER 5
<span class="lineNum">    4686 </span>            : #define IWM_FAST_SCHED_SCAN_ITERATIONS 3
<span class="lineNum">    4687 </span>            : #define IWM_MAX_SCHED_SCAN_PLANS 2
<span class="lineNum">    4688 </span>            : 
<span class="lineNum">    4689 </span>            : /**
<span class="lineNum">    4690 </span>            :  * iwm_scan_schedule_lmac - schedule of scan offload
<span class="lineNum">    4691 </span>            :  * @delay:              delay between iterations, in seconds.
<span class="lineNum">    4692 </span>            :  * @iterations:         num of scan iterations
<span class="lineNum">    4693 </span>            :  * @full_scan_mul:      number of partial scans before each full scan
<span class="lineNum">    4694 </span>            :  */
<span class="lineNum">    4695 </span>            : struct iwm_scan_schedule_lmac {
<span class="lineNum">    4696 </span>            :         uint16_t delay;
<span class="lineNum">    4697 </span>            :         uint8_t iterations;
<span class="lineNum">    4698 </span>            :         uint8_t full_scan_mul;
<span class="lineNum">    4699 </span>            : } __packed; /* SCAN_SCHEDULE_API_S */
<span class="lineNum">    4700 </span>            : 
<span class="lineNum">    4701 </span>            : /**
<span class="lineNum">    4702 </span>            :  * iwm_scan_req_tx_cmd - SCAN_REQ_TX_CMD_API_S
<span class="lineNum">    4703 </span>            :  * @tx_flags: combination of TX_CMD_FLG_*
<span class="lineNum">    4704 </span>            :  * @rate_n_flags: rate for *all* Tx attempts, if TX_CMD_FLG_STA_RATE_MSK is
<span class="lineNum">    4705 </span>            :  *      cleared. Combination of RATE_MCS_*
<span class="lineNum">    4706 </span>            :  * @sta_id: index of destination station in FW station table
<span class="lineNum">    4707 </span>            :  * @reserved: for alignment and future use
<span class="lineNum">    4708 </span>            :  */
<span class="lineNum">    4709 </span>            : struct iwm_scan_req_tx_cmd {
<span class="lineNum">    4710 </span>            :         uint32_t tx_flags;
<span class="lineNum">    4711 </span>            :         uint32_t rate_n_flags;
<span class="lineNum">    4712 </span>            :         uint8_t sta_id;
<span class="lineNum">    4713 </span>            :         uint8_t reserved[3];
<span class="lineNum">    4714 </span>            : } __packed;
<span class="lineNum">    4715 </span>            : 
<span class="lineNum">    4716 </span>            : #define IWM_UNIFIED_SCAN_CHANNEL_FULL           (1 &lt;&lt; 27)
<span class="lineNum">    4717 </span>            : #define IWM_UNIFIED_SCAN_CHANNEL_PARTIAL        (1 &lt;&lt; 28)
<span class="lineNum">    4718 </span>            : 
<span class="lineNum">    4719 </span>            : /**
<span class="lineNum">    4720 </span>            :  * iwm_scan_channel_cfg_lmac - SCAN_CHANNEL_CFG_S_VER2
<span class="lineNum">    4721 </span>            :  * @flags:              bits 1-20: directed scan to i'th ssid
<span class="lineNum">    4722 </span>            :  *                      other bits &amp;enum iwm_scan_channel_flags_lmac
<span class="lineNum">    4723 </span>            :  * @channel_number:     channel number 1-13 etc
<span class="lineNum">    4724 </span>            :  * @iter_count:         scan iteration on this channel
<span class="lineNum">    4725 </span>            :  * @iter_interval:      interval in seconds between iterations on one channel
<span class="lineNum">    4726 </span>            :  */
<span class="lineNum">    4727 </span>            : struct iwm_scan_channel_cfg_lmac {
<span class="lineNum">    4728 </span>            :         uint32_t flags;
<span class="lineNum">    4729 </span>            :         uint16_t channel_num;
<span class="lineNum">    4730 </span>            :         uint16_t iter_count;
<span class="lineNum">    4731 </span>            :         uint32_t iter_interval;
<span class="lineNum">    4732 </span>            : } __packed;
<span class="lineNum">    4733 </span>            : 
<span class="lineNum">    4734 </span>            : /*
<span class="lineNum">    4735 </span>            :  * iwm_scan_probe_segment - PROBE_SEGMENT_API_S_VER_1
<span class="lineNum">    4736 </span>            :  * @offset: offset in the data block
<span class="lineNum">    4737 </span>            :  * @len: length of the segment
<span class="lineNum">    4738 </span>            :  */
<span class="lineNum">    4739 </span>            : struct iwm_scan_probe_segment {
<span class="lineNum">    4740 </span>            :         uint16_t offset;
<span class="lineNum">    4741 </span>            :         uint16_t len;
<span class="lineNum">    4742 </span>            : } __packed;
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span>            : /* iwm_scan_probe_req - PROBE_REQUEST_FRAME_API_S_VER_2
<span class="lineNum">    4745 </span>            :  * @mac_header: first (and common) part of the probe
<span class="lineNum">    4746 </span>            :  * @band_data: band specific data
<span class="lineNum">    4747 </span>            :  * @common_data: last (and common) part of the probe
<span class="lineNum">    4748 </span>            :  * @buf: raw data block
<span class="lineNum">    4749 </span>            :  */
<span class="lineNum">    4750 </span>            : struct iwm_scan_probe_req {
<span class="lineNum">    4751 </span>            :         struct iwm_scan_probe_segment mac_header;
<span class="lineNum">    4752 </span>            :         struct iwm_scan_probe_segment band_data[2];
<span class="lineNum">    4753 </span>            :         struct iwm_scan_probe_segment common_data;
<span class="lineNum">    4754 </span>            :         uint8_t buf[IWM_SCAN_OFFLOAD_PROBE_REQ_SIZE];
<span class="lineNum">    4755 </span>            : } __packed;
<span class="lineNum">    4756 </span>            : 
<span class="lineNum">    4757 </span>            : #define IWM_SCAN_CHANNEL_FLAG_EBS               (1 &lt;&lt; 0)
<span class="lineNum">    4758 </span>            : #define IWM_SCAN_CHANNEL_FLAG_EBS_ACCURATE      (1 &lt;&lt; 1)
<span class="lineNum">    4759 </span>            : #define IWM_SCAN_CHANNEL_FLAG_CACHE_ADD         (1 &lt;&lt; 2)
<span class="lineNum">    4760 </span>            : 
<span class="lineNum">    4761 </span>            : /* iwm_scan_channel_opt - CHANNEL_OPTIMIZATION_API_S
<span class="lineNum">    4762 </span>            :  * @flags: enum iwm_scan_channel_flags
<span class="lineNum">    4763 </span>            :  * @non_ebs_ratio: defines the ratio of number of scan iterations where EBS is
<span class="lineNum">    4764 </span>            :  *      involved.
<span class="lineNum">    4765 </span>            :  *      1 - EBS is disabled.
<span class="lineNum">    4766 </span>            :  *      2 - every second scan will be full scan(and so on).
<span class="lineNum">    4767 </span>            :  */
<span class="lineNum">    4768 </span>            : struct iwm_scan_channel_opt {
<span class="lineNum">    4769 </span>            :         uint16_t flags;
<span class="lineNum">    4770 </span>            :         uint16_t non_ebs_ratio;
<span class="lineNum">    4771 </span>            : } __packed;
<span class="lineNum">    4772 </span>            : 
<span class="lineNum">    4773 </span>            : /**
<span class="lineNum">    4774 </span>            :  * LMAC scan flags
<span class="lineNum">    4775 </span>            :  * @IWM_LMAC_SCAN_FLAG_PASS_ALL: pass all beacons and probe responses
<span class="lineNum">    4776 </span>            :  *      without filtering.
<span class="lineNum">    4777 </span>            :  * @IWM_LMAC_SCAN_FLAG_PASSIVE: force passive scan on all channels
<span class="lineNum">    4778 </span>            :  * @IWM_LMAC_SCAN_FLAG_PRE_CONNECTION: single channel scan
<span class="lineNum">    4779 </span>            :  * @IWM_LMAC_SCAN_FLAG_ITER_COMPLETE: send iteration complete notification
<span class="lineNum">    4780 </span>            :  * @IWM_LMAC_SCAN_FLAG_MULTIPLE_SSIDS multiple SSID matching
<span class="lineNum">    4781 </span>            :  * @IWM_LMAC_SCAN_FLAG_FRAGMENTED: all passive scans will be fragmented
<span class="lineNum">    4782 </span>            :  * @IWM_LMAC_SCAN_FLAGS_RRM_ENABLED: insert WFA vendor-specific TPC report
<span class="lineNum">    4783 </span>            :  *      and DS parameter set IEs into probe requests.
<span class="lineNum">    4784 </span>            :  * @IWM_LMAC_SCAN_FLAG_EXTENDED_DWELL: use extended dwell time on channels
<span class="lineNum">    4785 </span>            :  *      1, 6 and 11.
<span class="lineNum">    4786 </span>            :  * @IWM_LMAC_SCAN_FLAG_MATCH: Send match found notification on matches
<span class="lineNum">    4787 </span>            :  */
<span class="lineNum">    4788 </span>            : #define IWM_LMAC_SCAN_FLAG_PASS_ALL             (1 &lt;&lt; 0)
<span class="lineNum">    4789 </span>            : #define IWM_LMAC_SCAN_FLAG_PASSIVE              (1 &lt;&lt; 1)
<span class="lineNum">    4790 </span>            : #define IWM_LMAC_SCAN_FLAG_PRE_CONNECTION       (1 &lt;&lt; 2)
<span class="lineNum">    4791 </span>            : #define IWM_LMAC_SCAN_FLAG_ITER_COMPLETE        (1 &lt;&lt; 3)
<span class="lineNum">    4792 </span>            : #define IWM_LMAC_SCAN_FLAG_MULTIPLE_SSIDS       (1 &lt;&lt; 4)
<span class="lineNum">    4793 </span>            : #define IWM_LMAC_SCAN_FLAG_FRAGMENTED   (1 &lt;&lt; 5)
<span class="lineNum">    4794 </span>            : #define IWM_LMAC_SCAN_FLAGS_RRM_ENABLED (1 &lt;&lt; 6)
<span class="lineNum">    4795 </span>            : #define IWM_LMAC_SCAN_FLAG_EXTENDED_DWELL       (1 &lt;&lt; 7)
<span class="lineNum">    4796 </span>            : #define IWM_LMAC_SCAN_FLAG_MATCH                (1 &lt;&lt; 9)
<span class="lineNum">    4797 </span>            : 
<span class="lineNum">    4798 </span>            : #define IWM_SCAN_PRIORITY_LOW           0
<span class="lineNum">    4799 </span>            : #define IWM_SCAN_PRIORITY_MEDIUM        1
<span class="lineNum">    4800 </span>            : #define IWM_SCAN_PRIORITY_HIGH          2
<span class="lineNum">    4801 </span>            : 
<span class="lineNum">    4802 </span>            : /**
<span class="lineNum">    4803 </span>            :  * iwm_scan_req_lmac - SCAN_REQUEST_CMD_API_S_VER_1
<span class="lineNum">    4804 </span>            :  * @reserved1: for alignment and future use
<span class="lineNum">    4805 </span>            :  * @channel_num: num of channels to scan
<span class="lineNum">    4806 </span>            :  * @active-dwell: dwell time for active channels
<span class="lineNum">    4807 </span>            :  * @passive-dwell: dwell time for passive channels
<span class="lineNum">    4808 </span>            :  * @fragmented-dwell: dwell time for fragmented passive scan
<span class="lineNum">    4809 </span>            :  * @extended_dwell: dwell time for channels 1, 6 and 11 (in certain cases)
<span class="lineNum">    4810 </span>            :  * @reserved2: for alignment and future use
<span class="lineNum">    4811 </span>            :  * @rx_chain_selct: PHY_RX_CHAIN_* flags
<span class="lineNum">    4812 </span>            :  * @scan_flags: &amp;enum iwm_lmac_scan_flags
<span class="lineNum">    4813 </span>            :  * @max_out_time: max time (in TU) to be out of associated channel
<span class="lineNum">    4814 </span>            :  * @suspend_time: pause scan this long (TUs) when returning to service channel
<span class="lineNum">    4815 </span>            :  * @flags: RXON flags
<span class="lineNum">    4816 </span>            :  * @filter_flags: RXON filter
<span class="lineNum">    4817 </span>            :  * @tx_cmd: tx command for active scan; for 2GHz and for 5GHz
<span class="lineNum">    4818 </span>            :  * @direct_scan: list of SSIDs for directed active scan
<span class="lineNum">    4819 </span>            :  * @scan_prio: enum iwm_scan_priority
<span class="lineNum">    4820 </span>            :  * @iter_num: number of scan iterations
<span class="lineNum">    4821 </span>            :  * @delay: delay in seconds before first iteration
<span class="lineNum">    4822 </span>            :  * @schedule: two scheduling plans. The first one is finite, the second one can
<span class="lineNum">    4823 </span>            :  *      be infinite.
<span class="lineNum">    4824 </span>            :  * @channel_opt: channel optimization options, for full and partial scan
<span class="lineNum">    4825 </span>            :  * @data: channel configuration and probe request packet.
<span class="lineNum">    4826 </span>            :  */
<span class="lineNum">    4827 </span>            : struct iwm_scan_req_lmac {
<span class="lineNum">    4828 </span>            :         /* SCAN_REQUEST_FIXED_PART_API_S_VER_7 */
<span class="lineNum">    4829 </span>            :         uint32_t reserved1;
<span class="lineNum">    4830 </span>            :         uint8_t n_channels;
<span class="lineNum">    4831 </span>            :         uint8_t active_dwell;
<span class="lineNum">    4832 </span>            :         uint8_t passive_dwell;
<span class="lineNum">    4833 </span>            :         uint8_t fragmented_dwell;
<span class="lineNum">    4834 </span>            :         uint8_t extended_dwell;
<span class="lineNum">    4835 </span>            :         uint8_t reserved2;
<span class="lineNum">    4836 </span>            :         uint16_t rx_chain_select;
<span class="lineNum">    4837 </span>            :         uint32_t scan_flags;
<span class="lineNum">    4838 </span>            :         uint32_t max_out_time;
<span class="lineNum">    4839 </span>            :         uint32_t suspend_time;
<span class="lineNum">    4840 </span>            :         /* RX_ON_FLAGS_API_S_VER_1 */
<span class="lineNum">    4841 </span>            :         uint32_t flags;
<span class="lineNum">    4842 </span>            :         uint32_t filter_flags;
<span class="lineNum">    4843 </span>            :         struct iwm_scan_req_tx_cmd tx_cmd[2];
<span class="lineNum">    4844 </span>            :         struct iwm_ssid_ie direct_scan[IWM_PROBE_OPTION_MAX];
<span class="lineNum">    4845 </span>            :         uint32_t scan_prio;
<span class="lineNum">    4846 </span>            :         /* SCAN_REQ_PERIODIC_PARAMS_API_S */
<span class="lineNum">    4847 </span>            :         uint32_t iter_num;
<span class="lineNum">    4848 </span>            :         uint32_t delay;
<span class="lineNum">    4849 </span>            :         struct iwm_scan_schedule_lmac schedule[IWM_MAX_SCHED_SCAN_PLANS];
<span class="lineNum">    4850 </span>            :         struct iwm_scan_channel_opt channel_opt[2];
<span class="lineNum">    4851 </span>            :         uint8_t data[];
<span class="lineNum">    4852 </span>            : } __packed;
<span class="lineNum">    4853 </span>            : 
<span class="lineNum">    4854 </span>            : /**
<span class="lineNum">    4855 </span>            :  * iwm_scan_offload_complete - PERIODIC_SCAN_COMPLETE_NTF_API_S_VER_2
<span class="lineNum">    4856 </span>            :  * @last_schedule_line: last schedule line executed (fast or regular)
<span class="lineNum">    4857 </span>            :  * @last_schedule_iteration: last scan iteration executed before scan abort
<span class="lineNum">    4858 </span>            :  * @status: enum iwm_scan_offload_complete_status
<span class="lineNum">    4859 </span>            :  * @ebs_status: EBS success status &amp;enum iwm_scan_ebs_status
<span class="lineNum">    4860 </span>            :  * @time_after_last_iter; time in seconds elapsed after last iteration
<span class="lineNum">    4861 </span>            :  */
<span class="lineNum">    4862 </span>            : struct iwm_periodic_scan_complete {
<span class="lineNum">    4863 </span>            :         uint8_t last_schedule_line;
<span class="lineNum">    4864 </span>            :         uint8_t last_schedule_iteration;
<span class="lineNum">    4865 </span>            :         uint8_t status;
<span class="lineNum">    4866 </span>            :         uint8_t ebs_status;
<span class="lineNum">    4867 </span>            :         uint32_t time_after_last_iter;
<span class="lineNum">    4868 </span>            :         uint32_t reserved;
<span class="lineNum">    4869 </span>            : } __packed;
<span class="lineNum">    4870 </span>            : 
<span class="lineNum">    4871 </span>            : /**
<span class="lineNum">    4872 </span>            :  * struct iwm_scan_results_notif - scan results for one channel -
<span class="lineNum">    4873 </span>            :  *      SCAN_RESULT_NTF_API_S_VER_3
<span class="lineNum">    4874 </span>            :  * @channel: which channel the results are from
<span class="lineNum">    4875 </span>            :  * @band: 0 for 5.2 GHz, 1 for 2.4 GHz
<span class="lineNum">    4876 </span>            :  * @probe_status: IWM_SCAN_PROBE_STATUS_*, indicates success of probe request
<span class="lineNum">    4877 </span>            :  * @num_probe_not_sent: # of request that weren't sent due to not enough time
<span class="lineNum">    4878 </span>            :  * @duration: duration spent in channel, in usecs
<span class="lineNum">    4879 </span>            :  */
<span class="lineNum">    4880 </span>            : struct iwm_scan_results_notif {
<span class="lineNum">    4881 </span>            :         uint8_t channel;
<span class="lineNum">    4882 </span>            :         uint8_t band;
<span class="lineNum">    4883 </span>            :         uint8_t probe_status;
<span class="lineNum">    4884 </span>            :         uint8_t num_probe_not_sent;
<span class="lineNum">    4885 </span>            :         uint32_t duration;
<span class="lineNum">    4886 </span>            : } __packed;
<span class="lineNum">    4887 </span>            : 
<span class="lineNum">    4888 </span>            : #define IWM_SCAN_CLIENT_SCHED_SCAN              (1 &lt;&lt; 0)
<span class="lineNum">    4889 </span>            : #define IWM_SCAN_CLIENT_NETDETECT               (1 &lt;&lt; 1)
<span class="lineNum">    4890 </span>            : #define IWM_SCAN_CLIENT_ASSET_TRACKING          (1 &lt;&lt; 2)
<span class="lineNum">    4891 </span>            : 
<span class="lineNum">    4892 </span>            : /**
<span class="lineNum">    4893 </span>            :  * iwm_scan_offload_blacklist - IWM_SCAN_OFFLOAD_BLACKLIST_S
<span class="lineNum">    4894 </span>            :  * @ssid:               MAC address to filter out
<span class="lineNum">    4895 </span>            :  * @reported_rssi:      AP rssi reported to the host
<span class="lineNum">    4896 </span>            :  * @client_bitmap: clients ignore this entry  - enum scan_framework_client
<span class="lineNum">    4897 </span>            :  */
<span class="lineNum">    4898 </span>            : struct iwm_scan_offload_blacklist {
<span class="lineNum">    4899 </span>            :         uint8_t ssid[ETHER_ADDR_LEN];
<span class="lineNum">    4900 </span>            :         uint8_t reported_rssi;
<span class="lineNum">    4901 </span>            :         uint8_t client_bitmap;
<span class="lineNum">    4902 </span>            : } __packed;
<span class="lineNum">    4903 </span>            : 
<span class="lineNum">    4904 </span>            : #define IWM_NETWORK_TYPE_BSS    1
<span class="lineNum">    4905 </span>            : #define IWM_NETWORK_TYPE_IBSS   2
<span class="lineNum">    4906 </span>            : #define IWM_NETWORK_TYPE_ANY    3
<span class="lineNum">    4907 </span>            : 
<span class="lineNum">    4908 </span>            : #define IWM_SCAN_OFFLOAD_SELECT_2_4     0x4
<span class="lineNum">    4909 </span>            : #define IWM_SCAN_OFFLOAD_SELECT_5_2     0x8
<span class="lineNum">    4910 </span>            : #define IWM_SCAN_OFFLOAD_SELECT_ANY     0xc
<span class="lineNum">    4911 </span>            : 
<span class="lineNum">    4912 </span>            : /**
<span class="lineNum">    4913 </span>            :  * iwm_scan_offload_profile - IWM_SCAN_OFFLOAD_PROFILE_S
<span class="lineNum">    4914 </span>            :  * @ssid_index:         index to ssid list in fixed part
<span class="lineNum">    4915 </span>            :  * @unicast_cipher:     encryption olgorithm to match - bitmap
<span class="lineNum">    4916 </span>            :  * @aut_alg:            authentication olgorithm to match - bitmap
<span class="lineNum">    4917 </span>            :  * @network_type:       enum iwm_scan_offload_network_type
<span class="lineNum">    4918 </span>            :  * @band_selection:     enum iwm_scan_offload_band_selection
<span class="lineNum">    4919 </span>            :  * @client_bitmap:      clients waiting for match - enum scan_framework_client
<span class="lineNum">    4920 </span>            :  */
<span class="lineNum">    4921 </span>            : struct iwm_scan_offload_profile {
<span class="lineNum">    4922 </span>            :         uint8_t ssid_index;
<span class="lineNum">    4923 </span>            :         uint8_t unicast_cipher;
<span class="lineNum">    4924 </span>            :         uint8_t auth_alg;
<span class="lineNum">    4925 </span>            :         uint8_t network_type;
<span class="lineNum">    4926 </span>            :         uint8_t band_selection;
<span class="lineNum">    4927 </span>            :         uint8_t client_bitmap;
<span class="lineNum">    4928 </span>            :         uint8_t reserved[2];
<span class="lineNum">    4929 </span>            : } __packed;
<span class="lineNum">    4930 </span>            : 
<span class="lineNum">    4931 </span>            : /**
<span class="lineNum">    4932 </span>            :  * iwm_scan_offload_profile_cfg - IWM_SCAN_OFFLOAD_PROFILES_CFG_API_S_VER_1
<span class="lineNum">    4933 </span>            :  * @blaclist:           AP list to filter off from scan results
<span class="lineNum">    4934 </span>            :  * @profiles:           profiles to search for match
<span class="lineNum">    4935 </span>            :  * @blacklist_len:      length of blacklist
<span class="lineNum">    4936 </span>            :  * @num_profiles:       num of profiles in the list
<span class="lineNum">    4937 </span>            :  * @match_notify:       clients waiting for match found notification
<span class="lineNum">    4938 </span>            :  * @pass_match:         clients waiting for the results
<span class="lineNum">    4939 </span>            :  * @active_clients:     active clients bitmap - enum scan_framework_client
<span class="lineNum">    4940 </span>            :  * @any_beacon_notify:  clients waiting for match notification without match
<span class="lineNum">    4941 </span>            :  */
<span class="lineNum">    4942 </span>            : struct iwm_scan_offload_profile_cfg {
<span class="lineNum">    4943 </span>            :         struct iwm_scan_offload_profile profiles[IWM_SCAN_MAX_PROFILES];
<span class="lineNum">    4944 </span>            :         uint8_t blacklist_len;
<span class="lineNum">    4945 </span>            :         uint8_t num_profiles;
<span class="lineNum">    4946 </span>            :         uint8_t match_notify;
<span class="lineNum">    4947 </span>            :         uint8_t pass_match;
<span class="lineNum">    4948 </span>            :         uint8_t active_clients;
<span class="lineNum">    4949 </span>            :         uint8_t any_beacon_notify;
<span class="lineNum">    4950 </span>            :         uint8_t reserved[2];
<span class="lineNum">    4951 </span>            : } __packed;
<span class="lineNum">    4952 </span>            : 
<span class="lineNum">    4953 </span>            : #define IWM_SCAN_OFFLOAD_COMPLETED      1
<span class="lineNum">    4954 </span>            : #define IWM_SCAN_OFFLOAD_ABORTED        2
<span class="lineNum">    4955 </span>            : 
<span class="lineNum">    4956 </span>            : /**
<span class="lineNum">    4957 </span>            :  * struct iwm_lmac_scan_complete_notif - notifies end of scanning (all channels)
<span class="lineNum">    4958 </span>            :  *      SCAN_COMPLETE_NTF_API_S_VER_3
<span class="lineNum">    4959 </span>            :  * @scanned_channels: number of channels scanned (and number of valid results)
<span class="lineNum">    4960 </span>            :  * @status: one of SCAN_COMP_STATUS_*
<span class="lineNum">    4961 </span>            :  * @bt_status: BT on/off status
<span class="lineNum">    4962 </span>            :  * @last_channel: last channel that was scanned
<span class="lineNum">    4963 </span>            :  * @tsf_low: TSF timer (lower half) in usecs
<span class="lineNum">    4964 </span>            :  * @tsf_high: TSF timer (higher half) in usecs
<span class="lineNum">    4965 </span>            :  * @results: an array of scan results, only &quot;scanned_channels&quot; of them are valid
<span class="lineNum">    4966 </span>            :  */
<span class="lineNum">    4967 </span>            : struct iwm_lmac_scan_complete_notif {
<span class="lineNum">    4968 </span>            :         uint8_t scanned_channels;
<span class="lineNum">    4969 </span>            :         uint8_t status;
<span class="lineNum">    4970 </span>            :         uint8_t bt_status;
<span class="lineNum">    4971 </span>            :         uint8_t last_channel;
<span class="lineNum">    4972 </span>            :         uint32_t tsf_low;
<span class="lineNum">    4973 </span>            :         uint32_t tsf_high;
<span class="lineNum">    4974 </span>            :         struct iwm_scan_results_notif results[];
<span class="lineNum">    4975 </span>            : } __packed;
<span class="lineNum">    4976 </span>            : 
<span class="lineNum">    4977 </span>            : 
<span class="lineNum">    4978 </span>            : /* UMAC Scan API */
<span class="lineNum">    4979 </span>            : 
<span class="lineNum">    4980 </span>            : /* The maximum of either of these cannot exceed 8, because we use an
<span class="lineNum">    4981 </span>            :  * 8-bit mask (see IWM_SCAN_MASK).
<span class="lineNum">    4982 </span>            :  */
<span class="lineNum">    4983 </span>            : #define IWM_MAX_UMAC_SCANS 8
<span class="lineNum">    4984 </span>            : #define IWM_MAX_LMAC_SCANS 1
<span class="lineNum">    4985 </span>            : 
<span class="lineNum">    4986 </span>            : #define IWM_SCAN_CONFIG_FLAG_ACTIVATE                   (1 &lt;&lt; 0)
<span class="lineNum">    4987 </span>            : #define IWM_SCAN_CONFIG_FLAG_DEACTIVATE                 (1 &lt;&lt; 1)
<span class="lineNum">    4988 </span>            : #define IWM_SCAN_CONFIG_FLAG_FORBID_CHUB_REQS           (1 &lt;&lt; 2)
<span class="lineNum">    4989 </span>            : #define IWM_SCAN_CONFIG_FLAG_ALLOW_CHUB_REQS            (1 &lt;&lt; 3)
<span class="lineNum">    4990 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_TX_CHAINS              (1 &lt;&lt; 8)
<span class="lineNum">    4991 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_RX_CHAINS              (1 &lt;&lt; 9)
<span class="lineNum">    4992 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_AUX_STA_ID             (1 &lt;&lt; 10)
<span class="lineNum">    4993 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_ALL_TIMES              (1 &lt;&lt; 11)
<span class="lineNum">    4994 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_EFFECTIVE_TIMES        (1 &lt;&lt; 12)
<span class="lineNum">    4995 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_CHANNEL_FLAGS          (1 &lt;&lt; 13)
<span class="lineNum">    4996 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_LEGACY_RATES           (1 &lt;&lt; 14)
<span class="lineNum">    4997 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_MAC_ADDR               (1 &lt;&lt; 15)
<span class="lineNum">    4998 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_FRAGMENTED             (1 &lt;&lt; 16)
<span class="lineNum">    4999 </span>            : #define IWM_SCAN_CONFIG_FLAG_CLEAR_FRAGMENTED           (1 &lt;&lt; 17)
<span class="lineNum">    5000 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_CAM_MODE               (1 &lt;&lt; 18)
<span class="lineNum">    5001 </span>            : #define IWM_SCAN_CONFIG_FLAG_CLEAR_CAM_MODE             (1 &lt;&lt; 19)
<span class="lineNum">    5002 </span>            : #define IWM_SCAN_CONFIG_FLAG_SET_PROMISC_MODE           (1 &lt;&lt; 20)
<span class="lineNum">    5003 </span>            : #define IWM_SCAN_CONFIG_FLAG_CLEAR_PROMISC_MODE         (1 &lt;&lt; 21)
<span class="lineNum">    5004 </span>            : 
<span class="lineNum">    5005 </span>            : /* Bits 26-31 are for num of channels in channel_array */
<span class="lineNum">    5006 </span>            : #define IWM_SCAN_CONFIG_N_CHANNELS(n) ((n) &lt;&lt; 26)
<span class="lineNum">    5007 </span>            : 
<span class="lineNum">    5008 </span>            : /* OFDM basic rates */
<span class="lineNum">    5009 </span>            : #define IWM_SCAN_CONFIG_RATE_6M         (1 &lt;&lt; 0)
<span class="lineNum">    5010 </span>            : #define IWM_SCAN_CONFIG_RATE_9M         (1 &lt;&lt; 1)
<span class="lineNum">    5011 </span>            : #define IWM_SCAN_CONFIG_RATE_12M        (1 &lt;&lt; 2)
<span class="lineNum">    5012 </span>            : #define IWM_SCAN_CONFIG_RATE_18M        (1 &lt;&lt; 3)
<span class="lineNum">    5013 </span>            : #define IWM_SCAN_CONFIG_RATE_24M        (1 &lt;&lt; 4)
<span class="lineNum">    5014 </span>            : #define IWM_SCAN_CONFIG_RATE_36M        (1 &lt;&lt; 5)
<span class="lineNum">    5015 </span>            : #define IWM_SCAN_CONFIG_RATE_48M        (1 &lt;&lt; 6)
<span class="lineNum">    5016 </span>            : #define IWM_SCAN_CONFIG_RATE_54M        (1 &lt;&lt; 7)
<span class="lineNum">    5017 </span>            : /* CCK basic rates */
<span class="lineNum">    5018 </span>            : #define IWM_SCAN_CONFIG_RATE_1M         (1 &lt;&lt; 8)
<span class="lineNum">    5019 </span>            : #define IWM_SCAN_CONFIG_RATE_2M         (1 &lt;&lt; 9)
<span class="lineNum">    5020 </span>            : #define IWM_SCAN_CONFIG_RATE_5M         (1 &lt;&lt; 10)
<span class="lineNum">    5021 </span>            : #define IWM_SCAN_CONFIG_RATE_11M        (1 &lt;&lt; 11)
<span class="lineNum">    5022 </span>            : 
<span class="lineNum">    5023 </span>            : /* Bits 16-27 are for supported rates */
<span class="lineNum">    5024 </span>            : #define IWM_SCAN_CONFIG_SUPPORTED_RATE(rate)    ((rate) &lt;&lt; 16)
<span class="lineNum">    5025 </span>            : 
<span class="lineNum">    5026 </span>            : #define IWM_CHANNEL_FLAG_EBS                            (1 &lt;&lt; 0)
<span class="lineNum">    5027 </span>            : #define IWM_CHANNEL_FLAG_ACCURATE_EBS                   (1 &lt;&lt; 1)
<span class="lineNum">    5028 </span>            : #define IWM_CHANNEL_FLAG_EBS_ADD                        (1 &lt;&lt; 2)
<span class="lineNum">    5029 </span>            : #define IWM_CHANNEL_FLAG_PRE_SCAN_PASSIVE2ACTIVE        (1 &lt;&lt; 3)
<span class="lineNum">    5030 </span>            : 
<span class="lineNum">    5031 </span>            : /**
<span class="lineNum">    5032 </span>            :  * struct iwm_scan_config
<span class="lineNum">    5033 </span>            :  * @flags:                      enum scan_config_flags
<span class="lineNum">    5034 </span>            :  * @tx_chains:                  valid_tx antenna - ANT_* definitions
<span class="lineNum">    5035 </span>            :  * @rx_chains:                  valid_rx antenna - ANT_* definitions
<span class="lineNum">    5036 </span>            :  * @legacy_rates:               default legacy rates - enum scan_config_rates
<span class="lineNum">    5037 </span>            :  * @out_of_channel_time:        default max out of serving channel time
<span class="lineNum">    5038 </span>            :  * @suspend_time:               default max suspend time
<span class="lineNum">    5039 </span>            :  * @dwell_active:               default dwell time for active scan
<span class="lineNum">    5040 </span>            :  * @dwell_passive:              default dwell time for passive scan
<span class="lineNum">    5041 </span>            :  * @dwell_fragmented:           default dwell time for fragmented scan
<span class="lineNum">    5042 </span>            :  * @dwell_extended:             default dwell time for channels 1, 6 and 11
<span class="lineNum">    5043 </span>            :  * @mac_addr:                   default mac address to be used in probes
<span class="lineNum">    5044 </span>            :  * @bcast_sta_id:               the index of the station in the fw
<span class="lineNum">    5045 </span>            :  * @channel_flags:              default channel flags - enum iwm_channel_flags
<span class="lineNum">    5046 </span>            :  *                              scan_config_channel_flag
<span class="lineNum">    5047 </span>            :  * @channel_array:              default supported channels
<span class="lineNum">    5048 </span>            :  */
<span class="lineNum">    5049 </span>            : struct iwm_scan_config {
<span class="lineNum">    5050 </span>            :         uint32_t flags;
<span class="lineNum">    5051 </span>            :         uint32_t tx_chains;
<span class="lineNum">    5052 </span>            :         uint32_t rx_chains;
<span class="lineNum">    5053 </span>            :         uint32_t legacy_rates;
<span class="lineNum">    5054 </span>            :         uint32_t out_of_channel_time;
<span class="lineNum">    5055 </span>            :         uint32_t suspend_time;
<span class="lineNum">    5056 </span>            :         uint8_t dwell_active;
<span class="lineNum">    5057 </span>            :         uint8_t dwell_passive;
<span class="lineNum">    5058 </span>            :         uint8_t dwell_fragmented;
<span class="lineNum">    5059 </span>            :         uint8_t dwell_extended;
<span class="lineNum">    5060 </span>            :         uint8_t mac_addr[ETHER_ADDR_LEN];
<span class="lineNum">    5061 </span>            :         uint8_t bcast_sta_id;
<span class="lineNum">    5062 </span>            :         uint8_t channel_flags;
<span class="lineNum">    5063 </span>            :         uint8_t channel_array[];
<span class="lineNum">    5064 </span>            : } __packed; /* SCAN_CONFIG_DB_CMD_API_S */
<span class="lineNum">    5065 </span>            : 
<span class="lineNum">    5066 </span>            : /**
<span class="lineNum">    5067 </span>            :  * iwm_umac_scan_flags
<span class="lineNum">    5068 </span>            :  *@IWM_UMAC_SCAN_FLAG_PREEMPTIVE: scan process triggered by this scan request
<span class="lineNum">    5069 </span>            :  *      can be preempted by other scan requests with higher priority.
<span class="lineNum">    5070 </span>            :  *      The low priority scan will be resumed when the higher proirity scan is
<span class="lineNum">    5071 </span>            :  *      completed.
<span class="lineNum">    5072 </span>            :  *@IWM_UMAC_SCAN_FLAG_START_NOTIF: notification will be sent to the driver
<span class="lineNum">    5073 </span>            :  *      when scan starts.
<span class="lineNum">    5074 </span>            :  */
<span class="lineNum">    5075 </span>            : #define IWM_UMAC_SCAN_FLAG_PREEMPTIVE           (1 &lt;&lt; 0)
<span class="lineNum">    5076 </span>            : #define IWM_UMAC_SCAN_FLAG_START_NOTIF          (1 &lt;&lt; 1)
<span class="lineNum">    5077 </span>            : 
<span class="lineNum">    5078 </span>            : #define IWM_UMAC_SCAN_UID_TYPE_OFFSET           0
<span class="lineNum">    5079 </span>            : #define IWM_UMAC_SCAN_UID_SEQ_OFFSET            8
<span class="lineNum">    5080 </span>            : 
<span class="lineNum">    5081 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_PERIODIC        (1 &lt;&lt; 0)
<span class="lineNum">    5082 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_OVER_BT         (1 &lt;&lt; 1)
<span class="lineNum">    5083 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_PASS_ALL        (1 &lt;&lt; 2)
<span class="lineNum">    5084 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_PASSIVE         (1 &lt;&lt; 3)
<span class="lineNum">    5085 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_PRE_CONNECT     (1 &lt;&lt; 4)
<span class="lineNum">    5086 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_ITER_COMPLETE   (1 &lt;&lt; 5)
<span class="lineNum">    5087 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_MULTIPLE_SSID   (1 &lt;&lt; 6)
<span class="lineNum">    5088 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_FRAGMENTED      (1 &lt;&lt; 7)
<span class="lineNum">    5089 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_RRM_ENABLED     (1 &lt;&lt; 8)
<span class="lineNum">    5090 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_MATCH           (1 &lt;&lt; 9)
<span class="lineNum">    5091 </span>            : #define IWM_UMAC_SCAN_GEN_FLAGS_EXTENDED_DWELL  (1 &lt;&lt; 10)
<span class="lineNum">    5092 </span>            : 
<span class="lineNum">    5093 </span>            : /**
<span class="lineNum">    5094 </span>            :  * struct iwm_scan_channel_cfg_umac
<span class="lineNum">    5095 </span>            :  * @flags:              bitmap - 0-19:  directed scan to i'th ssid.
<span class="lineNum">    5096 </span>            :  * @channel_num:        channel number 1-13 etc.
<span class="lineNum">    5097 </span>            :  * @iter_count:         repetition count for the channel.
<span class="lineNum">    5098 </span>            :  * @iter_interval:      interval between two scan iterations on one channel.
<span class="lineNum">    5099 </span>            :  */
<span class="lineNum">    5100 </span>            : struct iwm_scan_channel_cfg_umac {
<span class="lineNum">    5101 </span>            :         uint32_t flags;
<span class="lineNum">    5102 </span>            :         uint8_t channel_num;
<span class="lineNum">    5103 </span>            :         uint8_t iter_count;
<span class="lineNum">    5104 </span>            :         uint16_t iter_interval;
<span class="lineNum">    5105 </span>            : } __packed; /* SCAN_CHANNEL_CFG_S_VER2 */
<span class="lineNum">    5106 </span>            : 
<span class="lineNum">    5107 </span>            : /**
<span class="lineNum">    5108 </span>            :  * struct iwm_scan_umac_schedule
<span class="lineNum">    5109 </span>            :  * @interval: interval in seconds between scan iterations
<span class="lineNum">    5110 </span>            :  * @iter_count: num of scan iterations for schedule plan, 0xff for infinite loop
<span class="lineNum">    5111 </span>            :  * @reserved: for alignment and future use
<span class="lineNum">    5112 </span>            :  */
<span class="lineNum">    5113 </span>            : struct iwm_scan_umac_schedule {
<span class="lineNum">    5114 </span>            :         uint16_t interval;
<span class="lineNum">    5115 </span>            :         uint8_t iter_count;
<span class="lineNum">    5116 </span>            :         uint8_t reserved;
<span class="lineNum">    5117 </span>            : } __packed; /* SCAN_SCHED_PARAM_API_S_VER_1 */
<span class="lineNum">    5118 </span>            : 
<span class="lineNum">    5119 </span>            : /**
<span class="lineNum">    5120 </span>            :  * struct iwm_scan_req_umac_tail - the rest of the UMAC scan request command
<span class="lineNum">    5121 </span>            :  *      parameters following channels configuration array.
<span class="lineNum">    5122 </span>            :  * @schedule: two scheduling plans.
<span class="lineNum">    5123 </span>            :  * @delay: delay in TUs before starting the first scan iteration
<span class="lineNum">    5124 </span>            :  * @reserved: for future use and alignment
<span class="lineNum">    5125 </span>            :  * @preq: probe request with IEs blocks
<span class="lineNum">    5126 </span>            :  * @direct_scan: list of SSIDs for directed active scan
<span class="lineNum">    5127 </span>            :  */
<span class="lineNum">    5128 </span>            : struct iwm_scan_req_umac_tail {
<span class="lineNum">    5129 </span>            :         /* SCAN_PERIODIC_PARAMS_API_S_VER_1 */
<span class="lineNum">    5130 </span>            :         struct iwm_scan_umac_schedule schedule[IWM_MAX_SCHED_SCAN_PLANS];
<span class="lineNum">    5131 </span>            :         uint16_t delay;
<span class="lineNum">    5132 </span>            :         uint16_t reserved;
<span class="lineNum">    5133 </span>            :         /* SCAN_PROBE_PARAMS_API_S_VER_1 */
<span class="lineNum">    5134 </span>            :         struct iwm_scan_probe_req preq;
<span class="lineNum">    5135 </span>            :         struct iwm_ssid_ie direct_scan[IWM_PROBE_OPTION_MAX];
<span class="lineNum">    5136 </span>            : } __packed;
<span class="lineNum">    5137 </span>            : 
<span class="lineNum">    5138 </span>            : /**
<span class="lineNum">    5139 </span>            :  * struct iwm_scan_req_umac
<span class="lineNum">    5140 </span>            :  * @flags: &amp;enum iwm_umac_scan_flags
<span class="lineNum">    5141 </span>            :  * @uid: scan id, &amp;enum iwm_umac_scan_uid_offsets
<span class="lineNum">    5142 </span>            :  * @ooc_priority: out of channel priority - &amp;enum iwm_scan_priority
<span class="lineNum">    5143 </span>            :  * @general_flags: &amp;enum iwm_umac_scan_general_flags
<span class="lineNum">    5144 </span>            :  * @extended_dwell: dwell time for channels 1, 6 and 11
<span class="lineNum">    5145 </span>            :  * @active_dwell: dwell time for active scan
<span class="lineNum">    5146 </span>            :  * @passive_dwell: dwell time for passive scan
<span class="lineNum">    5147 </span>            :  * @fragmented_dwell: dwell time for fragmented passive scan
<span class="lineNum">    5148 </span>            :  * @max_out_time: max out of serving channel time
<span class="lineNum">    5149 </span>            :  * @suspend_time: max suspend time
<span class="lineNum">    5150 </span>            :  * @scan_priority: scan internal prioritization &amp;enum iwm_scan_priority
<span class="lineNum">    5151 </span>            :  * @channel_flags: &amp;enum iwm_scan_channel_flags
<span class="lineNum">    5152 </span>            :  * @n_channels: num of channels in scan request
<span class="lineNum">    5153 </span>            :  * @reserved: for future use and alignment
<span class="lineNum">    5154 </span>            :  * @data: &amp;struct iwm_scan_channel_cfg_umac and
<span class="lineNum">    5155 </span>            :  *      &amp;struct iwm_scan_req_umac_tail
<span class="lineNum">    5156 </span>            :  */
<span class="lineNum">    5157 </span>            : struct iwm_scan_req_umac {
<span class="lineNum">    5158 </span>            :         uint32_t flags;
<span class="lineNum">    5159 </span>            :         uint32_t uid;
<span class="lineNum">    5160 </span>            :         uint32_t ooc_priority;
<span class="lineNum">    5161 </span>            :         /* SCAN_GENERAL_PARAMS_API_S_VER_1 */
<span class="lineNum">    5162 </span>            :         uint32_t general_flags;
<span class="lineNum">    5163 </span>            :         uint8_t extended_dwell;
<span class="lineNum">    5164 </span>            :         uint8_t active_dwell;
<span class="lineNum">    5165 </span>            :         uint8_t passive_dwell;
<span class="lineNum">    5166 </span>            :         uint8_t fragmented_dwell;
<span class="lineNum">    5167 </span>            :         uint32_t max_out_time;
<span class="lineNum">    5168 </span>            :         uint32_t suspend_time;
<span class="lineNum">    5169 </span>            :         uint32_t scan_priority;
<span class="lineNum">    5170 </span>            :         /* SCAN_CHANNEL_PARAMS_API_S_VER_1 */
<span class="lineNum">    5171 </span>            :         uint8_t channel_flags;
<span class="lineNum">    5172 </span>            :         uint8_t n_channels;
<span class="lineNum">    5173 </span>            :         uint16_t reserved;
<span class="lineNum">    5174 </span>            :         uint8_t data[];
<span class="lineNum">    5175 </span>            : } __packed; /* SCAN_REQUEST_CMD_UMAC_API_S_VER_1 */
<span class="lineNum">    5176 </span>            : 
<span class="lineNum">    5177 </span>            : /**
<span class="lineNum">    5178 </span>            :  * struct iwm_umac_scan_abort
<span class="lineNum">    5179 </span>            :  * @uid: scan id, &amp;enum iwm_umac_scan_uid_offsets
<span class="lineNum">    5180 </span>            :  * @flags: reserved
<span class="lineNum">    5181 </span>            :  */
<span class="lineNum">    5182 </span>            : struct iwm_umac_scan_abort {
<span class="lineNum">    5183 </span>            :         uint32_t uid;
<span class="lineNum">    5184 </span>            :         uint32_t flags;
<span class="lineNum">    5185 </span>            : } __packed; /* SCAN_ABORT_CMD_UMAC_API_S_VER_1 */
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span>            : /**
<span class="lineNum">    5188 </span>            :  * struct iwm_umac_scan_complete
<span class="lineNum">    5189 </span>            :  * @uid: scan id, &amp;enum iwm_umac_scan_uid_offsets
<span class="lineNum">    5190 </span>            :  * @last_schedule: last scheduling line
<span class="lineNum">    5191 </span>            :  * @last_iter:  last scan iteration number
<span class="lineNum">    5192 </span>            :  * @scan status: &amp;enum iwm_scan_offload_complete_status
<span class="lineNum">    5193 </span>            :  * @ebs_status: &amp;enum iwm_scan_ebs_status
<span class="lineNum">    5194 </span>            :  * @time_from_last_iter: time elapsed from last iteration
<span class="lineNum">    5195 </span>            :  * @reserved: for future use
<span class="lineNum">    5196 </span>            :  */
<span class="lineNum">    5197 </span>            : struct iwm_umac_scan_complete {
<span class="lineNum">    5198 </span>            :         uint32_t uid;
<span class="lineNum">    5199 </span>            :         uint8_t last_schedule;
<span class="lineNum">    5200 </span>            :         uint8_t last_iter;
<span class="lineNum">    5201 </span>            :         uint8_t status;
<span class="lineNum">    5202 </span>            :         uint8_t ebs_status;
<span class="lineNum">    5203 </span>            :         uint32_t time_from_last_iter;
<span class="lineNum">    5204 </span>            :         uint32_t reserved;
<span class="lineNum">    5205 </span>            : } __packed; /* SCAN_COMPLETE_NTF_UMAC_API_S_VER_1 */
<span class="lineNum">    5206 </span>            : 
<span class="lineNum">    5207 </span>            : #define IWM_SCAN_OFFLOAD_MATCHING_CHANNELS_LEN 5
<span class="lineNum">    5208 </span>            : /**
<span class="lineNum">    5209 </span>            :  * struct iwm_scan_offload_profile_match - match information
<span class="lineNum">    5210 </span>            :  * @bssid: matched bssid
<span class="lineNum">    5211 </span>            :  * @channel: channel where the match occurred
<span class="lineNum">    5212 </span>            :  * @energy:
<span class="lineNum">    5213 </span>            :  * @matching_feature:
<span class="lineNum">    5214 </span>            :  * @matching_channels: bitmap of channels that matched, referencing
<span class="lineNum">    5215 </span>            :  *      the channels passed in tue scan offload request
<span class="lineNum">    5216 </span>            :  */
<span class="lineNum">    5217 </span>            : struct iwm_scan_offload_profile_match {
<span class="lineNum">    5218 </span>            :         uint8_t bssid[ETHER_ADDR_LEN];
<span class="lineNum">    5219 </span>            :         uint16_t reserved;
<span class="lineNum">    5220 </span>            :         uint8_t channel;
<span class="lineNum">    5221 </span>            :         uint8_t energy;
<span class="lineNum">    5222 </span>            :         uint8_t matching_feature;
<span class="lineNum">    5223 </span>            :         uint8_t matching_channels[IWM_SCAN_OFFLOAD_MATCHING_CHANNELS_LEN];
<span class="lineNum">    5224 </span>            : } __packed; /* SCAN_OFFLOAD_PROFILE_MATCH_RESULTS_S_VER_1 */
<span class="lineNum">    5225 </span>            : 
<span class="lineNum">    5226 </span>            : /**
<span class="lineNum">    5227 </span>            :  * struct iwm_scan_offload_profiles_query - match results query response
<span class="lineNum">    5228 </span>            :  * @matched_profiles: bitmap of matched profiles, referencing the
<span class="lineNum">    5229 </span>            :  *      matches passed in the scan offload request
<span class="lineNum">    5230 </span>            :  * @last_scan_age: age of the last offloaded scan
<span class="lineNum">    5231 </span>            :  * @n_scans_done: number of offloaded scans done
<span class="lineNum">    5232 </span>            :  * @gp2_d0u: GP2 when D0U occurred
<span class="lineNum">    5233 </span>            :  * @gp2_invoked: GP2 when scan offload was invoked
<span class="lineNum">    5234 </span>            :  * @resume_while_scanning: not used
<span class="lineNum">    5235 </span>            :  * @self_recovery: obsolete
<span class="lineNum">    5236 </span>            :  * @reserved: reserved
<span class="lineNum">    5237 </span>            :  * @matches: array of match information, one for each match
<span class="lineNum">    5238 </span>            :  */
<span class="lineNum">    5239 </span>            : struct iwm_scan_offload_profiles_query {
<span class="lineNum">    5240 </span>            :         uint32_t matched_profiles;
<span class="lineNum">    5241 </span>            :         uint32_t last_scan_age;
<span class="lineNum">    5242 </span>            :         uint32_t n_scans_done;
<span class="lineNum">    5243 </span>            :         uint32_t gp2_d0u;
<span class="lineNum">    5244 </span>            :         uint32_t gp2_invoked;
<span class="lineNum">    5245 </span>            :         uint8_t resume_while_scanning;
<span class="lineNum">    5246 </span>            :         uint8_t self_recovery;
<span class="lineNum">    5247 </span>            :         uint16_t reserved;
<span class="lineNum">    5248 </span>            :         struct iwm_scan_offload_profile_match matches[IWM_SCAN_MAX_PROFILES];
<span class="lineNum">    5249 </span>            : } __packed; /* SCAN_OFFLOAD_PROFILES_QUERY_RSP_S_VER_2 */
<span class="lineNum">    5250 </span>            : 
<span class="lineNum">    5251 </span>            : /**
<span class="lineNum">    5252 </span>            :  * struct iwm_umac_scan_iter_complete_notif - notifies end of scanning iteration
<span class="lineNum">    5253 </span>            :  * @uid: scan id, &amp;enum iwm_umac_scan_uid_offsets
<span class="lineNum">    5254 </span>            :  * @scanned_channels: number of channels scanned and number of valid elements in
<span class="lineNum">    5255 </span>            :  *      results array
<span class="lineNum">    5256 </span>            :  * @status: one of SCAN_COMP_STATUS_*
<span class="lineNum">    5257 </span>            :  * @bt_status: BT on/off status
<span class="lineNum">    5258 </span>            :  * @last_channel: last channel that was scanned
<span class="lineNum">    5259 </span>            :  * @tsf_low: TSF timer (lower half) in usecs
<span class="lineNum">    5260 </span>            :  * @tsf_high: TSF timer (higher half) in usecs
<span class="lineNum">    5261 </span>            :  * @results: array of scan results, only &quot;scanned_channels&quot; of them are valid
<span class="lineNum">    5262 </span>            :  */
<span class="lineNum">    5263 </span>            : struct iwm_umac_scan_iter_complete_notif {
<span class="lineNum">    5264 </span>            :         uint32_t uid;
<span class="lineNum">    5265 </span>            :         uint8_t scanned_channels;
<span class="lineNum">    5266 </span>            :         uint8_t status;
<span class="lineNum">    5267 </span>            :         uint8_t bt_status;
<span class="lineNum">    5268 </span>            :         uint8_t last_channel;
<span class="lineNum">    5269 </span>            :         uint32_t tsf_low;
<span class="lineNum">    5270 </span>            :         uint32_t tsf_high;
<span class="lineNum">    5271 </span>            :         struct iwm_scan_results_notif results[];
<span class="lineNum">    5272 </span>            : } __packed; /* SCAN_ITER_COMPLETE_NTF_UMAC_API_S_VER_1 */
<span class="lineNum">    5273 </span>            : 
<span class="lineNum">    5274 </span>            : #define IWM_GSCAN_START_CMD                     0x0
<span class="lineNum">    5275 </span>            : #define IWM_GSCAN_STOP_CMD                      0x1
<span class="lineNum">    5276 </span>            : #define IWM_GSCAN_SET_HOTLIST_CMD               0x2
<span class="lineNum">    5277 </span>            : #define IWM_GSCAN_RESET_HOTLIST_CMD             0x3
<span class="lineNum">    5278 </span>            : #define IWM_GSCAN_SET_SIGNIFICANT_CHANGE_CMD    0x4
<span class="lineNum">    5279 </span>            : #define IWM_GSCAN_RESET_SIGNIFICANT_CHANGE_CMD  0x5
<span class="lineNum">    5280 </span>            : #define IWM_GSCAN_SIGNIFICANT_CHANGE_EVENT      0xFD
<span class="lineNum">    5281 </span>            : #define IWM_GSCAN_HOTLIST_CHANGE_EVENT          0xFE
<span class="lineNum">    5282 </span>            : #define IWM_GSCAN_RESULTS_AVAILABLE_EVENT       0xFF
<span class="lineNum">    5283 </span>            : 
<span class="lineNum">    5284 </span>            : /* STA API */
<span class="lineNum">    5285 </span>            : 
<span class="lineNum">    5286 </span>            : /**
<span class="lineNum">    5287 </span>            :  * flags for the ADD_STA host command
<span class="lineNum">    5288 </span>            :  * @IWM_STA_FLG_REDUCED_TX_PWR_CTRL:
<span class="lineNum">    5289 </span>            :  * @IWM_STA_FLG_REDUCED_TX_PWR_DATA:
<span class="lineNum">    5290 </span>            :  * @IWM_STA_FLG_DISABLE_TX: set if TX should be disabled
<span class="lineNum">    5291 </span>            :  * @IWM_STA_FLG_PS: set if STA is in Power Save
<span class="lineNum">    5292 </span>            :  * @IWM_STA_FLG_INVALID: set if STA is invalid
<span class="lineNum">    5293 </span>            :  * @IWM_STA_FLG_DLP_EN: Direct Link Protocol is enabled
<span class="lineNum">    5294 </span>            :  * @IWM_STA_FLG_SET_ALL_KEYS: the current key applies to all key IDs
<span class="lineNum">    5295 </span>            :  * @IWM_STA_FLG_DRAIN_FLOW: drain flow
<span class="lineNum">    5296 </span>            :  * @IWM_STA_FLG_PAN: STA is for PAN interface
<span class="lineNum">    5297 </span>            :  * @IWM_STA_FLG_CLASS_AUTH:
<span class="lineNum">    5298 </span>            :  * @IWM_STA_FLG_CLASS_ASSOC:
<span class="lineNum">    5299 </span>            :  * @IWM_STA_FLG_CLASS_MIMO_PROT:
<span class="lineNum">    5300 </span>            :  * @IWM_STA_FLG_MAX_AGG_SIZE_MSK: maximal size for A-MPDU
<span class="lineNum">    5301 </span>            :  * @IWM_STA_FLG_AGG_MPDU_DENS_MSK: maximal MPDU density for Tx aggregation
<span class="lineNum">    5302 </span>            :  * @IWM_STA_FLG_FAT_EN_MSK: support for channel width (for Tx). This flag is
<span class="lineNum">    5303 </span>            :  *      initialised by driver and can be updated by fw upon reception of
<span class="lineNum">    5304 </span>            :  *      action frames that can change the channel width. When cleared the fw
<span class="lineNum">    5305 </span>            :  *      will send all the frames in 20MHz even when FAT channel is requested.
<span class="lineNum">    5306 </span>            :  * @IWM_STA_FLG_MIMO_EN_MSK: support for MIMO. This flag is initialised by the
<span class="lineNum">    5307 </span>            :  *      driver and can be updated by fw upon reception of action frames.
<span class="lineNum">    5308 </span>            :  * @IWM_STA_FLG_MFP_EN: Management Frame Protection
<span class="lineNum">    5309 </span>            :  */
<span class="lineNum">    5310 </span>            : #define IWM_STA_FLG_REDUCED_TX_PWR_CTRL (1 &lt;&lt; 3)
<span class="lineNum">    5311 </span>            : #define IWM_STA_FLG_REDUCED_TX_PWR_DATA (1 &lt;&lt; 6)
<span class="lineNum">    5312 </span>            : 
<span class="lineNum">    5313 </span>            : #define IWM_STA_FLG_DISABLE_TX          (1 &lt;&lt; 4)
<span class="lineNum">    5314 </span>            : 
<span class="lineNum">    5315 </span>            : #define IWM_STA_FLG_PS                  (1 &lt;&lt; 8)
<span class="lineNum">    5316 </span>            : #define IWM_STA_FLG_DRAIN_FLOW          (1 &lt;&lt; 12)
<span class="lineNum">    5317 </span>            : #define IWM_STA_FLG_PAN                 (1 &lt;&lt; 13)
<span class="lineNum">    5318 </span>            : #define IWM_STA_FLG_CLASS_AUTH          (1 &lt;&lt; 14)
<span class="lineNum">    5319 </span>            : #define IWM_STA_FLG_CLASS_ASSOC         (1 &lt;&lt; 15)
<span class="lineNum">    5320 </span>            : #define IWM_STA_FLG_RTS_MIMO_PROT       (1 &lt;&lt; 17)
<span class="lineNum">    5321 </span>            : 
<span class="lineNum">    5322 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_SHIFT  19
<span class="lineNum">    5323 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_8K     (0 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5324 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_16K    (1 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5325 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_32K    (2 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5326 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_64K    (3 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5327 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_128K   (4 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5328 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_256K   (5 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5329 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_512K   (6 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5330 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_1024K  (7 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5331 </span>            : #define IWM_STA_FLG_MAX_AGG_SIZE_MSK    (7 &lt;&lt; IWM_STA_FLG_MAX_AGG_SIZE_SHIFT)
<span class="lineNum">    5332 </span>            : 
<span class="lineNum">    5333 </span>            : #define IWM_STA_FLG_AGG_MPDU_DENS_SHIFT 23
<span class="lineNum">    5334 </span>            : #define IWM_STA_FLG_AGG_MPDU_DENS_2US   (4 &lt;&lt; IWM_STA_FLG_AGG_MPDU_DENS_SHIFT)
<span class="lineNum">    5335 </span>            : #define IWM_STA_FLG_AGG_MPDU_DENS_4US   (5 &lt;&lt; IWM_STA_FLG_AGG_MPDU_DENS_SHIFT)
<span class="lineNum">    5336 </span>            : #define IWM_STA_FLG_AGG_MPDU_DENS_8US   (6 &lt;&lt; IWM_STA_FLG_AGG_MPDU_DENS_SHIFT)
<span class="lineNum">    5337 </span>            : #define IWM_STA_FLG_AGG_MPDU_DENS_16US  (7 &lt;&lt; IWM_STA_FLG_AGG_MPDU_DENS_SHIFT)
<span class="lineNum">    5338 </span>            : #define IWM_STA_FLG_AGG_MPDU_DENS_MSK   (7 &lt;&lt; IWM_STA_FLG_AGG_MPDU_DENS_SHIFT)
<span class="lineNum">    5339 </span>            : 
<span class="lineNum">    5340 </span>            : #define IWM_STA_FLG_FAT_EN_20MHZ        (0 &lt;&lt; 26)
<span class="lineNum">    5341 </span>            : #define IWM_STA_FLG_FAT_EN_40MHZ        (1 &lt;&lt; 26)
<span class="lineNum">    5342 </span>            : #define IWM_STA_FLG_FAT_EN_80MHZ        (2 &lt;&lt; 26)
<span class="lineNum">    5343 </span>            : #define IWM_STA_FLG_FAT_EN_160MHZ       (3 &lt;&lt; 26)
<span class="lineNum">    5344 </span>            : #define IWM_STA_FLG_FAT_EN_MSK          (3 &lt;&lt; 26)
<span class="lineNum">    5345 </span>            : 
<span class="lineNum">    5346 </span>            : #define IWM_STA_FLG_MIMO_EN_SISO        (0 &lt;&lt; 28)
<span class="lineNum">    5347 </span>            : #define IWM_STA_FLG_MIMO_EN_MIMO2       (1 &lt;&lt; 28)
<span class="lineNum">    5348 </span>            : #define IWM_STA_FLG_MIMO_EN_MIMO3       (2 &lt;&lt; 28)
<span class="lineNum">    5349 </span>            : #define IWM_STA_FLG_MIMO_EN_MSK         (3 &lt;&lt; 28)
<span class="lineNum">    5350 </span>            : 
<span class="lineNum">    5351 </span>            : /**
<span class="lineNum">    5352 </span>            :  * key flags for the ADD_STA host command
<span class="lineNum">    5353 </span>            :  * @IWM_STA_KEY_FLG_NO_ENC: no encryption
<span class="lineNum">    5354 </span>            :  * @IWM_STA_KEY_FLG_WEP: WEP encryption algorithm
<span class="lineNum">    5355 </span>            :  * @IWM_STA_KEY_FLG_CCM: CCMP encryption algorithm
<span class="lineNum">    5356 </span>            :  * @IWM_STA_KEY_FLG_TKIP: TKIP encryption algorithm
<span class="lineNum">    5357 </span>            :  * @IWM_STA_KEY_FLG_EXT: extended cipher algorithm (depends on the FW support)
<span class="lineNum">    5358 </span>            :  * @IWM_STA_KEY_FLG_CMAC: CMAC encryption algorithm
<span class="lineNum">    5359 </span>            :  * @IWM_STA_KEY_FLG_ENC_UNKNOWN: unknown encryption algorithm
<span class="lineNum">    5360 </span>            :  * @IWM_STA_KEY_FLG_EN_MSK: mask for encryption algorithmi value
<span class="lineNum">    5361 </span>            :  * @IWM_STA_KEY_FLG_WEP_KEY_MAP: wep is either a group key (0 - legacy WEP) or from
<span class="lineNum">    5362 </span>            :  *      station info array (1 - n 1X mode)
<span class="lineNum">    5363 </span>            :  * @IWM_STA_KEY_FLG_KEYID_MSK: the index of the key
<span class="lineNum">    5364 </span>            :  * @IWM_STA_KEY_NOT_VALID: key is invalid
<span class="lineNum">    5365 </span>            :  * @IWM_STA_KEY_FLG_WEP_13BYTES: set for 13 bytes WEP key
<span class="lineNum">    5366 </span>            :  * @IWM_STA_KEY_MULTICAST: set for multical key
<span class="lineNum">    5367 </span>            :  * @IWM_STA_KEY_MFP: key is used for Management Frame Protection
<span class="lineNum">    5368 </span>            :  */
<span class="lineNum">    5369 </span>            : #define IWM_STA_KEY_FLG_NO_ENC          (0 &lt;&lt; 0)
<span class="lineNum">    5370 </span>            : #define IWM_STA_KEY_FLG_WEP             (1 &lt;&lt; 0)
<span class="lineNum">    5371 </span>            : #define IWM_STA_KEY_FLG_CCM             (2 &lt;&lt; 0)
<span class="lineNum">    5372 </span>            : #define IWM_STA_KEY_FLG_TKIP            (3 &lt;&lt; 0)
<span class="lineNum">    5373 </span>            : #define IWM_STA_KEY_FLG_EXT             (4 &lt;&lt; 0)
<span class="lineNum">    5374 </span>            : #define IWM_STA_KEY_FLG_CMAC            (6 &lt;&lt; 0)
<span class="lineNum">    5375 </span>            : #define IWM_STA_KEY_FLG_ENC_UNKNOWN     (7 &lt;&lt; 0)
<span class="lineNum">    5376 </span>            : #define IWM_STA_KEY_FLG_EN_MSK          (7 &lt;&lt; 0)
<span class="lineNum">    5377 </span>            : #define IWM_STA_KEY_FLG_WEP_KEY_MAP     (1 &lt;&lt; 3)
<span class="lineNum">    5378 </span>            : #define IWM_STA_KEY_FLG_KEYID_POS       8
<span class="lineNum">    5379 </span>            : #define IWM_STA_KEY_FLG_KEYID_MSK       (3 &lt;&lt; IWM_STA_KEY_FLG_KEYID_POS)
<span class="lineNum">    5380 </span>            : #define IWM_STA_KEY_NOT_VALID           (1 &lt;&lt; 11)
<span class="lineNum">    5381 </span>            : #define IWM_STA_KEY_FLG_WEP_13BYTES     (1 &lt;&lt; 12)
<span class="lineNum">    5382 </span>            : #define IWM_STA_KEY_MULTICAST           (1 &lt;&lt; 14)
<span class="lineNum">    5383 </span>            : #define IWM_STA_KEY_MFP                 (1 &lt;&lt; 15)
<span class="lineNum">    5384 </span>            : 
<span class="lineNum">    5385 </span>            : /**
<span class="lineNum">    5386 </span>            :  * indicate to the fw what flag are being changed
<span class="lineNum">    5387 </span>            :  * @IWM_STA_MODIFY_QUEUE_REMOVAL: this command removes a queue
<span class="lineNum">    5388 </span>            :  * @IWM_STA_MODIFY_TID_DISABLE_TX: this command modifies %tid_disable_tx
<span class="lineNum">    5389 </span>            :  * @IWM_STA_MODIFY_TX_RATE: unused
<span class="lineNum">    5390 </span>            :  * @IWM_STA_MODIFY_ADD_BA_TID: this command modifies %add_immediate_ba_tid
<span class="lineNum">    5391 </span>            :  * @IWM_STA_MODIFY_REMOVE_BA_TID: this command modifies %remove_immediate_ba_tid
<span class="lineNum">    5392 </span>            :  * @IWM_STA_MODIFY_SLEEPING_STA_TX_COUNT: this command modifies %sleep_tx_count
<span class="lineNum">    5393 </span>            :  * @IWM_STA_MODIFY_PROT_TH:
<span class="lineNum">    5394 </span>            :  * @IWM_STA_MODIFY_QUEUES: modify the queues used by this station
<span class="lineNum">    5395 </span>            :  */
<span class="lineNum">    5396 </span>            : #define IWM_STA_MODIFY_QUEUE_REMOVAL            (1 &lt;&lt; 0)
<span class="lineNum">    5397 </span>            : #define IWM_STA_MODIFY_TID_DISABLE_TX           (1 &lt;&lt; 1)
<span class="lineNum">    5398 </span>            : #define IWM_STA_MODIFY_TX_RATE                  (1 &lt;&lt; 2)
<span class="lineNum">    5399 </span>            : #define IWM_STA_MODIFY_ADD_BA_TID               (1 &lt;&lt; 3)
<span class="lineNum">    5400 </span>            : #define IWM_STA_MODIFY_REMOVE_BA_TID            (1 &lt;&lt; 4)
<span class="lineNum">    5401 </span>            : #define IWM_STA_MODIFY_SLEEPING_STA_TX_COUNT    (1 &lt;&lt; 5)
<span class="lineNum">    5402 </span>            : #define IWM_STA_MODIFY_PROT_TH                  (1 &lt;&lt; 6)
<span class="lineNum">    5403 </span>            : #define IWM_STA_MODIFY_QUEUES                   (1 &lt;&lt; 7)
<span class="lineNum">    5404 </span>            : 
<span class="lineNum">    5405 </span>            : #define IWM_STA_MODE_MODIFY     1
<span class="lineNum">    5406 </span>            : 
<span class="lineNum">    5407 </span>            : /**
<span class="lineNum">    5408 </span>            :  * type of sleep of the station
<span class="lineNum">    5409 </span>            :  * @IWM_STA_SLEEP_STATE_AWAKE:
<span class="lineNum">    5410 </span>            :  * @IWM_STA_SLEEP_STATE_PS_POLL:
<span class="lineNum">    5411 </span>            :  * @IWM_STA_SLEEP_STATE_UAPSD:
<span class="lineNum">    5412 </span>            :  * @IWM_STA_SLEEP_STATE_MOREDATA: set more-data bit on
<span class="lineNum">    5413 </span>            :  *      (last) released frame
<span class="lineNum">    5414 </span>            :  */
<span class="lineNum">    5415 </span>            : #define IWM_STA_SLEEP_STATE_AWAKE       0
<span class="lineNum">    5416 </span>            : #define IWM_STA_SLEEP_STATE_PS_POLL     (1 &lt;&lt; 0)
<span class="lineNum">    5417 </span>            : #define IWM_STA_SLEEP_STATE_UAPSD       (1 &lt;&lt; 1)
<span class="lineNum">    5418 </span>            : #define IWM_STA_SLEEP_STATE_MOREDATA    (1 &lt;&lt; 2)
<span class="lineNum">    5419 </span>            : 
<span class="lineNum">    5420 </span>            : /* STA ID and color bits definitions */
<span class="lineNum">    5421 </span>            : #define IWM_STA_ID_SEED         (0x0f)
<span class="lineNum">    5422 </span>            : #define IWM_STA_ID_POS          (0)
<span class="lineNum">    5423 </span>            : #define IWM_STA_ID_MSK          (IWM_STA_ID_SEED &lt;&lt; IWM_STA_ID_POS)
<span class="lineNum">    5424 </span>            : 
<span class="lineNum">    5425 </span>            : #define IWM_STA_COLOR_SEED      (0x7)
<span class="lineNum">    5426 </span>            : #define IWM_STA_COLOR_POS       (4)
<span class="lineNum">    5427 </span>            : #define IWM_STA_COLOR_MSK       (IWM_STA_COLOR_SEED &lt;&lt; IWM_STA_COLOR_POS)
<span class="lineNum">    5428 </span>            : 
<span class="lineNum">    5429 </span>            : #define IWM_STA_ID_N_COLOR_GET_COLOR(id_n_color) \
<span class="lineNum">    5430 </span>            :         (((id_n_color) &amp; IWM_STA_COLOR_MSK) &gt;&gt; IWM_STA_COLOR_POS)
<span class="lineNum">    5431 </span>            : #define IWM_STA_ID_N_COLOR_GET_ID(id_n_color)    \
<span class="lineNum">    5432 </span>            :         (((id_n_color) &amp; IWM_STA_ID_MSK) &gt;&gt; IWM_STA_ID_POS)
<span class="lineNum">    5433 </span>            : 
<span class="lineNum">    5434 </span>            : #define IWM_STA_KEY_MAX_NUM (16)
<span class="lineNum">    5435 </span>            : #define IWM_STA_KEY_IDX_INVALID (0xff)
<span class="lineNum">    5436 </span>            : #define IWM_STA_KEY_MAX_DATA_KEY_NUM (4)
<span class="lineNum">    5437 </span>            : #define IWM_MAX_GLOBAL_KEYS (4)
<span class="lineNum">    5438 </span>            : #define IWM_STA_KEY_LEN_WEP40 (5)
<span class="lineNum">    5439 </span>            : #define IWM_STA_KEY_LEN_WEP104 (13)
<span class="lineNum">    5440 </span>            : 
<span class="lineNum">    5441 </span>            : /**
<span class="lineNum">    5442 </span>            :  * struct iwm_keyinfo - key information
<span class="lineNum">    5443 </span>            :  * @key_flags: type %iwm_sta_key_flag
<span class="lineNum">    5444 </span>            :  * @tkip_rx_tsc_byte2: TSC[2] for key mix ph1 detection
<span class="lineNum">    5445 </span>            :  * @tkip_rx_ttak: 10-byte unicast TKIP TTAK for Rx
<span class="lineNum">    5446 </span>            :  * @key_offset: key offset in the fw's key table
<span class="lineNum">    5447 </span>            :  * @key: 16-byte unicast decryption key
<span class="lineNum">    5448 </span>            :  * @tx_secur_seq_cnt: initial RSC / PN needed for replay check
<span class="lineNum">    5449 </span>            :  * @hw_tkip_mic_rx_key: byte: MIC Rx Key - used for TKIP only
<span class="lineNum">    5450 </span>            :  * @hw_tkip_mic_tx_key: byte: MIC Tx Key - used for TKIP only
<span class="lineNum">    5451 </span>            :  */
<span class="lineNum">    5452 </span>            : struct iwm_keyinfo {
<span class="lineNum">    5453 </span>            :         uint16_t key_flags;
<span class="lineNum">    5454 </span>            :         uint8_t tkip_rx_tsc_byte2;
<span class="lineNum">    5455 </span>            :         uint8_t reserved1;
<span class="lineNum">    5456 </span>            :         uint16_t tkip_rx_ttak[5];
<span class="lineNum">    5457 </span>            :         uint8_t key_offset;
<span class="lineNum">    5458 </span>            :         uint8_t reserved2;
<span class="lineNum">    5459 </span>            :         uint8_t key[16];
<span class="lineNum">    5460 </span>            :         uint64_t tx_secur_seq_cnt;
<span class="lineNum">    5461 </span>            :         uint64_t hw_tkip_mic_rx_key;
<span class="lineNum">    5462 </span>            :         uint64_t hw_tkip_mic_tx_key;
<span class="lineNum">    5463 </span>            : } __packed;
<span class="lineNum">    5464 </span>            : 
<span class="lineNum">    5465 </span>            : #define IWM_ADD_STA_STATUS_MASK         0xFF
<span class="lineNum">    5466 </span>            : #define IWM_ADD_STA_BAID_VALID_MASK     0x8000
<span class="lineNum">    5467 </span>            : #define IWM_ADD_STA_BAID_MASK           0x7F00
<span class="lineNum">    5468 </span>            : #define IWM_ADD_STA_BAID_SHIFT          8
<span class="lineNum">    5469 </span>            : 
<span class="lineNum">    5470 </span>            : /**
<span class="lineNum">    5471 </span>            :  * struct iwm_add_sta_cmd_v7 - Add/modify a station in the fw's sta table.
<span class="lineNum">    5472 </span>            :  * ( REPLY_ADD_STA = 0x18 )
<span class="lineNum">    5473 </span>            :  * @add_modify: 1: modify existing, 0: add new station
<span class="lineNum">    5474 </span>            :  * @awake_acs:
<span class="lineNum">    5475 </span>            :  * @tid_disable_tx: is tid BIT(tid) enabled for Tx. Clear BIT(x) to enable
<span class="lineNum">    5476 </span>            :  *      AMPDU for tid x. Set %IWM_STA_MODIFY_TID_DISABLE_TX to change this field.
<span class="lineNum">    5477 </span>            :  * @mac_id_n_color: the Mac context this station belongs to
<span class="lineNum">    5478 </span>            :  * @addr[ETHER_ADDR_LEN]: station's MAC address
<span class="lineNum">    5479 </span>            :  * @sta_id: index of station in uCode's station table
<span class="lineNum">    5480 </span>            :  * @modify_mask: IWM_STA_MODIFY_*, selects which parameters to modify vs. leave
<span class="lineNum">    5481 </span>            :  *      alone. 1 - modify, 0 - don't change.
<span class="lineNum">    5482 </span>            :  * @station_flags: look at %iwm_sta_flags
<span class="lineNum">    5483 </span>            :  * @station_flags_msk: what of %station_flags have changed
<span class="lineNum">    5484 </span>            :  * @add_immediate_ba_tid: tid for which to add block-ack support (Rx)
<span class="lineNum">    5485 </span>            :  *      Set %IWM_STA_MODIFY_ADD_BA_TID to use this field, and also set
<span class="lineNum">    5486 </span>            :  *      add_immediate_ba_ssn.
<span class="lineNum">    5487 </span>            :  * @remove_immediate_ba_tid: tid for which to remove block-ack support (Rx)
<span class="lineNum">    5488 </span>            :  *      Set %IWM_STA_MODIFY_REMOVE_BA_TID to use this field
<span class="lineNum">    5489 </span>            :  * @add_immediate_ba_ssn: ssn for the Rx block-ack session. Used together with
<span class="lineNum">    5490 </span>            :  *      add_immediate_ba_tid.
<span class="lineNum">    5491 </span>            :  * @sleep_tx_count: number of packets to transmit to station even though it is
<span class="lineNum">    5492 </span>            :  *      asleep. Used to synchronise PS-poll and u-APSD responses while ucode
<span class="lineNum">    5493 </span>            :  *      keeps track of STA sleep state.
<span class="lineNum">    5494 </span>            :  * @sleep_state_flags: Look at %iwm_sta_sleep_flag.
<span class="lineNum">    5495 </span>            :  * @assoc_id: assoc_id to be sent in VHT PLCP (9-bit), for grp use 0, for AP
<span class="lineNum">    5496 </span>            :  *      mac-addr.
<span class="lineNum">    5497 </span>            :  * @beamform_flags: beam forming controls
<span class="lineNum">    5498 </span>            :  * @tfd_queue_msk: tfd queues used by this station
<span class="lineNum">    5499 </span>            :  *
<span class="lineNum">    5500 </span>            :  * The device contains an internal table of per-station information, with info
<span class="lineNum">    5501 </span>            :  * on security keys, aggregation parameters, and Tx rates for initial Tx
<span class="lineNum">    5502 </span>            :  * attempt and any retries (set by IWM_REPLY_TX_LINK_QUALITY_CMD).
<span class="lineNum">    5503 </span>            :  *
<span class="lineNum">    5504 </span>            :  * ADD_STA sets up the table entry for one station, either creating a new
<span class="lineNum">    5505 </span>            :  * entry, or modifying a pre-existing one.
<span class="lineNum">    5506 </span>            :  */
<span class="lineNum">    5507 </span>            : struct iwm_add_sta_cmd_v7 {
<span class="lineNum">    5508 </span>            :         uint8_t add_modify;
<span class="lineNum">    5509 </span>            :         uint8_t awake_acs;
<span class="lineNum">    5510 </span>            :         uint16_t tid_disable_tx;
<span class="lineNum">    5511 </span>            :         uint32_t mac_id_n_color;
<span class="lineNum">    5512 </span>            :         uint8_t addr[ETHER_ADDR_LEN];   /* _STA_ID_MODIFY_INFO_API_S_VER_1 */
<span class="lineNum">    5513 </span>            :         uint16_t reserved2;
<span class="lineNum">    5514 </span>            :         uint8_t sta_id;
<span class="lineNum">    5515 </span>            :         uint8_t modify_mask;
<span class="lineNum">    5516 </span>            :         uint16_t reserved3;
<span class="lineNum">    5517 </span>            :         uint32_t station_flags;
<span class="lineNum">    5518 </span>            :         uint32_t station_flags_msk;
<span class="lineNum">    5519 </span>            :         uint8_t add_immediate_ba_tid;
<span class="lineNum">    5520 </span>            :         uint8_t remove_immediate_ba_tid;
<span class="lineNum">    5521 </span>            :         uint16_t add_immediate_ba_ssn;
<span class="lineNum">    5522 </span>            :         uint16_t sleep_tx_count;
<span class="lineNum">    5523 </span>            :         uint16_t sleep_state_flags;
<span class="lineNum">    5524 </span>            :         uint16_t assoc_id;
<span class="lineNum">    5525 </span>            :         uint16_t beamform_flags;
<span class="lineNum">    5526 </span>            :         uint32_t tfd_queue_msk;
<span class="lineNum">    5527 </span>            : } __packed; /* ADD_STA_CMD_API_S_VER_7 */
<span class="lineNum">    5528 </span>            : 
<span class="lineNum">    5529 </span>            : /**
<span class="lineNum">    5530 </span>            :  * struct iwm_add_sta_key_cmd - add/modify sta key
<span class="lineNum">    5531 </span>            :  * ( IWM_REPLY_ADD_STA_KEY = 0x17 )
<span class="lineNum">    5532 </span>            :  * @sta_id: index of station in uCode's station table
<span class="lineNum">    5533 </span>            :  * @key_offset: key offset in key storage
<span class="lineNum">    5534 </span>            :  * @key_flags: type %iwm_sta_key_flag
<span class="lineNum">    5535 </span>            :  * @key: key material data
<span class="lineNum">    5536 </span>            :  * @key2: key material data
<span class="lineNum">    5537 </span>            :  * @rx_secur_seq_cnt: RX security sequence counter for the key
<span class="lineNum">    5538 </span>            :  * @tkip_rx_tsc_byte2: TSC[2] for key mix ph1 detection
<span class="lineNum">    5539 </span>            :  * @tkip_rx_ttak: 10-byte unicast TKIP TTAK for Rx
<span class="lineNum">    5540 </span>            :  */
<span class="lineNum">    5541 </span>            : struct iwm_add_sta_key_cmd {
<span class="lineNum">    5542 </span>            :         uint8_t sta_id;
<span class="lineNum">    5543 </span>            :         uint8_t key_offset;
<span class="lineNum">    5544 </span>            :         uint16_t key_flags;
<span class="lineNum">    5545 </span>            :         uint8_t key[16];
<span class="lineNum">    5546 </span>            :         uint8_t key2[16];
<span class="lineNum">    5547 </span>            :         uint8_t rx_secur_seq_cnt[16];
<span class="lineNum">    5548 </span>            :         uint8_t tkip_rx_tsc_byte2;
<span class="lineNum">    5549 </span>            :         uint8_t reserved;
<span class="lineNum">    5550 </span>            :         uint16_t tkip_rx_ttak[5];
<span class="lineNum">    5551 </span>            : } __packed; /* IWM_ADD_MODIFY_STA_KEY_API_S_VER_1 */
<span class="lineNum">    5552 </span>            : 
<span class="lineNum">    5553 </span>            : /**
<span class="lineNum">    5554 </span>            :  * status in the response to ADD_STA command
<span class="lineNum">    5555 </span>            :  * @IWM_ADD_STA_SUCCESS: operation was executed successfully
<span class="lineNum">    5556 </span>            :  * @IWM_ADD_STA_STATIONS_OVERLOAD: no room left in the fw's station table
<span class="lineNum">    5557 </span>            :  * @IWM_ADD_STA_IMMEDIATE_BA_FAILURE: can't add Rx block ack session
<span class="lineNum">    5558 </span>            :  * @IWM_ADD_STA_MODIFY_NON_EXISTING_STA: driver requested to modify a station
<span class="lineNum">    5559 </span>            :  *      that doesn't exist.
<span class="lineNum">    5560 </span>            :  */
<span class="lineNum">    5561 </span>            : #define IWM_ADD_STA_SUCCESS                     0x1
<span class="lineNum">    5562 </span>            : #define IWM_ADD_STA_STATIONS_OVERLOAD           0x2
<span class="lineNum">    5563 </span>            : #define IWM_ADD_STA_IMMEDIATE_BA_FAILURE        0x4
<span class="lineNum">    5564 </span>            : #define IWM_ADD_STA_MODIFY_NON_EXISTING_STA     0x8
<span class="lineNum">    5565 </span>            : 
<span class="lineNum">    5566 </span>            : /**
<span class="lineNum">    5567 </span>            :  * struct iwm_rm_sta_cmd - Add / modify a station in the fw's station table
<span class="lineNum">    5568 </span>            :  * ( IWM_REMOVE_STA = 0x19 )
<span class="lineNum">    5569 </span>            :  * @sta_id: the station id of the station to be removed
<span class="lineNum">    5570 </span>            :  */
<span class="lineNum">    5571 </span>            : struct iwm_rm_sta_cmd {
<span class="lineNum">    5572 </span>            :         uint8_t sta_id;
<span class="lineNum">    5573 </span>            :         uint8_t reserved[3];
<span class="lineNum">    5574 </span>            : } __packed; /* IWM_REMOVE_STA_CMD_API_S_VER_2 */
<span class="lineNum">    5575 </span>            : 
<span class="lineNum">    5576 </span>            : /**
<span class="lineNum">    5577 </span>            :  * struct iwm_mgmt_mcast_key_cmd
<span class="lineNum">    5578 </span>            :  * ( IWM_MGMT_MCAST_KEY = 0x1f )
<span class="lineNum">    5579 </span>            :  * @ctrl_flags: %iwm_sta_key_flag
<span class="lineNum">    5580 </span>            :  * @IGTK:
<span class="lineNum">    5581 </span>            :  * @K1: IGTK master key
<span class="lineNum">    5582 </span>            :  * @K2: IGTK sub key
<span class="lineNum">    5583 </span>            :  * @sta_id: station ID that support IGTK
<span class="lineNum">    5584 </span>            :  * @key_id:
<span class="lineNum">    5585 </span>            :  * @receive_seq_cnt: initial RSC/PN needed for replay check
<span class="lineNum">    5586 </span>            :  */
<span class="lineNum">    5587 </span>            : struct iwm_mgmt_mcast_key_cmd {
<span class="lineNum">    5588 </span>            :         uint32_t ctrl_flags;
<span class="lineNum">    5589 </span>            :         uint8_t IGTK[16];
<span class="lineNum">    5590 </span>            :         uint8_t K1[16];
<span class="lineNum">    5591 </span>            :         uint8_t K2[16];
<span class="lineNum">    5592 </span>            :         uint32_t key_id;
<span class="lineNum">    5593 </span>            :         uint32_t sta_id;
<span class="lineNum">    5594 </span>            :         uint64_t receive_seq_cnt;
<span class="lineNum">    5595 </span>            : } __packed; /* SEC_MGMT_MULTICAST_KEY_CMD_API_S_VER_1 */
<span class="lineNum">    5596 </span>            : 
<span class="lineNum">    5597 </span>            : struct iwm_wep_key {
<span class="lineNum">    5598 </span>            :         uint8_t key_index;
<span class="lineNum">    5599 </span>            :         uint8_t key_offset;
<span class="lineNum">    5600 </span>            :         uint16_t reserved1;
<span class="lineNum">    5601 </span>            :         uint8_t key_size;
<span class="lineNum">    5602 </span>            :         uint8_t reserved2[3];
<span class="lineNum">    5603 </span>            :         uint8_t key[16];
<span class="lineNum">    5604 </span>            : } __packed;
<span class="lineNum">    5605 </span>            : 
<span class="lineNum">    5606 </span>            : struct iwm_wep_key_cmd {
<span class="lineNum">    5607 </span>            :         uint32_t mac_id_n_color;
<span class="lineNum">    5608 </span>            :         uint8_t num_keys;
<span class="lineNum">    5609 </span>            :         uint8_t decryption_type;
<span class="lineNum">    5610 </span>            :         uint8_t flags;
<span class="lineNum">    5611 </span>            :         uint8_t reserved;
<span class="lineNum">    5612 </span>            :         struct iwm_wep_key wep_key[0];
<span class="lineNum">    5613 </span>            : } __packed; /* SEC_CURR_WEP_KEY_CMD_API_S_VER_2 */
<span class="lineNum">    5614 </span>            : 
<span class="lineNum">    5615 </span>            : /* 
<span class="lineNum">    5616 </span>            :  * BT coex
<span class="lineNum">    5617 </span>            :  */
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span>            : #define IWM_BT_COEX_DISABLE             0x0
<span class="lineNum">    5620 </span>            : #define IWM_BT_COEX_NW                  0x1
<span class="lineNum">    5621 </span>            : #define IWM_BT_COEX_BT                  0x2
<span class="lineNum">    5622 </span>            : #define IWM_BT_COEX_WIFI                0x3
<span class="lineNum">    5623 </span>            : /* BT_COEX_MODES_E */
<span class="lineNum">    5624 </span>            : 
<span class="lineNum">    5625 </span>            : #define IWM_BT_COEX_MPLUT_ENABLED       (1 &lt;&lt; 0)
<span class="lineNum">    5626 </span>            : #define IWM_BT_COEX_MPLUT_BOOST_ENABLED (1 &lt;&lt; 1)
<span class="lineNum">    5627 </span>            : #define IWM_BT_COEX_SYNC2SCO_ENABLED    (1 &lt;&lt; 2)
<span class="lineNum">    5628 </span>            : #define IWM_BT_COEX_CORUN_ENABLED       (1 &lt;&lt; 3)
<span class="lineNum">    5629 </span>            : #define IWM_BT_COEX_HIGH_BAND_RET       (1 &lt;&lt; 4)
<span class="lineNum">    5630 </span>            : /* BT_COEX_MODULES_ENABLE_E_VER_1 */
<span class="lineNum">    5631 </span>            : 
<span class="lineNum">    5632 </span>            : /**
<span class="lineNum">    5633 </span>            :  * struct iwm_bt_coex_cmd - bt coex configuration command
<span class="lineNum">    5634 </span>            :  * @mode: enum %iwm_bt_coex_mode
<span class="lineNum">    5635 </span>            :  * @enabled_modules: enum %iwm_bt_coex_enabled_modules
<span class="lineNum">    5636 </span>            :  *
<span class="lineNum">    5637 </span>            :  * The structure is used for the BT_COEX command.
<span class="lineNum">    5638 </span>            :  */
<span class="lineNum">    5639 </span>            : struct iwm_bt_coex_cmd {
<span class="lineNum">    5640 </span>            :         uint32_t mode;
<span class="lineNum">    5641 </span>            :         uint32_t enabled_modules;
<span class="lineNum">    5642 </span>            : } __packed; /* BT_COEX_CMD_API_S_VER_6 */
<span class="lineNum">    5643 </span>            : 
<span class="lineNum">    5644 </span>            : 
<span class="lineNum">    5645 </span>            : /*
<span class="lineNum">    5646 </span>            :  * Location Aware Regulatory (LAR) API - MCC updates
<span class="lineNum">    5647 </span>            :  */
<span class="lineNum">    5648 </span>            : 
<span class="lineNum">    5649 </span>            : /**
<span class="lineNum">    5650 </span>            :  * struct iwm_mcc_update_cmd_v1 - Request the device to update geographic
<span class="lineNum">    5651 </span>            :  * regulatory profile according to the given MCC (Mobile Country Code).
<span class="lineNum">    5652 </span>            :  * The MCC is two letter-code, ascii upper case[A-Z] or '00' for world domain.
<span class="lineNum">    5653 </span>            :  * 'ZZ' MCC will be used to switch to NVM default profile; in this case, the
<span class="lineNum">    5654 </span>            :  * MCC in the cmd response will be the relevant MCC in the NVM.
<span class="lineNum">    5655 </span>            :  * @mcc: given mobile country code
<span class="lineNum">    5656 </span>            :  * @source_id: the source from where we got the MCC, see iwm_mcc_source
<span class="lineNum">    5657 </span>            :  * @reserved: reserved for alignment
<span class="lineNum">    5658 </span>            :  */
<span class="lineNum">    5659 </span>            : struct iwm_mcc_update_cmd_v1 {
<span class="lineNum">    5660 </span>            :         uint16_t mcc;
<span class="lineNum">    5661 </span>            :         uint8_t source_id;
<span class="lineNum">    5662 </span>            :         uint8_t reserved;
<span class="lineNum">    5663 </span>            : } __packed; /* LAR_UPDATE_MCC_CMD_API_S_VER_1 */
<span class="lineNum">    5664 </span>            : 
<span class="lineNum">    5665 </span>            : /**
<span class="lineNum">    5666 </span>            :  * struct iwm_mcc_update_cmd - Request the device to update geographic
<span class="lineNum">    5667 </span>            :  * regulatory profile according to the given MCC (Mobile Country Code).
<span class="lineNum">    5668 </span>            :  * The MCC is two letter-code, ascii upper case[A-Z] or '00' for world domain.
<span class="lineNum">    5669 </span>            :  * 'ZZ' MCC will be used to switch to NVM default profile; in this case, the
<span class="lineNum">    5670 </span>            :  * MCC in the cmd response will be the relevant MCC in the NVM.
<span class="lineNum">    5671 </span>            :  * @mcc: given mobile country code
<span class="lineNum">    5672 </span>            :  * @source_id: the source from where we got the MCC, see iwm_mcc_source
<span class="lineNum">    5673 </span>            :  * @reserved: reserved for alignment
<span class="lineNum">    5674 </span>            :  * @key: integrity key for MCC API OEM testing
<span class="lineNum">    5675 </span>            :  * @reserved2: reserved
<span class="lineNum">    5676 </span>            :  */
<span class="lineNum">    5677 </span>            : struct iwm_mcc_update_cmd {
<span class="lineNum">    5678 </span>            :         uint16_t mcc;
<span class="lineNum">    5679 </span>            :         uint8_t source_id;
<span class="lineNum">    5680 </span>            :         uint8_t reserved;
<span class="lineNum">    5681 </span>            :         uint32_t key;
<span class="lineNum">    5682 </span>            :         uint32_t reserved2[5];
<span class="lineNum">    5683 </span>            : } __packed; /* LAR_UPDATE_MCC_CMD_API_S_VER_2 */
<span class="lineNum">    5684 </span>            : 
<span class="lineNum">    5685 </span>            : /**
<span class="lineNum">    5686 </span>            :  * iwm_mcc_update_resp_v1  - response to MCC_UPDATE_CMD.
<span class="lineNum">    5687 </span>            :  * Contains the new channel control profile map, if changed, and the new MCC
<span class="lineNum">    5688 </span>            :  * (mobile country code).
<span class="lineNum">    5689 </span>            :  * The new MCC may be different than what was requested in MCC_UPDATE_CMD.
<span class="lineNum">    5690 </span>            :  * @status: see &amp;enum iwm_mcc_update_status
<span class="lineNum">    5691 </span>            :  * @mcc: the new applied MCC
<span class="lineNum">    5692 </span>            :  * @cap: capabilities for all channels which matches the MCC
<span class="lineNum">    5693 </span>            :  * @source_id: the MCC source, see iwm_mcc_source
<span class="lineNum">    5694 </span>            :  * @n_channels: number of channels in @channels_data (may be 14, 39, 50 or 51
<span class="lineNum">    5695 </span>            :  *              channels, depending on platform)
<span class="lineNum">    5696 </span>            :  * @channels: channel control data map, DWORD for each channel. Only the first
<span class="lineNum">    5697 </span>            :  *      16bits are used.
<span class="lineNum">    5698 </span>            :  */
<span class="lineNum">    5699 </span>            : struct iwm_mcc_update_resp_v1  {
<span class="lineNum">    5700 </span>            :         uint32_t status;
<span class="lineNum">    5701 </span>            :         uint16_t mcc;
<span class="lineNum">    5702 </span>            :         uint8_t cap;
<span class="lineNum">    5703 </span>            :         uint8_t source_id;
<span class="lineNum">    5704 </span>            :         uint32_t n_channels;
<span class="lineNum">    5705 </span>            :         uint32_t channels[0];
<span class="lineNum">    5706 </span>            : } __packed; /* LAR_UPDATE_MCC_CMD_RESP_S_VER_1 */
<span class="lineNum">    5707 </span>            : 
<span class="lineNum">    5708 </span>            : /**
<span class="lineNum">    5709 </span>            :  * iwm_mcc_update_resp - response to MCC_UPDATE_CMD.
<span class="lineNum">    5710 </span>            :  * Contains the new channel control profile map, if changed, and the new MCC
<span class="lineNum">    5711 </span>            :  * (mobile country code).
<span class="lineNum">    5712 </span>            :  * The new MCC may be different than what was requested in MCC_UPDATE_CMD.
<span class="lineNum">    5713 </span>            :  * @status: see &amp;enum iwm_mcc_update_status
<span class="lineNum">    5714 </span>            :  * @mcc: the new applied MCC
<span class="lineNum">    5715 </span>            :  * @cap: capabilities for all channels which matches the MCC
<span class="lineNum">    5716 </span>            :  * @source_id: the MCC source, see iwm_mcc_source
<span class="lineNum">    5717 </span>            :  * @time: time elapsed from the MCC test start (in 30 seconds TU)
<span class="lineNum">    5718 </span>            :  * @reserved: reserved.
<span class="lineNum">    5719 </span>            :  * @n_channels: number of channels in @channels_data (may be 14, 39, 50 or 51
<span class="lineNum">    5720 </span>            :  *              channels, depending on platform)
<span class="lineNum">    5721 </span>            :  * @channels: channel control data map, DWORD for each channel. Only the first
<span class="lineNum">    5722 </span>            :  *      16bits are used.
<span class="lineNum">    5723 </span>            :  */
<span class="lineNum">    5724 </span>            : struct iwm_mcc_update_resp {
<span class="lineNum">    5725 </span>            :         uint32_t status;
<span class="lineNum">    5726 </span>            :         uint16_t mcc;
<span class="lineNum">    5727 </span>            :         uint8_t cap;
<span class="lineNum">    5728 </span>            :         uint8_t source_id;
<span class="lineNum">    5729 </span>            :         uint16_t time;
<span class="lineNum">    5730 </span>            :         uint16_t reserved;
<span class="lineNum">    5731 </span>            :         uint32_t n_channels;
<span class="lineNum">    5732 </span>            :         uint32_t channels[0];
<span class="lineNum">    5733 </span>            : } __packed; /* LAR_UPDATE_MCC_CMD_RESP_S_VER_2 */
<span class="lineNum">    5734 </span>            : 
<span class="lineNum">    5735 </span>            : /**
<span class="lineNum">    5736 </span>            :  * struct iwm_mcc_chub_notif - chub notifies of mcc change
<span class="lineNum">    5737 </span>            :  * (MCC_CHUB_UPDATE_CMD = 0xc9)
<span class="lineNum">    5738 </span>            :  * The Chub (Communication Hub, CommsHUB) is a HW component that connects to
<span class="lineNum">    5739 </span>            :  * the cellular and connectivity cores that gets updates of the mcc, and
<span class="lineNum">    5740 </span>            :  * notifies the ucode directly of any mcc change.
<span class="lineNum">    5741 </span>            :  * The ucode requests the driver to request the device to update geographic
<span class="lineNum">    5742 </span>            :  * regulatory  profile according to the given MCC (Mobile Country Code).
<span class="lineNum">    5743 </span>            :  * The MCC is two letter-code, ascii upper case[A-Z] or '00' for world domain.
<span class="lineNum">    5744 </span>            :  * 'ZZ' MCC will be used to switch to NVM default profile; in this case, the
<span class="lineNum">    5745 </span>            :  * MCC in the cmd response will be the relevant MCC in the NVM.
<span class="lineNum">    5746 </span>            :  * @mcc: given mobile country code
<span class="lineNum">    5747 </span>            :  * @source_id: identity of the change originator, see iwm_mcc_source
<span class="lineNum">    5748 </span>            :  * @reserved1: reserved for alignment
<span class="lineNum">    5749 </span>            :  */
<span class="lineNum">    5750 </span>            : struct iwm_mcc_chub_notif {
<span class="lineNum">    5751 </span>            :         uint16_t mcc;
<span class="lineNum">    5752 </span>            :         uint8_t source_id;
<span class="lineNum">    5753 </span>            :         uint8_t reserved1;
<span class="lineNum">    5754 </span>            : } __packed; /* LAR_MCC_NOTIFY_S */
<span class="lineNum">    5755 </span>            : 
<span class="lineNum">    5756 </span>            : #define IWM_MCC_RESP_NEW_CHAN_PROFILE                   0
<span class="lineNum">    5757 </span>            : #define IWM_MCC_RESP_SAME_CHAN_PROFILE                  1
<span class="lineNum">    5758 </span>            : #define IWM_MCC_RESP_INVALID                            2
<span class="lineNum">    5759 </span>            : #define IWM_MCC_RESP_NVM_DISABLED                       3
<span class="lineNum">    5760 </span>            : #define IWM_MCC_RESP_ILLEGAL                            4
<span class="lineNum">    5761 </span>            : #define IWM_MCC_RESP_LOW_PRIORITY                       5
<span class="lineNum">    5762 </span>            : #define IWM_MCC_RESP_TEST_MODE_ACTIVE                   6
<span class="lineNum">    5763 </span>            : #define IWM_MCC_RESP_TEST_MODE_NOT_ACTIVE               7
<span class="lineNum">    5764 </span>            : #define IWM_MCC_RESP_TEST_MODE_DENIAL_OF_SERVICE        8
<span class="lineNum">    5765 </span>            : 
<span class="lineNum">    5766 </span>            : #define IWM_MCC_SOURCE_OLD_FW                   0
<span class="lineNum">    5767 </span>            : #define IWM_MCC_SOURCE_ME                       1
<span class="lineNum">    5768 </span>            : #define IWM_MCC_SOURCE_BIOS                     2
<span class="lineNum">    5769 </span>            : #define IWM_MCC_SOURCE_3G_LTE_HOST              3
<span class="lineNum">    5770 </span>            : #define IWM_MCC_SOURCE_3G_LTE_DEVICE            4
<span class="lineNum">    5771 </span>            : #define IWM_MCC_SOURCE_WIFI                     5
<span class="lineNum">    5772 </span>            : #define IWM_MCC_SOURCE_RESERVED                 6
<span class="lineNum">    5773 </span>            : #define IWM_MCC_SOURCE_DEFAULT                  7
<span class="lineNum">    5774 </span>            : #define IWM_MCC_SOURCE_UNINITIALIZED            8
<span class="lineNum">    5775 </span>            : #define IWM_MCC_SOURCE_MCC_API                  9
<span class="lineNum">    5776 </span>            : #define IWM_MCC_SOURCE_GET_CURRENT              0x10
<span class="lineNum">    5777 </span>            : #define IWM_MCC_SOURCE_GETTING_MCC_TEST_MODE    0x11
<span class="lineNum">    5778 </span>            : 
<span class="lineNum">    5779 </span>            : /*
<span class="lineNum">    5780 </span>            :  * Some cherry-picked definitions
<span class="lineNum">    5781 </span>            :  */
<span class="lineNum">    5782 </span>            : 
<span class="lineNum">    5783 </span>            : #define IWM_FRAME_LIMIT 64
<span class="lineNum">    5784 </span>            : 
<span class="lineNum">    5785 </span>            : /*
<span class="lineNum">    5786 </span>            :  * From Linux commit ab02165ccec4c78162501acedeef1a768acdb811:
<span class="lineNum">    5787 </span>            :  *   As the firmware is slowly running out of command IDs and grouping of
<span class="lineNum">    5788 </span>            :  *   commands is desirable anyway, the firmware is extending the command
<span class="lineNum">    5789 </span>            :  *   header from 4 bytes to 8 bytes to introduce a group (in place of the
<span class="lineNum">    5790 </span>            :  *   former flags field, since that's always 0 on commands and thus can
<span class="lineNum">    5791 </span>            :  *   be easily used to distinguish between the two).
<span class="lineNum">    5792 </span>            :  *
<span class="lineNum">    5793 </span>            :  * These functions retrieve specific information from the id field in
<span class="lineNum">    5794 </span>            :  * the iwm_host_cmd struct which contains the command id, the group id,
<span class="lineNum">    5795 </span>            :  * and the version of the command.
<a name="5796"><span class="lineNum">    5796 </span>            : */</a>
<span class="lineNum">    5797 </span>            : static inline uint8_t
<span class="lineNum">    5798 </span><span class="lineNoCov">          0 : iwm_cmd_opcode(uint32_t cmdid)</span>
<span class="lineNum">    5799 </span>            : {
<span class="lineNum">    5800 </span><span class="lineNoCov">          0 :         return cmdid &amp; 0xff;</span>
<span class="lineNum">    5801 </span>            : }
<a name="5802"><span class="lineNum">    5802 </span>            : </a>
<span class="lineNum">    5803 </span>            : static inline uint8_t
<span class="lineNum">    5804 </span><span class="lineNoCov">          0 : iwm_cmd_groupid(uint32_t cmdid)</span>
<span class="lineNum">    5805 </span>            : {
<span class="lineNum">    5806 </span><span class="lineNoCov">          0 :         return ((cmdid &amp; 0Xff00) &gt;&gt; 8);</span>
<span class="lineNum">    5807 </span>            : }
<a name="5808"><span class="lineNum">    5808 </span>            : </a>
<span class="lineNum">    5809 </span>            : static inline uint8_t
<span class="lineNum">    5810 </span><span class="lineNoCov">          0 : iwm_cmd_version(uint32_t cmdid)</span>
<span class="lineNum">    5811 </span>            : {
<span class="lineNum">    5812 </span><span class="lineNoCov">          0 :         return ((cmdid &amp; 0xff0000) &gt;&gt; 16);</span>
<span class="lineNum">    5813 </span>            : }
<a name="5814"><span class="lineNum">    5814 </span>            : </a>
<span class="lineNum">    5815 </span>            : static inline uint32_t
<span class="lineNum">    5816 </span><span class="lineNoCov">          0 : iwm_cmd_id(uint8_t opcode, uint8_t groupid, uint8_t version)</span>
<span class="lineNum">    5817 </span>            : {
<span class="lineNum">    5818 </span><span class="lineNoCov">          0 :         return opcode + (groupid &lt;&lt; 8) + (version &lt;&lt; 16);</span>
<span class="lineNum">    5819 </span>            : }
<span class="lineNum">    5820 </span>            : 
<span class="lineNum">    5821 </span>            : /* make uint16_t wide id out of uint8_t group and opcode */
<span class="lineNum">    5822 </span>            : #define IWM_WIDE_ID(grp, opcode) ((grp &lt;&lt; 8) | opcode)
<span class="lineNum">    5823 </span>            : 
<span class="lineNum">    5824 </span>            : /* due to the conversion, this group is special */
<span class="lineNum">    5825 </span>            : #define IWM_ALWAYS_LONG_GROUP   1
<span class="lineNum">    5826 </span>            : #define IWM_SYSTEM_GROUP        4
<span class="lineNum">    5827 </span>            : 
<span class="lineNum">    5828 </span>            : struct iwm_cmd_header {
<span class="lineNum">    5829 </span>            :         uint8_t code;
<span class="lineNum">    5830 </span>            :         uint8_t flags;
<span class="lineNum">    5831 </span>            :         uint8_t idx;
<span class="lineNum">    5832 </span>            :         uint8_t qid;
<span class="lineNum">    5833 </span>            : } __packed;
<span class="lineNum">    5834 </span>            : 
<span class="lineNum">    5835 </span>            : struct iwm_cmd_header_wide {
<span class="lineNum">    5836 </span>            :         uint8_t opcode;
<span class="lineNum">    5837 </span>            :         uint8_t group_id;
<span class="lineNum">    5838 </span>            :         uint8_t idx;
<span class="lineNum">    5839 </span>            :         uint8_t qid;
<span class="lineNum">    5840 </span>            :         uint16_t length;
<span class="lineNum">    5841 </span>            :         uint8_t reserved;
<span class="lineNum">    5842 </span>            :         uint8_t version;
<span class="lineNum">    5843 </span>            : } __packed;
<span class="lineNum">    5844 </span>            : 
<span class="lineNum">    5845 </span>            : #define IWM_POWER_SCHEME_CAM    1
<span class="lineNum">    5846 </span>            : #define IWM_POWER_SCHEME_BPS    2
<span class="lineNum">    5847 </span>            : #define IWM_POWER_SCHEME_LP     3
<span class="lineNum">    5848 </span>            : 
<span class="lineNum">    5849 </span>            : #define IWM_DEF_CMD_PAYLOAD_SIZE 320
<span class="lineNum">    5850 </span>            : #define IWM_MAX_CMD_PAYLOAD_SIZE ((4096 - 4) - sizeof(struct iwm_cmd_header))
<span class="lineNum">    5851 </span>            : #define IWM_CMD_FAILED_MSK 0x40
<span class="lineNum">    5852 </span>            : 
<span class="lineNum">    5853 </span>            : /**
<span class="lineNum">    5854 </span>            :  * struct iwm_device_cmd
<span class="lineNum">    5855 </span>            :  *
<span class="lineNum">    5856 </span>            :  * For allocation of the command and tx queues, this establishes the overall
<span class="lineNum">    5857 </span>            :  * size of the largest command we send to uCode, except for commands that
<span class="lineNum">    5858 </span>            :  * aren't fully copied and use other TFD space.
<span class="lineNum">    5859 </span>            :  */
<span class="lineNum">    5860 </span>            : struct iwm_device_cmd {
<span class="lineNum">    5861 </span>            :         union {
<span class="lineNum">    5862 </span>            :                 struct {
<span class="lineNum">    5863 </span>            :                         struct iwm_cmd_header hdr;
<span class="lineNum">    5864 </span>            :                         uint8_t data[IWM_DEF_CMD_PAYLOAD_SIZE];
<span class="lineNum">    5865 </span>            :                 };
<span class="lineNum">    5866 </span>            :                 struct {
<span class="lineNum">    5867 </span>            :                         struct iwm_cmd_header_wide hdr_wide;
<span class="lineNum">    5868 </span>            :                         uint8_t data_wide[IWM_DEF_CMD_PAYLOAD_SIZE -
<span class="lineNum">    5869 </span>            :                                         sizeof(struct iwm_cmd_header_wide) +
<span class="lineNum">    5870 </span>            :                                         sizeof(struct iwm_cmd_header)];
<span class="lineNum">    5871 </span>            :                 };
<span class="lineNum">    5872 </span>            :         };
<span class="lineNum">    5873 </span>            : } __packed;
<span class="lineNum">    5874 </span>            : 
<span class="lineNum">    5875 </span>            : struct iwm_rx_packet {
<span class="lineNum">    5876 </span>            :         /*
<span class="lineNum">    5877 </span>            :          * The first 4 bytes of the RX frame header contain both the RX frame
<span class="lineNum">    5878 </span>            :          * size and some flags.
<span class="lineNum">    5879 </span>            :          * Bit fields:
<span class="lineNum">    5880 </span>            :          * 31:    flag flush RB request
<span class="lineNum">    5881 </span>            :          * 30:    flag ignore TC (terminal counter) request
<span class="lineNum">    5882 </span>            :          * 29:    flag fast IRQ request
<span class="lineNum">    5883 </span>            :          * 28-26: Reserved
<span class="lineNum">    5884 </span>            :          * 25:    Offload enabled
<span class="lineNum">    5885 </span>            :          * 24:    RPF enabled
<span class="lineNum">    5886 </span>            :          * 23:    RSS enabled
<span class="lineNum">    5887 </span>            :          * 22:    Checksum enabled
<span class="lineNum">    5888 </span>            :          * 21-16: RX queue
<span class="lineNum">    5889 </span>            :          * 15-14: Reserved
<span class="lineNum">    5890 </span>            :          * 13-00: RX frame size
<span class="lineNum">    5891 </span>            :          */
<span class="lineNum">    5892 </span>            :         uint32_t len_n_flags;
<span class="lineNum">    5893 </span>            :         struct iwm_cmd_header hdr;
<span class="lineNum">    5894 </span>            :         uint8_t data[];
<span class="lineNum">    5895 </span>            : } __packed;
<span class="lineNum">    5896 </span>            : 
<span class="lineNum">    5897 </span>            : #define IWM_FH_RSCSR_FRAME_SIZE_MSK     0x00003fff
<span class="lineNum">    5898 </span>            : #define IWM_FH_RSCSR_FRAME_INVALID      0x55550000
<span class="lineNum">    5899 </span>            : #define IWM_FH_RSCSR_FRAME_ALIGN        0x40
<span class="lineNum">    5900 </span>            : #define IWM_FH_RSCSR_RPA_EN             (1 &lt;&lt; 25)
<span class="lineNum">    5901 </span>            : #define IWM_FH_RSCSR_RXQ_POS            16
<span class="lineNum">    5902 </span>            : #define IWM_FH_RSCSR_RXQ_MASK           0x3F0000
<a name="5903"><span class="lineNum">    5903 </span>            : </a>
<span class="lineNum">    5904 </span>            : static uint32_t
<span class="lineNum">    5905 </span><span class="lineNoCov">          0 : iwm_rx_packet_len(const struct iwm_rx_packet *pkt)</span>
<span class="lineNum">    5906 </span>            : {
<span class="lineNum">    5907 </span>            : 
<span class="lineNum">    5908 </span><span class="lineNoCov">          0 :         return le32toh(pkt-&gt;len_n_flags) &amp; IWM_FH_RSCSR_FRAME_SIZE_MSK;</span>
<span class="lineNum">    5909 </span>            : }
<a name="5910"><span class="lineNum">    5910 </span>            : </a>
<span class="lineNum">    5911 </span>            : static uint32_t
<span class="lineNum">    5912 </span><span class="lineNoCov">          0 : iwm_rx_packet_payload_len(const struct iwm_rx_packet *pkt)</span>
<span class="lineNum">    5913 </span>            : {
<span class="lineNum">    5914 </span>            : 
<span class="lineNum">    5915 </span><span class="lineNoCov">          0 :         return iwm_rx_packet_len(pkt) - sizeof(pkt-&gt;hdr);</span>
<span class="lineNum">    5916 </span>            : }
<span class="lineNum">    5917 </span>            : 
<span class="lineNum">    5918 </span>            : 
<span class="lineNum">    5919 </span>            : #define IWM_MIN_DBM     -100
<span class="lineNum">    5920 </span>            : #define IWM_MAX_DBM     -33     /* realistic guess */
<span class="lineNum">    5921 </span>            : 
<span class="lineNum">    5922 </span>            : #define IWM_READ(sc, reg)                                               \
<span class="lineNum">    5923 </span>            :         bus_space_read_4((sc)-&gt;sc_st, (sc)-&gt;sc_sh, (reg))
<span class="lineNum">    5924 </span>            : 
<span class="lineNum">    5925 </span>            : #define IWM_WRITE(sc, reg, val)                                         \
<span class="lineNum">    5926 </span>            :         bus_space_write_4((sc)-&gt;sc_st, (sc)-&gt;sc_sh, (reg), (val))
<span class="lineNum">    5927 </span>            : 
<span class="lineNum">    5928 </span>            : #define IWM_WRITE_1(sc, reg, val)                                       \
<span class="lineNum">    5929 </span>            :         bus_space_write_1((sc)-&gt;sc_st, (sc)-&gt;sc_sh, (reg), (val))
<span class="lineNum">    5930 </span>            : 
<span class="lineNum">    5931 </span>            : #define IWM_SETBITS(sc, reg, mask)                                      \
<span class="lineNum">    5932 </span>            :         IWM_WRITE(sc, reg, IWM_READ(sc, reg) | (mask))
<span class="lineNum">    5933 </span>            : 
<span class="lineNum">    5934 </span>            : #define IWM_CLRBITS(sc, reg, mask)                                      \
<span class="lineNum">    5935 </span>            :         IWM_WRITE(sc, reg, IWM_READ(sc, reg) &amp; ~(mask))
<span class="lineNum">    5936 </span>            : 
<span class="lineNum">    5937 </span>            : #define IWM_BARRIER_WRITE(sc)                                           \
<span class="lineNum">    5938 </span>            :         bus_space_barrier((sc)-&gt;sc_st, (sc)-&gt;sc_sh, 0, (sc)-&gt;sc_sz,    \
<span class="lineNum">    5939 </span>            :             BUS_SPACE_BARRIER_WRITE)
<span class="lineNum">    5940 </span>            : 
<span class="lineNum">    5941 </span>            : #define IWM_BARRIER_READ_WRITE(sc)                                      \
<span class="lineNum">    5942 </span>            :         bus_space_barrier((sc)-&gt;sc_st, (sc)-&gt;sc_sh, 0, (sc)-&gt;sc_sz,    \
<span class="lineNum">    5943 </span>            :             BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE)
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
