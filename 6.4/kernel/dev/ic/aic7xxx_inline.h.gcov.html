<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - dev/ic/aic7xxx_inline.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dev/ic</a> - aic7xxx_inline.h<span style="font-size: 80%;"> (source / <a href="aic7xxx_inline.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">159</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: aic7xxx_inline.h,v 1.17 2016/08/17 01:17:54 krw Exp $ */</a>
<span class="lineNum">       2 </span>            : /*      $NetBSD: aic7xxx_inline.h,v 1.4 2003/11/02 11:07:44 wiz Exp $   */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /*
<span class="lineNum">       5 </span>            :  * Inline routines shareable across OS platforms.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Copyright (c) 1994-2001 Justin T. Gibbs.
<span class="lineNum">       8 </span>            :  * Copyright (c) 2000-2001 Adaptec Inc.
<span class="lineNum">       9 </span>            :  * All rights reserved.
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">      12 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      13 </span>            :  * are met:
<span class="lineNum">      14 </span>            :  * 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      15 </span>            :  *    notice, this list of conditions, and the following disclaimer,
<span class="lineNum">      16 </span>            :  *    without modification.
<span class="lineNum">      17 </span>            :  * 2. Redistributions in binary form must reproduce at minimum a disclaimer
<span class="lineNum">      18 </span>            :  *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below
<span class="lineNum">      19 </span>            :  *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon
<span class="lineNum">      20 </span>            :  *    including a substantially similar Disclaimer requirement for further
<span class="lineNum">      21 </span>            :  *    binary redistribution.
<span class="lineNum">      22 </span>            :  * 3. Neither the names of the above-listed copyright holders nor the names
<span class="lineNum">      23 </span>            :  *    of any contributors may be used to endorse or promote products derived
<span class="lineNum">      24 </span>            :  *    from this software without specific prior written permission.
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  * Alternatively, this software may be distributed under the terms of the
<span class="lineNum">      27 </span>            :  * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free
<span class="lineNum">      28 </span>            :  * Software Foundation.
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * NO WARRANTY
<span class="lineNum">      31 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      32 </span>            :  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      33 </span>            :  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
<span class="lineNum">      34 </span>            :  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      35 </span>            :  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
<span class="lineNum">      36 </span>            :  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
<span class="lineNum">      37 </span>            :  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
<span class="lineNum">      38 </span>            :  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
<span class="lineNum">      39 </span>            :  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
<span class="lineNum">      40 </span>            :  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      41 </span>            :  * POSSIBILITY OF SUCH DAMAGES.
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#39 $
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_inline.h,v 1.20 2003/01/20 20:44:55 gibbs Exp $
<span class="lineNum">      46 </span>            :  */
<span class="lineNum">      47 </span>            : /*
<span class="lineNum">      48 </span>            :  * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
<span class="lineNum">      49 </span>            :  */
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #ifndef _AIC7XXX_INLINE_H_
<span class="lineNum">      52 </span>            : #define _AIC7XXX_INLINE_H_
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #ifdef SMALL_KERNEL
<span class="lineNum">      55 </span>            : #define IO_INLINE
<span class="lineNum">      56 </span>            : #else
<span class="lineNum">      57 </span>            : #define IO_INLINE       static __inline
<span class="lineNum">      58 </span>            : #define IO_EXPAND
<span class="lineNum">      59 </span>            : #endif
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : /************************* Sequencer Execution Control ************************/
<span class="lineNum">      62 </span>            : IO_INLINE void ahc_pause_bug_fix(struct ahc_softc *ahc);
<span class="lineNum">      63 </span>            : IO_INLINE int  ahc_is_paused(struct ahc_softc *ahc);
<span class="lineNum">      64 </span>            : IO_INLINE void ahc_pause(struct ahc_softc *ahc);
<span class="lineNum">      65 </span>            : IO_INLINE void ahc_unpause(struct ahc_softc *ahc);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #ifdef IO_EXPAND
<span class="lineNum">      68 </span>            : /*
<span class="lineNum">      69 </span>            :  * Work around any chip bugs related to halting sequencer execution.
<span class="lineNum">      70 </span>            :  * On Ultra2 controllers, we must clear the CIOBUS stretch signal by
<span class="lineNum">      71 </span>            :  * reading a register that will set this signal and deassert it.
<span class="lineNum">      72 </span>            :  * Without this workaround, if the chip is paused, by an interrupt or
<span class="lineNum">      73 </span>            :  * manual pause while accessing scb ram, accesses to certain registers
<span class="lineNum">      74 </span>            :  * will hang the system (infinite pci retries).
<a name="75"><span class="lineNum">      75 </span>            :  */</a>
<span class="lineNum">      76 </span>            : IO_INLINE void
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : ahc_pause_bug_fix(struct ahc_softc *ahc)</span>
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :         if ((ahc-&gt;features &amp; AHC_ULTRA2) != 0)</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :                 (void)ahc_inb(ahc, CCSCBCTL);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : /*
<span class="lineNum">      84 </span>            :  * Determine whether the sequencer has halted code execution.
<span class="lineNum">      85 </span>            :  * Returns non-zero status if the sequencer is stopped.
<a name="86"><span class="lineNum">      86 </span>            :  */</a>
<span class="lineNum">      87 </span>            : IO_INLINE int
<span class="lineNum">      88 </span><span class="lineNoCov">          0 : ahc_is_paused(struct ahc_softc *ahc)</span>
<span class="lineNum">      89 </span>            : {
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         return ((ahc_inb(ahc, HCNTRL) &amp; PAUSE) != 0);</span>
<span class="lineNum">      91 </span>            : }
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /*
<span class="lineNum">      94 </span>            :  * Request that the sequencer stop and wait, indefinitely, for it
<span class="lineNum">      95 </span>            :  * to stop.  The sequencer will only acknowledge that it is paused
<span class="lineNum">      96 </span>            :  * once it has reached an instruction boundary and PAUSEDIS is
<span class="lineNum">      97 </span>            :  * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS
<span class="lineNum">      98 </span>            :  * for critical sections.
<a name="99"><span class="lineNum">      99 </span>            :  */</a>
<span class="lineNum">     100 </span>            : IO_INLINE void
<span class="lineNum">     101 </span><span class="lineNoCov">          0 : ahc_pause(struct ahc_softc *ahc)</span>
<span class="lineNum">     102 </span>            : {
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, HCNTRL, ahc-&gt;pause);</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :         /*
<span class="lineNum">     106 </span>            :          * Since the sequencer can disable pausing in a critical section, we
<span class="lineNum">     107 </span>            :          * must loop until it actually stops.
<span class="lineNum">     108 </span>            :          */
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         while (ahc_is_paused(ahc) == 0)</span>
<span class="lineNum">     110 </span>            :                 ;
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         ahc_pause_bug_fix(ahc);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : /*
<span class="lineNum">     116 </span>            :  * Allow the sequencer to continue program execution.
<span class="lineNum">     117 </span>            :  * We check here to ensure that no additional interrupt
<span class="lineNum">     118 </span>            :  * sources that would cause the sequencer to halt have been
<span class="lineNum">     119 </span>            :  * asserted.  If, for example, a SCSI bus reset is detected
<span class="lineNum">     120 </span>            :  * while we are fielding a different, pausing, interrupt type,
<span class="lineNum">     121 </span>            :  * we don't want to release the sequencer before going back
<span class="lineNum">     122 </span>            :  * into our interrupt handler and dealing with this new
<span class="lineNum">     123 </span>            :  * condition.
<a name="124"><span class="lineNum">     124 </span>            :  */</a>
<span class="lineNum">     125 </span>            : IO_INLINE void
<span class="lineNum">     126 </span><span class="lineNoCov">          0 : ahc_unpause(struct ahc_softc *ahc)</span>
<span class="lineNum">     127 </span>            : {
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         if ((ahc_inb(ahc, INTSTAT) &amp; (SCSIINT | SEQINT | BRKADRINT)) == 0)</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :                 ahc_outb(ahc, HCNTRL, ahc-&gt;unpause);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     131 </span>            : #endif /* IO_EXPAND */
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : /*********************** Untagged Transaction Routines ************************/
<span class="lineNum">     134 </span>            : IO_INLINE void  ahc_freeze_untagged_queues(struct ahc_softc *ahc);
<span class="lineNum">     135 </span>            : IO_INLINE void  ahc_release_untagged_queues(struct ahc_softc *ahc);
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : #ifdef IO_EXPAND
<span class="lineNum">     138 </span>            : /*
<span class="lineNum">     139 </span>            :  * Block our completion routine from starting the next untagged
<span class="lineNum">     140 </span>            :  * transaction for this target or target lun.
<a name="141"><span class="lineNum">     141 </span>            :  */</a>
<span class="lineNum">     142 </span>            : IO_INLINE void
<span class="lineNum">     143 </span><span class="lineNoCov">          0 : ahc_freeze_untagged_queues(struct ahc_softc *ahc)</span>
<span class="lineNum">     144 </span>            : {
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         if ((ahc-&gt;flags &amp; AHC_SCB_BTT) == 0)</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :                 ahc-&gt;untagged_queue_lock++;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /*
<span class="lineNum">     150 </span>            :  * Allow the next untagged transaction for this target or target lun
<span class="lineNum">     151 </span>            :  * to be executed.  We use a counting semaphore to allow the lock
<span class="lineNum">     152 </span>            :  * to be acquired recursively.  Once the count drops to zero, the
<span class="lineNum">     153 </span>            :  * transaction queues will be run.
<a name="154"><span class="lineNum">     154 </span>            :  */</a>
<span class="lineNum">     155 </span>            : IO_INLINE void
<span class="lineNum">     156 </span><span class="lineNoCov">          0 : ahc_release_untagged_queues(struct ahc_softc *ahc)</span>
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         if ((ahc-&gt;flags &amp; AHC_SCB_BTT) == 0) {</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                 ahc-&gt;untagged_queue_lock--;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 if (ahc-&gt;untagged_queue_lock == 0)</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :                         ahc_run_untagged_queues(ahc);</span>
<span class="lineNum">     162 </span>            :         }
<span class="lineNum">     163 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     164 </span>            : #endif /* IO_EXPAND */
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : /************************** Memory mapping routines ***************************/
<span class="lineNum">     168 </span>            : IO_INLINE struct ahc_dma_seg *
<span class="lineNum">     169 </span>            :                         ahc_sg_bus_to_virt(struct scb *scb,
<span class="lineNum">     170 </span>            :                                            uint32_t sg_busaddr);
<span class="lineNum">     171 </span>            : IO_INLINE uint32_t
<span class="lineNum">     172 </span>            :                         ahc_sg_virt_to_bus(struct scb *scb,
<span class="lineNum">     173 </span>            :                                            struct ahc_dma_seg *sg);
<span class="lineNum">     174 </span>            : IO_INLINE uint32_t
<span class="lineNum">     175 </span>            :                         ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index);
<span class="lineNum">     176 </span>            : IO_INLINE void          ahc_sync_scb(struct ahc_softc *ahc,
<span class="lineNum">     177 </span>            :                                            struct scb *scb, int op);
<span class="lineNum">     178 </span>            : #ifdef AHC_TARGET_MODE
<span class="lineNum">     179 </span>            : IO_INLINE uint32_t
<span class="lineNum">     180 </span>            :                         ahc_targetcmd_offset(struct ahc_softc *ahc,
<span class="lineNum">     181 </span>            :                                              u_int index);
<span class="lineNum">     182 </span>            : #endif
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : #ifdef IO_EXPAND
<a name="185"><span class="lineNum">     185 </span>            : </a>
<span class="lineNum">     186 </span>            : IO_INLINE struct ahc_dma_seg *
<span class="lineNum">     187 </span><span class="lineNoCov">          0 : ahc_sg_bus_to_virt(struct scb *scb, uint32_t sg_busaddr)</span>
<span class="lineNum">     188 </span>            : {
<span class="lineNum">     189 </span>            :         int sg_index;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         sg_index = (sg_busaddr - scb-&gt;sg_list_phys)/sizeof(struct ahc_dma_seg);</span>
<span class="lineNum">     192 </span>            :         /* sg_list_phys points to entry 1, not 0 */
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         sg_index++;</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         return (&amp;scb-&gt;sg_list[sg_index]);</span>
<span class="lineNum">     196 </span>            : }
<a name="197"><span class="lineNum">     197 </span>            : </a>
<span class="lineNum">     198 </span>            : IO_INLINE uint32_t
<span class="lineNum">     199 </span><span class="lineNoCov">          0 : ahc_sg_virt_to_bus(struct scb *scb, struct ahc_dma_seg *sg)</span>
<span class="lineNum">     200 </span>            : {
<span class="lineNum">     201 </span>            :         int sg_index;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :         /* sg_list_phys points to entry 1, not 0 */
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         sg_index = sg - &amp;scb-&gt;sg_list[1];</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         return (scb-&gt;sg_list_phys + (sg_index * sizeof(*scb-&gt;sg_list)));</span>
<span class="lineNum">     207 </span>            : }
<a name="208"><span class="lineNum">     208 </span>            : </a>
<span class="lineNum">     209 </span>            : IO_INLINE uint32_t
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)</span>
<span class="lineNum">     211 </span>            : {
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         return (ahc-&gt;scb_data-&gt;hscb_busaddr</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :                 + (sizeof(struct hardware_scb) * index));</span>
<span class="lineNum">     214 </span>            : }
<a name="215"><span class="lineNum">     215 </span>            : </a>
<span class="lineNum">     216 </span>            : IO_INLINE void
<span class="lineNum">     217 </span><span class="lineNoCov">          0 : ahc_sync_scb(struct ahc_softc *ahc, struct scb *scb, int op)</span>
<span class="lineNum">     218 </span>            : {
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         ahc_dmamap_sync(ahc, ahc-&gt;parent_dmat,</span>
<span class="lineNum">     220 </span>            :                         ahc-&gt;scb_data-&gt;hscb_dmamap,
<span class="lineNum">     221 </span>            :                         /*offset*/(scb-&gt;hscb - ahc-&gt;scb_data-&gt;hscbs) * sizeof(*scb-&gt;hscb),
<span class="lineNum">     222 </span>            :                         /*len*/sizeof(*scb-&gt;hscb), op);
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : #ifdef AHC_TARGET_MODE
<span class="lineNum">     226 </span>            : IO_INLINE uint32_t
<span class="lineNum">     227 </span>            : ahc_targetcmd_offset(struct ahc_softc *ahc, u_int index)
<span class="lineNum">     228 </span>            : {
<span class="lineNum">     229 </span>            :         return (((uint8_t *)&amp;ahc-&gt;targetcmds[index]) - ahc-&gt;qoutfifo);
<span class="lineNum">     230 </span>            : }
<span class="lineNum">     231 </span>            : #endif /* AHC_TARGET_MODE */
<span class="lineNum">     232 </span>            : #endif /* IO_EXPAND */
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /******************************** Debugging ***********************************/
<span class="lineNum">     235 </span>            : static __inline char *ahc_name(struct ahc_softc *ahc);
<a name="236"><span class="lineNum">     236 </span>            : </a>
<span class="lineNum">     237 </span>            : static __inline char *
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : ahc_name(struct ahc_softc *ahc)</span>
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         return (ahc-&gt;name);</span>
<span class="lineNum">     241 </span>            : }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : /*********************** Miscellaneous Support Functions ***********************/
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : IO_INLINE void  ahc_update_residual(struct ahc_softc *ahc,
<span class="lineNum">     246 </span>            :                                             struct scb *scb);
<span class="lineNum">     247 </span>            : IO_INLINE struct ahc_initiator_tinfo *
<span class="lineNum">     248 </span>            :                         ahc_fetch_transinfo(struct ahc_softc *ahc,
<span class="lineNum">     249 </span>            :                                             char channel, u_int our_id,
<span class="lineNum">     250 </span>            :                                             u_int remote_id,
<span class="lineNum">     251 </span>            :                                             struct ahc_tmode_tstate **tstate);
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : IO_INLINE uint16_t
<span class="lineNum">     254 </span>            :                         ahc_inw(struct ahc_softc *ahc, u_int port);
<span class="lineNum">     255 </span>            : IO_INLINE void  ahc_outw(struct ahc_softc *ahc, u_int port,
<span class="lineNum">     256 </span>            :                                  u_int value);
<span class="lineNum">     257 </span>            : IO_INLINE uint32_t
<span class="lineNum">     258 </span>            :                         ahc_inl(struct ahc_softc *ahc, u_int port);
<span class="lineNum">     259 </span>            : IO_INLINE void  ahc_outl(struct ahc_softc *ahc, u_int port,
<span class="lineNum">     260 </span>            :                                  uint32_t value);
<span class="lineNum">     261 </span>            : IO_INLINE struct scb *ahc_lookup_scb(struct ahc_softc *ahc, u_int tag);
<span class="lineNum">     262 </span>            : IO_INLINE void          ahc_swap_with_next_hscb(struct ahc_softc *ahc,
<span class="lineNum">     263 </span>            :                                                 struct scb *scb);
<span class="lineNum">     264 </span>            : IO_INLINE void          ahc_queue_scb(struct ahc_softc *ahc, struct scb *scb);
<span class="lineNum">     265 </span>            : IO_INLINE struct scsi_sense_data *
<span class="lineNum">     266 </span>            :                         ahc_get_sense_buf(struct ahc_softc *ahc,
<span class="lineNum">     267 </span>            :                                           struct scb *scb);
<span class="lineNum">     268 </span>            : IO_INLINE uint32_t
<span class="lineNum">     269 </span>            :                         ahc_get_sense_bufaddr(struct ahc_softc *ahc,
<span class="lineNum">     270 </span>            :                                               struct scb *scb);
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : #ifdef IO_EXPAND
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : /*
<span class="lineNum">     275 </span>            :  * Determine whether the sequencer reported a residual
<span class="lineNum">     276 </span>            :  * for this SCB/transaction.
<a name="277"><span class="lineNum">     277 </span>            :  */</a>
<span class="lineNum">     278 </span>            : IO_INLINE void
<span class="lineNum">     279 </span><span class="lineNoCov">          0 : ahc_update_residual(struct ahc_softc *ahc, struct scb *scb)</span>
<span class="lineNum">     280 </span>            : {
<span class="lineNum">     281 </span>            :         uint32_t sgptr;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         sgptr = aic_le32toh(scb-&gt;hscb-&gt;sgptr);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         if ((sgptr &amp; SG_RESID_VALID) != 0)</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :                 ahc_calc_residual(ahc, scb);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : /*
<span class="lineNum">     289 </span>            :  * Return pointers to the transfer negotiation information
<span class="lineNum">     290 </span>            :  * for the specified our_id/remote_id pair.
<a name="291"><span class="lineNum">     291 </span>            :  */</a>
<span class="lineNum">     292 </span>            : IO_INLINE struct ahc_initiator_tinfo *
<span class="lineNum">     293 </span><span class="lineNoCov">          0 : ahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,</span>
<span class="lineNum">     294 </span>            :                     u_int remote_id, struct ahc_tmode_tstate **tstate)
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span>            :         /*
<span class="lineNum">     297 </span>            :          * Transfer data structures are stored from the perspective
<span class="lineNum">     298 </span>            :          * of the target role.  Since the parameters for a connection
<span class="lineNum">     299 </span>            :          * in the initiator role to a given target are the same as
<span class="lineNum">     300 </span>            :          * when the roles are reversed, we pretend we are the target.
<span class="lineNum">     301 </span>            :          */
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         if (channel == 'B')</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :                 our_id += 8;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         *tstate = ahc-&gt;enabled_targets[our_id];</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         return (&amp;(*tstate)-&gt;transinfo[remote_id]);</span>
<span class="lineNum">     306 </span>            : }
<a name="307"><span class="lineNum">     307 </span>            : </a>
<span class="lineNum">     308 </span>            : IO_INLINE uint16_t
<span class="lineNum">     309 </span><span class="lineNoCov">          0 : ahc_inw(struct ahc_softc *ahc, u_int port)</span>
<span class="lineNum">     310 </span>            : {
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         return ((ahc_inb(ahc, port+1) &lt;&lt; 8) | ahc_inb(ahc, port));</span>
<span class="lineNum">     312 </span>            : }
<a name="313"><span class="lineNum">     313 </span>            : </a>
<span class="lineNum">     314 </span>            : IO_INLINE void
<span class="lineNum">     315 </span><span class="lineNoCov">          0 : ahc_outw(struct ahc_softc *ahc, u_int port, u_int value)</span>
<span class="lineNum">     316 </span>            : {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, port, value &amp; 0xFF);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, port+1, (value &gt;&gt; 8) &amp; 0xFF);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : }</span>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<span class="lineNum">     321 </span>            : IO_INLINE uint32_t
<span class="lineNum">     322 </span><span class="lineNoCov">          0 : ahc_inl(struct ahc_softc *ahc, u_int port)</span>
<span class="lineNum">     323 </span>            : {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         return ((ahc_inb(ahc, port))</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :               | (ahc_inb(ahc, port+1) &lt;&lt; 8)</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :               | (ahc_inb(ahc, port+2) &lt;&lt; 16)</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :               | (ahc_inb(ahc, port+3) &lt;&lt; 24));</span>
<span class="lineNum">     328 </span>            : }
<a name="329"><span class="lineNum">     329 </span>            : </a>
<span class="lineNum">     330 </span>            : IO_INLINE void
<span class="lineNum">     331 </span><span class="lineNoCov">          0 : ahc_outl(struct ahc_softc *ahc, u_int port, uint32_t value)</span>
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, port, (value) &amp; 0xFF);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, port+1, ((value) &gt;&gt; 8) &amp; 0xFF);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, port+2, ((value) &gt;&gt; 16) &amp; 0xFF);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         ahc_outb(ahc, port+3, ((value) &gt;&gt; 24) &amp; 0xFF);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : }</span>
<a name="338"><span class="lineNum">     338 </span>            : </a>
<span class="lineNum">     339 </span>            : IO_INLINE struct scb *
<span class="lineNum">     340 </span><span class="lineNoCov">          0 : ahc_lookup_scb(struct ahc_softc *ahc, u_int tag)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span>            :         struct scb* scb;
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         scb = ahc-&gt;scb_data-&gt;scbindex[tag];</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         if (scb != NULL)</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                 ahc_sync_scb(ahc, scb,</span>
<span class="lineNum">     347 </span>            :                              BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         return (scb);</span>
<span class="lineNum">     349 </span>            : }
<span class="lineNum">     350 </span>            : 
<a name="351"><span class="lineNum">     351 </span>            : </a>
<span class="lineNum">     352 </span>            : IO_INLINE void
<span class="lineNum">     353 </span><span class="lineNoCov">          0 : ahc_swap_with_next_hscb(struct ahc_softc *ahc, struct scb *scb)</span>
<span class="lineNum">     354 </span>            : {
<span class="lineNum">     355 </span>            :         struct hardware_scb *q_hscb;
<span class="lineNum">     356 </span>            :         u_int  saved_tag;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :         /*
<span class="lineNum">     359 </span>            :          * Our queuing method is a bit tricky.  The card
<span class="lineNum">     360 </span>            :          * knows in advance which HSCB to download, and we
<span class="lineNum">     361 </span>            :          * can't disappoint it.  To achieve this, the next
<span class="lineNum">     362 </span>            :          * SCB to download is saved off in ahc-&gt;next_queued_scb.
<span class="lineNum">     363 </span>            :          * When we are called to queue &quot;an arbitrary scb&quot;,
<span class="lineNum">     364 </span>            :          * we copy the contents of the incoming HSCB to the one
<span class="lineNum">     365 </span>            :          * the sequencer knows about, swap HSCB pointers and
<span class="lineNum">     366 </span>            :          * finally assign the SCB to the tag indexed location
<span class="lineNum">     367 </span>            :          * in the scb_array.  This makes sure that we can still
<span class="lineNum">     368 </span>            :          * locate the correct SCB by SCB_TAG.
<span class="lineNum">     369 </span>            :          */
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         q_hscb = ahc-&gt;next_queued_scb-&gt;hscb;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         saved_tag = q_hscb-&gt;tag;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         memcpy(q_hscb, scb-&gt;hscb, sizeof(*scb-&gt;hscb));</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         if ((scb-&gt;flags &amp; SCB_CDB32_PTR) != 0) {</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                 q_hscb-&gt;shared_data.cdb_ptr =</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                     aic_htole32(ahc_hscb_busaddr(ahc, q_hscb-&gt;tag)</span>
<span class="lineNum">     376 </span>            :                               + offsetof(struct hardware_scb, cdb32));
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         q_hscb-&gt;tag = saved_tag;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         q_hscb-&gt;next = scb-&gt;hscb-&gt;tag;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :         /* Now swap HSCB pointers. */
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         ahc-&gt;next_queued_scb-&gt;hscb = scb-&gt;hscb;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         scb-&gt;hscb = q_hscb;</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :         /* Now define the mapping from tag to SCB in the scbindex */
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         ahc-&gt;scb_data-&gt;scbindex[scb-&gt;hscb-&gt;tag] = scb;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : /*
<span class="lineNum">     390 </span>            :  * Tell the sequencer about a new transaction to execute.
<a name="391"><span class="lineNum">     391 </span>            :  */</a>
<span class="lineNum">     392 </span>            : IO_INLINE void
<span class="lineNum">     393 </span><span class="lineNoCov">          0 : ahc_queue_scb(struct ahc_softc *ahc, struct scb *scb)</span>
<span class="lineNum">     394 </span>            : {
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         ahc_swap_with_next_hscb(ahc, scb);</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         if (scb-&gt;hscb-&gt;tag == SCB_LIST_NULL</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :          || scb-&gt;hscb-&gt;next == SCB_LIST_NULL)</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                 panic(&quot;Attempt to queue invalid SCB tag %x:%x&quot;,</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                       scb-&gt;hscb-&gt;tag, scb-&gt;hscb-&gt;next);</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :         /*
<span class="lineNum">     403 </span>            :          * Setup data &quot;oddness&quot;.
<span class="lineNum">     404 </span>            :          */
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         scb-&gt;hscb-&gt;lun &amp;= LID;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         if (ahc_get_transfer_length(scb) &amp; 0x1)</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                 scb-&gt;hscb-&gt;lun |= SCB_XFERLEN_ODD;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :         /*
<span class="lineNum">     410 </span>            :          * Keep a history of SCBs we've downloaded in the qinfifo.
<span class="lineNum">     411 </span>            :          */
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         ahc-&gt;qinfifo[ahc-&gt;qinfifonext] = scb-&gt;hscb-&gt;tag;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         ahc_dmamap_sync(ahc, ahc-&gt;parent_dmat, ahc-&gt;shared_data_dmamap,</span>
<span class="lineNum">     414 </span>            :                         /*offset*/ahc-&gt;qinfifonext+256, /*len*/1,
<span class="lineNum">     415 </span>            :                         BUS_DMASYNC_PREWRITE);
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         ahc-&gt;qinfifonext++;</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :         /*
<span class="lineNum">     419 </span>            :          * Make sure our data is consistent from the
<span class="lineNum">     420 </span>            :          * perspective of the adapter.
<span class="lineNum">     421 </span>            :          */
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :         /* Tell the adapter about the newly queued SCB */
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         if ((ahc-&gt;features &amp; AHC_QUEUE_REGS) != 0) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                 ahc_outb(ahc, HNSCB_QOFF, ahc-&gt;qinfifonext);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                 if ((ahc-&gt;features &amp; AHC_AUTOPAUSE) == 0)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                         ahc_pause(ahc);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                 ahc_outb(ahc, KERNEL_QINPOS, ahc-&gt;qinfifonext);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                 if ((ahc-&gt;features &amp; AHC_AUTOPAUSE) == 0)</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                         ahc_unpause(ahc);</span>
<span class="lineNum">     433 </span>            :         }
<span class="lineNum">     434 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     435 </span>            : 
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : IO_INLINE struct scsi_sense_data *
<span class="lineNum">     438 </span><span class="lineNoCov">          0 : ahc_get_sense_buf(struct ahc_softc *ahc, struct scb *scb)</span>
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span>            :         int offset;
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         offset = scb - ahc-&gt;scb_data-&gt;scbarray;</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :         return (&amp;ahc-&gt;scb_data-&gt;sense[offset]);</span>
<span class="lineNum">     444 </span>            : }
<a name="445"><span class="lineNum">     445 </span>            : </a>
<span class="lineNum">     446 </span>            : IO_INLINE uint32_t
<span class="lineNum">     447 </span><span class="lineNoCov">          0 : ahc_get_sense_bufaddr(struct ahc_softc *ahc, struct scb *scb)</span>
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span>            :         int offset;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         offset = scb - ahc-&gt;scb_data-&gt;scbarray;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         return (ahc-&gt;scb_data-&gt;sense_busaddr</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :               + (offset * sizeof(struct scsi_sense_data)));</span>
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : #endif /* IO_EXPAND */
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : /************************** Interrupt Processing ******************************/
<span class="lineNum">     458 </span>            : IO_INLINE void  ahc_sync_qoutfifo(struct ahc_softc *ahc, int op);
<span class="lineNum">     459 </span>            : IO_INLINE void  ahc_sync_tqinfifo(struct ahc_softc *ahc, int op);
<span class="lineNum">     460 </span>            : IO_INLINE u_int ahc_check_cmdcmpltqueues(struct ahc_softc *ahc);
<span class="lineNum">     461 </span>            : IO_INLINE int   ahc_intr(struct ahc_softc *ahc);
<span class="lineNum">     462 </span>            : 
<a name="463"><span class="lineNum">     463 </span>            : #ifdef IO_EXPAND</a>
<span class="lineNum">     464 </span>            : IO_INLINE void
<span class="lineNum">     465 </span><span class="lineNoCov">          0 : ahc_sync_qoutfifo(struct ahc_softc *ahc, int op)</span>
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         ahc_dmamap_sync(ahc, ahc-&gt;parent_dmat, ahc-&gt;shared_data_dmamap,</span>
<span class="lineNum">     468 </span>            :                         /*offset*/0, /*len*/256, op);
<span class="lineNum">     469 </span><span class="lineNoCov">          0 : }</span>
<a name="470"><span class="lineNum">     470 </span>            : </a>
<span class="lineNum">     471 </span>            : IO_INLINE void
<span class="lineNum">     472 </span><span class="lineNoCov">          0 : ahc_sync_tqinfifo(struct ahc_softc *ahc, int op)</span>
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span>            : #ifdef AHC_TARGET_MODE
<span class="lineNum">     475 </span>            :         if ((ahc-&gt;flags &amp; AHC_TARGETROLE) != 0) {
<span class="lineNum">     476 </span>            :           ahc_dmamap_sync(ahc, ahc-&gt;parent_dmat /*shared_data_dmat*/,
<span class="lineNum">     477 </span>            :                                 ahc-&gt;shared_data_dmamap,
<span class="lineNum">     478 </span>            :                                 ahc_targetcmd_offset(ahc, 0),
<span class="lineNum">     479 </span>            :                                 sizeof(struct target_cmd) * AHC_TMODE_CMDS,
<span class="lineNum">     480 </span>            :                                 op);
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span>            : #endif
<span class="lineNum">     483 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : /*
<span class="lineNum">     486 </span>            :  * See if the firmware has posted any completed commands
<span class="lineNum">     487 </span>            :  * into our in-core command complete fifos.
<span class="lineNum">     488 </span>            :  */
<span class="lineNum">     489 </span>            : #define AHC_RUN_QOUTFIFO 0x1
<a name="490"><span class="lineNum">     490 </span>            : #define AHC_RUN_TQINFIFO 0x2</a>
<span class="lineNum">     491 </span>            : IO_INLINE u_int
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : ahc_check_cmdcmpltqueues(struct ahc_softc *ahc)</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span>            :         u_int retval;
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :         retval = 0;
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         ahc_dmamap_sync(ahc, ahc-&gt;parent_dmat /*shared_data_dmat*/, ahc-&gt;shared_data_dmamap,</span>
<span class="lineNum">     498 </span>            :                         /*offset*/ahc-&gt;qoutfifonext, /*len*/1,
<span class="lineNum">     499 </span>            :                         BUS_DMASYNC_POSTREAD);
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         if (ahc-&gt;qoutfifo[ahc-&gt;qoutfifonext] != SCB_LIST_NULL)</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                 retval |= AHC_RUN_QOUTFIFO;</span>
<span class="lineNum">     502 </span>            : #ifdef AHC_TARGET_MODE
<span class="lineNum">     503 </span>            :         if ((ahc-&gt;flags &amp; AHC_TARGETROLE) != 0
<span class="lineNum">     504 </span>            :             &amp;&amp; (ahc-&gt;flags &amp; AHC_TQINFIFO_BLOCKED) == 0) {
<span class="lineNum">     505 </span>            :           ahc_dmamap_sync(ahc, ahc-&gt;parent_dmat /*shared_data_dmat*/,
<span class="lineNum">     506 </span>            :                           ahc-&gt;shared_data_dmamap,
<span class="lineNum">     507 </span>            :                           ahc_targetcmd_offset(ahc, ahc-&gt;tqinfifonext),
<span class="lineNum">     508 </span>            :                           /*len*/sizeof(struct target_cmd),
<span class="lineNum">     509 </span>            :                           BUS_DMASYNC_POSTREAD);
<span class="lineNum">     510 </span>            :                 if (ahc-&gt;targetcmds[ahc-&gt;tqinfifonext].cmd_valid != 0)
<span class="lineNum">     511 </span>            :                         retval |= AHC_RUN_TQINFIFO;
<span class="lineNum">     512 </span>            :         }
<span class="lineNum">     513 </span>            : #endif
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         return (retval);</span>
<span class="lineNum">     515 </span>            : }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : /*
<span class="lineNum">     519 </span>            :  * Catch an interrupt from the adapter
<a name="520"><span class="lineNum">     520 </span>            :  */</a>
<span class="lineNum">     521 </span>            : IO_INLINE int
<span class="lineNum">     522 </span><span class="lineNoCov">          0 : ahc_intr(struct ahc_softc *ahc)</span>
<span class="lineNum">     523 </span>            : {
<span class="lineNum">     524 </span>            :         u_int   intstat;
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         if ((ahc-&gt;pause &amp; INTEN) == 0) {</span>
<span class="lineNum">     527 </span>            :                 /*
<span class="lineNum">     528 </span>            :                  * Our interrupt is not enabled on the chip
<span class="lineNum">     529 </span>            :                  * and may be disabled for re-entrancy reasons,
<span class="lineNum">     530 </span>            :                  * so just return.  This is likely just a shared
<span class="lineNum">     531 </span>            :                  * interrupt.
<span class="lineNum">     532 </span>            :                  */
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                 return (0);</span>
<span class="lineNum">     534 </span>            :         }
<span class="lineNum">     535 </span>            :         /*
<span class="lineNum">     536 </span>            :          * Instead of directly reading the interrupt status register,
<span class="lineNum">     537 </span>            :          * infer the cause of the interrupt by checking our in-core
<span class="lineNum">     538 </span>            :          * completion queues.  This avoids a costly PCI bus read in
<span class="lineNum">     539 </span>            :          * most cases.
<span class="lineNum">     540 </span>            :          */
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         if ((ahc-&gt;flags &amp; (AHC_ALL_INTERRUPTS|AHC_EDGE_INTERRUPT)) == 0</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :             &amp;&amp; (ahc_check_cmdcmpltqueues(ahc) != 0))</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                 intstat = CMDCMPLT;</span>
<span class="lineNum">     544 </span>            :         else {
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 intstat = ahc_inb(ahc, INTSTAT);</span>
<span class="lineNum">     546 </span>            :         }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         if (intstat &amp; CMDCMPLT) {</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                 ahc_outb(ahc, CLRINT, CLRCMDINT);</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :                 /*
<span class="lineNum">     552 </span>            :                  * Ensure that the chip sees that we've cleared
<span class="lineNum">     553 </span>            :                  * this interrupt before we walk the output fifo.
<span class="lineNum">     554 </span>            :                  * Otherwise, we may, due to posted bus writes,
<span class="lineNum">     555 </span>            :                  * clear the interrupt after we finish the scan,
<span class="lineNum">     556 </span>            :                  * and after the sequencer has added new entries
<span class="lineNum">     557 </span>            :                  * and asserted the interrupt again.
<span class="lineNum">     558 </span>            :                  */
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                 ahc_flush_device_writes(ahc);</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                 ahc_run_qoutfifo(ahc);</span>
<span class="lineNum">     561 </span>            : #ifdef AHC_TARGET_MODE
<span class="lineNum">     562 </span>            :                 if ((ahc-&gt;flags &amp; AHC_TARGETROLE) != 0)
<span class="lineNum">     563 </span>            :                         ahc_run_tqinfifo(ahc, /*paused*/FALSE);
<span class="lineNum">     564 </span>            : #endif
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         if (intstat == 0xFF &amp;&amp; (ahc-&gt;features &amp; AHC_REMOVABLE) != 0)</span>
<span class="lineNum">     568 </span>            :                 /* Hot eject */
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         if ((intstat &amp; INT_PEND) == 0) {</span>
<span class="lineNum">     572 </span>            : #if AHC_PCI_CONFIG &gt; 0
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 if (ahc-&gt;unsolicited_ints &gt; 500) {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                         ahc-&gt;unsolicited_ints = 0;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                         if ((ahc-&gt;chip &amp; AHC_PCI) != 0</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :                          &amp;&amp; (ahc_inb(ahc, ERROR) &amp; PCIERRSTAT) != 0)</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :                                 ahc-&gt;bus_intr(ahc);</span>
<span class="lineNum">     578 </span>            :                 }
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :                 ahc-&gt;unsolicited_ints++;</span>
<span class="lineNum">     580 </span>            : #endif
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     582 </span>            :         }
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         ahc-&gt;unsolicited_ints = 0;</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :         if (intstat &amp; BRKADRINT) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                 ahc_handle_brkadrint(ahc);</span>
<span class="lineNum">     587 </span>            :                 /* Fatal error, no more interrupts to handle. */
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     589 </span>            :         }
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :         if ((intstat &amp; (SEQINT|SCSIINT)) != 0)</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 ahc_pause_bug_fix(ahc);</span>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         if ((intstat &amp; SEQINT) != 0)</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :                 ahc_handle_seqint(ahc, intstat);</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         if ((intstat &amp; SCSIINT) != 0)</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                 ahc_handle_scsiint(ahc, intstat);</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         return (1);</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : #endif  /* IO_EXPAND */
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : #endif  /* _AIC7XXX_INLINE_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
