<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - net/fq_codel.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">net</a> - fq_codel.c<span style="font-size: 80%;"> (source / <a href="fq_codel.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">295</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">37</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2017 Mike Belopuhov
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Permission to use, copy, modify, and distribute this software for any
<span class="lineNum">       5 </span>            :  * purpose with or without fee is hereby granted, provided that the above
<span class="lineNum">       6 </span>            :  * copyright notice and this permission notice appear in all copies.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<span class="lineNum">       9 </span>            :  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<span class="lineNum">      10 </span>            :  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<span class="lineNum">      11 </span>            :  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<span class="lineNum">      12 </span>            :  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<span class="lineNum">      13 </span>            :  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="lineNum">      14 </span>            :  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /*
<span class="lineNum">      18 </span>            :  * Codel - The Controlled-Delay Active Queue Management algorithm
<span class="lineNum">      19 </span>            :  * IETF draft-ietf-aqm-codel-07
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * Based on the algorithm by Kathleen Nichols and Van Jacobson with
<span class="lineNum">      22 </span>            :  * improvements from Dave Taht and Eric Dumazet.
<span class="lineNum">      23 </span>            :  */
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /*
<span class="lineNum">      26 </span>            :  * The FlowQueue-CoDel Packet Scheduler and Active Queue Management
<span class="lineNum">      27 </span>            :  * IETF draft-ietf-aqm-fq-codel-06
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  * Based on the implementation by Rasool Al-Saadi, Centre for Advanced
<span class="lineNum">      30 </span>            :  * Internet Architectures, Swinburne University of Technology, Melbourne,
<span class="lineNum">      31 </span>            :  * Australia.
<span class="lineNum">      32 </span>            :  */
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;sys/systm.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;sys/socket.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;sys/mbuf.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;sys/queue.h&gt;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &lt;net/if.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;net/if_var.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;net/pfvar.h&gt;
<span class="lineNum">      43 </span>            : #include &lt;net/fq_codel.h&gt;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /* #define FQCODEL_DEBUG 1 */
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #ifdef FQCODEL_DEBUG
<span class="lineNum">      48 </span>            : #define DPRINTF(x...)           printf(x)
<span class="lineNum">      49 </span>            : #else
<span class="lineNum">      50 </span>            : #define DPRINTF(x...)
<span class="lineNum">      51 </span>            : #endif
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : struct codel {
<span class="lineNum">      54 </span>            :         struct mbuf_list q;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :         unsigned int     dropping:1;    /* Dropping state */
<span class="lineNum">      57 </span>            :         unsigned int     backlog:31;    /* Number of bytes in the queue */
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :         unsigned short   drops;         /* Free running counter of drops */
<span class="lineNum">      60 </span>            :         unsigned short   ldrops;        /* Value from the previous run */
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :         int64_t          start;         /* The moment queue was above target */
<span class="lineNum">      63 </span>            :         int64_t          next;          /* Next interval */
<span class="lineNum">      64 </span>            :         int64_t          delay;         /* Delay incurred by the last packet */
<span class="lineNum">      65 </span>            : };
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : struct codel_params {
<span class="lineNum">      68 </span>            :         int64_t          target;
<span class="lineNum">      69 </span>            :         int64_t          interval;
<span class="lineNum">      70 </span>            :         int              quantum;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :         uint32_t        *intervals;
<span class="lineNum">      73 </span>            : };
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : void             codel_initparams(struct codel_params *, unsigned int,
<span class="lineNum">      76 </span>            :                     unsigned int, int);
<span class="lineNum">      77 </span>            : void             codel_freeparams(struct codel_params *);
<span class="lineNum">      78 </span>            : void             codel_enqueue(struct codel *, int64_t, struct mbuf *);
<span class="lineNum">      79 </span>            : struct mbuf     *codel_dequeue(struct codel *, struct codel_params *, int64_t,
<span class="lineNum">      80 </span>            :                     struct mbuf_list *, uint64_t *, uint64_t *);
<span class="lineNum">      81 </span>            : struct mbuf     *codel_commit(struct codel *, struct mbuf *);
<span class="lineNum">      82 </span>            : void             codel_purge(struct codel *, struct mbuf_list *ml);
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : struct flow {
<span class="lineNum">      85 </span>            :         struct codel             cd;
<span class="lineNum">      86 </span>            :         int                      active:1;
<span class="lineNum">      87 </span>            :         int                      deficit:31;
<span class="lineNum">      88 </span>            : #ifdef FQCODEL_DEBUG
<span class="lineNum">      89 </span>            :         uint16_t                 id;
<span class="lineNum">      90 </span>            : #endif
<span class="lineNum">      91 </span>            :         SIMPLEQ_ENTRY(flow)      flowentry;
<span class="lineNum">      92 </span>            : };
<span class="lineNum">      93 </span>            : SIMPLEQ_HEAD(flowq, flow);
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : struct fqcodel {
<span class="lineNum">      96 </span>            :         struct flowq             newq;
<span class="lineNum">      97 </span>            :         struct flowq             oldq;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :         struct flow             *flows;
<span class="lineNum">     100 </span>            :         unsigned int             qlength;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :         struct ifnet            *ifp;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :         struct codel_params      cparams;
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :         unsigned int             nflows;
<span class="lineNum">     107 </span>            :         unsigned int             qlimit;
<span class="lineNum">     108 </span>            :         int                      quantum;
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :         unsigned int             flags;
<span class="lineNum">     111 </span>            : #define FQCF_FIXED_QUANTUM        0x1
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :         /* stats */
<span class="lineNum">     114 </span>            :         struct fqcodel_pktcntr   xmit_cnt;
<span class="lineNum">     115 </span>            :         struct fqcodel_pktcntr   drop_cnt;
<span class="lineNum">     116 </span>            : };
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : unsigned int     fqcodel_idx(unsigned int, const struct mbuf *);
<span class="lineNum">     119 </span>            : void            *fqcodel_alloc(unsigned int, void *);
<span class="lineNum">     120 </span>            : void             fqcodel_free(unsigned int, void *);
<span class="lineNum">     121 </span>            : struct mbuf     *fqcodel_if_enq(struct ifqueue *, struct mbuf *);
<span class="lineNum">     122 </span>            : struct mbuf     *fqcodel_if_deq_begin(struct ifqueue *, void **);
<span class="lineNum">     123 </span>            : void             fqcodel_if_deq_commit(struct ifqueue *, struct mbuf *, void *);
<span class="lineNum">     124 </span>            : void             fqcodel_if_purge(struct ifqueue *, struct mbuf_list *);
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : struct mbuf     *fqcodel_enq(struct fqcodel *, struct mbuf *);
<span class="lineNum">     127 </span>            : struct mbuf     *fqcodel_deq_begin(struct fqcodel *, void **,
<span class="lineNum">     128 </span>            :                     struct mbuf_list *);
<span class="lineNum">     129 </span>            : void             fqcodel_deq_commit(struct fqcodel *, struct mbuf *, void *);
<span class="lineNum">     130 </span>            : void             fqcodel_purge(struct fqcodel *, struct mbuf_list *);
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : /*
<span class="lineNum">     133 </span>            :  * ifqueue glue.
<span class="lineNum">     134 </span>            :  */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : static const struct ifq_ops fqcodel_ops = {
<span class="lineNum">     137 </span>            :         fqcodel_idx,
<span class="lineNum">     138 </span>            :         fqcodel_if_enq,
<span class="lineNum">     139 </span>            :         fqcodel_if_deq_begin,
<span class="lineNum">     140 </span>            :         fqcodel_if_deq_commit,
<span class="lineNum">     141 </span>            :         fqcodel_if_purge,
<span class="lineNum">     142 </span>            :         fqcodel_alloc,
<span class="lineNum">     143 </span>            :         fqcodel_free
<span class="lineNum">     144 </span>            : };
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : const struct ifq_ops * const ifq_fqcodel_ops = &amp;fqcodel_ops;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : void            *fqcodel_pf_alloc(struct ifnet *);
<span class="lineNum">     149 </span>            : int              fqcodel_pf_addqueue(void *, struct pf_queuespec *);
<span class="lineNum">     150 </span>            : void             fqcodel_pf_free(void *);
<span class="lineNum">     151 </span>            : int              fqcodel_pf_qstats(struct pf_queuespec *, void *, int *);
<span class="lineNum">     152 </span>            : unsigned int     fqcodel_pf_qlength(void *);
<span class="lineNum">     153 </span>            : struct mbuf *    fqcodel_pf_enqueue(void *, struct mbuf *);
<span class="lineNum">     154 </span>            : struct mbuf *    fqcodel_pf_deq_begin(void *, void **, struct mbuf_list *);
<span class="lineNum">     155 </span>            : void             fqcodel_pf_deq_commit(void *, struct mbuf *, void *);
<span class="lineNum">     156 </span>            : void             fqcodel_pf_purge(void *, struct mbuf_list *);
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : /*
<span class="lineNum">     159 </span>            :  * pf queue glue.
<span class="lineNum">     160 </span>            :  */
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            : static const struct pfq_ops fqcodel_pf_ops = {
<span class="lineNum">     163 </span>            :         fqcodel_pf_alloc,
<span class="lineNum">     164 </span>            :         fqcodel_pf_addqueue,
<span class="lineNum">     165 </span>            :         fqcodel_pf_free,
<span class="lineNum">     166 </span>            :         fqcodel_pf_qstats,
<span class="lineNum">     167 </span>            :         fqcodel_pf_qlength,
<span class="lineNum">     168 </span>            :         fqcodel_pf_enqueue,
<span class="lineNum">     169 </span>            :         fqcodel_pf_deq_begin,
<span class="lineNum">     170 </span>            :         fqcodel_pf_deq_commit,
<span class="lineNum">     171 </span>            :         fqcodel_pf_purge
<span class="lineNum">     172 </span>            : };
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : const struct pfq_ops * const pfq_fqcodel_ops = &amp;fqcodel_pf_ops;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /* Default aggregate queue depth */
<span class="lineNum">     177 </span>            : static const unsigned int fqcodel_qlimit = 1024;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /*
<span class="lineNum">     180 </span>            :  * CoDel implementation
<span class="lineNum">     181 </span>            :  */
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : /* Delay target, 5ms */
<span class="lineNum">     184 </span>            : static const int64_t codel_target = 5000000;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Grace period after last drop, 16 100ms intervals */
<span class="lineNum">     187 </span>            : static const int64_t codel_grace = 1600000000;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /* First 399 &quot;100 / sqrt(x)&quot; intervarls, ns precision */
<span class="lineNum">     190 </span>            : static const uint32_t codel_intervals[] = {
<span class="lineNum">     191 </span>            :         100000000, 70710678, 57735027, 50000000, 44721360, 40824829, 37796447,
<span class="lineNum">     192 </span>            :         35355339,  33333333, 31622777, 30151134, 28867513, 27735010, 26726124,
<span class="lineNum">     193 </span>            :         25819889,  25000000, 24253563, 23570226, 22941573, 22360680, 21821789,
<span class="lineNum">     194 </span>            :         21320072,  20851441, 20412415, 20000000, 19611614, 19245009, 18898224,
<span class="lineNum">     195 </span>            :         18569534,  18257419, 17960530, 17677670, 17407766, 17149859, 16903085,
<span class="lineNum">     196 </span>            :         16666667,  16439899, 16222142, 16012815, 15811388, 15617376, 15430335,
<span class="lineNum">     197 </span>            :         15249857,  15075567, 14907120, 14744196, 14586499, 14433757, 14285714,
<span class="lineNum">     198 </span>            :         14142136,  14002801, 13867505, 13736056, 13608276, 13483997, 13363062,
<span class="lineNum">     199 </span>            :         13245324,  13130643, 13018891, 12909944, 12803688, 12700013, 12598816,
<span class="lineNum">     200 </span>            :         12500000,  12403473, 12309149, 12216944, 12126781, 12038585, 11952286,
<span class="lineNum">     201 </span>            :         11867817,  11785113, 11704115, 11624764, 11547005, 11470787, 11396058,
<span class="lineNum">     202 </span>            :         11322770,  11250879, 11180340, 11111111, 11043153, 10976426, 10910895,
<span class="lineNum">     203 </span>            :         10846523,  10783277, 10721125, 10660036, 10599979, 10540926, 10482848,
<span class="lineNum">     204 </span>            :         10425721,  10369517, 10314212, 10259784, 10206207, 10153462, 10101525,
<span class="lineNum">     205 </span>            :         10050378,  10000000, 9950372,  9901475,  9853293,  9805807,  9759001,
<span class="lineNum">     206 </span>            :         9712859,   9667365,  9622504,  9578263,  9534626,  9491580,  9449112,
<span class="lineNum">     207 </span>            :         9407209,   9365858,  9325048,  9284767,  9245003,  9205746,  9166985,
<span class="lineNum">     208 </span>            :         9128709,   9090909,  9053575,  9016696,  8980265,  8944272,  8908708,
<span class="lineNum">     209 </span>            :         8873565,   8838835,  8804509,  8770580,  8737041,  8703883,  8671100,
<span class="lineNum">     210 </span>            :         8638684,   8606630,  8574929,  8543577,  8512565,  8481889,  8451543,
<span class="lineNum">     211 </span>            :         8421519,   8391814,  8362420,  8333333,  8304548,  8276059,  8247861,
<span class="lineNum">     212 </span>            :         8219949,   8192319,  8164966,  8137885,  8111071,  8084521,  8058230,
<span class="lineNum">     213 </span>            :         8032193,   8006408,  7980869,  7955573,  7930516,  7905694,  7881104,
<span class="lineNum">     214 </span>            :         7856742,   7832604,  7808688,  7784989,  7761505,  7738232,  7715167,
<span class="lineNum">     215 </span>            :         7692308,   7669650,  7647191,  7624929,  7602859,  7580980,  7559289,
<span class="lineNum">     216 </span>            :         7537784,   7516460,  7495317,  7474351,  7453560,  7432941,  7412493,
<span class="lineNum">     217 </span>            :         7392213,   7372098,  7352146,  7332356,  7312724,  7293250,  7273930,
<span class="lineNum">     218 </span>            :         7254763,   7235746,  7216878,  7198158,  7179582,  7161149,  7142857,
<span class="lineNum">     219 </span>            :         7124705,   7106691,  7088812,  7071068,  7053456,  7035975,  7018624,
<span class="lineNum">     220 </span>            :         7001400,   6984303,  6967330,  6950480,  6933752,  6917145,  6900656,
<span class="lineNum">     221 </span>            :         6884284,   6868028,  6851887,  6835859,  6819943,  6804138,  6788442,
<span class="lineNum">     222 </span>            :         6772855,   6757374,  6741999,  6726728,  6711561,  6696495,  6681531,
<span class="lineNum">     223 </span>            :         6666667,   6651901,  6637233,  6622662,  6608186,  6593805,  6579517,
<span class="lineNum">     224 </span>            :         6565322,   6551218,  6537205,  6523281,  6509446,  6495698,  6482037,
<span class="lineNum">     225 </span>            :         6468462,   6454972,  6441566,  6428243,  6415003,  6401844,  6388766,
<span class="lineNum">     226 </span>            :         6375767,   6362848,  6350006,  6337243,  6324555,  6311944,  6299408,
<span class="lineNum">     227 </span>            :         6286946,   6274558,  6262243,  6250000,  6237829,  6225728,  6213698,
<span class="lineNum">     228 </span>            :         6201737,   6189845,  6178021,  6166264,  6154575,  6142951,  6131393,
<span class="lineNum">     229 </span>            :         6119901,   6108472,  6097108,  6085806,  6074567,  6063391,  6052275,
<span class="lineNum">     230 </span>            :         6041221,   6030227,  6019293,  6008418,  5997601,  5986843,  5976143,
<span class="lineNum">     231 </span>            :         5965500,   5954913,  5944383,  5933908,  5923489,  5913124,  5902813,
<span class="lineNum">     232 </span>            :         5892557,   5882353,  5872202,  5862104,  5852057,  5842062,  5832118,
<span class="lineNum">     233 </span>            :         5822225,   5812382,  5802589,  5792844,  5783149,  5773503,  5763904,
<span class="lineNum">     234 </span>            :         5754353,   5744850,  5735393,  5725983,  5716620,  5707301,  5698029,
<span class="lineNum">     235 </span>            :         5688801,   5679618,  5670480,  5661385,  5652334,  5643326,  5634362,
<span class="lineNum">     236 </span>            :         5625440,   5616560,  5607722,  5598925,  5590170,  5581456,  5572782,
<span class="lineNum">     237 </span>            :         5564149,   5555556,  5547002,  5538488,  5530013,  5521576,  5513178,
<span class="lineNum">     238 </span>            :         5504819,   5496497,  5488213,  5479966,  5471757,  5463584,  5455447,
<span class="lineNum">     239 </span>            :         5447347,   5439283,  5431254,  5423261,  5415304,  5407381,  5399492,
<span class="lineNum">     240 </span>            :         5391639,   5383819,  5376033,  5368281,  5360563,  5352877,  5345225,
<span class="lineNum">     241 </span>            :         5337605,   5330018,  5322463,  5314940,  5307449,  5299989,  5292561,
<span class="lineNum">     242 </span>            :         5285164,   5277798,  5270463,  5263158,  5255883,  5248639,  5241424,
<span class="lineNum">     243 </span>            :         5234239,   5227084,  5219958,  5212860,  5205792,  5198752,  5191741,
<span class="lineNum">     244 </span>            :         5184758,   5177804,  5170877,  5163978,  5157106,  5150262,  5143445,
<span class="lineNum">     245 </span>            :         5136655,   5129892,  5123155,  5116445,  5109761,  5103104,  5096472,
<span class="lineNum">     246 </span>            :         5089866,   5083286,  5076731,  5070201,  5063697,  5057217,  5050763,
<span class="lineNum">     247 </span>            :         5044333,   5037927,  5031546,  5025189,  5018856,  5012547,  5006262
<span class="lineNum">     248 </span>            : };
<a name="249"><span class="lineNum">     249 </span>            : </a>
<span class="lineNum">     250 </span>            : void
<span class="lineNum">     251 </span><span class="lineNoCov">          0 : codel_initparams(struct codel_params *cp, unsigned int target,</span>
<span class="lineNum">     252 </span>            :     unsigned int interval, int quantum)
<span class="lineNum">     253 </span>            : {
<span class="lineNum">     254 </span>            :         uint64_t mult;
<span class="lineNum">     255 </span>            :         unsigned int i;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :         /*
<span class="lineNum">     258 </span>            :          * Update observation intervals table according to the configured
<span class="lineNum">     259 </span>            :          * initial interval value.
<span class="lineNum">     260 </span>            :          */
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         if (interval &gt; codel_intervals[0]) {</span>
<span class="lineNum">     262 </span>            :                 /* Select either specified target or 5% of an interval */
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :                 cp-&gt;target = MAX(target, interval / 5);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :                 cp-&gt;interval = interval;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :                 /* The coefficient is scaled up by a 1000 */
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :                 mult = ((uint64_t)cp-&gt;interval * 1000) / codel_intervals[0];</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :                 /* Prepare table of intervals */
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :                 cp-&gt;intervals = mallocarray(nitems(codel_intervals),</span>
<span class="lineNum">     271 </span>            :                     sizeof(codel_intervals[0]), M_DEVBUF, M_WAITOK | M_ZERO);
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; nitems(codel_intervals); i++)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                         cp-&gt;intervals[i] = ((uint64_t)codel_intervals[i] *</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :                             mult) / 1000;</span>
<span class="lineNum">     275 </span>            :         } else {
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 cp-&gt;target = MAX(target, codel_target);</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                 cp-&gt;interval = codel_intervals[0];</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                 cp-&gt;intervals = (uint32_t *)codel_intervals;</span>
<span class="lineNum">     279 </span>            :         }
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         cp-&gt;quantum = quantum;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : }</span>
<a name="283"><span class="lineNum">     283 </span>            : </a>
<span class="lineNum">     284 </span>            : void
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : codel_freeparams(struct codel_params *cp)</span>
<span class="lineNum">     286 </span>            : {
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         if (cp-&gt;intervals != codel_intervals)</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 free(cp-&gt;intervals, M_DEVBUF, nitems(codel_intervals) *</span>
<span class="lineNum">     289 </span>            :                     sizeof(codel_intervals[0]));
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         cp-&gt;intervals = NULL;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 : }</span>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<span class="lineNum">     293 </span>            : static inline void
<span class="lineNum">     294 </span><span class="lineNoCov">          0 : codel_gettime(int64_t *now)</span>
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         struct timespec tv;</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         nanouptime(&amp;tv);</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         *now = tv.tv_sec * 1000000000LL + tv.tv_nsec;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 : }</span>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<span class="lineNum">     302 </span>            : static inline unsigned int
<span class="lineNum">     303 </span><span class="lineNoCov">          0 : codel_backlog(struct codel *cd)</span>
<span class="lineNum">     304 </span>            : {
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         return (cd-&gt;backlog);</span>
<span class="lineNum">     306 </span>            : }
<a name="307"><span class="lineNum">     307 </span>            : </a>
<span class="lineNum">     308 </span>            : static inline unsigned int
<span class="lineNum">     309 </span><span class="lineNoCov">          0 : codel_qlength(struct codel *cd)</span>
<span class="lineNum">     310 </span>            : {
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         return (ml_len(&amp;cd-&gt;q));</span>
<span class="lineNum">     312 </span>            : }
<a name="313"><span class="lineNum">     313 </span>            : </a>
<span class="lineNum">     314 </span>            : static inline int64_t
<span class="lineNum">     315 </span><span class="lineNoCov">          0 : codel_delay(struct codel *cd)</span>
<span class="lineNum">     316 </span>            : {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         return (cd-&gt;delay);</span>
<span class="lineNum">     318 </span>            : }
<a name="319"><span class="lineNum">     319 </span>            : </a>
<span class="lineNum">     320 </span>            : void
<span class="lineNum">     321 </span><span class="lineNoCov">          0 : codel_enqueue(struct codel *cd, int64_t now, struct mbuf *m)</span>
<span class="lineNum">     322 </span>            : {
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         m-&gt;m_pkthdr.ph_timestamp = now;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         ml_enqueue(&amp;cd-&gt;q, m);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         cd-&gt;backlog += m-&gt;m_pkthdr.len;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /*
<span class="lineNum">     330 </span>            :  * Select the next interval according to the number of drops
<span class="lineNum">     331 </span>            :  * in the current one relative to the provided timestamp.
<a name="332"><span class="lineNum">     332 </span>            :  */</a>
<span class="lineNum">     333 </span>            : static inline void
<span class="lineNum">     334 </span><span class="lineNoCov">          0 : control_law(struct codel *cd, struct codel_params *cp, int64_t rts)</span>
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span>            :         unsigned int idx;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         idx = min(cd-&gt;drops, nitems(codel_intervals) - 1);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         cd-&gt;next = rts + cp-&gt;intervals[idx];</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /*
<span class="lineNum">     343 </span>            :  * Pick the next enqueued packet and determine the queueing delay
<span class="lineNum">     344 </span>            :  * as well as whether or not it's a good candidate for dropping
<span class="lineNum">     345 </span>            :  * from the queue.
<span class="lineNum">     346 </span>            :  *
<span class="lineNum">     347 </span>            :  * The decision whether to drop the packet or not is made based
<span class="lineNum">     348 </span>            :  * on the queueing delay target of 5ms and on the current queue
<span class="lineNum">     349 </span>            :  * length in bytes which shouldn't be less than the amount of data
<span class="lineNum">     350 </span>            :  * that arrives in a typical interarrival time (MTU-sized packets
<span class="lineNum">     351 </span>            :  * arriving spaced by the amount of time it takes to send such a
<span class="lineNum">     352 </span>            :  * packet on the bottleneck).
<a name="353"><span class="lineNum">     353 </span>            :  */</a>
<span class="lineNum">     354 </span>            : static inline struct mbuf *
<span class="lineNum">     355 </span><span class="lineNoCov">          0 : codel_next_packet(struct codel *cd, struct codel_params *cp, int64_t now,</span>
<span class="lineNum">     356 </span>            :     int *drop)
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span>            :         struct mbuf *m;
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         *drop = 0;</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         m = MBUF_LIST_FIRST(&amp;cd-&gt;q);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         if (m == NULL) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                 KASSERT(cd-&gt;backlog == 0);</span>
<span class="lineNum">     365 </span>            :                 /* Empty queue, reset interval */
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                 cd-&gt;start = 0;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                 return (NULL);</span>
<span class="lineNum">     368 </span>            :         }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         if (now - m-&gt;m_pkthdr.ph_timestamp &lt; cp-&gt;target ||</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :             cd-&gt;backlog &lt;= cp-&gt;quantum) {</span>
<span class="lineNum">     372 </span>            :                 /*
<span class="lineNum">     373 </span>            :                  * The minimum delay decreased below the target, reset
<span class="lineNum">     374 </span>            :                  * the current observation interval.
<span class="lineNum">     375 </span>            :                  */
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :                 cd-&gt;start = 0;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                 return (m);</span>
<span class="lineNum">     378 </span>            :         }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         if (cd-&gt;start == 0) {</span>
<span class="lineNum">     381 </span>            :                 /*
<span class="lineNum">     382 </span>            :                  * This is the first packet to be delayed for more than
<span class="lineNum">     383 </span>            :                  * the target, start the first observation interval after
<span class="lineNum">     384 </span>            :                  * a single RTT and see if the minimum delay goes below
<span class="lineNum">     385 </span>            :                  * the target within the interval, otherwise punish the
<span class="lineNum">     386 </span>            :                  * next packet.
<span class="lineNum">     387 </span>            :                  */
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :                 cd-&gt;start = now + cp-&gt;interval;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         } else if (now &gt; cd-&gt;start) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 *drop = 1;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         return (m);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : enum { INITIAL, ACCEPTING, FIRSTDROP, DROPPING, CONTROL, RECOVERY };
<a name="396"><span class="lineNum">     396 </span>            : </a>
<span class="lineNum">     397 </span>            : static inline int
<span class="lineNum">     398 </span><span class="lineNoCov">          0 : codel_state_change(struct codel *cd, int64_t now, struct mbuf *m, int drop,</span>
<span class="lineNum">     399 </span>            :     int state)
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         if (state == FIRSTDROP)</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                 return (ACCEPTING);</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         if (cd-&gt;dropping) {</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                 if (!drop)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                         return (RECOVERY);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                 else if (now &gt;= cd-&gt;next)</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                         return (state == DROPPING ? CONTROL : DROPPING);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         } else if (drop)</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                 return (FIRSTDROP);</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         if (m == NULL)</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :                 return (RECOVERY);</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         return (ACCEPTING);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : }</span>
<a name="417"><span class="lineNum">     417 </span>            : </a>
<span class="lineNum">     418 </span>            : struct mbuf *
<span class="lineNum">     419 </span><span class="lineNoCov">          0 : codel_dequeue(struct codel *cd, struct codel_params *cp, int64_t now,</span>
<span class="lineNum">     420 </span>            :     struct mbuf_list *free_ml, uint64_t *dpkts, uint64_t *dbytes)
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :         struct mbuf *m;
<span class="lineNum">     423 </span>            :         unsigned short delta;
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         int drop, state, done = 0;</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :         state = INITIAL;
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         while (!done) {</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                 m = codel_next_packet(cd, cp, now, &amp;drop);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                 state = codel_state_change(cd, now, m, drop, state);</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                 switch (state) {</span>
<span class="lineNum">     433 </span>            :                 case FIRSTDROP:
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                         m = codel_commit(cd, m);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                         ml_enqueue(free_ml, m);</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                         *dpkts += 1;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                         *dbytes += m-&gt;m_pkthdr.len;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                         cd-&gt;dropping = 1;</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :                         /*
<span class="lineNum">     443 </span>            :                          * If we're still within the grace period and not
<span class="lineNum">     444 </span>            :                          * meeting our minimal delay target we treat this
<span class="lineNum">     445 </span>            :                          * as a continuation of the previous observation
<span class="lineNum">     446 </span>            :                          * interval and shrink it further.  Otherwise we
<span class="lineNum">     447 </span>            :                          * start from the initial one.
<span class="lineNum">     448 </span>            :                          */
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                         delta = cd-&gt;drops - cd-&gt;ldrops;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                         if (delta &gt; 1) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                                 if (now &lt; cd-&gt;next ||</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                                     now - cd-&gt;next &lt; codel_grace)</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                                         cd-&gt;drops = delta;</span>
<span class="lineNum">     454 </span>            :                                 else
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                                         cd-&gt;drops = 1;</span>
<span class="lineNum">     456 </span>            :                         } else
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                                 cd-&gt;drops = 1;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                         control_law(cd, cp, now);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                         cd-&gt;ldrops = cd-&gt;drops;</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :                         /* fetches the next packet and goes to ACCEPTING */
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     463 </span>            :                 case DROPPING:
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                         m = codel_commit(cd, m);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                         ml_enqueue(free_ml, m);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                         cd-&gt;drops++;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                         *dpkts += 1;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                         *dbytes += m-&gt;m_pkthdr.len;</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :                         /* fetches the next packet and goes to CONTROL */
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     473 </span>            :                 case CONTROL:
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         if (drop) {</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                                 control_law(cd, cp, cd-&gt;next);</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     477 </span>            :                         }
<span class="lineNum">     478 </span>            :                         /* FALLTHROUGH */
<span class="lineNum">     479 </span>            :                 case RECOVERY:
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                         cd-&gt;dropping = 0;</span>
<span class="lineNum">     481 </span>            :                         /* FALLTHROUGH */
<span class="lineNum">     482 </span>            :                 case ACCEPTING:
<span class="lineNum">     483 </span>            :                         done = 1;
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     485 </span>            :                 }
<span class="lineNum">     486 </span>            :         }
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         if (m != NULL)</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                 cd-&gt;delay = now - m-&gt;m_pkthdr.ph_timestamp;</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         return (m);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : }</span>
<a name="493"><span class="lineNum">     493 </span>            : </a>
<span class="lineNum">     494 </span>            : struct mbuf *
<span class="lineNum">     495 </span><span class="lineNoCov">          0 : codel_commit(struct codel *cd, struct mbuf *m)</span>
<span class="lineNum">     496 </span>            : {
<span class="lineNum">     497 </span>            :         struct mbuf *n;
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         n = ml_dequeue(&amp;cd-&gt;q);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         if (m)</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                 KASSERT(n == m);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         KASSERT(n != NULL);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         KASSERT(cd-&gt;backlog &gt;= n-&gt;m_pkthdr.len);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         cd-&gt;backlog -= n-&gt;m_pkthdr.len;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         return (n);</span>
<span class="lineNum">     506 </span>            : }
<a name="507"><span class="lineNum">     507 </span>            : </a>
<span class="lineNum">     508 </span>            : void
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : codel_purge(struct codel *cd, struct mbuf_list *ml)</span>
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         ml_enlist(ml, &amp;cd-&gt;q);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         cd-&gt;backlog = 0;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            : /*
<span class="lineNum">     516 </span>            :  * FQ-CoDel implementation
<span class="lineNum">     517 </span>            :  */
<a name="518"><span class="lineNum">     518 </span>            : </a>
<span class="lineNum">     519 </span>            : static inline struct flow *
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : classify_flow(struct fqcodel *fqc, struct mbuf *m)</span>
<span class="lineNum">     521 </span>            : {
<span class="lineNum">     522 </span>            :         unsigned int index;
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         if (m-&gt;m_pkthdr.ph_flowid &amp; M_FLOWID_VALID)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                 index = (m-&gt;m_pkthdr.ph_flowid &amp; M_FLOWID_MASK) % fqc-&gt;nflows;</span>
<span class="lineNum">     526 </span>            :         else
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                 index = arc4random_uniform(fqc-&gt;nflows);</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :         DPRINTF(&quot;%s: %u\n&quot;, __func__, index);
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         return (&amp;fqc-&gt;flows[index]);</span>
<span class="lineNum">     532 </span>            : }
<a name="533"><span class="lineNum">     533 </span>            : </a>
<span class="lineNum">     534 </span>            : struct mbuf *
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : fqcodel_enq(struct fqcodel *fqc, struct mbuf *m)</span>
<span class="lineNum">     536 </span>            : {
<span class="lineNum">     537 </span>            :         struct flow *flow;
<span class="lineNum">     538 </span>            :         unsigned int backlog = 0;
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         int64_t now;</span>
<span class="lineNum">     540 </span>            :         int i;
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         flow = classify_flow(fqc, m);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         if (flow == NULL)</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                 return (m);</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         codel_gettime(&amp;now);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         codel_enqueue(&amp;flow-&gt;cd, now, m);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         fqc-&gt;qlength++;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         if (!flow-&gt;active) {</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                 SIMPLEQ_INSERT_TAIL(&amp;fqc-&gt;newq, flow, flowentry);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                 flow-&gt;deficit = fqc-&gt;quantum;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :                 flow-&gt;active = 1;</span>
<span class="lineNum">     554 </span>            :                 DPRINTF(&quot;%s: flow %u active deficit %d\n&quot;, __func__,
<span class="lineNum">     555 </span>            :                     flow-&gt;id, flow-&gt;deficit);
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :         /*
<span class="lineNum">     559 </span>            :          * Check the limit for all queues and remove a packet
<span class="lineNum">     560 </span>            :          * from the longest one.
<span class="lineNum">     561 </span>            :          */
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         if (fqc-&gt;qlength &gt;= fqcodel_qlimit) {</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; fqc-&gt;nflows; i++) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :                         if (codel_backlog(&amp;fqc-&gt;flows[i].cd) &gt; backlog) {</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :                                 flow = &amp;fqc-&gt;flows[i];</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                                 backlog = codel_backlog(&amp;flow-&gt;cd);</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">     568 </span>            :                 }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                 KASSERT(flow != NULL);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :                 m = codel_commit(&amp;flow-&gt;cd, NULL);</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 fqc-&gt;drop_cnt.packets++;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                 fqc-&gt;drop_cnt.bytes += m-&gt;m_pkthdr.len;</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :                 fqc-&gt;qlength--;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :                 DPRINTF(&quot;%s: dropping from flow %u\n&quot;, __func__,
<span class="lineNum">     579 </span>            :                     flow-&gt;id);
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :                 return (m);</span>
<span class="lineNum">     581 </span>            :         }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         return (NULL);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 : }</span>
<a name="585"><span class="lineNum">     585 </span>            : </a>
<span class="lineNum">     586 </span>            : static inline struct flowq *
<span class="lineNum">     587 </span><span class="lineNoCov">          0 : select_queue(struct fqcodel *fqc)</span>
<span class="lineNum">     588 </span>            : {
<span class="lineNum">     589 </span>            :         struct flowq *fq = NULL;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :         if (!SIMPLEQ_EMPTY(&amp;fqc-&gt;newq))</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 fq = &amp;fqc-&gt;newq;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :         else if (!SIMPLEQ_EMPTY(&amp;fqc-&gt;oldq))</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :                 fq = &amp;fqc-&gt;oldq;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         return (fq);</span>
<span class="lineNum">     596 </span>            : }
<a name="597"><span class="lineNum">     597 </span>            : </a>
<span class="lineNum">     598 </span>            : static inline struct flow *
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : first_flow(struct fqcodel *fqc, struct flowq **fq)</span>
<span class="lineNum">     600 </span>            : {
<span class="lineNum">     601 </span>            :         struct flow *flow;
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         while ((*fq = select_queue(fqc)) != NULL) {</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 while ((flow = SIMPLEQ_FIRST(*fq)) != NULL) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                         if (flow-&gt;deficit &lt;= 0) {</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                                 flow-&gt;deficit += fqc-&gt;quantum;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                                 SIMPLEQ_REMOVE_HEAD(*fq, flowentry);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                                 SIMPLEQ_INSERT_TAIL(&amp;fqc-&gt;oldq, flow,</span>
<span class="lineNum">     609 </span>            :                                     flowentry);
<span class="lineNum">     610 </span>            :                                 DPRINTF(&quot;%s: flow %u deficit %d\n&quot;, __func__,
<span class="lineNum">     611 </span>            :                                     flow-&gt;id, flow-&gt;deficit);
<span class="lineNum">     612 </span>            :                         } else
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                                 return (flow);</span>
<span class="lineNum">     614 </span>            :                 }
<span class="lineNum">     615 </span>            :         }
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         return (NULL);</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 : }</span>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<span class="lineNum">     620 </span>            : static inline struct flow *
<span class="lineNum">     621 </span><span class="lineNoCov">          0 : next_flow(struct fqcodel *fqc, struct flow *flow, struct flowq **fq)</span>
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :         SIMPLEQ_REMOVE_HEAD(*fq, flowentry);</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         if (*fq == &amp;fqc-&gt;newq &amp;&amp; !SIMPLEQ_EMPTY(&amp;fqc-&gt;oldq)) {</span>
<span class="lineNum">     626 </span>            :                 /* A packet was dropped, starve the queue */
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :                 SIMPLEQ_INSERT_TAIL(&amp;fqc-&gt;oldq, flow, flowentry);</span>
<span class="lineNum">     628 </span>            :                 DPRINTF(&quot;%s: flow %u -&gt;oldq deficit %d\n&quot;, __func__,
<span class="lineNum">     629 </span>            :                     flow-&gt;id, flow-&gt;deficit);
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     631 </span>            :                 /* A packet was dropped on a starved queue, disable it */
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :                 flow-&gt;active = 0;</span>
<span class="lineNum">     633 </span>            :                 DPRINTF(&quot;%s: flow %u inactive deficit %d\n&quot;, __func__,
<span class="lineNum">     634 </span>            :                     flow-&gt;id, flow-&gt;deficit);
<span class="lineNum">     635 </span>            :         }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         return (first_flow(fqc, fq));</span>
<span class="lineNum">     638 </span>            : }
<a name="639"><span class="lineNum">     639 </span>            : </a>
<span class="lineNum">     640 </span>            : struct mbuf *
<span class="lineNum">     641 </span><span class="lineNoCov">          0 : fqcodel_deq_begin(struct fqcodel *fqc, void **cookiep,</span>
<span class="lineNum">     642 </span>            :     struct mbuf_list *free_ml)
<span class="lineNum">     643 </span>            : {
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         struct mbuf_list ml = MBUF_LIST_INITIALIZER();</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         struct flowq *fq;</span>
<span class="lineNum">     646 </span>            :         struct flow *flow;
<span class="lineNum">     647 </span>            :         struct mbuf *m;
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         int64_t now;</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         if ((fqc-&gt;flags &amp; FQCF_FIXED_QUANTUM) == 0)</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                 fqc-&gt;quantum = fqc-&gt;ifp-&gt;if_mtu + max_linkhdr;</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         codel_gettime(&amp;now);</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         for (flow = first_flow(fqc, &amp;fq); flow != NULL;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :              flow = next_flow(fqc, flow, &amp;fq)) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                 m = codel_dequeue(&amp;flow-&gt;cd, &amp;fqc-&gt;cparams, now, &amp;ml,</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                     &amp;fqc-&gt;drop_cnt.packets, &amp;fqc-&gt;drop_cnt.bytes);</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                 KASSERT(fqc-&gt;qlength &gt;= ml_len(&amp;ml));</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :                 fqc-&gt;qlength -= ml_len(&amp;ml);</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 ml_enlist(free_ml, &amp;ml);</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 if (m != NULL) {</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                         flow-&gt;deficit -= m-&gt;m_pkthdr.len;</span>
<span class="lineNum">     667 </span>            :                         DPRINTF(&quot;%s: flow %u deficit %d\n&quot;, __func__,
<span class="lineNum">     668 </span>            :                             flow-&gt;id, flow-&gt;deficit);
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                         *cookiep = flow;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                         return (m);</span>
<span class="lineNum">     671 </span>            :                 }
<span class="lineNum">     672 </span>            :         }
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :         return (NULL);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 : }</span>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<span class="lineNum">     677 </span>            : void
<span class="lineNum">     678 </span><span class="lineNoCov">          0 : fqcodel_deq_commit(struct fqcodel *fqc, struct mbuf *m, void *cookie)</span>
<span class="lineNum">     679 </span>            : {
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         struct flow *flow = cookie;</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         KASSERT(fqc-&gt;qlength &gt; 0);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         fqc-&gt;qlength--;</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         fqc-&gt;xmit_cnt.packets++;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         fqc-&gt;xmit_cnt.bytes += m-&gt;m_pkthdr.len;</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         (void)codel_commit(&amp;flow-&gt;cd, m);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : }</span>
<a name="690"><span class="lineNum">     690 </span>            : </a>
<span class="lineNum">     691 </span>            : void
<span class="lineNum">     692 </span><span class="lineNoCov">          0 : fqcodel_purge(struct fqcodel *fqc, struct mbuf_list *ml)</span>
<span class="lineNum">     693 </span>            : {
<span class="lineNum">     694 </span>            :         unsigned int i;
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; fqc-&gt;nflows; i++)</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                 codel_purge(&amp;fqc-&gt;flows[i].cd, ml);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         fqc-&gt;qlength = 0;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 : }</span>
<a name="700"><span class="lineNum">     700 </span>            : </a>
<span class="lineNum">     701 </span>            : struct mbuf *
<span class="lineNum">     702 </span><span class="lineNoCov">          0 : fqcodel_if_enq(struct ifqueue *ifq, struct mbuf *m)</span>
<span class="lineNum">     703 </span>            : {
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :         return fqcodel_enq(ifq-&gt;ifq_q, m);</span>
<span class="lineNum">     705 </span>            : }
<a name="706"><span class="lineNum">     706 </span>            : </a>
<span class="lineNum">     707 </span>            : struct mbuf *
<span class="lineNum">     708 </span><span class="lineNoCov">          0 : fqcodel_if_deq_begin(struct ifqueue *ifq, void **cookiep)</span>
<span class="lineNum">     709 </span>            : {
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         struct mbuf_list free_ml = MBUF_LIST_INITIALIZER();</span>
<span class="lineNum">     711 </span>            :         struct mbuf *m;
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         m = fqcodel_deq_begin(ifq-&gt;ifq_q, cookiep, &amp;free_ml);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         ifq_mfreeml(ifq, &amp;free_ml);</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         return (m);</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 : }</span>
<a name="717"><span class="lineNum">     717 </span>            : </a>
<span class="lineNum">     718 </span>            : void
<span class="lineNum">     719 </span><span class="lineNoCov">          0 : fqcodel_if_deq_commit(struct ifqueue *ifq, struct mbuf *m, void *cookie)</span>
<span class="lineNum">     720 </span>            : {
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :         return fqcodel_deq_commit(ifq-&gt;ifq_q, m, cookie);</span>
<span class="lineNum">     722 </span>            : }
<a name="723"><span class="lineNum">     723 </span>            : </a>
<span class="lineNum">     724 </span>            : void
<span class="lineNum">     725 </span><span class="lineNoCov">          0 : fqcodel_if_purge(struct ifqueue *ifq, struct mbuf_list *ml)</span>
<span class="lineNum">     726 </span>            : {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         return fqcodel_purge(ifq-&gt;ifq_q, ml);</span>
<span class="lineNum">     728 </span>            : }
<a name="729"><span class="lineNum">     729 </span>            : </a>
<span class="lineNum">     730 </span>            : void *
<span class="lineNum">     731 </span><span class="lineNoCov">          0 : fqcodel_pf_alloc(struct ifnet *ifp)</span>
<span class="lineNum">     732 </span>            : {
<span class="lineNum">     733 </span>            :         struct fqcodel *fqc;
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :         fqc = malloc(sizeof(struct fqcodel), M_DEVBUF, M_WAITOK | M_ZERO);</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         SIMPLEQ_INIT(&amp;fqc-&gt;newq);</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         SIMPLEQ_INIT(&amp;fqc-&gt;oldq);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         return (fqc);</span>
<span class="lineNum">     741 </span>            : }
<a name="742"><span class="lineNum">     742 </span>            : </a>
<span class="lineNum">     743 </span>            : int
<span class="lineNum">     744 </span><span class="lineNoCov">          0 : fqcodel_pf_addqueue(void *arg, struct pf_queuespec *qs)</span>
<span class="lineNum">     745 </span>            : {
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         struct ifnet *ifp = qs-&gt;kif-&gt;pfik_ifp;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         struct fqcodel *fqc = arg;</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         if (qs-&gt;flowqueue.flows == 0 || qs-&gt;flowqueue.flows &gt; M_FLOWID_MASK)</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :                 return (EINVAL);</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         fqc-&gt;nflows = qs-&gt;flowqueue.flows;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         fqc-&gt;quantum = qs-&gt;flowqueue.quantum;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         if (qs-&gt;qlimit &gt; 0)</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :                 fqc-&gt;qlimit = qs-&gt;qlimit;</span>
<span class="lineNum">     756 </span>            :         else
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :                 fqc-&gt;qlimit = fqcodel_qlimit;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         if (fqc-&gt;quantum &gt; 0)</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                 fqc-&gt;flags |= FQCF_FIXED_QUANTUM;</span>
<span class="lineNum">     760 </span>            :         else
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :                 fqc-&gt;quantum = ifp-&gt;if_mtu + max_linkhdr;</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         codel_initparams(&amp;fqc-&gt;cparams, qs-&gt;flowqueue.target,</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :             qs-&gt;flowqueue.interval, fqc-&gt;quantum);</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :         fqc-&gt;flows = mallocarray(fqc-&gt;nflows, sizeof(struct flow),</span>
<span class="lineNum">     767 </span>            :             M_DEVBUF, M_WAITOK | M_ZERO);
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : #ifdef FQCODEL_DEBUG
<span class="lineNum">     770 </span>            :         {
<span class="lineNum">     771 </span>            :                 unsigned int i;
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :                 for (i = 0; i &lt; fqc-&gt;nflows; i++)
<span class="lineNum">     774 </span>            :                         fqc-&gt;flows[i].id = i;
<span class="lineNum">     775 </span>            :         }
<span class="lineNum">     776 </span>            : #endif
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         fqc-&gt;ifp = ifp;</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :         DPRINTF(&quot;fq-codel on %s: %d queues %d deep, quantum %d target %llums &quot;
<span class="lineNum">     781 </span>            :             &quot;interval %llums\n&quot;, ifp-&gt;if_xname, fqc-&gt;nflows, fqc-&gt;qlimit,
<span class="lineNum">     782 </span>            :             fqc-&gt;quantum, fqc-&gt;cparams.target / 1000000,
<span class="lineNum">     783 </span>            :             fqc-&gt;cparams.interval / 1000000);
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 : }</span>
<a name="787"><span class="lineNum">     787 </span>            : </a>
<span class="lineNum">     788 </span>            : void
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : fqcodel_pf_free(void *arg)</span>
<span class="lineNum">     790 </span>            : {
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         struct fqcodel *fqc = arg;</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         codel_freeparams(&amp;fqc-&gt;cparams);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         free(fqc-&gt;flows, M_DEVBUF, fqc-&gt;nflows * sizeof(struct flow));</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         free(fqc, M_DEVBUF, sizeof(struct fqcodel));</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : }</span>
<a name="797"><span class="lineNum">     797 </span>            : </a>
<span class="lineNum">     798 </span>            : int
<span class="lineNum">     799 </span><span class="lineNoCov">          0 : fqcodel_pf_qstats(struct pf_queuespec *qs, void *ubuf, int *nbytes)</span>
<span class="lineNum">     800 </span>            : {
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         struct ifnet *ifp = qs-&gt;kif-&gt;pfik_ifp;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         struct fqcodel_stats stats;</span>
<span class="lineNum">     803 </span>            :         struct fqcodel *fqc;
<span class="lineNum">     804 </span>            :         int64_t delay;
<span class="lineNum">     805 </span>            :         unsigned int i;
<span class="lineNum">     806 </span>            :         int error = 0;
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         if (ifp == NULL)</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                 return (EBADF);</span>
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :         if (*nbytes &lt; sizeof(stats))</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :                 return (EINVAL);</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         memset(&amp;stats, 0, sizeof(stats));</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :         /* XXX: multi-q? */
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         fqc = ifq_q_enter(&amp;ifp-&gt;if_snd, ifq_fqcodel_ops);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         if (fqc == NULL)</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :                 return (EBADF);</span>
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         stats.xmit_cnt = fqc-&gt;xmit_cnt;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         stats.drop_cnt = fqc-&gt;drop_cnt;</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         stats.qlength = ifq_len(&amp;ifp-&gt;if_snd);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         stats.qlimit = fqc-&gt;qlimit;</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :         stats.flows = 0;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         stats.delaysum = stats.delaysumsq = 0;</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; fqc-&gt;nflows; i++) {</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :                 if (codel_qlength(&amp;fqc-&gt;flows[i].cd) == 0)</span>
<span class="lineNum">     832 </span>            :                         continue;
<span class="lineNum">     833 </span>            :                 /* Scale down to microseconds to avoid overflows */
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                 delay = codel_delay(&amp;fqc-&gt;flows[i].cd) / 1000;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                 stats.delaysum += delay;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :                 stats.delaysumsq += delay * delay;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                 stats.flows++;</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :         ifq_q_leave(&amp;ifp-&gt;if_snd, fqc);</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :         if ((error = copyout((caddr_t)&amp;stats, ubuf, sizeof(stats))) != 0)</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :         *nbytes = sizeof(stats);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 : }</span>
<a name="848"><span class="lineNum">     848 </span>            : </a>
<span class="lineNum">     849 </span>            : unsigned int
<span class="lineNum">     850 </span><span class="lineNoCov">          0 : fqcodel_pf_qlength(void *fqc)</span>
<span class="lineNum">     851 </span>            : {
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :         return ((struct fqcodel *)fqc)-&gt;qlength;</span>
<span class="lineNum">     853 </span>            : }
<a name="854"><span class="lineNum">     854 </span>            : </a>
<span class="lineNum">     855 </span>            : struct mbuf *
<span class="lineNum">     856 </span><span class="lineNoCov">          0 : fqcodel_pf_enqueue(void *fqc, struct mbuf *m)</span>
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :         return fqcodel_enq(fqc, m);</span>
<span class="lineNum">     859 </span>            : }
<a name="860"><span class="lineNum">     860 </span>            : </a>
<span class="lineNum">     861 </span>            : struct mbuf *
<span class="lineNum">     862 </span><span class="lineNoCov">          0 : fqcodel_pf_deq_begin(void *fqc, void **cookiep, struct mbuf_list *free_ml)</span>
<span class="lineNum">     863 </span>            : {
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         return fqcodel_deq_begin(fqc, cookiep, free_ml);</span>
<span class="lineNum">     865 </span>            : }
<a name="866"><span class="lineNum">     866 </span>            : </a>
<span class="lineNum">     867 </span>            : void
<span class="lineNum">     868 </span><span class="lineNoCov">          0 : fqcodel_pf_deq_commit(void *fqc, struct mbuf *m, void *cookie)</span>
<span class="lineNum">     869 </span>            : {
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :         return fqcodel_deq_commit(fqc, m, cookie);</span>
<span class="lineNum">     871 </span>            : }
<a name="872"><span class="lineNum">     872 </span>            : </a>
<span class="lineNum">     873 </span>            : void
<span class="lineNum">     874 </span><span class="lineNoCov">          0 : fqcodel_pf_purge(void *fqc, struct mbuf_list *ml)</span>
<span class="lineNum">     875 </span>            : {
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         return fqcodel_purge(fqc, ml);</span>
<span class="lineNum">     877 </span>            : }
<a name="878"><span class="lineNum">     878 </span>            : </a>
<span class="lineNum">     879 </span>            : unsigned int
<span class="lineNum">     880 </span><span class="lineNoCov">          0 : fqcodel_idx(unsigned int nqueues, const struct mbuf *m)</span>
<span class="lineNum">     881 </span>            : {
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     883 </span>            : }
<a name="884"><span class="lineNum">     884 </span>            : </a>
<span class="lineNum">     885 </span>            : void *
<span class="lineNum">     886 </span><span class="lineNoCov">          0 : fqcodel_alloc(unsigned int idx, void *arg)</span>
<span class="lineNum">     887 </span>            : {
<span class="lineNum">     888 </span>            :         /* Allocation is done in fqcodel_pf_alloc */
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         return (arg);</span>
<span class="lineNum">     890 </span>            : }
<a name="891"><span class="lineNum">     891 </span>            : </a>
<span class="lineNum">     892 </span>            : void
<span class="lineNum">     893 </span><span class="lineNoCov">          0 : fqcodel_free(unsigned int idx, void *arg)</span>
<span class="lineNum">     894 </span>            : {
<span class="lineNum">     895 </span>            :         /* nothing to do here */
<span class="lineNum">     896 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
