<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - net/ifq.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">net</a> - ifq.h<span style="font-size: 80%;"> (source / <a href="ifq.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: ifq.h,v 1.20 2018/01/04 11:02:57 tb Exp $ */</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            :  * Copyright (c) 2015 David Gwynne &lt;dlg@openbsd.org&gt;
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Permission to use, copy, modify, and distribute this software for any
<span class="lineNum">       7 </span>            :  * purpose with or without fee is hereby granted, provided that the above
<span class="lineNum">       8 </span>            :  * copyright notice and this permission notice appear in all copies.
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<span class="lineNum">      11 </span>            :  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<span class="lineNum">      12 </span>            :  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<span class="lineNum">      13 </span>            :  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<span class="lineNum">      14 </span>            :  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<span class="lineNum">      15 </span>            :  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="lineNum">      16 </span>            :  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #ifndef _NET_IFQ_H_
<span class="lineNum">      20 </span>            : #define _NET_IFQ_H_
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : struct ifnet;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : struct ifq_ops;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : struct ifqueue {
<span class="lineNum">      27 </span>            :         struct ifnet            *ifq_if;
<span class="lineNum">      28 </span>            :         union {
<span class="lineNum">      29 </span>            :                 void                    *_ifq_softc;
<span class="lineNum">      30 </span>            :                 /*
<span class="lineNum">      31 </span>            :                  * a rings sndq is found by looking up an array of pointers.
<span class="lineNum">      32 </span>            :                  * by default we only have one sndq and the default drivers
<span class="lineNum">      33 </span>            :                  * dont use ifq_softc, so we can borrow it for the map until
<span class="lineNum">      34 </span>            :                  * we need to allocate a proper map.
<span class="lineNum">      35 </span>            :                  */
<span class="lineNum">      36 </span>            :                 struct ifqueue          *_ifq_ifqs[1];
<span class="lineNum">      37 </span>            :         } _ifq_ptr;
<span class="lineNum">      38 </span>            : #define ifq_softc                _ifq_ptr._ifq_softc
<span class="lineNum">      39 </span>            : #define ifq_ifqs                 _ifq_ptr._ifq_ifqs
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :         /* mbuf handling */
<span class="lineNum">      42 </span>            :         struct mutex             ifq_mtx;
<span class="lineNum">      43 </span>            :         const struct ifq_ops    *ifq_ops;
<span class="lineNum">      44 </span>            :         void                    *ifq_q;
<span class="lineNum">      45 </span>            :         struct mbuf_list         ifq_free;
<span class="lineNum">      46 </span>            :         unsigned int             ifq_len;
<span class="lineNum">      47 </span>            :         unsigned int             ifq_oactive;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :         /* statistics */
<span class="lineNum">      50 </span>            :         uint64_t                 ifq_packets;
<span class="lineNum">      51 </span>            :         uint64_t                 ifq_bytes;
<span class="lineNum">      52 </span>            :         uint64_t                 ifq_qdrops;
<span class="lineNum">      53 </span>            :         uint64_t                 ifq_errors;
<span class="lineNum">      54 </span>            :         uint64_t                 ifq_mcasts;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :         /* work serialisation */
<span class="lineNum">      57 </span>            :         struct mutex             ifq_task_mtx;
<span class="lineNum">      58 </span>            :         struct task_list         ifq_task_list;
<span class="lineNum">      59 </span>            :         void                    *ifq_serializer;
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :         /* work to be serialised */
<span class="lineNum">      62 </span>            :         struct task              ifq_start;
<span class="lineNum">      63 </span>            :         struct task              ifq_restart;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :         /* properties */
<span class="lineNum">      66 </span>            :         unsigned int             ifq_maxlen;
<span class="lineNum">      67 </span>            :         unsigned int             ifq_idx;
<span class="lineNum">      68 </span>            : };
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : struct ifiqueue {
<span class="lineNum">      71 </span>            :         struct ifnet            *ifiq_if;
<span class="lineNum">      72 </span>            :         struct taskq            *ifiq_softnet;
<span class="lineNum">      73 </span>            :         union {
<span class="lineNum">      74 </span>            :                 void                    *_ifiq_softc;
<span class="lineNum">      75 </span>            :                 struct ifiqueue         *_ifiq_ifiqs[1];
<span class="lineNum">      76 </span>            :         } _ifiq_ptr;
<span class="lineNum">      77 </span>            : #define ifiq_softc               _ifiq_ptr._ifiq_softc
<span class="lineNum">      78 </span>            : #define ifiq_ifiqs               _ifiq_ptr._ifiq_ifiqs
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :         struct mutex             ifiq_mtx;
<span class="lineNum">      81 </span>            :         struct mbuf_list         ifiq_ml;
<span class="lineNum">      82 </span>            :         struct task              ifiq_task;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :         /* counters */
<span class="lineNum">      85 </span>            :         uint64_t                 ifiq_packets;
<span class="lineNum">      86 </span>            :         uint64_t                 ifiq_bytes;
<span class="lineNum">      87 </span>            :         uint64_t                 ifiq_qdrops;
<span class="lineNum">      88 </span>            :         uint64_t                 ifiq_errors;
<span class="lineNum">      89 </span>            :         uint64_t                 ifiq_mcasts;
<span class="lineNum">      90 </span>            :         uint64_t                 ifiq_noproto;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :         /* properties */
<span class="lineNum">      93 </span>            :         unsigned int             ifiq_idx;
<span class="lineNum">      94 </span>            : };
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : #ifdef _KERNEL
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : #define IFQ_MAXLEN              256
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : /*
<span class="lineNum">     101 </span>            :  *
<span class="lineNum">     102 </span>            :  * Interface Send Queues
<span class="lineNum">     103 </span>            :  *
<span class="lineNum">     104 </span>            :  * struct ifqueue sits between the network stack and a drivers
<span class="lineNum">     105 </span>            :  * transmission of packets. The high level view is that when the stack
<span class="lineNum">     106 </span>            :  * has finished generating a packet it hands it to a driver for
<span class="lineNum">     107 </span>            :  * transmission. It does this by queueing the packet on an ifqueue and
<span class="lineNum">     108 </span>            :  * notifying the driver to start transmission of the queued packets.
<span class="lineNum">     109 </span>            :  *
<span class="lineNum">     110 </span>            :  * A network device may have multiple contexts for the transmission
<span class="lineNum">     111 </span>            :  * of packets, ie, independent transmit rings. An network device
<span class="lineNum">     112 </span>            :  * represented by a struct ifnet may have multiple ifqueue structures,
<span class="lineNum">     113 </span>            :  * each of which represents an independent context.
<span class="lineNum">     114 </span>            :  *
<span class="lineNum">     115 </span>            :  * struct ifqueue also provides the point where conditioning of
<span class="lineNum">     116 </span>            :  * traffic (ie, priq and hfsc) is implemented, and provides some
<span class="lineNum">     117 </span>            :  * infrastructure to assist in the implementation of network drivers.
<span class="lineNum">     118 </span>            :  *
<span class="lineNum">     119 </span>            :  * = ifq API
<span class="lineNum">     120 </span>            :  *
<span class="lineNum">     121 </span>            :  * The ifq API provides functions for three distinct consumers:
<span class="lineNum">     122 </span>            :  *
<span class="lineNum">     123 </span>            :  * 1. The network stack
<span class="lineNum">     124 </span>            :  * 2. Traffic QoS/conditioning implementations
<span class="lineNum">     125 </span>            :  * 3. Network drivers
<span class="lineNum">     126 </span>            :  *
<span class="lineNum">     127 </span>            :  * == Network Stack API
<span class="lineNum">     128 </span>            :  *
<span class="lineNum">     129 </span>            :  * The network stack is responsible for initialising and destroying
<span class="lineNum">     130 </span>            :  * the ifqueue structures, changing the traffic conditioner on an
<span class="lineNum">     131 </span>            :  * interface, enqueuing packets for transmission, and notifying
<span class="lineNum">     132 </span>            :  * the driver to start transmission of a particular ifqueue.
<span class="lineNum">     133 </span>            :  *
<span class="lineNum">     134 </span>            :  * === ifq_init()
<span class="lineNum">     135 </span>            :  *
<span class="lineNum">     136 </span>            :  * During if_attach(), the network stack calls ifq_init to initialise
<span class="lineNum">     137 </span>            :  * the ifqueue structure. By default it configures the priq traffic
<span class="lineNum">     138 </span>            :  * conditioner.
<span class="lineNum">     139 </span>            :  *
<span class="lineNum">     140 </span>            :  * === ifq_destroy()
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  * The network stack calls ifq_destroy() during if_detach to tear down
<span class="lineNum">     143 </span>            :  * the ifqueue structure. It frees the traffic conditioner state, and
<span class="lineNum">     144 </span>            :  * frees any mbufs that were left queued.
<span class="lineNum">     145 </span>            :  *
<span class="lineNum">     146 </span>            :  * === ifq_attach()
<span class="lineNum">     147 </span>            :  *
<span class="lineNum">     148 </span>            :  * ifq_attach() is used to replace the current traffic conditioner on
<span class="lineNum">     149 </span>            :  * the ifqueue. All the pending mbufs are removed from the previous
<span class="lineNum">     150 </span>            :  * conditioner and requeued on the new.
<span class="lineNum">     151 </span>            :  *
<span class="lineNum">     152 </span>            :  * === ifq_idx()
<span class="lineNum">     153 </span>            :  *
<span class="lineNum">     154 </span>            :  * ifq_idx() selects a specific ifqueue from the current ifnet
<span class="lineNum">     155 </span>            :  * structure for use in the transmission of the mbuf.
<span class="lineNum">     156 </span>            :  *
<span class="lineNum">     157 </span>            :  * === ifq_enqueue()
<span class="lineNum">     158 </span>            :  *
<span class="lineNum">     159 </span>            :  * ifq_enqueue() attempts to fit an mbuf onto the ifqueue. The
<span class="lineNum">     160 </span>            :  * current traffic conditioner may drop a packet to make space on the
<span class="lineNum">     161 </span>            :  * queue.
<span class="lineNum">     162 </span>            :  *
<span class="lineNum">     163 </span>            :  * === ifq_start()
<span class="lineNum">     164 </span>            :  *
<span class="lineNum">     165 </span>            :  * Once a packet has been successfully queued with ifq_enqueue(),
<span class="lineNum">     166 </span>            :  * the network card is notified with a call to ifq_start().
<span class="lineNum">     167 </span>            :  * Calls to ifq_start() run in the ifqueue serialisation context,
<span class="lineNum">     168 </span>            :  * guaranteeing that only one instance of ifp-&gt;if_qstart() will be
<span class="lineNum">     169 </span>            :  * running on behalf of a specific ifqueue in the system at any point
<span class="lineNum">     170 </span>            :  * in time.
<span class="lineNum">     171 </span>            :  *
<span class="lineNum">     172 </span>            :  * == Traffic conditioners API
<span class="lineNum">     173 </span>            :  *
<span class="lineNum">     174 </span>            :  * The majority of interaction between struct ifqueue and a traffic
<span class="lineNum">     175 </span>            :  * conditioner occurs via the callbacks a traffic conditioner provides
<span class="lineNum">     176 </span>            :  * in an instance of struct ifq_ops.
<span class="lineNum">     177 </span>            :  *
<span class="lineNum">     178 </span>            :  * XXX document ifqop_*
<span class="lineNum">     179 </span>            :  *
<span class="lineNum">     180 </span>            :  * The ifqueue API implements the locking on behalf of the conditioning
<span class="lineNum">     181 </span>            :  * implementations so conditioners only have to reject or keep mbufs.
<span class="lineNum">     182 </span>            :  * If something needs to inspect a conditioners internals, the queue lock
<span class="lineNum">     183 </span>            :  * needs to be taken to allow for a consistent or safe view. The queue
<span class="lineNum">     184 </span>            :  * lock may be taken and released with ifq_q_enter() and ifq_q_leave().
<span class="lineNum">     185 </span>            :  *
<span class="lineNum">     186 </span>            :  * === ifq_q_enter()
<span class="lineNum">     187 </span>            :  *
<span class="lineNum">     188 </span>            :  * Code wishing to access a conditioners internals may take the queue
<span class="lineNum">     189 </span>            :  * lock with ifq_q_enter(). The caller must pass a reference to the
<span class="lineNum">     190 </span>            :  * conditioners ifq_ops structure so the infrastructure can ensure the
<span class="lineNum">     191 </span>            :  * caller is able to understand the internals. ifq_q_enter() returns
<span class="lineNum">     192 </span>            :  * a pointer to the conditions internal structures, or NULL if the
<span class="lineNum">     193 </span>            :  * ifq_ops did not match the current conditioner.
<span class="lineNum">     194 </span>            :  *
<span class="lineNum">     195 </span>            :  * === ifq_q_leave()
<span class="lineNum">     196 </span>            :  *
<span class="lineNum">     197 </span>            :  * The queue lock acquired with ifq_q_enter() is released with
<span class="lineNum">     198 </span>            :  * ifq_q_leave().
<span class="lineNum">     199 </span>            :  *
<span class="lineNum">     200 </span>            :  * === ifq_mfreem() and ifq_mfreeml()
<span class="lineNum">     201 </span>            :  *
<span class="lineNum">     202 </span>            :  * A goal of the API is to avoid freeing an mbuf while mutexs are
<span class="lineNum">     203 </span>            :  * held. Because the ifq API manages the lock on behalf of the backend
<span class="lineNum">     204 </span>            :  * ifqops, the backend should not directly free mbufs. If a conditioner
<span class="lineNum">     205 </span>            :  * backend needs to drop a packet during the handling of ifqop_deq_begin,
<span class="lineNum">     206 </span>            :  * it may free it by calling ifq_mfreem(). This accounts for the drop,
<span class="lineNum">     207 </span>            :  * and schedules the free of the mbuf outside the hold of ifq_mtx.
<span class="lineNum">     208 </span>            :  * ifq_mfreeml() takes an mbuf list as an argument instead.
<span class="lineNum">     209 </span>            :  *
<span class="lineNum">     210 </span>            :  *
<span class="lineNum">     211 </span>            :  * == Network Driver API
<span class="lineNum">     212 </span>            :  *
<span class="lineNum">     213 </span>            :  * The API used by network drivers is mostly documented in the
<span class="lineNum">     214 </span>            :  * ifq_dequeue(9) manpage except for ifq_serialize(),
<span class="lineNum">     215 </span>            :  * ifq_is_serialized(), and IFQ_ASSERT_SERIALIZED().
<span class="lineNum">     216 </span>            :  *
<span class="lineNum">     217 </span>            :  * === ifq_serialize()
<span class="lineNum">     218 </span>            :  *
<span class="lineNum">     219 </span>            :  * A driver may run arbitrary work in the ifqueue serialiser context
<span class="lineNum">     220 </span>            :  * via ifq_serialize(). The work to be done is represented by a task
<span class="lineNum">     221 </span>            :  * that has been prepared with task_set.
<span class="lineNum">     222 </span>            :  *
<span class="lineNum">     223 </span>            :  * The work will be run in series with any other work dispatched by
<span class="lineNum">     224 </span>            :  * ifq_start(), ifq_restart(), or other ifq_serialize() calls.
<span class="lineNum">     225 </span>            :  *
<span class="lineNum">     226 </span>            :  * Because the work may be run on another CPU, the lifetime of the
<span class="lineNum">     227 </span>            :  * task and the work it represents can extend beyond the end of the
<span class="lineNum">     228 </span>            :  * call to ifq_serialize() that dispatched it.
<span class="lineNum">     229 </span>            :  *
<span class="lineNum">     230 </span>            :  * === ifq_is_serialized()
<span class="lineNum">     231 </span>            :  *
<span class="lineNum">     232 </span>            :  * This function returns whether the caller is currently within the
<span class="lineNum">     233 </span>            :  * ifqueue serializer context.
<span class="lineNum">     234 </span>            :  *
<span class="lineNum">     235 </span>            :  * === IFQ_ASSERT_SERIALIZED()
<span class="lineNum">     236 </span>            :  *
<span class="lineNum">     237 </span>            :  * This macro will assert that the caller is currently within the
<span class="lineNum">     238 </span>            :  * specified ifqueue serialiser context.
<span class="lineNum">     239 </span>            :  *
<span class="lineNum">     240 </span>            :  *
<span class="lineNum">     241 </span>            :  * = ifqueue work serialisation
<span class="lineNum">     242 </span>            :  *
<span class="lineNum">     243 </span>            :  * ifqueues provide a mechanism to dispatch work to be run in a single
<span class="lineNum">     244 </span>            :  * context. Work in this mechanism is represtented by task structures.
<span class="lineNum">     245 </span>            :  *
<span class="lineNum">     246 </span>            :  * The tasks are run in a context similar to a taskq serviced by a
<span class="lineNum">     247 </span>            :  * single kernel thread, except the work is run immediately by the
<span class="lineNum">     248 </span>            :  * first CPU that dispatches work. If a second CPU attempts to dispatch
<span class="lineNum">     249 </span>            :  * additional tasks while the first is still running, it will be queued
<span class="lineNum">     250 </span>            :  * to be run by the first CPU. The second CPU will return immediately.
<span class="lineNum">     251 </span>            :  *
<span class="lineNum">     252 </span>            :  * = MP Safe Network Drivers
<span class="lineNum">     253 </span>            :  *
<span class="lineNum">     254 </span>            :  * An MP safe network driver is one in which its start routine can be
<span class="lineNum">     255 </span>            :  * called by the network stack without holding the big kernel lock.
<span class="lineNum">     256 </span>            :  *
<span class="lineNum">     257 </span>            :  * == Attach
<span class="lineNum">     258 </span>            :  *
<span class="lineNum">     259 </span>            :  * A driver advertises it's ability to run its start routine without
<span class="lineNum">     260 </span>            :  * the kernel lock by setting the IFXF_MPSAFE flag in ifp-&gt;if_xflags
<span class="lineNum">     261 </span>            :  * before calling if_attach(). Advertising an MPSAFE start routine
<span class="lineNum">     262 </span>            :  * also implies that the driver understands that a network card can
<span class="lineNum">     263 </span>            :  * have multiple rings or transmit queues, and therefore provides
<span class="lineNum">     264 </span>            :  * if_qstart function (which takes an ifqueue pointer) instead of an
<span class="lineNum">     265 </span>            :  * if_start function (which takes an ifnet pointer).
<span class="lineNum">     266 </span>            :  *
<span class="lineNum">     267 </span>            :  *      void    drv_start(struct ifqueue *);
<span class="lineNum">     268 </span>            :  *
<span class="lineNum">     269 </span>            :  *      void
<span class="lineNum">     270 </span>            :  *      drv_attach()
<span class="lineNum">     271 </span>            :  *      {
<span class="lineNum">     272 </span>            :  *      ...
<span class="lineNum">     273 </span>            :  *              ifp-&gt;if_xflags = IFXF_MPSAFE;
<span class="lineNum">     274 </span>            :  *              ifp-&gt;if_qstart = drv_start;
<span class="lineNum">     275 </span>            :  *              if_attach(ifp);
<span class="lineNum">     276 </span>            :  *      }
<span class="lineNum">     277 </span>            :  *
<span class="lineNum">     278 </span>            :  * The network stack will then call ifp-&gt;if_qstart via ifq_start()
<span class="lineNum">     279 </span>            :  * to guarantee there is only one instance of that function running
<span class="lineNum">     280 </span>            :  * in the system and to serialise it with other work the driver may
<span class="lineNum">     281 </span>            :  * provide.
<span class="lineNum">     282 </span>            :  *
<span class="lineNum">     283 </span>            :  * == Initialise
<span class="lineNum">     284 </span>            :  *
<span class="lineNum">     285 </span>            :  * When the stack requests an interface be brought up (ie, drv_ioctl()
<span class="lineNum">     286 </span>            :  * is called to handle SIOCSIFFLAGS with IFF_UP set in ifp-&gt;if_flags)
<span class="lineNum">     287 </span>            :  * drivers should set IFF_RUNNING in ifp-&gt;if_flags and call
<span class="lineNum">     288 </span>            :  * ifq_clr_oactive().
<span class="lineNum">     289 </span>            :  *
<span class="lineNum">     290 </span>            :  * == if_start
<span class="lineNum">     291 </span>            :  *
<span class="lineNum">     292 </span>            :  * ifq_start() checks that IFF_RUNNING is set in ifp-&gt;if_flags, that
<span class="lineNum">     293 </span>            :  * ifq_is_oactive() does not return true, and that there are pending
<span class="lineNum">     294 </span>            :  * packets to transmit via a call to ifq_len(). Therefore, drivers are
<span class="lineNum">     295 </span>            :  * no longer responsible for doing this themselves.
<span class="lineNum">     296 </span>            :  *
<span class="lineNum">     297 </span>            :  * If a driver should not transmit packets while its link is down, use
<span class="lineNum">     298 </span>            :  * ifq_purge() to flush pending packets from the transmit queue.
<span class="lineNum">     299 </span>            :  *
<span class="lineNum">     300 </span>            :  * Drivers for hardware should use the following pattern to transmit
<span class="lineNum">     301 </span>            :  * packets:
<span class="lineNum">     302 </span>            :  *
<span class="lineNum">     303 </span>            :  *      void
<span class="lineNum">     304 </span>            :  *      drv_start(struct ifqueue *ifq)
<span class="lineNum">     305 </span>            :  *      {
<span class="lineNum">     306 </span>            :  *              struct ifnet *ifp = ifq-&gt;ifq_if;
<span class="lineNum">     307 </span>            :  *              struct drv_softc *sc = ifp-&gt;if_softc;
<span class="lineNum">     308 </span>            :  *              struct mbuf *m;
<span class="lineNum">     309 </span>            :  *              int kick = 0;
<span class="lineNum">     310 </span>            :  *
<span class="lineNum">     311 </span>            :  *              if (NO_LINK) {
<span class="lineNum">     312 </span>            :  *                      ifq_purge(ifq);
<span class="lineNum">     313 </span>            :  *                      return;
<span class="lineNum">     314 </span>            :  *              }
<span class="lineNum">     315 </span>            :  *
<span class="lineNum">     316 </span>            :  *              for (;;) {
<span class="lineNum">     317 </span>            :  *                      if (NO_SPACE) {
<span class="lineNum">     318 </span>            :  *                              ifq_set_oactive(ifq);
<span class="lineNum">     319 </span>            :  *                              break;
<span class="lineNum">     320 </span>            :  *                      }
<span class="lineNum">     321 </span>            :  *
<span class="lineNum">     322 </span>            :  *                      m = ifq_dequeue(ifq);
<span class="lineNum">     323 </span>            :  *                      if (m == NULL)
<span class="lineNum">     324 </span>            :  *                              break;
<span class="lineNum">     325 </span>            :  *
<span class="lineNum">     326 </span>            :  *                      if (drv_encap(sc, m) != 0) { // map and fill ring
<span class="lineNum">     327 </span>            :  *                              m_freem(m);
<span class="lineNum">     328 </span>            :  *                              continue;
<span class="lineNum">     329 </span>            :  *                      }
<span class="lineNum">     330 </span>            :  *
<span class="lineNum">     331 </span>            :  *                      bpf_mtap();
<span class="lineNum">     332 </span>            :  *              }
<span class="lineNum">     333 </span>            :  *
<span class="lineNum">     334 </span>            :  *              drv_kick(sc); // notify hw of new descriptors on the ring
<span class="lineNum">     335 </span>            :  *       }
<span class="lineNum">     336 </span>            :  *
<span class="lineNum">     337 </span>            :  * == Transmission completion
<span class="lineNum">     338 </span>            :  *
<span class="lineNum">     339 </span>            :  * The following pattern should be used for transmit queue interrupt
<span class="lineNum">     340 </span>            :  * processing:
<span class="lineNum">     341 </span>            :  *
<span class="lineNum">     342 </span>            :  *      void
<span class="lineNum">     343 </span>            :  *      drv_txeof(struct ifqueue *ifq)
<span class="lineNum">     344 </span>            :  *      {
<span class="lineNum">     345 </span>            :  *              while (COMPLETED_PKTS) {
<span class="lineNum">     346 </span>            :  *                      // unmap packets, m_freem() the mbufs.
<span class="lineNum">     347 </span>            :  *              }
<span class="lineNum">     348 </span>            :  *
<span class="lineNum">     349 </span>            :  *              if (ifq_is_oactive(ifq))
<span class="lineNum">     350 </span>            :  *                      ifq_restart(ifq);
<span class="lineNum">     351 </span>            :  *      }
<span class="lineNum">     352 </span>            :  *
<span class="lineNum">     353 </span>            :  * == Stop
<span class="lineNum">     354 </span>            :  *
<span class="lineNum">     355 </span>            :  * Bringing an interface down (ie, IFF_UP was cleared in ifp-&gt;if_flags)
<span class="lineNum">     356 </span>            :  * should clear IFF_RUNNING in ifp-&gt;if_flags, and guarantee the start
<span class="lineNum">     357 </span>            :  * routine is not running before freeing any resources it uses:
<span class="lineNum">     358 </span>            :  *
<span class="lineNum">     359 </span>            :  *      void
<span class="lineNum">     360 </span>            :  *      drv_down(struct drv_softc *sc)
<span class="lineNum">     361 </span>            :  *      {
<span class="lineNum">     362 </span>            :  *              struct ifnet *ifp = &amp;sc-&gt;sc_if;
<span class="lineNum">     363 </span>            :  *              struct ifqueue *ifq;
<span class="lineNum">     364 </span>            :  *              int i;
<span class="lineNum">     365 </span>            :  *
<span class="lineNum">     366 </span>            :  *              CLR(ifp-&gt;if_flags, IFF_RUNNING);
<span class="lineNum">     367 </span>            :  *              DISABLE_INTERRUPTS();
<span class="lineNum">     368 </span>            :  *
<span class="lineNum">     369 </span>            :  *              for (i = 0; i &lt; sc-&gt;sc_num_queues; i++) {
<span class="lineNum">     370 </span>            :  *                      ifq = ifp-&gt;if_ifqs[i];
<span class="lineNum">     371 </span>            :  *                      ifq_barrier(ifq);
<span class="lineNum">     372 </span>            :  *              }
<span class="lineNum">     373 </span>            :  *
<span class="lineNum">     374 </span>            :  *              intr_barrier(sc-&gt;sc_ih);
<span class="lineNum">     375 </span>            :  *
<span class="lineNum">     376 </span>            :  *              FREE_RESOURCES();
<span class="lineNum">     377 </span>            :  *
<span class="lineNum">     378 </span>            :  *              for (i = 0; i &lt; sc-&gt;sc_num_queues; i++) {
<span class="lineNum">     379 </span>            :  *                      ifq = ifp-&gt;if_ifqs[i];
<span class="lineNum">     380 </span>            :  *                      ifq_clr_oactive(ifq);
<span class="lineNum">     381 </span>            :  *              }
<span class="lineNum">     382 </span>            :  *      }
<span class="lineNum">     383 </span>            :  *
<span class="lineNum">     384 </span>            :  */
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : struct ifq_ops {
<span class="lineNum">     387 </span>            :         unsigned int             (*ifqop_idx)(unsigned int,
<span class="lineNum">     388 </span>            :                                     const struct mbuf *);
<span class="lineNum">     389 </span>            :         struct mbuf             *(*ifqop_enq)(struct ifqueue *, struct mbuf *);
<span class="lineNum">     390 </span>            :         struct mbuf             *(*ifqop_deq_begin)(struct ifqueue *, void **);
<span class="lineNum">     391 </span>            :         void                     (*ifqop_deq_commit)(struct ifqueue *,
<span class="lineNum">     392 </span>            :                                     struct mbuf *, void *);
<span class="lineNum">     393 </span>            :         void                     (*ifqop_purge)(struct ifqueue *,
<span class="lineNum">     394 </span>            :                                     struct mbuf_list *);
<span class="lineNum">     395 </span>            :         void                    *(*ifqop_alloc)(unsigned int, void *);
<span class="lineNum">     396 </span>            :         void                     (*ifqop_free)(unsigned int, void *);
<span class="lineNum">     397 </span>            : };
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : /*
<span class="lineNum">     400 </span>            :  * Interface send queues.
<span class="lineNum">     401 </span>            :  */
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : void             ifq_init(struct ifqueue *, struct ifnet *, unsigned int);
<span class="lineNum">     404 </span>            : void             ifq_attach(struct ifqueue *, const struct ifq_ops *, void *);
<span class="lineNum">     405 </span>            : void             ifq_destroy(struct ifqueue *);
<span class="lineNum">     406 </span>            : void             ifq_add_data(struct ifqueue *, struct if_data *);
<span class="lineNum">     407 </span>            : int              ifq_enqueue(struct ifqueue *, struct mbuf *);
<span class="lineNum">     408 </span>            : struct mbuf     *ifq_deq_begin(struct ifqueue *);
<span class="lineNum">     409 </span>            : void             ifq_deq_commit(struct ifqueue *, struct mbuf *);
<span class="lineNum">     410 </span>            : void             ifq_deq_rollback(struct ifqueue *, struct mbuf *);
<span class="lineNum">     411 </span>            : struct mbuf     *ifq_dequeue(struct ifqueue *);
<span class="lineNum">     412 </span>            : void             ifq_mfreem(struct ifqueue *, struct mbuf *);
<span class="lineNum">     413 </span>            : void             ifq_mfreeml(struct ifqueue *, struct mbuf_list *);
<span class="lineNum">     414 </span>            : unsigned int     ifq_purge(struct ifqueue *);
<span class="lineNum">     415 </span>            : void            *ifq_q_enter(struct ifqueue *, const struct ifq_ops *);
<span class="lineNum">     416 </span>            : void             ifq_q_leave(struct ifqueue *, void *);
<span class="lineNum">     417 </span>            : void             ifq_serialize(struct ifqueue *, struct task *);
<span class="lineNum">     418 </span>            : int              ifq_is_serialized(struct ifqueue *);
<span class="lineNum">     419 </span>            : void             ifq_barrier(struct ifqueue *);
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : #define ifq_len(_ifq)                   ((_ifq)-&gt;ifq_len)
<span class="lineNum">     422 </span>            : #define ifq_empty(_ifq)                 (ifq_len(_ifq) == 0)
<span class="lineNum">     423 </span>            : #define ifq_set_maxlen(_ifq, _l)        ((_ifq)-&gt;ifq_maxlen = (_l))
<a name="424"><span class="lineNum">     424 </span>            : </a>
<span class="lineNum">     425 </span>            : static inline void
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : ifq_set_oactive(struct ifqueue *ifq)</span>
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         ifq-&gt;ifq_oactive = 1;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 : }</span>
<a name="430"><span class="lineNum">     430 </span>            : </a>
<span class="lineNum">     431 </span>            : static inline void
<span class="lineNum">     432 </span><span class="lineNoCov">          0 : ifq_clr_oactive(struct ifqueue *ifq)</span>
<span class="lineNum">     433 </span>            : {
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         ifq-&gt;ifq_oactive = 0;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 : }</span>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : static inline unsigned int
<span class="lineNum">     438 </span><span class="lineNoCov">          0 : ifq_is_oactive(struct ifqueue *ifq)</span>
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         return (ifq-&gt;ifq_oactive);</span>
<span class="lineNum">     441 </span>            : }
<a name="442"><span class="lineNum">     442 </span>            : </a>
<span class="lineNum">     443 </span>            : static inline void
<span class="lineNum">     444 </span><span class="lineNoCov">          0 : ifq_start(struct ifqueue *ifq)</span>
<span class="lineNum">     445 </span>            : {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         ifq_serialize(ifq, &amp;ifq-&gt;ifq_start);</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 : }</span>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<span class="lineNum">     449 </span>            : static inline void
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : ifq_restart(struct ifqueue *ifq)</span>
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         ifq_serialize(ifq, &amp;ifq-&gt;ifq_restart);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 : }</span>
<a name="454"><span class="lineNum">     454 </span>            : </a>
<span class="lineNum">     455 </span>            : static inline unsigned int
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : ifq_idx(struct ifqueue *ifq, unsigned int nifqs, const struct mbuf *m)</span>
<span class="lineNum">     457 </span>            : {
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         return ((*ifq-&gt;ifq_ops-&gt;ifqop_idx)(nifqs, m));</span>
<span class="lineNum">     459 </span>            : }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : #define IFQ_ASSERT_SERIALIZED(_ifq)     KASSERT(ifq_is_serialized(_ifq))
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : extern const struct ifq_ops * const ifq_priq_ops;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /* ifiq */
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : void             ifiq_init(struct ifiqueue *, struct ifnet *, unsigned int);
<span class="lineNum">     468 </span>            : void             ifiq_destroy(struct ifiqueue *);
<span class="lineNum">     469 </span>            : int              ifiq_input(struct ifiqueue *, struct mbuf_list *,
<span class="lineNum">     470 </span>            :                      unsigned int);
<span class="lineNum">     471 </span>            : int              ifiq_enqueue(struct ifiqueue *, struct mbuf *);
<span class="lineNum">     472 </span>            : void             ifiq_add_data(struct ifiqueue *, struct if_data *);
<span class="lineNum">     473 </span>            : void             ifiq_barrier(struct ifiqueue *);
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : #define ifiq_len(_ifiq)                 ml_len(&amp;(_ifiq)-&gt;ifiq_ml)
<span class="lineNum">     476 </span>            : #define ifiq_empty(_ifiq)               ml_empty(&amp;(_ifiq)-&gt;ifiq_ml)
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : #endif /* _KERNEL */
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : #endif /* _NET_IFQ_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
