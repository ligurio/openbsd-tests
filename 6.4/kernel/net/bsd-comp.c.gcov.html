<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - net/bsd-comp.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">net</a> - bsd-comp.c<span style="font-size: 80%;"> (source / <a href="bsd-comp.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">432</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: bsd-comp.c,v 1.15 2017/09/08 05:36:53 deraadt Exp $   */</a>
<span class="lineNum">       2 </span>            : /*      $NetBSD: bsd-comp.c,v 1.6 1996/10/13 02:10:58 christos Exp $    */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /* Because this code is derived from the 4.3BSD compress source:
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Copyright (c) 1985, 1986 The Regents of the University of California.
<span class="lineNum">       8 </span>            :  * All rights reserved.
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * This code is derived from software contributed to Berkeley by
<span class="lineNum">      11 </span>            :  * James A. Woods, derived from original work by Spencer Thomas
<span class="lineNum">      12 </span>            :  * and Joseph Orost.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">      15 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      16 </span>            :  * are met:
<span class="lineNum">      17 </span>            :  * 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      18 </span>            :  *    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      19 </span>            :  * 2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      20 </span>            :  *    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      21 </span>            :  *    documentation and/or other materials provided with the distribution.
<span class="lineNum">      22 </span>            :  * 3. Neither the name of the University nor the names of its contributors
<span class="lineNum">      23 </span>            :  *    may be used to endorse or promote products derived from this software
<span class="lineNum">      24 </span>            :  *    without specific prior written permission.
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
<span class="lineNum">      27 </span>            :  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      28 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      29 </span>            :  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
<span class="lineNum">      30 </span>            :  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
<span class="lineNum">      31 </span>            :  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
<span class="lineNum">      32 </span>            :  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
<span class="lineNum">      33 </span>            :  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
<span class="lineNum">      34 </span>            :  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
<span class="lineNum">      35 </span>            :  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
<span class="lineNum">      36 </span>            :  * SUCH DAMAGE.
<span class="lineNum">      37 </span>            :  */
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /*
<span class="lineNum">      40 </span>            :  * This version is for use with mbufs on BSD-derived systems.
<span class="lineNum">      41 </span>            :  */
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      44 </span>            : #include &lt;sys/systm.h&gt;
<span class="lineNum">      45 </span>            : #include &lt;sys/mbuf.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;sys/socket.h&gt;
<span class="lineNum">      47 </span>            : #include &lt;net/if.h&gt;
<span class="lineNum">      48 </span>            : #include &lt;net/if_var.h&gt;
<span class="lineNum">      49 </span>            : #include &lt;net/ppp_defs.h&gt;
<span class="lineNum">      50 </span>            : #include &lt;net/if_ppp.h&gt;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #define PACKETPTR       struct mbuf *
<span class="lineNum">      53 </span>            : #include &lt;net/ppp-comp.h&gt;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #if DO_BSD_COMPRESS
<span class="lineNum">      56 </span>            : /*
<span class="lineNum">      57 </span>            :  * PPP &quot;BSD compress&quot; compression
<span class="lineNum">      58 </span>            :  *  The differences between this compression and the classic BSD LZW
<span class="lineNum">      59 </span>            :  *  source are obvious from the requirement that the classic code worked
<span class="lineNum">      60 </span>            :  *  with files while this handles arbitrarily long streams that
<span class="lineNum">      61 </span>            :  *  are broken into packets.  They are:
<span class="lineNum">      62 </span>            :  *
<span class="lineNum">      63 </span>            :  *      When the code size expands, a block of junk is not emitted by
<span class="lineNum">      64 </span>            :  *          the compressor and not expected by the decompressor.
<span class="lineNum">      65 </span>            :  *
<span class="lineNum">      66 </span>            :  *      New codes are not necessarily assigned every time an old
<span class="lineNum">      67 </span>            :  *          code is output by the compressor.  This is because a packet
<span class="lineNum">      68 </span>            :  *          end forces a code to be emitted, but does not imply that a
<span class="lineNum">      69 </span>            :  *          new sequence has been seen.
<span class="lineNum">      70 </span>            :  *
<span class="lineNum">      71 </span>            :  *      The compression ratio is checked at the first end of a packet
<span class="lineNum">      72 </span>            :  *          after the appropriate gap.  Besides simplifying and speeding
<span class="lineNum">      73 </span>            :  *          things up, this makes it more likely that the transmitter
<span class="lineNum">      74 </span>            :  *          and receiver will agree when the dictionary is cleared when
<span class="lineNum">      75 </span>            :  *          compression is not going well.
<span class="lineNum">      76 </span>            :  */
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /*
<span class="lineNum">      79 </span>            :  * A dictionary for doing BSD compress.
<span class="lineNum">      80 </span>            :  */
<span class="lineNum">      81 </span>            : struct bsd_db {
<span class="lineNum">      82 </span>            :     int     totlen;                     /* length of this structure */
<span class="lineNum">      83 </span>            :     u_int   hsize;                      /* size of the hash table */
<span class="lineNum">      84 </span>            :     u_char  hshift;                     /* used in hash function */
<span class="lineNum">      85 </span>            :     u_char  n_bits;                     /* current bits/code */
<span class="lineNum">      86 </span>            :     u_char  maxbits;
<span class="lineNum">      87 </span>            :     u_char  debug;
<span class="lineNum">      88 </span>            :     u_char  unit;
<span class="lineNum">      89 </span>            :     u_int16_t seqno;                    /* sequence # of next packet */
<span class="lineNum">      90 </span>            :     u_int   hdrlen;                     /* header length to preallocate */
<span class="lineNum">      91 </span>            :     u_int   mru;
<span class="lineNum">      92 </span>            :     u_int   maxmaxcode;                 /* largest valid code */
<span class="lineNum">      93 </span>            :     u_int   max_ent;                    /* largest code in use */
<span class="lineNum">      94 </span>            :     u_int   in_count;                   /* uncompressed bytes, aged */
<span class="lineNum">      95 </span>            :     u_int   bytes_out;                  /* compressed bytes, aged */
<span class="lineNum">      96 </span>            :     u_int   ratio;                      /* recent compression ratio */
<span class="lineNum">      97 </span>            :     u_int   checkpoint;                 /* when to next check the ratio */
<span class="lineNum">      98 </span>            :     u_int   clear_count;                /* times dictionary cleared */
<span class="lineNum">      99 </span>            :     u_int   incomp_count;               /* incompressible packets */
<span class="lineNum">     100 </span>            :     u_int   incomp_bytes;               /* incompressible bytes */
<span class="lineNum">     101 </span>            :     u_int   uncomp_count;               /* uncompressed packets */
<span class="lineNum">     102 </span>            :     u_int   uncomp_bytes;               /* uncompressed bytes */
<span class="lineNum">     103 </span>            :     u_int   comp_count;                 /* compressed packets */
<span class="lineNum">     104 </span>            :     u_int   comp_bytes;                 /* compressed bytes */
<span class="lineNum">     105 </span>            :     u_int16_t *lens;                    /* array of lengths of codes */
<span class="lineNum">     106 </span>            :     struct bsd_dict {
<span class="lineNum">     107 </span>            :         union {                         /* hash value */
<span class="lineNum">     108 </span>            :             u_int32_t   fcode;
<span class="lineNum">     109 </span>            :             struct {
<span class="lineNum">     110 </span>            : #if BYTE_ORDER == LITTLE_ENDIAN
<span class="lineNum">     111 </span>            :                 u_int16_t prefix;       /* preceding code */
<span class="lineNum">     112 </span>            :                 u_char  suffix;         /* last character of new code */
<span class="lineNum">     113 </span>            :                 u_char  pad;
<span class="lineNum">     114 </span>            : #else
<span class="lineNum">     115 </span>            :                 u_char  pad;
<span class="lineNum">     116 </span>            :                 u_char  suffix;         /* last character of new code */
<span class="lineNum">     117 </span>            :                 u_int16_t prefix;       /* preceding code */
<span class="lineNum">     118 </span>            : #endif
<span class="lineNum">     119 </span>            :             } hs;
<span class="lineNum">     120 </span>            :         } f;
<span class="lineNum">     121 </span>            :         u_int16_t codem1;               /* output of hash table -1 */
<span class="lineNum">     122 </span>            :         u_int16_t cptr;                 /* map code to hash table entry */
<span class="lineNum">     123 </span>            :     } dict[1];
<span class="lineNum">     124 </span>            : };
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : #define BSD_OVHD        2               /* BSD compress overhead/packet */
<span class="lineNum">     127 </span>            : #define BSD_INIT_BITS   BSD_MIN_BITS
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : static void     *bsd_comp_alloc(u_char *options, int opt_len);
<span class="lineNum">     130 </span>            : static void     *bsd_decomp_alloc(u_char *options, int opt_len);
<span class="lineNum">     131 </span>            : static void     bsd_free(void *state);
<span class="lineNum">     132 </span>            : static int      bsd_comp_init(void *state, u_char *options, int opt_len,
<span class="lineNum">     133 </span>            :                                    int unit, int hdrlen, int debug);
<span class="lineNum">     134 </span>            : static int      bsd_decomp_init(void *state, u_char *options, int opt_len,
<span class="lineNum">     135 </span>            :                                      int unit, int hdrlen, int mru, int debug);
<span class="lineNum">     136 </span>            : static int      bsd_compress(void *state, struct mbuf **mret,
<span class="lineNum">     137 </span>            :                                   struct mbuf *mp, int slen, int maxolen);
<span class="lineNum">     138 </span>            : static void     bsd_incomp(void *state, struct mbuf *dmsg);
<span class="lineNum">     139 </span>            : static int      bsd_decompress(void *state, struct mbuf *cmp,
<span class="lineNum">     140 </span>            :                                     struct mbuf **dmpp);
<span class="lineNum">     141 </span>            : static void     bsd_reset(void *state);
<span class="lineNum">     142 </span>            : static void     bsd_comp_stats(void *state, struct compstat *stats);
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /*
<span class="lineNum">     145 </span>            :  * Procedures exported to if_ppp.c.
<span class="lineNum">     146 </span>            :  */
<span class="lineNum">     147 </span>            : struct compressor ppp_bsd_compress = {
<span class="lineNum">     148 </span>            :     CI_BSD_COMPRESS,            /* compress_proto */
<span class="lineNum">     149 </span>            :     bsd_comp_alloc,             /* comp_alloc */
<span class="lineNum">     150 </span>            :     bsd_free,                   /* comp_free */
<span class="lineNum">     151 </span>            :     bsd_comp_init,              /* comp_init */
<span class="lineNum">     152 </span>            :     bsd_reset,                  /* comp_reset */
<span class="lineNum">     153 </span>            :     bsd_compress,               /* compress */
<span class="lineNum">     154 </span>            :     bsd_comp_stats,             /* comp_stat */
<span class="lineNum">     155 </span>            :     bsd_decomp_alloc,           /* decomp_alloc */
<span class="lineNum">     156 </span>            :     bsd_free,                   /* decomp_free */
<span class="lineNum">     157 </span>            :     bsd_decomp_init,            /* decomp_init */
<span class="lineNum">     158 </span>            :     bsd_reset,                  /* decomp_reset */
<span class="lineNum">     159 </span>            :     bsd_decompress,             /* decompress */
<span class="lineNum">     160 </span>            :     bsd_incomp,                 /* incomp */
<span class="lineNum">     161 </span>            :     bsd_comp_stats,             /* decomp_stat */
<span class="lineNum">     162 </span>            : };
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /*
<span class="lineNum">     165 </span>            :  * the next two codes should not be changed lightly, as they must not
<span class="lineNum">     166 </span>            :  * lie within the contiguous general code space.
<span class="lineNum">     167 </span>            :  */
<span class="lineNum">     168 </span>            : #define CLEAR   256                     /* table clear output code */
<span class="lineNum">     169 </span>            : #define FIRST   257                     /* first free entry */
<span class="lineNum">     170 </span>            : #define LAST    255
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : #define MAXCODE(b)      ((1 &lt;&lt; (b)) - 1)
<span class="lineNum">     173 </span>            : #define BADCODEM1       MAXCODE(BSD_MAX_BITS)
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : #define BSD_HASH(prefix,suffix,hshift)  ((((u_int32_t)(suffix)) &lt;&lt; (hshift)) \
<span class="lineNum">     176 </span>            :                                          ^ (u_int32_t)(prefix))
<span class="lineNum">     177 </span>            : #define BSD_KEY(prefix,suffix)          ((((u_int32_t)(suffix)) &lt;&lt; 16) \
<span class="lineNum">     178 </span>            :                                          + (u_int32_t)(prefix))
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : #define CHECK_GAP       10000           /* Ratio check interval */
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : #define RATIO_SCALE_LOG 8
<span class="lineNum">     183 </span>            : #define RATIO_SCALE     (1&lt;&lt;RATIO_SCALE_LOG)
<span class="lineNum">     184 </span>            : #define RATIO_MAX       (0x7fffffff&gt;&gt;RATIO_SCALE_LOG)
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : static void bsd_clear(struct bsd_db *);
<span class="lineNum">     187 </span>            : static int bsd_check(struct bsd_db *);
<span class="lineNum">     188 </span>            : static void *bsd_alloc(u_char *, int, int);
<span class="lineNum">     189 </span>            : static int bsd_init(struct bsd_db *, u_char *, int, int, int, int,
<span class="lineNum">     190 </span>            :                          int, int);
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : /*
<span class="lineNum">     193 </span>            :  * clear the dictionary
<a name="194"><span class="lineNum">     194 </span>            :  */</a>
<span class="lineNum">     195 </span>            : static void
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : bsd_clear(db)</span>
<span class="lineNum">     197 </span>            :     struct bsd_db *db;
<span class="lineNum">     198 </span>            : {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     db-&gt;clear_count++;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     db-&gt;max_ent = FIRST-1;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     db-&gt;n_bits = BSD_INIT_BITS;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     db-&gt;ratio = 0;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     db-&gt;bytes_out = 0;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     db-&gt;in_count = 0;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     db-&gt;incomp_count = 0;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     db-&gt;checkpoint = CHECK_GAP;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : /*
<span class="lineNum">     210 </span>            :  * If the dictionary is full, then see if it is time to reset it.
<span class="lineNum">     211 </span>            :  *
<span class="lineNum">     212 </span>            :  * Compute the compression ratio using fixed-point arithmetic
<span class="lineNum">     213 </span>            :  * with 8 fractional bits.
<span class="lineNum">     214 </span>            :  *
<span class="lineNum">     215 </span>            :  * Since we have an infinite stream instead of a single file,
<span class="lineNum">     216 </span>            :  * watch only the local compression ratio.
<span class="lineNum">     217 </span>            :  *
<span class="lineNum">     218 </span>            :  * Since both peers must reset the dictionary at the same time even in
<span class="lineNum">     219 </span>            :  * the absence of CLEAR codes (while packets are incompressible), they
<span class="lineNum">     220 </span>            :  * must compute the same ratio.
<a name="221"><span class="lineNum">     221 </span>            :  */</a>
<span class="lineNum">     222 </span>            : static int                              /* 1=output CLEAR */
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : bsd_check(db)</span>
<span class="lineNum">     224 </span>            :     struct bsd_db *db;
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            :     u_int new_ratio;
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     if (db-&gt;in_count &gt;= db-&gt;checkpoint) {</span>
<span class="lineNum">     229 </span>            :         /* age the ratio by limiting the size of the counts */
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :         if (db-&gt;in_count &gt;= RATIO_MAX</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :             || db-&gt;bytes_out &gt;= RATIO_MAX) {</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :             db-&gt;in_count -= db-&gt;in_count/4;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :             db-&gt;bytes_out -= db-&gt;bytes_out/4;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         db-&gt;checkpoint = db-&gt;in_count + CHECK_GAP;</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         if (db-&gt;max_ent &gt;= db-&gt;maxmaxcode) {</span>
<span class="lineNum">     239 </span>            :             /* Reset the dictionary only if the ratio is worse,
<span class="lineNum">     240 </span>            :              * or if it looks as if it has been poisoned
<span class="lineNum">     241 </span>            :              * by incompressible data.
<span class="lineNum">     242 </span>            :              *
<span class="lineNum">     243 </span>            :              * This does not overflow, because
<span class="lineNum">     244 </span>            :              *  db-&gt;in_count &lt;= RATIO_MAX.
<span class="lineNum">     245 </span>            :              */
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :             new_ratio = db-&gt;in_count &lt;&lt; RATIO_SCALE_LOG;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :             if (db-&gt;bytes_out != 0)</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                 new_ratio /= db-&gt;bytes_out;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :             if (new_ratio &lt; db-&gt;ratio || new_ratio &lt; 1 * RATIO_SCALE) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :                 bsd_clear(db);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     253 </span>            :             }
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :             db-&gt;ratio = new_ratio;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     256 </span>            :     }
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : /*
<span class="lineNum">     261 </span>            :  * Return statistics.
<a name="262"><span class="lineNum">     262 </span>            :  */</a>
<span class="lineNum">     263 </span>            : static void
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : bsd_comp_stats(state, stats)</span>
<span class="lineNum">     265 </span>            :     void *state;
<span class="lineNum">     266 </span>            :     struct compstat *stats;
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     struct bsd_db *db = (struct bsd_db *) state;</span>
<span class="lineNum">     269 </span>            :     u_int out;
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     stats-&gt;unc_bytes = db-&gt;uncomp_bytes;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     stats-&gt;unc_packets = db-&gt;uncomp_count;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     stats-&gt;comp_bytes = db-&gt;comp_bytes;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     stats-&gt;comp_packets = db-&gt;comp_count;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     stats-&gt;inc_bytes = db-&gt;incomp_bytes;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     stats-&gt;inc_packets = db-&gt;incomp_count;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     stats-&gt;ratio = db-&gt;in_count;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     out = db-&gt;bytes_out;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     if (stats-&gt;ratio &lt;= 0x7fffff)</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         stats-&gt;ratio &lt;&lt;= 8;</span>
<span class="lineNum">     281 </span>            :     else
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :         out &gt;&gt;= 8;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     if (out != 0)</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         stats-&gt;ratio /= out;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : /*
<span class="lineNum">     288 </span>            :  * Reset state, as on a CCP ResetReq.
<a name="289"><span class="lineNum">     289 </span>            :  */</a>
<span class="lineNum">     290 </span>            : static void
<span class="lineNum">     291 </span><span class="lineNoCov">          0 : bsd_reset(state)</span>
<span class="lineNum">     292 </span>            :     void *state;
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     struct bsd_db *db = (struct bsd_db *) state;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     db-&gt;seqno = 0;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     bsd_clear(db);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     db-&gt;clear_count = 0;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : /*
<span class="lineNum">     302 </span>            :  * Allocate space for a (de) compressor.
<a name="303"><span class="lineNum">     303 </span>            :  */</a>
<span class="lineNum">     304 </span>            : static void *
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : bsd_alloc(options, opt_len, decomp)</span>
<span class="lineNum">     306 </span>            :     u_char *options;
<span class="lineNum">     307 </span>            :     int opt_len, decomp;
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span>            :     int bits;
<span class="lineNum">     310 </span>            :     u_int newlen, hsize, hshift, maxmaxcode;
<span class="lineNum">     311 </span>            :     struct bsd_db *db;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     if (opt_len &lt; CILEN_BSD_COMPRESS || options[0] != CI_BSD_COMPRESS</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         || options[1] != CILEN_BSD_COMPRESS</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         || BSD_VERSION(options[2]) != BSD_CURRENT_VERSION)</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     bits = BSD_NBITS(options[2]);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     switch (bits) {</span>
<span class="lineNum">     319 </span>            :     case 9:                     /* needs 82152 for both directions */
<span class="lineNum">     320 </span>            :     case 10:                    /* needs 84144 */
<span class="lineNum">     321 </span>            :     case 11:                    /* needs 88240 */
<span class="lineNum">     322 </span>            :     case 12:                    /* needs 96432 */
<span class="lineNum">     323 </span>            :         hsize = 5003;
<span class="lineNum">     324 </span>            :         hshift = 4;
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     326 </span>            :     case 13:                    /* needs 176784 */
<span class="lineNum">     327 </span>            :         hsize = 9001;
<span class="lineNum">     328 </span>            :         hshift = 5;
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     330 </span>            :     case 14:                    /* needs 353744 */
<span class="lineNum">     331 </span>            :         hsize = 18013;
<span class="lineNum">     332 </span>            :         hshift = 6;
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     334 </span>            :     case 15:                    /* needs 691440 */
<span class="lineNum">     335 </span>            :         hsize = 35023;
<span class="lineNum">     336 </span>            :         hshift = 7;
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     338 </span>            :     case 16:                    /* needs 1366160--far too much, */
<span class="lineNum">     339 </span>            :         /* hsize = 69001; */    /* and 69001 is too big for cptr */
<span class="lineNum">     340 </span>            :         /* hshift = 8; */       /* in struct bsd_db */
<span class="lineNum">     341 </span>            :         /* break; */
<span class="lineNum">     342 </span>            :     default:
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     344 </span>            :     }
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     maxmaxcode = MAXCODE(bits);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     newlen = sizeof(*db) + (hsize-1) * (sizeof(db-&gt;dict[0]));</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     db = malloc(newlen, M_DEVBUF, M_NOWAIT|M_ZERO);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     if (!db)</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     if (!decomp) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         db-&gt;lens = NULL;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         db-&gt;lens = mallocarray(maxmaxcode + 1, sizeof(db-&gt;lens[0]), M_DEVBUF,</span>
<span class="lineNum">     356 </span>            :             M_NOWAIT);
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         if (!db-&gt;lens) {</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :             free(db, M_DEVBUF, newlen);</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     360 </span>            :         }
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     db-&gt;totlen = newlen;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     db-&gt;hsize = hsize;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     db-&gt;hshift = hshift;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     db-&gt;maxmaxcode = maxmaxcode;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     db-&gt;maxbits = bits;</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     return (void *) db;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : }</span>
<a name="371"><span class="lineNum">     371 </span>            : </a>
<span class="lineNum">     372 </span>            : static void
<span class="lineNum">     373 </span><span class="lineNoCov">          0 : bsd_free(state)</span>
<span class="lineNum">     374 </span>            :     void *state;
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     struct bsd_db *db = (struct bsd_db *) state;</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     if (db-&gt;lens)</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         free(db-&gt;lens, M_DEVBUF, (db-&gt;maxmaxcode + 1) * sizeof(db-&gt;lens[0]));</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     free(db, M_DEVBUF, db-&gt;totlen);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 : }</span>
<a name="382"><span class="lineNum">     382 </span>            : </a>
<span class="lineNum">     383 </span>            : static void *
<span class="lineNum">     384 </span><span class="lineNoCov">          0 : bsd_comp_alloc(options, opt_len)</span>
<span class="lineNum">     385 </span>            :     u_char *options;
<span class="lineNum">     386 </span>            :     int opt_len;
<span class="lineNum">     387 </span>            : {
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     return bsd_alloc(options, opt_len, 0);</span>
<span class="lineNum">     389 </span>            : }
<a name="390"><span class="lineNum">     390 </span>            : </a>
<span class="lineNum">     391 </span>            : static void *
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : bsd_decomp_alloc(options, opt_len)</span>
<span class="lineNum">     393 </span>            :     u_char *options;
<span class="lineNum">     394 </span>            :     int opt_len;
<span class="lineNum">     395 </span>            : {
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     return bsd_alloc(options, opt_len, 1);</span>
<span class="lineNum">     397 </span>            : }
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : /*
<span class="lineNum">     400 </span>            :  * Initialize the database.
<a name="401"><span class="lineNum">     401 </span>            :  */</a>
<span class="lineNum">     402 </span>            : static int
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : bsd_init(db, options, opt_len, unit, hdrlen, mru, debug, decomp)</span>
<span class="lineNum">     404 </span>            :     struct bsd_db *db;
<span class="lineNum">     405 </span>            :     u_char *options;
<span class="lineNum">     406 </span>            :     int opt_len, unit, hdrlen, mru, debug, decomp;
<span class="lineNum">     407 </span>            : {
<span class="lineNum">     408 </span>            :     int i;
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     if (opt_len &lt; CILEN_BSD_COMPRESS || options[0] != CI_BSD_COMPRESS</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         || options[1] != CILEN_BSD_COMPRESS</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         || BSD_VERSION(options[2]) != BSD_CURRENT_VERSION</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         || BSD_NBITS(options[2]) != db-&gt;maxbits</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         || (decomp &amp;&amp; db-&gt;lens == NULL))</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     if (decomp) {</span>
<span class="lineNum">     418 </span>            :         i = LAST+1;
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         while (i != 0)</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :             db-&gt;lens[--i] = 1;</span>
<span class="lineNum">     421 </span>            :     }
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     i = db-&gt;hsize;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     while (i != 0) {</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         db-&gt;dict[--i].codem1 = BADCODEM1;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         db-&gt;dict[i].cptr = 0;</span>
<span class="lineNum">     426 </span>            :     }
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     db-&gt;unit = unit;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     db-&gt;hdrlen = hdrlen;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     db-&gt;mru = mru;</span>
<span class="lineNum">     431 </span>            : #ifndef DEBUG
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     if (debug)</span>
<span class="lineNum">     433 </span>            : #endif
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         db-&gt;debug = 1;</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     bsd_reset(db);</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 : }</span>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<span class="lineNum">     441 </span>            : static int
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : bsd_comp_init(state, options, opt_len, unit, hdrlen, debug)</span>
<span class="lineNum">     443 </span>            :     void *state;
<span class="lineNum">     444 </span>            :     u_char *options;
<span class="lineNum">     445 </span>            :     int opt_len, unit, hdrlen, debug;
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     return bsd_init((struct bsd_db *) state, options, opt_len,</span>
<span class="lineNum">     448 </span>            :                     unit, hdrlen, 0, debug, 0);
<span class="lineNum">     449 </span>            : }
<a name="450"><span class="lineNum">     450 </span>            : </a>
<span class="lineNum">     451 </span>            : static int
<span class="lineNum">     452 </span><span class="lineNoCov">          0 : bsd_decomp_init(state, options, opt_len, unit, hdrlen, mru, debug)</span>
<span class="lineNum">     453 </span>            :     void *state;
<span class="lineNum">     454 </span>            :     u_char *options;
<span class="lineNum">     455 </span>            :     int opt_len, unit, hdrlen, mru, debug;
<span class="lineNum">     456 </span>            : {
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     return bsd_init((struct bsd_db *) state, options, opt_len,</span>
<span class="lineNum">     458 </span>            :                     unit, hdrlen, mru, debug, 1);
<span class="lineNum">     459 </span>            : }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : /*
<span class="lineNum">     463 </span>            :  * compress a packet
<span class="lineNum">     464 </span>            :  *      One change from the BSD compress command is that when the
<span class="lineNum">     465 </span>            :  *      code size expands, we do not output a bunch of padding.
<a name="466"><span class="lineNum">     466 </span>            :  */</a>
<span class="lineNum">     467 </span>            : int                                     /* new slen */
<span class="lineNum">     468 </span><span class="lineNoCov">          0 : bsd_compress(state, mret, mp, slen, maxolen)</span>
<span class="lineNum">     469 </span>            :     void *state;
<span class="lineNum">     470 </span>            :     struct mbuf **mret;         /* return compressed mbuf chain here */
<span class="lineNum">     471 </span>            :     struct mbuf *mp;            /* from here */
<span class="lineNum">     472 </span>            :     int slen;                   /* uncompressed length */
<span class="lineNum">     473 </span>            :     int maxolen;                /* max compressed length */
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     struct bsd_db *db = (struct bsd_db *) state;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     int hshift = db-&gt;hshift;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     u_int max_ent = db-&gt;max_ent;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     u_int n_bits = db-&gt;n_bits;</span>
<span class="lineNum">     479 </span>            :     u_int bitno = 32;
<span class="lineNum">     480 </span>            :     u_int32_t accm = 0, fcode;
<span class="lineNum">     481 </span>            :     struct bsd_dict *dictp;
<span class="lineNum">     482 </span>            :     u_char c;
<span class="lineNum">     483 </span>            :     int hval, disp, ent, ilen;
<span class="lineNum">     484 </span>            :     u_char *rptr, *wptr;
<span class="lineNum">     485 </span>            :     u_char *cp_end;
<span class="lineNum">     486 </span>            :     int olen;
<span class="lineNum">     487 </span>            :     struct mbuf *m;
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : #define PUTBYTE(v) {                                    \
<span class="lineNum">     490 </span>            :     ++olen;                                             \
<span class="lineNum">     491 </span>            :     if (wptr) {                                         \
<span class="lineNum">     492 </span>            :         *wptr++ = (v);                                  \
<span class="lineNum">     493 </span>            :         if (wptr &gt;= cp_end) {                                \
<span class="lineNum">     494 </span>            :             m-&gt;m_len = wptr - mtod(m, u_char *);     \
<span class="lineNum">     495 </span>            :             MGET(m-&gt;m_next, M_DONTWAIT, MT_DATA);    \
<span class="lineNum">     496 </span>            :             m = m-&gt;m_next;                           \
<span class="lineNum">     497 </span>            :             if (m) {                                    \
<span class="lineNum">     498 </span>            :                 m-&gt;m_len = 0;                                \
<span class="lineNum">     499 </span>            :                 if (maxolen - olen &gt; MLEN)           \
<span class="lineNum">     500 </span>            :                     MCLGET(m, M_DONTWAIT);              \
<span class="lineNum">     501 </span>            :                 wptr = mtod(m, u_char *);               \
<span class="lineNum">     502 </span>            :                 cp_end = wptr + M_TRAILINGSPACE(m);     \
<span class="lineNum">     503 </span>            :             } else                                      \
<span class="lineNum">     504 </span>            :                 wptr = NULL;                            \
<span class="lineNum">     505 </span>            :         }                                               \
<span class="lineNum">     506 </span>            :     }                                                   \
<span class="lineNum">     507 </span>            : }
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : #define OUTPUT(ent) {                                   \
<span class="lineNum">     510 </span>            :     bitno -= n_bits;                                    \
<span class="lineNum">     511 </span>            :     accm |= ((ent) &lt;&lt; bitno);                             \
<span class="lineNum">     512 </span>            :     do {                                                \
<span class="lineNum">     513 </span>            :         PUTBYTE(accm &gt;&gt; 24);                              \
<span class="lineNum">     514 </span>            :         accm &lt;&lt;= 8;                                       \
<span class="lineNum">     515 </span>            :         bitno += 8;                                     \
<span class="lineNum">     516 </span>            :     } while (bitno &lt;= 24);                           \
<span class="lineNum">     517 </span>            : }
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :     /*
<span class="lineNum">     520 </span>            :      * If the protocol is not in the range we're interested in,
<span class="lineNum">     521 </span>            :      * just return without compressing the packet.  If it is,
<span class="lineNum">     522 </span>            :      * the protocol becomes the first byte to compress.
<span class="lineNum">     523 </span>            :      */
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     rptr = mtod(mp, u_char *);</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     ent = PPP_PROTOCOL(rptr);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     if (ent &lt; 0x21 || ent &gt; 0xf9) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         *mret = NULL;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         return slen;</span>
<span class="lineNum">     529 </span>            :     }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :     /* Don't generate compressed packets which are larger than
<span class="lineNum">     532 </span>            :        the uncompressed packet. */
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     if (maxolen &gt; slen)</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         maxolen = slen;</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :     /* Allocate one mbuf to start with. */
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     MGET(m, M_DONTWAIT, MT_DATA);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     *mret = m;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     if (m != NULL) {</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         m-&gt;m_len = 0;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         if (maxolen + db-&gt;hdrlen &gt; MLEN)</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :             MCLGET(m, M_DONTWAIT);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         m-&gt;m_data += db-&gt;hdrlen;</span>
<span class="lineNum">     544 </span>            :         wptr = mtod(m, u_char *);
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         cp_end = wptr + M_TRAILINGSPACE(m);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     } else</span>
<span class="lineNum">     547 </span>            :         wptr = cp_end = NULL;
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :     /*
<span class="lineNum">     550 </span>            :      * Copy the PPP header over, changing the protocol,
<span class="lineNum">     551 </span>            :      * and install the 2-byte packet sequence number.
<span class="lineNum">     552 </span>            :      */
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     if (wptr) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         *wptr++ = PPP_ADDRESS(rptr);    /* assumes the ppp header is */</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         *wptr++ = PPP_CONTROL(rptr);    /* all in one mbuf */</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         *wptr++ = 0;                    /* change the protocol */</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         *wptr++ = PPP_COMP;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :         *wptr++ = db-&gt;seqno &gt;&gt; 8;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         *wptr++ = db-&gt;seqno;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     ++db-&gt;seqno;</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            :     olen = 0;
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     rptr += PPP_HDRLEN;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     slen = mp-&gt;m_len - PPP_HDRLEN;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     ilen = slen + 1;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     for (;;) {</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         if (slen &lt;= 0) {</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :             mp = mp-&gt;m_next;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :             if (!mp)</span>
<span class="lineNum">     571 </span>            :                 break;
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :             rptr = mtod(mp, u_char *);</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :             slen = mp-&gt;m_len;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :             if (!slen)</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                 continue;   /* handle 0-length buffers */</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :             ilen += slen;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :         slen--;</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         c = *rptr++;</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         fcode = BSD_KEY(ent, c);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         hval = BSD_HASH(ent, c, hshift);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         dictp = &amp;db-&gt;dict[hval];</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :         /* Validate and then check the entry. */
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         if (dictp-&gt;codem1 &gt;= max_ent)</span>
<span class="lineNum">     587 </span>            :             goto nomatch;
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :         if (dictp-&gt;f.fcode == fcode) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :             ent = dictp-&gt;codem1+1;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :             continue;   /* found (prefix,suffix) */</span>
<span class="lineNum">     591 </span>            :         }
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :         /* continue probing until a match or invalid entry */
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         disp = (hval == 0) ? 1 : hval;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :             hval += disp;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :             if (hval &gt;= db-&gt;hsize)</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                 hval -= db-&gt;hsize;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :             dictp = &amp;db-&gt;dict[hval];</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :             if (dictp-&gt;codem1 &gt;= max_ent)</span>
<span class="lineNum">     601 </span>            :                 goto nomatch;
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :         } while (dictp-&gt;f.fcode != fcode);</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         ent = dictp-&gt;codem1 + 1;     /* finally found (prefix,suffix) */</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :     nomatch:
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         OUTPUT(ent);            /* output the prefix */</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :         /* code -&gt; hashtable */
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         if (max_ent &lt; db-&gt;maxmaxcode) {</span>
<span class="lineNum">     611 </span>            :             struct bsd_dict *dictp2;
<span class="lineNum">     612 </span>            :             /* expand code size if needed */
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :             if (max_ent &gt;= MAXCODE(n_bits))</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                 db-&gt;n_bits = ++n_bits;</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :             /* Invalidate old hash table entry using
<span class="lineNum">     617 </span>            :              * this code, and then take it over.
<span class="lineNum">     618 </span>            :              */
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             dictp2 = &amp;db-&gt;dict[max_ent+1];</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :             if (db-&gt;dict[dictp2-&gt;cptr].codem1 == max_ent)</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                 db-&gt;dict[dictp2-&gt;cptr].codem1 = BADCODEM1;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             dictp2-&gt;cptr = hval;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             dictp-&gt;codem1 = max_ent;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :             dictp-&gt;f.fcode = fcode;</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :             db-&gt;max_ent = ++max_ent;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     628 </span>            :         ent = c;
<span class="lineNum">     629 </span>            :     }
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     OUTPUT(ent);                /* output the last code */</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     db-&gt;bytes_out += olen;</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     db-&gt;in_count += ilen;</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     if (bitno &lt; 32)</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         ++db-&gt;bytes_out;     /* count complete bytes */</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     if (bsd_check(db))</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         OUTPUT(CLEAR);          /* do not count the CLEAR */</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :     /*
<span class="lineNum">     641 </span>            :      * Pad dribble bits of last code with ones.
<span class="lineNum">     642 </span>            :      * Do not emit a completely useless byte of ones.
<span class="lineNum">     643 </span>            :      */
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     if (bitno != 32)</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         PUTBYTE((accm | (0xff &lt;&lt; (bitno-8))) &gt;&gt; 24);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     if (m != NULL) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         m-&gt;m_len = wptr - mtod(m, u_char *);</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         m-&gt;m_next = NULL;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :     /*
<span class="lineNum">     653 </span>            :      * Increase code size if we would have without the packet
<span class="lineNum">     654 </span>            :      * boundary and as the decompressor will.
<span class="lineNum">     655 </span>            :      */
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     if (max_ent &gt;= MAXCODE(n_bits) &amp;&amp; max_ent &lt; db-&gt;maxmaxcode)</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         db-&gt;n_bits++;</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     db-&gt;uncomp_bytes += ilen;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     ++db-&gt;uncomp_count;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     if (olen + PPP_HDRLEN + BSD_OVHD &gt; maxolen) {</span>
<span class="lineNum">     662 </span>            :         /* throw away the compressed stuff if it is longer than uncompressed */
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         m_freemp(mret);</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :         ++db-&gt;incomp_count;</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :         db-&gt;incomp_bytes += ilen;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         ++db-&gt;comp_count;</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         db-&gt;comp_bytes += olen + BSD_OVHD;</span>
<span class="lineNum">     670 </span>            :     }
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     return olen + PPP_HDRLEN + BSD_OVHD;</span>
<span class="lineNum">     673 </span>            : #undef OUTPUT
<span class="lineNum">     674 </span>            : #undef PUTBYTE
<span class="lineNum">     675 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : /*
<span class="lineNum">     679 </span>            :  * Update the &quot;BSD Compress&quot; dictionary on the receiver for
<span class="lineNum">     680 </span>            :  * incompressible data by pretending to compress the incoming data.
<a name="681"><span class="lineNum">     681 </span>            :  */</a>
<span class="lineNum">     682 </span>            : static void
<span class="lineNum">     683 </span><span class="lineNoCov">          0 : bsd_incomp(state, dmsg)</span>
<span class="lineNum">     684 </span>            :     void *state;
<span class="lineNum">     685 </span>            :     struct mbuf *dmsg;
<span class="lineNum">     686 </span>            : {
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     struct bsd_db *db = (struct bsd_db *) state;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     u_int hshift = db-&gt;hshift;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     u_int max_ent = db-&gt;max_ent;</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     u_int n_bits = db-&gt;n_bits;</span>
<span class="lineNum">     691 </span>            :     struct bsd_dict *dictp;
<span class="lineNum">     692 </span>            :     u_int32_t fcode;
<span class="lineNum">     693 </span>            :     u_char c;
<span class="lineNum">     694 </span>            :     u_int32_t hval, disp;
<span class="lineNum">     695 </span>            :     int slen, ilen;
<span class="lineNum">     696 </span>            :     u_int bitno = 7;
<span class="lineNum">     697 </span>            :     u_char *rptr;
<span class="lineNum">     698 </span>            :     u_int ent;
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :     /*
<span class="lineNum">     701 </span>            :      * If the protocol is not in the range we're interested in,
<span class="lineNum">     702 </span>            :      * just return without looking at the packet.  If it is,
<span class="lineNum">     703 </span>            :      * the protocol becomes the first byte to &quot;compress&quot;.
<span class="lineNum">     704 </span>            :      */
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     rptr = mtod(dmsg, u_char *);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     ent = PPP_PROTOCOL(rptr);</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     if (ent &lt; 0x21 || ent &gt; 0xf9)</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     db-&gt;incomp_count++;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     db-&gt;seqno++;</span>
<span class="lineNum">     712 </span>            :     ilen = 1;           /* count the protocol as 1 byte */
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     rptr += PPP_HDRLEN;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     slen = dmsg-&gt;m_len - PPP_HDRLEN;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     for (;;) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         if (slen &lt;= 0) {</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :             dmsg = dmsg-&gt;m_next;</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :             if (!dmsg)</span>
<span class="lineNum">     719 </span>            :                 break;
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :             rptr = mtod(dmsg, u_char *);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :             slen = dmsg-&gt;m_len;</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     723 </span>            :         }
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         ilen += slen;</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :             c = *rptr++;</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :             fcode = BSD_KEY(ent, c);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :             hval = BSD_HASH(ent, c, hshift);</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :             dictp = &amp;db-&gt;dict[hval];</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :             /* validate and then check the entry */
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :             if (dictp-&gt;codem1 &gt;= max_ent)</span>
<span class="lineNum">     734 </span>            :                 goto nomatch;
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :             if (dictp-&gt;f.fcode == fcode) {</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :                 ent = dictp-&gt;codem1+1;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :                 continue;   /* found (prefix,suffix) */</span>
<span class="lineNum">     738 </span>            :             }
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :             /* continue probing until a match or invalid entry */
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :             disp = (hval == 0) ? 1 : hval;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :             do {</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :                 hval += disp;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                 if (hval &gt;= db-&gt;hsize)</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                     hval -= db-&gt;hsize;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :                 dictp = &amp;db-&gt;dict[hval];</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                 if (dictp-&gt;codem1 &gt;= max_ent)</span>
<span class="lineNum">     748 </span>            :                     goto nomatch;
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :             } while (dictp-&gt;f.fcode != fcode);</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :             ent = dictp-&gt;codem1+1;</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :             continue;   /* finally found (prefix,suffix) */</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :         nomatch:                /* output (count) the prefix */
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :             bitno += n_bits;</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :             /* code -&gt; hashtable */
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :             if (max_ent &lt; db-&gt;maxmaxcode) {</span>
<span class="lineNum">     758 </span>            :                 struct bsd_dict *dictp2;
<span class="lineNum">     759 </span>            :                 /* expand code size if needed */
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :                 if (max_ent &gt;= MAXCODE(n_bits))</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :                     db-&gt;n_bits = ++n_bits;</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :                 /* Invalidate previous hash table entry
<span class="lineNum">     764 </span>            :                  * assigned this code, and then take it over.
<span class="lineNum">     765 </span>            :                  */
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 dictp2 = &amp;db-&gt;dict[max_ent+1];</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :                 if (db-&gt;dict[dictp2-&gt;cptr].codem1 == max_ent)</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :                     db-&gt;dict[dictp2-&gt;cptr].codem1 = BADCODEM1;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :                 dictp2-&gt;cptr = hval;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :                 dictp-&gt;codem1 = max_ent;</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :                 dictp-&gt;f.fcode = fcode;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 db-&gt;max_ent = ++max_ent;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :                 db-&gt;lens[max_ent] = db-&gt;lens[ent]+1;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     776 </span>            :             ent = c;
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :         } while (--slen != 0);</span>
<span class="lineNum">     778 </span>            :     }
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     bitno += n_bits;            /* output (count) the last code */</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     db-&gt;bytes_out += bitno/8;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     db-&gt;in_count += ilen;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     (void)bsd_check(db);</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     ++db-&gt;incomp_count;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     db-&gt;incomp_bytes += ilen;</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     ++db-&gt;uncomp_count;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     db-&gt;uncomp_bytes += ilen;</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :     /* Increase code size if we would have without the packet
<span class="lineNum">     790 </span>            :      * boundary and as the decompressor will.
<span class="lineNum">     791 </span>            :      */
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     if (max_ent &gt;= MAXCODE(n_bits) &amp;&amp; max_ent &lt; db-&gt;maxmaxcode)</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         db-&gt;n_bits++;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : /*
<span class="lineNum">     798 </span>            :  * Decompress &quot;BSD Compress&quot;.
<span class="lineNum">     799 </span>            :  *
<span class="lineNum">     800 </span>            :  * Because of patent problems, we return DECOMP_ERROR for errors
<span class="lineNum">     801 </span>            :  * found by inspecting the input data and for system problems, but
<span class="lineNum">     802 </span>            :  * DECOMP_FATALERROR for any errors which could possibly be said to
<span class="lineNum">     803 </span>            :  * be being detected &quot;after&quot; decompression.  For DECOMP_ERROR,
<span class="lineNum">     804 </span>            :  * we can issue a CCP reset-request; for DECOMP_FATALERROR, we may be
<span class="lineNum">     805 </span>            :  * infringing a patent of Motorola's if we do, so we take CCP down
<span class="lineNum">     806 </span>            :  * instead.
<span class="lineNum">     807 </span>            :  *
<span class="lineNum">     808 </span>            :  * Given that the frame has the correct sequence number and a good FCS,
<span class="lineNum">     809 </span>            :  * errors such as invalid codes in the input most likely indicate a
<span class="lineNum">     810 </span>            :  * bug, so we return DECOMP_FATALERROR for them in order to turn off
<span class="lineNum">     811 </span>            :  * compression, even though they are detected by inspecting the input.
<a name="812"><span class="lineNum">     812 </span>            :  */</a>
<span class="lineNum">     813 </span>            : int
<span class="lineNum">     814 </span><span class="lineNoCov">          0 : bsd_decompress(state, cmp, dmpp)</span>
<span class="lineNum">     815 </span>            :     void *state;
<span class="lineNum">     816 </span>            :     struct mbuf *cmp, **dmpp;
<span class="lineNum">     817 </span>            : {
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     struct bsd_db *db = (struct bsd_db *) state;</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     u_int max_ent = db-&gt;max_ent;</span>
<span class="lineNum">     820 </span>            :     u_int32_t accm = 0;
<span class="lineNum">     821 </span>            :     u_int bitno = 32;           /* 1st valid bit in accm */
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :     u_int n_bits = db-&gt;n_bits;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     u_int tgtbitno = 32-n_bits; /* bitno when we have a code */</span>
<span class="lineNum">     824 </span>            :     struct bsd_dict *dictp;
<span class="lineNum">     825 </span>            :     int explen, i, seq, len;
<span class="lineNum">     826 </span>            :     u_int incode, oldcode, finchar;
<span class="lineNum">     827 </span>            :     u_char *p, *rptr, *wptr;
<span class="lineNum">     828 </span>            :     struct mbuf *m, *dmp, *mret;
<span class="lineNum">     829 </span>            :     int adrs, ctrl, ilen;
<span class="lineNum">     830 </span>            :     int space, codelen, extra;
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     /*
<span class="lineNum">     833 </span>            :      * Save the address/control from the PPP header
<span class="lineNum">     834 </span>            :      * and then get the sequence number.
<span class="lineNum">     835 </span>            :      */
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     *dmpp = NULL;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     rptr = mtod(cmp, u_char *);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     adrs = PPP_ADDRESS(rptr);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     ctrl = PPP_CONTROL(rptr);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     rptr += PPP_HDRLEN;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     len = cmp-&gt;m_len - PPP_HDRLEN;</span>
<span class="lineNum">     842 </span>            :     seq = 0;
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; 2; ++i) {</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         while (len &lt;= 0) {</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :             cmp = cmp-&gt;m_next;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :             if (cmp == NULL)</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                 return DECOMP_ERROR;</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :             rptr = mtod(cmp, u_char *);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :             len = cmp-&gt;m_len;</span>
<span class="lineNum">     850 </span>            :         }
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         seq = (seq &lt;&lt; 8) + *rptr++;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :         --len;</span>
<span class="lineNum">     853 </span>            :     }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :     /*
<span class="lineNum">     856 </span>            :      * Check the sequence number and give up if it differs from
<span class="lineNum">     857 </span>            :      * the value we're expecting.
<span class="lineNum">     858 </span>            :      */
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     if (seq != db-&gt;seqno) {</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :         if (db-&gt;debug)</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :             printf(&quot;bsd_decomp%d: bad sequence # %d, expected %d\n&quot;,</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                    db-&gt;unit, seq, db-&gt;seqno - 1);</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :         return DECOMP_ERROR;</span>
<span class="lineNum">     864 </span>            :     }
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     ++db-&gt;seqno;</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :     /*
<span class="lineNum">     868 </span>            :      * Allocate one mbuf to start with.
<span class="lineNum">     869 </span>            :      */
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     MGETHDR(dmp, M_DONTWAIT, MT_DATA);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     if (dmp == NULL)</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         return DECOMP_ERROR;</span>
<span class="lineNum">     873 </span>            :     mret = dmp;
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     dmp-&gt;m_len = 0;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     dmp-&gt;m_next = NULL;</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     MCLGET(dmp, M_DONTWAIT);</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     dmp-&gt;m_data += db-&gt;hdrlen;</span>
<span class="lineNum">     878 </span>            :     wptr = mtod(dmp, u_char *);
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     space = M_TRAILINGSPACE(dmp) - PPP_HDRLEN + 1;</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :     /*
<span class="lineNum">     882 </span>            :      * Fill in the ppp header, but not the last byte of the protocol
<span class="lineNum">     883 </span>            :      * (that comes from the decompressed data).
<span class="lineNum">     884 </span>            :      */
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     wptr[0] = adrs;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     wptr[1] = ctrl;</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     wptr[2] = 0;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     wptr += PPP_HDRLEN - 1;</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :     ilen = len;
<span class="lineNum">     891 </span>            :     oldcode = CLEAR;
<span class="lineNum">     892 </span>            :     explen = 0;
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     for (;;) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         if (len == 0) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :             cmp = cmp-&gt;m_next;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :             if (!cmp)           /* quit at end of message */</span>
<span class="lineNum">     897 </span>            :                 break;
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :             rptr = mtod(cmp, u_char *);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :             len = cmp-&gt;m_len;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :             ilen += len;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :             continue;           /* handle 0-length buffers */</span>
<span class="lineNum">     902 </span>            :         }
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span>            :         /*
<span class="lineNum">     905 </span>            :          * Accumulate bytes until we have a complete code.
<span class="lineNum">     906 </span>            :          * Then get the next code, relying on the 32-bit,
<span class="lineNum">     907 </span>            :          * unsigned accm to mask the result.
<span class="lineNum">     908 </span>            :          */
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :         bitno -= 8;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         accm |= *rptr++ &lt;&lt; bitno;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :         --len;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :         if (tgtbitno &lt; bitno)</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :         incode = accm &gt;&gt; tgtbitno;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :         accm &lt;&lt;= n_bits;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         bitno += n_bits;</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         if (incode == CLEAR) {</span>
<span class="lineNum">     919 </span>            :             /*
<span class="lineNum">     920 </span>            :              * The dictionary must only be cleared at
<span class="lineNum">     921 </span>            :              * the end of a packet.  But there could be an
<span class="lineNum">     922 </span>            :              * empty mbuf at the end.
<span class="lineNum">     923 </span>            :              */
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :             if (len &gt; 0 || cmp-&gt;m_next != NULL) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :                 while ((cmp = cmp-&gt;m_next) != NULL)</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                     len += cmp-&gt;m_len;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :                 if (len &gt; 0) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :                     m_freem(mret);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :                     if (db-&gt;debug)</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                         printf(&quot;bsd_decomp%d: bad CLEAR\n&quot;, db-&gt;unit);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :                     return DECOMP_FATALERROR;   /* probably a bug */</span>
<span class="lineNum">     932 </span>            :                 }
<span class="lineNum">     933 </span>            :             }
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :             bsd_clear(db);</span>
<span class="lineNum">     935 </span>            :             explen = ilen = 0;
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     937 </span>            :         }
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         if (incode &gt; max_ent + 2 || incode &gt; db-&gt;maxmaxcode</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :             || (incode &gt; max_ent &amp;&amp; oldcode == CLEAR)) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :             m_freem(mret);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :             if (db-&gt;debug) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :                 printf(&quot;bsd_decomp%d: bad code 0x%x oldcode=0x%x &quot;,</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :                        db-&gt;unit, incode, oldcode);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                 printf(&quot;max_ent=0x%x explen=%d seqno=%d\n&quot;,</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :                        max_ent, explen, db-&gt;seqno);</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :             return DECOMP_FATALERROR;   /* probably a bug */</span>
<span class="lineNum">     949 </span>            :         }
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :         /* Special case for KwKwK string. */
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         if (incode &gt; max_ent) {</span>
<span class="lineNum">     953 </span>            :             finchar = oldcode;
<span class="lineNum">     954 </span>            :             extra = 1;
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">     956 </span>            :             finchar = incode;
<span class="lineNum">     957 </span>            :             extra = 0;
<span class="lineNum">     958 </span>            :         }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         codelen = db-&gt;lens[finchar];</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         explen += codelen + extra;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         if (explen &gt; db-&gt;mru + 1) {</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :             m_freem(mret);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :             if (db-&gt;debug) {</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                 printf(&quot;bsd_decomp%d: ran out of mru\n&quot;, db-&gt;unit);</span>
<span class="lineNum">     966 </span>            : #ifdef DEBUG
<span class="lineNum">     967 </span>            :                 while ((cmp = cmp-&gt;m_next) != NULL)
<span class="lineNum">     968 </span>            :                     len += cmp-&gt;m_len;
<span class="lineNum">     969 </span>            :                 printf(&quot;  len=%d, finchar=0x%x, codelen=%d, explen=%d\n&quot;,
<span class="lineNum">     970 </span>            :                        len, finchar, codelen, explen);
<span class="lineNum">     971 </span>            : #endif
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             return DECOMP_FATALERROR;</span>
<span class="lineNum">     974 </span>            :         }
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            :         /*
<span class="lineNum">     977 </span>            :          * For simplicity, the decoded characters go in a single mbuf,
<span class="lineNum">     978 </span>            :          * so we allocate a single extra cluster mbuf if necessary.
<span class="lineNum">     979 </span>            :          */
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         if ((space -= codelen + extra) &lt; 0) {</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :             dmp-&gt;m_len = wptr - mtod(dmp, u_char *);</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :             MGET(m, M_DONTWAIT, MT_DATA);</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :             if (m == NULL) {</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 m_freem(mret);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :                 return DECOMP_ERROR;</span>
<span class="lineNum">     986 </span>            :             }
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :             m-&gt;m_len = 0;</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :             m-&gt;m_next = NULL;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :             dmp-&gt;m_next = m;</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :             MCLGET(m, M_DONTWAIT);</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :             space = M_TRAILINGSPACE(m) - (codelen + extra);</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :             if (space &lt; 0) {</span>
<span class="lineNum">     993 </span>            :                 /* now that's what I call *compression*. */
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :                 m_freem(mret);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :                 return DECOMP_ERROR;</span>
<span class="lineNum">     996 </span>            :             }
<span class="lineNum">     997 </span>            :             dmp = m;
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :             wptr = mtod(dmp, u_char *);</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :         /*
<span class="lineNum">    1002 </span>            :          * Decode this code and install it in the decompressed buffer.
<span class="lineNum">    1003 </span>            :          */
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         p = (wptr += codelen);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         while (finchar &gt; LAST) {</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :             dictp = &amp;db-&gt;dict[db-&gt;dict[finchar].cptr];</span>
<span class="lineNum">    1007 </span>            : #ifdef DEBUG
<span class="lineNum">    1008 </span>            :             if (--codelen &lt;= 0 || dictp-&gt;codem1 != finchar-1)
<span class="lineNum">    1009 </span>            :                 goto bad;
<span class="lineNum">    1010 </span>            : #endif
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :             *--p = dictp-&gt;f.hs.suffix;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :             finchar = dictp-&gt;f.hs.prefix;</span>
<span class="lineNum">    1013 </span>            :         }
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         *--p = finchar;</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : #ifdef DEBUG
<span class="lineNum">    1017 </span>            :         if (--codelen != 0)
<span class="lineNum">    1018 </span>            :             printf(&quot;bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x\n&quot;,
<span class="lineNum">    1019 </span>            :                    db-&gt;unit, codelen, incode, max_ent);
<span class="lineNum">    1020 </span>            : #endif
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :         if (extra)              /* the KwKwK case again */</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :             *wptr++ = finchar;</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :         /*
<span class="lineNum">    1026 </span>            :          * If not first code in a packet, and
<span class="lineNum">    1027 </span>            :          * if not out of code space, then allocate a new code.
<span class="lineNum">    1028 </span>            :          *
<span class="lineNum">    1029 </span>            :          * Keep the hash table correct so it can be used
<span class="lineNum">    1030 </span>            :          * with uncompressed packets.
<span class="lineNum">    1031 </span>            :          */
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :         if (oldcode != CLEAR &amp;&amp; max_ent &lt; db-&gt;maxmaxcode) {</span>
<span class="lineNum">    1033 </span>            :             struct bsd_dict *dictp2;
<span class="lineNum">    1034 </span>            :             u_int32_t fcode;
<span class="lineNum">    1035 </span>            :             u_int32_t hval, disp;
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :             fcode = BSD_KEY(oldcode,finchar);</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :             hval = BSD_HASH(oldcode,finchar,db-&gt;hshift);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :             dictp = &amp;db-&gt;dict[hval];</span>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :             /* look for a free hash table entry */
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :             if (dictp-&gt;codem1 &lt; max_ent) {</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                 disp = (hval == 0) ? 1 : hval;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :                 do {</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                     hval += disp;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                     if (hval &gt;= db-&gt;hsize)</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                         hval -= db-&gt;hsize;</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :                     dictp = &amp;db-&gt;dict[hval];</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                 } while (dictp-&gt;codem1 &lt; max_ent);</span>
<span class="lineNum">    1050 </span>            :             }
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :             /*
<span class="lineNum">    1053 </span>            :              * Invalidate previous hash table entry
<span class="lineNum">    1054 </span>            :              * assigned this code, and then take it over
<span class="lineNum">    1055 </span>            :              */
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :             dictp2 = &amp;db-&gt;dict[max_ent+1];</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :             if (db-&gt;dict[dictp2-&gt;cptr].codem1 == max_ent) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                 db-&gt;dict[dictp2-&gt;cptr].codem1 = BADCODEM1;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :             dictp2-&gt;cptr = hval;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :             dictp-&gt;codem1 = max_ent;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :             dictp-&gt;f.fcode = fcode;</span>
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :             db-&gt;max_ent = ++max_ent;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :             db-&gt;lens[max_ent] = db-&gt;lens[oldcode]+1;</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :             /* Expand code size if needed. */
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :             if (max_ent &gt;= MAXCODE(n_bits) &amp;&amp; max_ent &lt; db-&gt;maxmaxcode) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                 db-&gt;n_bits = ++n_bits;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                 tgtbitno = 32-n_bits;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1073 </span>            :         oldcode = incode;
<span class="lineNum">    1074 </span>            :     }
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :     dmp-&gt;m_len = wptr - mtod(dmp, u_char *);</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            :     /*
<span class="lineNum">    1078 </span>            :      * Keep the checkpoint right so that incompressible packets
<span class="lineNum">    1079 </span>            :      * clear the dictionary at the right times.
<span class="lineNum">    1080 </span>            :      */
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     db-&gt;bytes_out += ilen;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     db-&gt;in_count += explen;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     if (bsd_check(db) &amp;&amp; db-&gt;debug) {</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         printf(&quot;bsd_decomp%d: peer should have cleared dictionary\n&quot;,</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                db-&gt;unit);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     ++db-&gt;comp_count;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     db-&gt;comp_bytes += ilen + BSD_OVHD;</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     ++db-&gt;uncomp_count;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     db-&gt;uncomp_bytes += explen;</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     *dmpp = mret;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     return DECOMP_OK;</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            : #ifdef DEBUG
<span class="lineNum">    1097 </span>            :  bad:
<span class="lineNum">    1098 </span>            :     if (codelen &lt;= 0) {
<span class="lineNum">    1099 </span>            :         printf(&quot;bsd_decomp%d: fell off end of chain &quot;, db-&gt;unit);
<span class="lineNum">    1100 </span>            :         printf(&quot;0x%x at 0x%x by 0x%x, max_ent=0x%x\n&quot;,
<span class="lineNum">    1101 </span>            :                incode, finchar, db-&gt;dict[finchar].cptr, max_ent);
<span class="lineNum">    1102 </span>            :     } else if (dictp-&gt;codem1 != finchar-1) {
<span class="lineNum">    1103 </span>            :         printf(&quot;bsd_decomp%d: bad code chain 0x%x finchar=0x%x &quot;,
<span class="lineNum">    1104 </span>            :                db-&gt;unit, incode, finchar);
<span class="lineNum">    1105 </span>            :         printf(&quot;oldcode=0x%x cptr=0x%x codem1=0x%x\n&quot;, oldcode,
<span class="lineNum">    1106 </span>            :                db-&gt;dict[finchar].cptr, dictp-&gt;codem1);
<span class="lineNum">    1107 </span>            :     }
<span class="lineNum">    1108 </span>            :     m_freem(mret);
<span class="lineNum">    1109 </span>            :     return DECOMP_FATALERROR;
<span class="lineNum">    1110 </span>            : #endif /* DEBUG */
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1112 </span>            : #endif /* DO_BSD_COMPRESS */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
