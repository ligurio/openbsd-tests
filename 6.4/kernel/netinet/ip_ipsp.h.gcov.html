<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - netinet/ip_ipsp.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">netinet</a> - ip_ipsp.h<span style="font-size: 80%;"> (source / <a href="ip_ipsp.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: ip_ipsp.h,v 1.193 2018/08/28 15:15:02 mpi Exp $       */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * The authors of this code are John Ioannidis (ji@tla.org),
<span class="lineNum">       4 </span>            :  * Angelos D. Keromytis (kermit@csd.uch.gr),
<span class="lineNum">       5 </span>            :  * Niels Provos (provos@physnet.uni-hamburg.de) and
<span class="lineNum">       6 </span>            :  * Niklas Hallqvist (niklas@appli.se).
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * The original version of this code was written by John Ioannidis
<span class="lineNum">       9 </span>            :  * for BSD/OS in Athens, Greece, in November 1995.
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
<span class="lineNum">      12 </span>            :  * by Angelos D. Keromytis.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
<span class="lineNum">      15 </span>            :  * and Niels Provos.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * Additional features in 1999 by Angelos D. Keromytis and Niklas Hallqvist.
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  * Copyright (c) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
<span class="lineNum">      20 </span>            :  * Angelos D. Keromytis and Niels Provos.
<span class="lineNum">      21 </span>            :  * Copyright (c) 1999 Niklas Hallqvist.
<span class="lineNum">      22 </span>            :  * Copyright (c) 2001, Angelos D. Keromytis.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Permission to use, copy, and modify this software with or without fee
<span class="lineNum">      25 </span>            :  * is hereby granted, provided that this entire notice is included in
<span class="lineNum">      26 </span>            :  * all copies of any software which is or includes a copy or
<span class="lineNum">      27 </span>            :  * modification of this software.
<span class="lineNum">      28 </span>            :  * You may use this code under the GNU public license if you so wish. Please
<span class="lineNum">      29 </span>            :  * contribute changes back to the authors under this freer than GPL license
<span class="lineNum">      30 </span>            :  * so that we may further the use of strong encryption without limitations to
<span class="lineNum">      31 </span>            :  * all.
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR
<span class="lineNum">      34 </span>            :  * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
<span class="lineNum">      35 </span>            :  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
<span class="lineNum">      36 </span>            :  * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
<span class="lineNum">      37 </span>            :  * PURPOSE.
<span class="lineNum">      38 </span>            :  */
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #ifndef _NETINET_IPSP_H_
<span class="lineNum">      41 </span>            : #define _NETINET_IPSP_H_
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /* IPSP global definitions. */
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;netinet/in.h&gt;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : union sockaddr_union {
<span class="lineNum">      49 </span>            :         struct sockaddr         sa;
<span class="lineNum">      50 </span>            :         struct sockaddr_in      sin;
<span class="lineNum">      51 </span>            :         struct sockaddr_in6     sin6;
<span class="lineNum">      52 </span>            : };
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #define AH_HMAC_MAX_HASHLEN     32      /* 256 bits of authenticator for SHA512 */
<span class="lineNum">      55 </span>            : #define AH_HMAC_RPLENGTH        4       /* 32 bits of replay counter */
<span class="lineNum">      56 </span>            : #define AH_HMAC_INITIAL_RPL     1       /* Replay counter initial value */
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /* Authenticator lengths */
<span class="lineNum">      59 </span>            : #define AH_MD5_ALEN             16
<span class="lineNum">      60 </span>            : #define AH_SHA1_ALEN            20
<span class="lineNum">      61 </span>            : #define AH_RMD160_ALEN          20
<span class="lineNum">      62 </span>            : #define AH_SHA2_256_ALEN        32
<span class="lineNum">      63 </span>            : #define AH_SHA2_384_ALEN        48
<span class="lineNum">      64 </span>            : #define AH_SHA2_512_ALEN        64
<span class="lineNum">      65 </span>            : #define AH_ALEN_MAX             64      /* Keep updated */
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* Reserved SPI numbers */
<span class="lineNum">      68 </span>            : #define SPI_LOCAL_USE           0
<span class="lineNum">      69 </span>            : #define SPI_RESERVED_MIN        1
<span class="lineNum">      70 </span>            : #define SPI_RESERVED_MAX        255
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* Reserved CPI numbers */
<span class="lineNum">      73 </span>            : #define CPI_RESERVED_MIN        1
<span class="lineNum">      74 </span>            : #define CPI_RESERVED_MAX        255
<span class="lineNum">      75 </span>            : #define CPI_PRIVATE_MIN         61440
<span class="lineNum">      76 </span>            : #define CPI_PRIVATE_MAX         65535
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /* sysctl default values */
<span class="lineNum">      79 </span>            : #define IPSEC_DEFAULT_EMBRYONIC_SA_TIMEOUT      60      /* 1 minute */
<span class="lineNum">      80 </span>            : #define IPSEC_DEFAULT_PFS                       1
<span class="lineNum">      81 </span>            : #define IPSEC_DEFAULT_SOFT_ALLOCATIONS          0
<span class="lineNum">      82 </span>            : #define IPSEC_DEFAULT_EXP_ALLOCATIONS           0
<span class="lineNum">      83 </span>            : #define IPSEC_DEFAULT_SOFT_BYTES                0
<span class="lineNum">      84 </span>            : #define IPSEC_DEFAULT_EXP_BYTES                 0
<span class="lineNum">      85 </span>            : #define IPSEC_DEFAULT_SOFT_TIMEOUT              80000
<span class="lineNum">      86 </span>            : #define IPSEC_DEFAULT_EXP_TIMEOUT               86400
<span class="lineNum">      87 </span>            : #define IPSEC_DEFAULT_SOFT_FIRST_USE            3600
<span class="lineNum">      88 </span>            : #define IPSEC_DEFAULT_EXP_FIRST_USE             7200
<span class="lineNum">      89 </span>            : #define IPSEC_DEFAULT_DEF_ENC                   &quot;aes&quot;
<span class="lineNum">      90 </span>            : #define IPSEC_DEFAULT_DEF_AUTH                  &quot;hmac-sha1&quot;
<span class="lineNum">      91 </span>            : #define IPSEC_DEFAULT_EXPIRE_ACQUIRE            30
<span class="lineNum">      92 </span>            : #define IPSEC_DEFAULT_DEF_COMP                  &quot;deflate&quot;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : struct sockaddr_encap {
<span class="lineNum">      95 </span>            :         u_int8_t        sen_len;                /* length */
<span class="lineNum">      96 </span>            :         u_int8_t        sen_family;             /* PF_KEY */
<span class="lineNum">      97 </span>            :         u_int16_t       sen_type;               /* see SENT_* */
<span class="lineNum">      98 </span>            :         union {
<span class="lineNum">      99 </span>            :                 struct {                                /* SENT_IP4 */
<span class="lineNum">     100 </span>            :                         u_int8_t        Direction;
<span class="lineNum">     101 </span>            :                         struct in_addr  Src;
<span class="lineNum">     102 </span>            :                         struct in_addr  Dst;
<span class="lineNum">     103 </span>            :                         u_int8_t        Proto;
<span class="lineNum">     104 </span>            :                         u_int16_t       Sport;
<span class="lineNum">     105 </span>            :                         u_int16_t       Dport;
<span class="lineNum">     106 </span>            :                 } Sip4;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :                 struct {                                /* SENT_IP6 */
<span class="lineNum">     109 </span>            :                         u_int8_t        Direction;
<span class="lineNum">     110 </span>            :                         struct in6_addr Src;
<span class="lineNum">     111 </span>            :                         struct in6_addr Dst;
<span class="lineNum">     112 </span>            :                         u_int8_t        Proto;
<span class="lineNum">     113 </span>            :                         u_int16_t       Sport;
<span class="lineNum">     114 </span>            :                         u_int16_t       Dport;
<span class="lineNum">     115 </span>            :                 } Sip6;
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :                 struct ipsec_policy     *PolicyHead;    /* SENT_IPSP */
<span class="lineNum">     118 </span>            :         } Sen;
<span class="lineNum">     119 </span>            : };
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : #define IPSP_DIRECTION_IN       0x1
<span class="lineNum">     122 </span>            : #define IPSP_DIRECTION_OUT      0x2
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : struct ipsecstat {
<span class="lineNum">     125 </span>            :         uint64_t        ipsec_tunnels;          /* Number of active tunnels */
<span class="lineNum">     126 </span>            :         uint64_t        ipsec_prevtunnels;      /* Past number of tunnels */
<span class="lineNum">     127 </span>            :         uint64_t        ipsec_ipackets;         /* Input IPsec packets */
<span class="lineNum">     128 </span>            :         uint64_t        ipsec_opackets;         /* Output IPsec packets */
<span class="lineNum">     129 </span>            :         uint64_t        ipsec_ibytes;           /* Input bytes */
<span class="lineNum">     130 </span>            :         uint64_t        ipsec_obytes;           /* Output bytes */
<span class="lineNum">     131 </span>            :         uint64_t        ipsec_idecompbytes;     /* Input bytes, decompressed */
<span class="lineNum">     132 </span>            :         uint64_t        ipsec_ouncompbytes;     /* Output bytes, uncompressed */
<span class="lineNum">     133 </span>            :         uint64_t        ipsec_idrops;           /* Dropped on input */
<span class="lineNum">     134 </span>            :         uint64_t        ipsec_odrops;           /* Dropped on output */
<span class="lineNum">     135 </span>            :         uint64_t        ipsec_crypto;           /* Crypto processing failure */
<span class="lineNum">     136 </span>            :         uint64_t        ipsec_notdb;            /* Expired while in crypto */
<span class="lineNum">     137 </span>            :         uint64_t        ipsec_noxform;          /* Crypto error */
<span class="lineNum">     138 </span>            : };
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : struct tdb_data {
<span class="lineNum">     141 </span>            :         uint64_t        tdd_ipackets;           /* Input IPsec packets */
<span class="lineNum">     142 </span>            :         uint64_t        tdd_opackets;           /* Output IPsec packets */
<span class="lineNum">     143 </span>            :         uint64_t        tdd_ibytes;             /* Input bytes */
<span class="lineNum">     144 </span>            :         uint64_t        tdd_obytes;             /* Output bytes */
<span class="lineNum">     145 </span>            :         uint64_t        tdd_idrops;             /* Dropped on input */
<span class="lineNum">     146 </span>            :         uint64_t        tdd_odrops;             /* Dropped on output */
<span class="lineNum">     147 </span>            :         uint64_t        tdd_idecompbytes;       /* Input bytes, decompressed */
<span class="lineNum">     148 </span>            :         uint64_t        tdd_ouncompbytes;       /* Output bytes, uncompressed */
<span class="lineNum">     149 </span>            : };
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : #ifdef _KERNEL
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : #include &lt;sys/timeout.h&gt;
<span class="lineNum">     154 </span>            : #include &lt;sys/tree.h&gt;
<span class="lineNum">     155 </span>            : #include &lt;sys/queue.h&gt;
<span class="lineNum">     156 </span>            : #include &lt;net/radix.h&gt;
<span class="lineNum">     157 </span>            : #include &lt;sys/percpu.h&gt;
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : enum ipsec_counters {
<span class="lineNum">     160 </span>            :         ipsec_tunnels,
<span class="lineNum">     161 </span>            :         ipsec_prevtunnels,
<span class="lineNum">     162 </span>            :         ipsec_ipackets,
<span class="lineNum">     163 </span>            :         ipsec_opackets,
<span class="lineNum">     164 </span>            :         ipsec_ibytes,
<span class="lineNum">     165 </span>            :         ipsec_obytes,
<span class="lineNum">     166 </span>            :         ipsec_idecompbytes,
<span class="lineNum">     167 </span>            :         ipsec_ouncompbytes,
<span class="lineNum">     168 </span>            :         ipsec_idrops,
<span class="lineNum">     169 </span>            :         ipsec_odrops,
<span class="lineNum">     170 </span>            :         ipsec_crypto,
<span class="lineNum">     171 </span>            :         ipsec_notdb,
<span class="lineNum">     172 </span>            :         ipsec_noxform,
<span class="lineNum">     173 </span>            :         ipsec_ncounters
<span class="lineNum">     174 </span>            : };
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : extern struct cpumem *ipseccounters;
<a name="177"><span class="lineNum">     177 </span>            : </a>
<span class="lineNum">     178 </span>            : static inline void
<span class="lineNum">     179 </span><span class="lineNoCov">          0 : ipsecstat_inc(enum ipsec_counters c)</span>
<span class="lineNum">     180 </span>            : {
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         counters_inc(ipseccounters, c);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 : }</span>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<span class="lineNum">     184 </span>            : static inline void
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : ipsecstat_dec(enum ipsec_counters c)</span>
<span class="lineNum">     186 </span>            : {
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         counters_dec(ipseccounters, c);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 : }</span>
<a name="189"><span class="lineNum">     189 </span>            : </a>
<span class="lineNum">     190 </span>            : static inline void
<span class="lineNum">     191 </span><span class="lineNoCov">          0 : ipsecstat_add(enum ipsec_counters c, uint64_t v)</span>
<span class="lineNum">     192 </span>            : {
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         counters_add(ipseccounters, c, v);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : struct m_tag;
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : #define sen_data                Sen.Data
<span class="lineNum">     199 </span>            : #define sen_ip_src              Sen.Sip4.Src
<span class="lineNum">     200 </span>            : #define sen_ip_dst              Sen.Sip4.Dst
<span class="lineNum">     201 </span>            : #define sen_proto               Sen.Sip4.Proto
<span class="lineNum">     202 </span>            : #define sen_sport               Sen.Sip4.Sport
<span class="lineNum">     203 </span>            : #define sen_dport               Sen.Sip4.Dport
<span class="lineNum">     204 </span>            : #define sen_direction           Sen.Sip4.Direction
<span class="lineNum">     205 </span>            : #define sen_ip6_src             Sen.Sip6.Src
<span class="lineNum">     206 </span>            : #define sen_ip6_dst             Sen.Sip6.Dst
<span class="lineNum">     207 </span>            : #define sen_ip6_proto           Sen.Sip6.Proto
<span class="lineNum">     208 </span>            : #define sen_ip6_sport           Sen.Sip6.Sport
<span class="lineNum">     209 </span>            : #define sen_ip6_dport           Sen.Sip6.Dport
<span class="lineNum">     210 </span>            : #define sen_ip6_direction       Sen.Sip6.Direction
<span class="lineNum">     211 </span>            : #define sen_ipsp                Sen.PolicyHead
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : /*
<span class="lineNum">     214 </span>            :  * The &quot;type&quot; is really part of the address as far as the routing
<span class="lineNum">     215 </span>            :  * system is concerned. By using only one bit in the type field
<span class="lineNum">     216 </span>            :  * for each type, we sort-of make sure that different types of
<span class="lineNum">     217 </span>            :  * encapsulation addresses won't be matched against the wrong type.
<span class="lineNum">     218 </span>            :  *
<span class="lineNum">     219 </span>            :  */
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            : #define SENT_IP4        0x0001          /* data is two struct in_addr */
<span class="lineNum">     222 </span>            : #define SENT_IPSP       0x0002          /* data as in IP4/6 plus SPI */
<span class="lineNum">     223 </span>            : #define SENT_IP6        0x0004
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : #define SENT_LEN        sizeof(struct sockaddr_encap)
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : struct ipsec_id {
<span class="lineNum">     228 </span>            :         u_int16_t       type;           /* Subtype of data */
<span class="lineNum">     229 </span>            :         int16_t         len;            /* Length of data following */
<span class="lineNum">     230 </span>            : };
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : struct ipsec_ids {
<span class="lineNum">     233 </span>            :         RBT_ENTRY(ipsec_ids)    id_node_id;
<span class="lineNum">     234 </span>            :         RBT_ENTRY(ipsec_ids)    id_node_flow;
<span class="lineNum">     235 </span>            :         struct ipsec_id         *id_local;
<span class="lineNum">     236 </span>            :         struct ipsec_id         *id_remote;
<span class="lineNum">     237 </span>            :         u_int32_t               id_flow;
<span class="lineNum">     238 </span>            :         int                     id_refcount;
<span class="lineNum">     239 </span>            :         struct timeout          id_timeout;
<span class="lineNum">     240 </span>            : };
<span class="lineNum">     241 </span>            : RBT_HEAD(ipsec_ids_flows, ipsec_ids);
<span class="lineNum">     242 </span>            : RBT_HEAD(ipsec_ids_tree, ipsec_ids);
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : struct ipsec_acquire {
<span class="lineNum">     245 </span>            :         union sockaddr_union            ipa_addr;
<span class="lineNum">     246 </span>            :         u_int32_t                       ipa_seq;
<span class="lineNum">     247 </span>            :         struct sockaddr_encap           ipa_info;
<span class="lineNum">     248 </span>            :         struct sockaddr_encap           ipa_mask;
<span class="lineNum">     249 </span>            :         struct timeout                  ipa_timeout;
<span class="lineNum">     250 </span>            :         struct ipsec_policy             *ipa_policy;
<span class="lineNum">     251 </span>            :         struct inpcb                    *ipa_pcb;
<span class="lineNum">     252 </span>            :         TAILQ_ENTRY(ipsec_acquire)      ipa_ipo_next;
<span class="lineNum">     253 </span>            :         TAILQ_ENTRY(ipsec_acquire)      ipa_next;
<span class="lineNum">     254 </span>            : };
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : struct ipsec_policy {
<span class="lineNum">     257 </span>            :         struct radix_node       ipo_nodes[2];   /* radix tree glue */
<span class="lineNum">     258 </span>            :         struct sockaddr_encap   ipo_addr;
<span class="lineNum">     259 </span>            :         struct sockaddr_encap   ipo_mask;
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :         union sockaddr_union    ipo_src;        /* Local address to use */
<span class="lineNum">     262 </span>            :         union sockaddr_union    ipo_dst;        /* Remote gateway -- if it's zeroed:
<span class="lineNum">     263 </span>            :                                                  * - on output, we try to
<span class="lineNum">     264 </span>            :                                                  * contact the remote host
<span class="lineNum">     265 </span>            :                                                  * directly (if needed).  
<span class="lineNum">     266 </span>            :                                                  * - on input, we accept on if
<span class="lineNum">     267 </span>            :                                                  * the inner source is the
<span class="lineNum">     268 </span>            :                                                  * same as the outer source
<span class="lineNum">     269 </span>            :                                                  * address, or if transport
<span class="lineNum">     270 </span>            :                                                  * mode was used.
<span class="lineNum">     271 </span>            :                                                  */
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :         u_int64_t               ipo_last_searched;      /* Timestamp of last lookup */
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :         u_int8_t                ipo_flags;      /* See IPSP_POLICY_* definitions */
<span class="lineNum">     276 </span>            :         u_int8_t                ipo_type;       /* USE/ACQUIRE/... */
<span class="lineNum">     277 </span>            :         u_int8_t                ipo_sproto;     /* ESP/AH; if zero, use system dflts */
<span class="lineNum">     278 </span>            :         u_int                   ipo_rdomain;
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :         int                     ipo_ref_count;
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :         struct tdb              *ipo_tdb;               /* Cached entry */
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :         struct ipsec_ids        *ipo_ids;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :         TAILQ_HEAD(ipo_acquires_head, ipsec_acquire) ipo_acquires; /* List of acquires */
<span class="lineNum">     287 </span>            :         TAILQ_ENTRY(ipsec_policy)       ipo_tdb_next;   /* List TDB policies */
<span class="lineNum">     288 </span>            :         TAILQ_ENTRY(ipsec_policy)       ipo_list;       /* List of all policies */
<span class="lineNum">     289 </span>            : };
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : #define IPSP_POLICY_NONE        0x0000  /* No flags set */
<span class="lineNum">     292 </span>            : #define IPSP_POLICY_STATIC      0x0002  /* Static policy */
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : #define IPSP_IPSEC_USE          0       /* Use if existing, don't acquire */
<span class="lineNum">     295 </span>            : #define IPSP_IPSEC_ACQUIRE      1       /* Try acquire, let packet through */
<span class="lineNum">     296 </span>            : #define IPSP_IPSEC_REQUIRE      2       /* Require SA */
<span class="lineNum">     297 </span>            : #define IPSP_PERMIT             3       /* Permit traffic through */
<span class="lineNum">     298 </span>            : #define IPSP_DENY               4       /* Deny traffic */
<span class="lineNum">     299 </span>            : #define IPSP_IPSEC_DONTACQ      5       /* Require, but don't acquire */
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : /* Identity types */
<span class="lineNum">     302 </span>            : #define IPSP_IDENTITY_NONE              0
<span class="lineNum">     303 </span>            : #define IPSP_IDENTITY_PREFIX            1
<span class="lineNum">     304 </span>            : #define IPSP_IDENTITY_FQDN              2
<span class="lineNum">     305 </span>            : #define IPSP_IDENTITY_USERFQDN          3
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : struct tdb {                            /* tunnel descriptor block */
<span class="lineNum">     308 </span>            :         /*
<span class="lineNum">     309 </span>            :          * Each TDB is on three hash tables: one keyed on dst/spi/sproto,
<span class="lineNum">     310 </span>            :          * one keyed on dst/sproto, and one keyed on src/sproto. The first
<span class="lineNum">     311 </span>            :          * is used for finding a specific TDB, the second for finding TDBs
<span class="lineNum">     312 </span>            :          * for outgoing policy matching, and the third for incoming
<span class="lineNum">     313 </span>            :          * policy matching. The following three fields maintain the hash
<span class="lineNum">     314 </span>            :          * queues in those three tables.
<span class="lineNum">     315 </span>            :          */
<span class="lineNum">     316 </span>            :         struct tdb      *tdb_hnext;     /* dst/spi/sproto table */
<span class="lineNum">     317 </span>            :         struct tdb      *tdb_dnext;     /* dst/sproto table */
<span class="lineNum">     318 </span>            :         struct tdb      *tdb_snext;     /* src/sproto table */
<span class="lineNum">     319 </span>            :         struct tdb      *tdb_inext;
<span class="lineNum">     320 </span>            :         struct tdb      *tdb_onext;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :         struct xformsw          *tdb_xform;             /* Transform to use */
<span class="lineNum">     323 </span>            :         struct enc_xform        *tdb_encalgxform;       /* Enc algorithm */
<span class="lineNum">     324 </span>            :         struct auth_hash        *tdb_authalgxform;      /* Auth algorithm */
<span class="lineNum">     325 </span>            :         struct comp_algo        *tdb_compalgxform;      /* Compression algo */
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : #define TDBF_UNIQUE             0x00001 /* This should not be used by others */
<span class="lineNum">     328 </span>            : #define TDBF_TIMER              0x00002 /* Absolute expiration timer in use */
<span class="lineNum">     329 </span>            : #define TDBF_BYTES              0x00004 /* Check the byte counters */
<span class="lineNum">     330 </span>            : #define TDBF_ALLOCATIONS        0x00008 /* Check the flows counters */
<span class="lineNum">     331 </span>            : #define TDBF_INVALID            0x00010 /* This SPI is not valid yet/anymore */
<span class="lineNum">     332 </span>            : #define TDBF_FIRSTUSE           0x00020 /* Expire after first use */
<span class="lineNum">     333 </span>            : #define TDBF_SOFT_TIMER         0x00080 /* Soft expiration */
<span class="lineNum">     334 </span>            : #define TDBF_SOFT_BYTES         0x00100 /* Soft expiration */
<span class="lineNum">     335 </span>            : #define TDBF_SOFT_ALLOCATIONS   0x00200 /* Soft expiration */
<span class="lineNum">     336 </span>            : #define TDBF_SOFT_FIRSTUSE      0x00400 /* Soft expiration */
<span class="lineNum">     337 </span>            : #define TDBF_PFS                0x00800 /* Ask for PFS from Key Mgmt. */
<span class="lineNum">     338 </span>            : #define TDBF_TUNNELING          0x01000 /* Force IP-IP encapsulation */
<span class="lineNum">     339 </span>            : #define TDBF_USEDTUNNEL         0x10000 /* Appended a tunnel header in past */
<span class="lineNum">     340 </span>            : #define TDBF_UDPENCAP           0x20000 /* UDP encapsulation */
<span class="lineNum">     341 </span>            : #define TDBF_PFSYNC             0x40000 /* TDB will be synced */
<span class="lineNum">     342 </span>            : #define TDBF_PFSYNC_RPL         0x80000 /* Replay counter should be bumped */
<span class="lineNum">     343 </span>            : #define TDBF_ESN                0x100000 /* 64-bit sequence numbers (ESN) */
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :         u_int32_t       tdb_flags;      /* Flags related to this TDB */
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :         struct timeout  tdb_timer_tmo;
<span class="lineNum">     348 </span>            :         struct timeout  tdb_first_tmo;
<span class="lineNum">     349 </span>            :         struct timeout  tdb_stimer_tmo;
<span class="lineNum">     350 </span>            :         struct timeout  tdb_sfirst_tmo;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :         u_int32_t       tdb_seq;                /* Tracking number for PFKEY */
<span class="lineNum">     353 </span>            :         u_int32_t       tdb_exp_allocations;    /* Expire after so many flows */
<span class="lineNum">     354 </span>            :         u_int32_t       tdb_soft_allocations;   /* Expiration warning */
<span class="lineNum">     355 </span>            :         u_int32_t       tdb_cur_allocations;    /* Total number of allocs */
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :         u_int64_t       tdb_exp_bytes;  /* Expire after so many bytes passed */
<span class="lineNum">     358 </span>            :         u_int64_t       tdb_soft_bytes; /* Expiration warning */
<span class="lineNum">     359 </span>            :         u_int64_t       tdb_cur_bytes;  /* Current count of bytes */
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :         u_int64_t       tdb_exp_timeout;        /* When does the SPI expire */
<span class="lineNum">     362 </span>            :         u_int64_t       tdb_soft_timeout;       /* Send soft-expire warning */
<span class="lineNum">     363 </span>            :         u_int64_t       tdb_established;        /* When was SPI established */
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :         u_int64_t       tdb_first_use;          /* When was it first used */
<span class="lineNum">     366 </span>            :         u_int64_t       tdb_soft_first_use;     /* Soft warning */
<span class="lineNum">     367 </span>            :         u_int64_t       tdb_exp_first_use;      /* Expire if tdb_first_use +
<span class="lineNum">     368 </span>            :                                                  * tdb_exp_first_use &lt;= curtime
<span class="lineNum">     369 </span>            :                                                  */
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :         u_int64_t       tdb_last_used;  /* When was this SA last used */
<span class="lineNum">     372 </span>            :         u_int64_t       tdb_last_marked;/* Last SKIPCRYPTO status change */
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :         struct tdb_data tdb_data;       /* stats about this TDB */
<span class="lineNum">     375 </span>            :         u_int64_t       tdb_cryptoid;   /* Crypto session ID */
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :         u_int32_t       tdb_spi;        /* SPI */
<span class="lineNum">     378 </span>            :         u_int16_t       tdb_amxkeylen;  /* Raw authentication key length */
<span class="lineNum">     379 </span>            :         u_int16_t       tdb_emxkeylen;  /* Raw encryption key length */
<span class="lineNum">     380 </span>            :         u_int16_t       tdb_ivlen;      /* IV length */
<span class="lineNum">     381 </span>            :         u_int8_t        tdb_sproto;     /* IPsec protocol */
<span class="lineNum">     382 </span>            :         u_int8_t        tdb_wnd;        /* Replay window */
<span class="lineNum">     383 </span>            :         u_int8_t        tdb_satype;     /* SA type (RFC2367, PF_KEY) */
<span class="lineNum">     384 </span>            :         u_int8_t        tdb_updates;    /* pfsync update counter */
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :         union sockaddr_union    tdb_dst;        /* Destination address */
<span class="lineNum">     387 </span>            :         union sockaddr_union    tdb_src;        /* Source address */
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :         u_int8_t        *tdb_amxkey;    /* Raw authentication key */
<span class="lineNum">     390 </span>            :         u_int8_t        *tdb_emxkey;    /* Raw encryption key */
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : #define TDB_REPLAYWASTE 32
<span class="lineNum">     393 </span>            : #define TDB_REPLAYMAX   (2100+TDB_REPLAYWASTE)
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :         u_int64_t       tdb_rpl;        /* Replay counter */
<span class="lineNum">     396 </span>            :         u_int32_t       tdb_seen[howmany(TDB_REPLAYMAX, 32)]; /* Anti-replay window */
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :         u_int8_t        tdb_iv[4];      /* Used for HALF-IV ESP */
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :         struct ipsec_ids        *tdb_ids;       /* Src/Dst ID for this SA */
<span class="lineNum">     401 </span>            :         int             tdb_ids_swapped;        /* XXX */
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :         u_int32_t       tdb_mtu;        /* MTU at this point in the chain */
<span class="lineNum">     404 </span>            :         u_int64_t       tdb_mtutimeout; /* When to ignore this entry */
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :         u_int16_t       tdb_udpencap_port;      /* Peer UDP port */
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :         u_int16_t       tdb_tag;                /* Packet filter tag */
<span class="lineNum">     409 </span>            :         u_int32_t       tdb_tap;                /* Alternate enc(4) interface */
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :         u_int           tdb_rdomain;            /* Routing domain */
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :         struct sockaddr_encap   tdb_filter; /* What traffic is acceptable */
<span class="lineNum">     414 </span>            :         struct sockaddr_encap   tdb_filtermask; /* And the mask */
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :         TAILQ_HEAD(tdb_policy_head, ipsec_policy)       tdb_policy_head;
<span class="lineNum">     417 </span>            :         TAILQ_ENTRY(tdb)        tdb_sync_entry;
<span class="lineNum">     418 </span>            : };
<span class="lineNum">     419 </span>            : #define tdb_ipackets            tdb_data.tdd_ipackets
<span class="lineNum">     420 </span>            : #define tdb_opackets            tdb_data.tdd_opackets
<span class="lineNum">     421 </span>            : #define tdb_ibytes              tdb_data.tdd_ibytes
<span class="lineNum">     422 </span>            : #define tdb_obytes              tdb_data.tdd_obytes
<span class="lineNum">     423 </span>            : #define tdb_idrops              tdb_data.tdd_idrops
<span class="lineNum">     424 </span>            : #define tdb_odrops              tdb_data.tdd_odrops
<span class="lineNum">     425 </span>            : #define tdb_idecompbytes        tdb_data.tdd_idecompbytes
<span class="lineNum">     426 </span>            : #define tdb_ouncompbytes        tdb_data.tdd_ouncompbytes
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : struct tdb_ident {
<span class="lineNum">     430 </span>            :         u_int32_t spi;
<span class="lineNum">     431 </span>            :         union sockaddr_union dst;
<span class="lineNum">     432 </span>            :         u_int8_t proto;
<span class="lineNum">     433 </span>            :         u_int rdomain;
<span class="lineNum">     434 </span>            : };
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : struct tdb_crypto {
<span class="lineNum">     437 </span>            :         u_int32_t               tc_spi;
<span class="lineNum">     438 </span>            :         union sockaddr_union    tc_dst;
<span class="lineNum">     439 </span>            :         u_int8_t                tc_proto;
<span class="lineNum">     440 </span>            :         int                     tc_protoff;
<span class="lineNum">     441 </span>            :         int                     tc_skip;
<span class="lineNum">     442 </span>            :         u_int                   tc_rdomain;
<span class="lineNum">     443 </span>            : };
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : struct ipsecinit {
<span class="lineNum">     446 </span>            :         u_int8_t        *ii_enckey;
<span class="lineNum">     447 </span>            :         u_int8_t        *ii_authkey;
<span class="lineNum">     448 </span>            :         u_int16_t       ii_enckeylen;
<span class="lineNum">     449 </span>            :         u_int16_t       ii_authkeylen;
<span class="lineNum">     450 </span>            :         u_int8_t        ii_encalg;
<span class="lineNum">     451 </span>            :         u_int8_t        ii_authalg;
<span class="lineNum">     452 </span>            :         u_int8_t        ii_compalg;
<span class="lineNum">     453 </span>            : };
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : /* xform IDs */
<span class="lineNum">     456 </span>            : #define XF_IP4          1       /* IP inside IP */
<span class="lineNum">     457 </span>            : #define XF_AH           2       /* AH */
<span class="lineNum">     458 </span>            : #define XF_ESP          3       /* ESP */
<span class="lineNum">     459 </span>            : #define XF_TCPSIGNATURE 5       /* TCP MD5 Signature option, RFC 2358 */
<span class="lineNum">     460 </span>            : #define XF_IPCOMP       6       /* IPCOMP */
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : /* xform attributes */
<span class="lineNum">     463 </span>            : #define XFT_AUTH        0x0001
<span class="lineNum">     464 </span>            : #define XFT_CONF        0x0100
<span class="lineNum">     465 </span>            : #define XFT_COMP        0x1000
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : #define IPSEC_ZEROES_SIZE       256     /* Larger than an IP6 extension hdr. */
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : struct xformsw {
<span class="lineNum">     470 </span>            :         u_short xf_type;                /* Unique ID of xform */
<span class="lineNum">     471 </span>            :         u_short xf_flags;               /* flags (see below) */
<span class="lineNum">     472 </span>            :         char    *xf_name;               /* human-readable name */
<span class="lineNum">     473 </span>            :         int     (*xf_attach)(void);     /* called at config time */
<span class="lineNum">     474 </span>            :         int     (*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
<span class="lineNum">     475 </span>            :         int     (*xf_zeroize)(struct tdb *); /* termination */
<span class="lineNum">     476 </span>            :         int     (*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
<span class="lineNum">     477 </span>            :         int     (*xf_output)(struct mbuf *, struct tdb *, struct mbuf **,
<span class="lineNum">     478 </span>            :             int, int);        /* output */
<span class="lineNum">     479 </span>            : };
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : extern int ipsec_in_use;
<span class="lineNum">     482 </span>            : extern u_int64_t ipsec_last_added;
<span class="lineNum">     483 </span>            : extern int ipsec_policy_pool_initialized;
<span class="lineNum">     484 </span>            : extern int encdebug;                    /* enable message reporting */
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : extern int ipsec_keep_invalid;          /* lifetime of embryonic SAs (in sec) */
<span class="lineNum">     487 </span>            : extern int ipsec_require_pfs;           /* use Perfect Forward Secrecy */
<span class="lineNum">     488 </span>            : extern int ipsec_expire_acquire;        /* wait for security assoc. (in sec) */
<span class="lineNum">     489 </span>            : extern int ipsec_soft_allocations;      /* flows/SA before renegotiation */
<span class="lineNum">     490 </span>            : extern int ipsec_exp_allocations;       /* num. of flows/SA before it expires */
<span class="lineNum">     491 </span>            : extern int ipsec_soft_bytes;            /* bytes/SA before renegotiation */
<span class="lineNum">     492 </span>            : extern int ipsec_exp_bytes;             /* num of bytes/SA before it expires */
<span class="lineNum">     493 </span>            : extern int ipsec_soft_timeout;          /* seconds/SA before renegotiation */
<span class="lineNum">     494 </span>            : extern int ipsec_exp_timeout;           /* seconds/SA before it expires */
<span class="lineNum">     495 </span>            : extern int ipsec_soft_first_use;        /* seconds between 1st asso &amp; renego */
<span class="lineNum">     496 </span>            : extern int ipsec_exp_first_use;         /* seconds between 1st asso &amp; expire */     
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : /*
<span class="lineNum">     499 </span>            :  * Names for IPsec sysctl objects
<span class="lineNum">     500 </span>            :  */
<span class="lineNum">     501 </span>            : #define IPSEC_ENCDEBUG                  IPCTL_ENCDEBUG                  /* 12 */
<span class="lineNum">     502 </span>            : #define IPSEC_STATS                     IPCTL_IPSEC_STATS               /* 13 */
<span class="lineNum">     503 </span>            : #define IPSEC_EXPIRE_ACQUIRE            IPCTL_IPSEC_EXPIRE_ACQUIRE      /* 14 */
<span class="lineNum">     504 </span>            : #define IPSEC_EMBRYONIC_SA_TIMEOUT      IPCTL_IPSEC_EMBRYONIC_SA_TIMEOUT/* 15 */
<span class="lineNum">     505 </span>            : #define IPSEC_REQUIRE_PFS               IPCTL_IPSEC_REQUIRE_PFS         /* 16 */
<span class="lineNum">     506 </span>            : #define IPSEC_SOFT_ALLOCATIONS          IPCTL_IPSEC_SOFT_ALLOCATIONS    /* 17 */
<span class="lineNum">     507 </span>            : #define IPSEC_ALLOCATIONS               IPCTL_IPSEC_ALLOCATIONS         /* 18 */
<span class="lineNum">     508 </span>            : #define IPSEC_SOFT_BYTES                IPCTL_IPSEC_SOFT_BYTES          /* 19 */
<span class="lineNum">     509 </span>            : #define IPSEC_BYTES                     IPCTL_IPSEC_BYTES               /* 20 */
<span class="lineNum">     510 </span>            : #define IPSEC_TIMEOUT                   IPCTL_IPSEC_TIMEOUT             /* 21 */
<span class="lineNum">     511 </span>            : #define IPSEC_SOFT_TIMEOUT              IPCTL_IPSEC_SOFT_TIMEOUT        /* 22 */
<span class="lineNum">     512 </span>            : #define IPSEC_SOFT_FIRSTUSE             IPCTL_IPSEC_SOFT_FIRSTUSE       /* 23 */
<span class="lineNum">     513 </span>            : #define IPSEC_FIRSTUSE                  IPCTL_IPSEC_FIRSTUSE            /* 24 */
<span class="lineNum">     514 </span>            : #define IPSEC_MAXID     25
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            : #define IPSECCTL_VARS { \
<span class="lineNum">     517 </span>            :         NULL, \
<span class="lineNum">     518 </span>            :         NULL, \
<span class="lineNum">     519 </span>            :         NULL, \
<span class="lineNum">     520 </span>            :         NULL, \
<span class="lineNum">     521 </span>            :         NULL, \
<span class="lineNum">     522 </span>            :         NULL, \
<span class="lineNum">     523 </span>            :         NULL, \
<span class="lineNum">     524 </span>            :         NULL, \
<span class="lineNum">     525 </span>            :         NULL, \
<span class="lineNum">     526 </span>            :         NULL, \
<span class="lineNum">     527 </span>            :         NULL, \
<span class="lineNum">     528 </span>            :         NULL, \
<span class="lineNum">     529 </span>            :         &amp;encdebug, \
<span class="lineNum">     530 </span>            :         NULL, /* ipsecstat */ \
<span class="lineNum">     531 </span>            :         &amp;ipsec_expire_acquire, \
<span class="lineNum">     532 </span>            :         &amp;ipsec_keep_invalid, \
<span class="lineNum">     533 </span>            :         &amp;ipsec_require_pfs, \
<span class="lineNum">     534 </span>            :         &amp;ipsec_soft_allocations, \
<span class="lineNum">     535 </span>            :         &amp;ipsec_exp_allocations, \
<span class="lineNum">     536 </span>            :         &amp;ipsec_soft_bytes, \
<span class="lineNum">     537 </span>            :         &amp;ipsec_exp_bytes, \
<span class="lineNum">     538 </span>            :         &amp;ipsec_exp_timeout, \
<span class="lineNum">     539 </span>            :         &amp;ipsec_soft_timeout, \
<span class="lineNum">     540 </span>            :         &amp;ipsec_soft_first_use, \
<span class="lineNum">     541 </span>            :         &amp;ipsec_exp_first_use, \
<span class="lineNum">     542 </span>            : }
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : extern char ipsec_def_enc[];
<span class="lineNum">     545 </span>            : extern char ipsec_def_auth[];
<span class="lineNum">     546 </span>            : extern char ipsec_def_comp[];
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : extern struct enc_xform enc_xform_des;
<span class="lineNum">     549 </span>            : extern struct enc_xform enc_xform_3des;
<span class="lineNum">     550 </span>            : extern struct enc_xform enc_xform_blf;
<span class="lineNum">     551 </span>            : extern struct enc_xform enc_xform_cast5;
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : extern struct auth_hash auth_hash_hmac_md5_96;
<span class="lineNum">     554 </span>            : extern struct auth_hash auth_hash_hmac_sha1_96;
<span class="lineNum">     555 </span>            : extern struct auth_hash auth_hash_hmac_ripemd_160_96;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : extern struct comp_algo comp_algo_deflate;
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            : extern TAILQ_HEAD(ipsec_policy_head, ipsec_policy) ipsec_policy_head;
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : struct cryptop;
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : /* Misc. */
<span class="lineNum">     564 </span>            : #ifdef ENCDEBUG
<span class="lineNum">     565 </span>            : const char *ipsp_address(union sockaddr_union *, char *, socklen_t);
<span class="lineNum">     566 </span>            : #endif /* ENCDEBUG */
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : /* SPD tables */
<span class="lineNum">     569 </span>            : struct radix_node_head *spd_table_add(unsigned int);
<span class="lineNum">     570 </span>            : struct radix_node_head *spd_table_get(unsigned int);
<span class="lineNum">     571 </span>            : int spd_table_walk(unsigned int,
<span class="lineNum">     572 </span>            :     int (*walker)(struct ipsec_policy *, void *, unsigned int), void *);
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            : /* TDB management routines */
<span class="lineNum">     575 </span>            : uint32_t reserve_spi(u_int, u_int32_t, u_int32_t, union sockaddr_union *,
<span class="lineNum">     576 </span>            :                 union sockaddr_union *, u_int8_t, int *);
<span class="lineNum">     577 </span>            : struct  tdb *gettdb(u_int, u_int32_t, union sockaddr_union *, u_int8_t);
<span class="lineNum">     578 </span>            : struct  tdb *gettdbbydst(u_int, union sockaddr_union *, u_int8_t,
<span class="lineNum">     579 </span>            :                 struct ipsec_ids *,
<span class="lineNum">     580 </span>            :                 struct sockaddr_encap *, struct sockaddr_encap *);
<span class="lineNum">     581 </span>            : struct  tdb *gettdbbysrc(u_int, union sockaddr_union *, u_int8_t,
<span class="lineNum">     582 </span>            :                 struct ipsec_ids *,
<span class="lineNum">     583 </span>            :                 struct sockaddr_encap *, struct sockaddr_encap *);
<span class="lineNum">     584 </span>            : struct  tdb *gettdbbysrcdst(u_int, u_int32_t, union sockaddr_union *,
<span class="lineNum">     585 </span>            :                 union sockaddr_union *, u_int8_t);
<span class="lineNum">     586 </span>            : void    puttdb(struct tdb *);
<span class="lineNum">     587 </span>            : void    tdb_delete(struct tdb *);
<span class="lineNum">     588 </span>            : struct  tdb *tdb_alloc(u_int);
<span class="lineNum">     589 </span>            : void    tdb_free(struct tdb *);
<span class="lineNum">     590 </span>            : int     tdb_init(struct tdb *, u_int16_t, struct ipsecinit *);
<span class="lineNum">     591 </span>            : void    tdb_unlink(struct tdb *);
<span class="lineNum">     592 </span>            : int     tdb_walk(u_int, int (*)(struct tdb *, void *, int), void *);
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            : /* XF_IP4 */
<span class="lineNum">     595 </span>            : int     ipe4_attach(void);
<span class="lineNum">     596 </span>            : int     ipe4_init(struct tdb *, struct xformsw *, struct ipsecinit *);
<span class="lineNum">     597 </span>            : int     ipe4_zeroize(struct tdb *);
<span class="lineNum">     598 </span>            : int     ipe4_input(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            : /* XF_AH */
<span class="lineNum">     601 </span>            : int     ah_attach(void);
<span class="lineNum">     602 </span>            : int     ah_init(struct tdb *, struct xformsw *, struct ipsecinit *);
<span class="lineNum">     603 </span>            : int     ah_zeroize(struct tdb *);
<span class="lineNum">     604 </span>            : int     ah_input(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     605 </span>            : int     ah_input_cb(struct tdb *, struct tdb_crypto *, struct mbuf *, int);
<span class="lineNum">     606 </span>            : int     ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
<span class="lineNum">     607 </span>            : int     ah_output_cb(struct tdb *, struct tdb_crypto *, struct mbuf *, int,
<span class="lineNum">     608 </span>            :             int);
<span class="lineNum">     609 </span>            : int     ah_sysctl(int *, u_int, void *, size_t *, void *, size_t);
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : int     ah4_input(struct mbuf **, int *, int, int);
<span class="lineNum">     612 </span>            : void    ah4_ctlinput(int, struct sockaddr *, u_int, void *);
<span class="lineNum">     613 </span>            : void    udpencap_ctlinput(int, struct sockaddr *, u_int, void *);
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            : #ifdef INET6
<span class="lineNum">     616 </span>            : int     ah6_input(struct mbuf **, int *, int, int);
<span class="lineNum">     617 </span>            : #endif /* INET6 */
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : /* XF_ESP */
<span class="lineNum">     620 </span>            : int     esp_attach(void);
<span class="lineNum">     621 </span>            : int     esp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
<span class="lineNum">     622 </span>            : int     esp_zeroize(struct tdb *);
<span class="lineNum">     623 </span>            : int     esp_input(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     624 </span>            : int     esp_input_cb(struct tdb *, struct tdb_crypto *, struct mbuf *, int);
<span class="lineNum">     625 </span>            : int     esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
<span class="lineNum">     626 </span>            : int     esp_output_cb(struct tdb *, struct tdb_crypto *, struct mbuf *, int,
<span class="lineNum">     627 </span>            :             int);
<span class="lineNum">     628 </span>            : int     esp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : int     esp4_input(struct mbuf **, int *, int, int);
<span class="lineNum">     631 </span>            : void    esp4_ctlinput(int, struct sockaddr *, u_int, void *);
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            : #ifdef INET6
<span class="lineNum">     634 </span>            : int     esp6_input(struct mbuf **, int *, int, int);
<span class="lineNum">     635 </span>            : #endif /* INET6 */
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : /* XF_IPCOMP */
<span class="lineNum">     638 </span>            : int     ipcomp_attach(void);
<span class="lineNum">     639 </span>            : int     ipcomp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
<span class="lineNum">     640 </span>            : int     ipcomp_zeroize(struct tdb *);
<span class="lineNum">     641 </span>            : int     ipcomp_input(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     642 </span>            : int     ipcomp_input_cb(struct tdb *, struct tdb_crypto *, struct mbuf *, int);
<span class="lineNum">     643 </span>            : int     ipcomp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
<span class="lineNum">     644 </span>            : int     ipcomp_output_cb(struct tdb *, struct tdb_crypto *, struct mbuf *, int,
<span class="lineNum">     645 </span>            :             int);
<span class="lineNum">     646 </span>            : int     ipcomp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
<span class="lineNum">     647 </span>            : int     ipcomp4_input(struct mbuf **, int *, int, int);
<span class="lineNum">     648 </span>            : #ifdef INET6
<span class="lineNum">     649 </span>            : int     ipcomp6_input(struct mbuf **, int *, int, int);
<span class="lineNum">     650 </span>            : #endif /* INET6 */
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : /* XF_TCPSIGNATURE */
<span class="lineNum">     653 </span>            : int     tcp_signature_tdb_attach(void);
<span class="lineNum">     654 </span>            : int     tcp_signature_tdb_init(struct tdb *, struct xformsw *,
<span class="lineNum">     655 </span>            :             struct ipsecinit *);
<span class="lineNum">     656 </span>            : int     tcp_signature_tdb_zeroize(struct tdb *);
<span class="lineNum">     657 </span>            : int     tcp_signature_tdb_input(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     658 </span>            : int     tcp_signature_tdb_output(struct mbuf *, struct tdb *, struct mbuf **,
<span class="lineNum">     659 </span>            :           int, int);
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : /* Replay window */
<span class="lineNum">     662 </span>            : int     checkreplaywindow(struct tdb *, u_int32_t, u_int32_t *, int);
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : /* Packet processing */
<span class="lineNum">     665 </span>            : int     ipsp_process_packet(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     666 </span>            : int     ipsp_process_done(struct mbuf *, struct tdb *);
<span class="lineNum">     667 </span>            : struct  tdb *ipsp_spd_lookup(struct mbuf *, int, int, int *, int,
<span class="lineNum">     668 </span>            :             struct tdb *, struct inpcb *, u_int32_t);
<span class="lineNum">     669 </span>            : struct  tdb *ipsp_spd_inp(struct mbuf *, int, int, int *, int,
<span class="lineNum">     670 </span>            :             struct tdb *, struct inpcb *, struct ipsec_policy *);
<span class="lineNum">     671 </span>            : int     ipsp_is_unspecified(union sockaddr_union);
<span class="lineNum">     672 </span>            : int     ipsp_aux_match(struct tdb *, struct ipsec_ids *,
<span class="lineNum">     673 </span>            :             struct sockaddr_encap *, struct sockaddr_encap *);
<span class="lineNum">     674 </span>            : int     ipsp_ids_match(struct ipsec_ids *, struct ipsec_ids *);
<span class="lineNum">     675 </span>            : struct ipsec_ids *ipsp_ids_insert(struct ipsec_ids *);
<span class="lineNum">     676 </span>            : struct ipsec_ids *ipsp_ids_lookup(u_int32_t);
<span class="lineNum">     677 </span>            : void    ipsp_ids_free(struct ipsec_ids *);
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : void    ipsec_init(void);
<span class="lineNum">     680 </span>            : int     ipsec_sysctl(int *, u_int, void *, size_t *, void *, size_t);
<span class="lineNum">     681 </span>            : int     ipsec_common_input(struct mbuf *, int, int, int, int, int);
<span class="lineNum">     682 </span>            : void    ipsec_input_cb(struct cryptop *);
<span class="lineNum">     683 </span>            : void    ipsec_output_cb(struct cryptop *);
<span class="lineNum">     684 </span>            : int     ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int);
<span class="lineNum">     685 </span>            : int     ipsec_delete_policy(struct ipsec_policy *);
<span class="lineNum">     686 </span>            : ssize_t ipsec_hdrsz(struct tdb *);
<span class="lineNum">     687 </span>            : void    ipsec_adjust_mtu(struct mbuf *, u_int32_t);
<span class="lineNum">     688 </span>            : struct  ipsec_acquire *ipsec_get_acquire(u_int32_t);
<span class="lineNum">     689 </span>            : int     ipsec_forward_check(struct mbuf *, int, int);
<span class="lineNum">     690 </span>            : int     ipsec_local_check(struct mbuf *, int, int, int);
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            : #endif /* _KERNEL */
<span class="lineNum">     693 </span>            : #endif /* _NETINET_IPSP_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
