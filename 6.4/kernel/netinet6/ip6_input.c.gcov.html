<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - netinet6/ip6_input.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">netinet6</a> - ip6_input.c<span style="font-size: 80%;"> (source / <a href="ip6_input.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">642</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: ip6_input.c,v 1.215 2018/05/21 15:52:22 bluhm Exp $   */</a>
<span class="lineNum">       2 </span>            : /*      $KAME: ip6_input.c,v 1.188 2001/03/29 05:34:31 itojun Exp $     */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /*
<span class="lineNum">       5 </span>            :  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
<span class="lineNum">       6 </span>            :  * All rights reserved.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       9 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      10 </span>            :  * are met:
<span class="lineNum">      11 </span>            :  * 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      12 </span>            :  *    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      13 </span>            :  * 2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      14 </span>            :  *    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      15 </span>            :  *    documentation and/or other materials provided with the distribution.
<span class="lineNum">      16 </span>            :  * 3. Neither the name of the project nor the names of its contributors
<span class="lineNum">      17 </span>            :  *    may be used to endorse or promote products derived from this software
<span class="lineNum">      18 </span>            :  *    without specific prior written permission.
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
<span class="lineNum">      21 </span>            :  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      22 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      23 </span>            :  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
<span class="lineNum">      24 </span>            :  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
<span class="lineNum">      25 </span>            :  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
<span class="lineNum">      26 </span>            :  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
<span class="lineNum">      27 </span>            :  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
<span class="lineNum">      28 </span>            :  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
<span class="lineNum">      29 </span>            :  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
<span class="lineNum">      30 </span>            :  * SUCH DAMAGE.
<span class="lineNum">      31 </span>            :  */
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : /*
<span class="lineNum">      34 </span>            :  * Copyright (c) 1982, 1986, 1988, 1993
<span class="lineNum">      35 </span>            :  *      The Regents of the University of California.  All rights reserved.
<span class="lineNum">      36 </span>            :  *
<span class="lineNum">      37 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">      38 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      39 </span>            :  * are met:
<span class="lineNum">      40 </span>            :  * 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      41 </span>            :  *    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      42 </span>            :  * 2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      43 </span>            :  *    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      44 </span>            :  *    documentation and/or other materials provided with the distribution.
<span class="lineNum">      45 </span>            :  * 3. Neither the name of the University nor the names of its contributors
<span class="lineNum">      46 </span>            :  *    may be used to endorse or promote products derived from this software
<span class="lineNum">      47 </span>            :  *    without specific prior written permission.
<span class="lineNum">      48 </span>            :  *
<span class="lineNum">      49 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
<span class="lineNum">      50 </span>            :  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      51 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      52 </span>            :  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
<span class="lineNum">      53 </span>            :  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
<span class="lineNum">      54 </span>            :  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
<span class="lineNum">      55 </span>            :  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
<span class="lineNum">      56 </span>            :  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
<span class="lineNum">      57 </span>            :  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
<span class="lineNum">      58 </span>            :  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
<span class="lineNum">      59 </span>            :  * SUCH DAMAGE.
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  *      @(#)ip_input.c  8.2 (Berkeley) 1/4/94
<span class="lineNum">      62 </span>            :  */
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #include &quot;pf.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;carp.h&quot;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      68 </span>            : #include &lt;sys/systm.h&gt;
<span class="lineNum">      69 </span>            : #include &lt;sys/mbuf.h&gt;
<span class="lineNum">      70 </span>            : #include &lt;sys/domain.h&gt;
<span class="lineNum">      71 </span>            : #include &lt;sys/sysctl.h&gt;
<span class="lineNum">      72 </span>            : #include &lt;sys/protosw.h&gt;
<span class="lineNum">      73 </span>            : #include &lt;sys/socket.h&gt;
<span class="lineNum">      74 </span>            : #include &lt;sys/socketvar.h&gt;
<span class="lineNum">      75 </span>            : #include &lt;sys/errno.h&gt;
<span class="lineNum">      76 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      77 </span>            : #include &lt;sys/timeout.h&gt;
<span class="lineNum">      78 </span>            : #include &lt;sys/kernel.h&gt;
<span class="lineNum">      79 </span>            : #include &lt;sys/syslog.h&gt;
<span class="lineNum">      80 </span>            : #include &lt;sys/task.h&gt;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : #include &lt;net/if.h&gt;
<span class="lineNum">      83 </span>            : #include &lt;net/if_var.h&gt;
<span class="lineNum">      84 </span>            : #include &lt;net/if_types.h&gt;
<span class="lineNum">      85 </span>            : #include &lt;net/route.h&gt;
<span class="lineNum">      86 </span>            : #include &lt;net/netisr.h&gt;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : #include &lt;netinet/in.h&gt;
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #include &lt;netinet/ip.h&gt;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : #include &lt;netinet/in_pcb.h&gt;
<span class="lineNum">      93 </span>            : #include &lt;netinet/ip_var.h&gt;
<span class="lineNum">      94 </span>            : #include &lt;netinet6/in6_var.h&gt;
<span class="lineNum">      95 </span>            : #include &lt;netinet6/in6_ifattach.h&gt;
<span class="lineNum">      96 </span>            : #include &lt;netinet/ip6.h&gt;
<span class="lineNum">      97 </span>            : #include &lt;netinet6/ip6_var.h&gt;
<span class="lineNum">      98 </span>            : #include &lt;netinet/icmp6.h&gt;
<span class="lineNum">      99 </span>            : #include &lt;netinet6/nd6.h&gt;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : #include &lt;netinet6/ip6protosw.h&gt;
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : #include &quot;gif.h&quot;
<span class="lineNum">     104 </span>            : #include &quot;bpfilter.h&quot;
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : #ifdef MROUTING
<span class="lineNum">     107 </span>            : #include &lt;netinet6/ip6_mroute.h&gt;
<span class="lineNum">     108 </span>            : #endif
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : #if NPF &gt; 0
<span class="lineNum">     111 </span>            : #include &lt;net/pfvar.h&gt;
<span class="lineNum">     112 </span>            : #endif
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : #if NCARP &gt; 0
<span class="lineNum">     115 </span>            : #include &lt;netinet/ip_carp.h&gt;
<span class="lineNum">     116 </span>            : #endif
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : struct niqueue ip6intrq = NIQUEUE_INITIALIZER(IPQ_MAXLEN, NETISR_IPV6);
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : struct cpumem *ip6counters;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : uint8_t ip6_soiikey[IP6_SOIIKEY_LEN];
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : int ip6_ours(struct mbuf **, int *, int, int);
<span class="lineNum">     125 </span>            : int ip6_local(struct mbuf **, int *, int, int);
<span class="lineNum">     126 </span>            : int ip6_check_rh0hdr(struct mbuf *, int *);
<span class="lineNum">     127 </span>            : int ip6_hbhchcheck(struct mbuf *, int *, int *, int *);
<span class="lineNum">     128 </span>            : int ip6_hopopts_input(u_int32_t *, u_int32_t *, struct mbuf **, int *);
<span class="lineNum">     129 </span>            : struct mbuf *ip6_pullexthdr(struct mbuf *, size_t, int);
<span class="lineNum">     130 </span>            : int ip6_sysctl_soiikey(void *, size_t *, void *, size_t);
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : static struct mbuf_queue        ip6send_mq;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : static void ip6_send_dispatch(void *);
<span class="lineNum">     135 </span>            : static struct task ip6send_task =
<span class="lineNum">     136 </span>            :         TASK_INITIALIZER(ip6_send_dispatch, &amp;ip6send_mq);
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : /*
<span class="lineNum">     139 </span>            :  * IP6 initialization: fill in IP6 protocol switch table.
<span class="lineNum">     140 </span>            :  * All protocols not implemented in kernel go to raw IP6 protocol handler.
<a name="141"><span class="lineNum">     141 </span>            :  */</a>
<span class="lineNum">     142 </span>            : void
<span class="lineNum">     143 </span><span class="lineNoCov">          0 : ip6_init(void)</span>
<span class="lineNum">     144 </span>            : {
<span class="lineNum">     145 </span>            :         const struct protosw *pr;
<span class="lineNum">     146 </span>            :         int i;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :         pr = pffindproto(PF_INET6, IPPROTO_RAW, SOCK_RAW);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         if (pr == NULL)</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                 panic(&quot;ip6_init&quot;);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; IPPROTO_MAX; i++)</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :                 ip6_protox[i] = pr - inet6sw;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         for (pr = inet6domain.dom_protosw;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             pr &lt; inet6domain.dom_protoswNPROTOSW; pr++)</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :                 if (pr-&gt;pr_domain-&gt;dom_family == PF_INET6 &amp;&amp;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                     pr-&gt;pr_protocol &amp;&amp; pr-&gt;pr_protocol != IPPROTO_RAW &amp;&amp;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                     pr-&gt;pr_protocol &lt; IPPROTO_MAX)</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :                         ip6_protox[pr-&gt;pr_protocol] = pr - inet6sw;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         ip6_randomid_init();</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :         nd6_init();</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :         frag6_init();</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :         mq_init(&amp;ip6send_mq, 64, IPL_SOFTNET);</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :         ip6counters = counters_alloc(ip6s_ncounters);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : /*
<span class="lineNum">     169 </span>            :  * Enqueue packet for local delivery.  Queuing is used as a boundary
<span class="lineNum">     170 </span>            :  * between the network layer (input/forward path) running without
<span class="lineNum">     171 </span>            :  * KERNEL_LOCK() and the transport layer still needing it.
<a name="172"><span class="lineNum">     172 </span>            :  */</a>
<span class="lineNum">     173 </span>            : int
<span class="lineNum">     174 </span><span class="lineNoCov">          0 : ip6_ours(struct mbuf **mp, int *offp, int nxt, int af)</span>
<span class="lineNum">     175 </span>            : {
<span class="lineNum">     176 </span>            :         /* We are already in a IPv4/IPv6 local deliver loop. */
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         if (af != AF_UNSPEC)</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 return ip6_local(mp, offp, nxt, af);</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         niq_enqueue(&amp;ip6intrq, *mp);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         *mp = NULL;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :         return IPPROTO_DONE;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /*
<span class="lineNum">     186 </span>            :  * Dequeue and process locally delivered packets.
<a name="187"><span class="lineNum">     187 </span>            :  */</a>
<span class="lineNum">     188 </span>            : void
<span class="lineNum">     189 </span><span class="lineNoCov">          0 : ip6intr(void)</span>
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         struct mbuf *m;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         int off, nxt;</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :         while ((m = niq_dequeue(&amp;ip6intrq)) != NULL) {</span>
<span class="lineNum">     195 </span>            : #ifdef DIAGNOSTIC
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 if ((m-&gt;m_flags &amp; M_PKTHDR) == 0)</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                         panic(&quot;ip6intr no HDR&quot;);</span>
<span class="lineNum">     198 </span>            : #endif
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 off = 0;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :                 nxt = ip6_local(&amp;m, &amp;off, IPPROTO_IPV6, AF_UNSPEC);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 KASSERT(nxt == IPPROTO_DONE);</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : }</span>
<a name="204"><span class="lineNum">     204 </span>            : </a>
<span class="lineNum">     205 </span>            : void
<span class="lineNum">     206 </span><span class="lineNoCov">          0 : ipv6_input(struct ifnet *ifp, struct mbuf *m)</span>
<span class="lineNum">     207 </span>            : {
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         int off, nxt;</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         off = 0;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         nxt = ip6_input_if(&amp;m, &amp;off, IPPROTO_IPV6, AF_UNSPEC, ifp);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         KASSERT(nxt == IPPROTO_DONE);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : }</span>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<span class="lineNum">     215 </span>            : int
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : ip6_input_if(struct mbuf **mp, int *offp, int nxt, int af, struct ifnet *ifp)</span>
<span class="lineNum">     217 </span>            : {
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         struct mbuf *m = *mp;</span>
<span class="lineNum">     219 </span>            :         struct ip6_hdr *ip6;
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         struct sockaddr_in6 sin6;</span>
<span class="lineNum">     221 </span>            :         struct rtentry *rt = NULL;
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         int ours = 0;</span>
<span class="lineNum">     223 </span>            :         u_int16_t src_scope, dst_scope;
<span class="lineNum">     224 </span>            : #if NPF &gt; 0
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         struct in6_addr odst;</span>
<span class="lineNum">     226 </span>            : #endif
<span class="lineNum">     227 </span>            :         int srcrt = 0;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         KASSERT(*offp == 0);</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         ip6stat_inc(ip6s_total);</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         if (m-&gt;m_len &lt; sizeof(struct ip6_hdr)) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :                 if ((m = *mp = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :                         ip6stat_inc(ip6s_toosmall);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                         goto bad;</span>
<span class="lineNum">     237 </span>            :                 }
<span class="lineNum">     238 </span>            :         }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         if ((ip6-&gt;ip6_vfc &amp; IPV6_VERSION_MASK) != IPV6_VERSION) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badvers);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     245 </span>            :         }
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : #if NCARP &gt; 0
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         if (carp_lsdrop(ifp, m, AF_INET6, ip6-&gt;ip6_src.s6_addr32,</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :             ip6-&gt;ip6_dst.s6_addr32, (ip6-&gt;ip6_nxt == IPPROTO_ICMPV6 ? 0 : 1)))</span>
<span class="lineNum">     250 </span>            :                 goto bad;
<span class="lineNum">     251 </span>            : #endif
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         ip6stat_inc(ip6s_nxthist + ip6-&gt;ip6_nxt);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :         /*
<span class="lineNum">     255 </span>            :          * Check against address spoofing/corruption.
<span class="lineNum">     256 </span>            :          */
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         if (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_src) ||</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             IN6_IS_ADDR_UNSPECIFIED(&amp;ip6-&gt;ip6_dst)) {</span>
<span class="lineNum">     259 </span>            :                 /*
<span class="lineNum">     260 </span>            :                  * XXX: &quot;badscope&quot; is not very suitable for a multicast source.
<span class="lineNum">     261 </span>            :                  */
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badscope);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     264 </span>            :         }
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         if ((IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_src) ||</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :             IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_dst)) &amp;&amp;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :             (ifp-&gt;if_flags &amp; IFF_LOOPBACK) == 0) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :                     ip6stat_inc(ip6s_badscope);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :                     goto bad;</span>
<span class="lineNum">     270 </span>            :         }
<span class="lineNum">     271 </span>            :         /* Drop packets if interface ID portion is already filled. */
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         if (((IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src) &amp;&amp; ip6-&gt;ip6_src.s6_addr16[1]) ||</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :             (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst) &amp;&amp; ip6-&gt;ip6_dst.s6_addr16[1])) &amp;&amp;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :             (ifp-&gt;if_flags &amp; IFF_LOOPBACK) == 0) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badscope);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     277 </span>            :         }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         if (IN6_IS_ADDR_MC_INTFACELOCAL(&amp;ip6-&gt;ip6_dst) &amp;&amp;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :             !(m-&gt;m_flags &amp; M_LOOP)) {</span>
<span class="lineNum">     280 </span>            :                 /*
<span class="lineNum">     281 </span>            :                  * In this case, the packet should come from the loopback
<span class="lineNum">     282 </span>            :                  * interface.  However, we cannot just check the if_flags,
<span class="lineNum">     283 </span>            :                  * because ip6_mloopback() passes the &quot;actual&quot; interface
<span class="lineNum">     284 </span>            :                  * as the outgoing/incoming interface.
<span class="lineNum">     285 </span>            :                  */
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badscope);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     288 </span>            :         }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :         /*
<span class="lineNum">     291 </span>            :          * The following check is not documented in specs.  A malicious
<span class="lineNum">     292 </span>            :          * party may be able to use IPv4 mapped addr to confuse tcp/udp stack
<span class="lineNum">     293 </span>            :          * and bypass security checks (act as if it was from 127.0.0.1 by using
<span class="lineNum">     294 </span>            :          * IPv6 src ::ffff:127.0.0.1).  Be cautious.
<span class="lineNum">     295 </span>            :          *
<span class="lineNum">     296 </span>            :          * This check chokes if we are in an SIIT cloud.  As none of BSDs
<span class="lineNum">     297 </span>            :          * support IPv4-less kernel compilation, we cannot support SIIT
<span class="lineNum">     298 </span>            :          * environment at all.  So, it makes more sense for us to reject any
<span class="lineNum">     299 </span>            :          * malicious packets for non-SIIT environment, than try to do a
<span class="lineNum">     300 </span>            :          * partial support for SIIT environment.
<span class="lineNum">     301 </span>            :          */
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         if (IN6_IS_ADDR_V4MAPPED(&amp;ip6-&gt;ip6_src) ||</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :             IN6_IS_ADDR_V4MAPPED(&amp;ip6-&gt;ip6_dst)) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badscope);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     306 </span>            :         }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :         /*
<span class="lineNum">     309 </span>            :          * Reject packets with IPv4 compatible addresses (auto tunnel).
<span class="lineNum">     310 </span>            :          *
<span class="lineNum">     311 </span>            :          * The code forbids automatic tunneling as per RFC4213.
<span class="lineNum">     312 </span>            :          */
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         if (IN6_IS_ADDR_V4COMPAT(&amp;ip6-&gt;ip6_src) ||</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             IN6_IS_ADDR_V4COMPAT(&amp;ip6-&gt;ip6_dst)) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badscope);</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     317 </span>            :         }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :         /*
<span class="lineNum">     320 </span>            :          * If the packet has been received on a loopback interface it
<span class="lineNum">     321 </span>            :          * can be destinated to any local address, not necessarily to
<span class="lineNum">     322 </span>            :          * an address configured on `ifp'.
<span class="lineNum">     323 </span>            :          */
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         if (ifp-&gt;if_flags &amp; IFF_LOOPBACK) {</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src)) {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                         src_scope = ip6-&gt;ip6_src.s6_addr16[1];</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                         ip6-&gt;ip6_src.s6_addr16[1] = 0;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst)) {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                         dst_scope = ip6-&gt;ip6_dst.s6_addr16[1];</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                         ip6-&gt;ip6_dst.s6_addr16[1] = 0;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     333 </span>            :         }
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            : #if NPF &gt; 0
<span class="lineNum">     336 </span>            :         /*
<span class="lineNum">     337 </span>            :          * Packet filter
<span class="lineNum">     338 </span>            :          */
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         odst = ip6-&gt;ip6_dst;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :         if (pf_test(AF_INET6, PF_IN, ifp, mp) != PF_PASS)</span>
<span class="lineNum">     341 </span>            :                 goto bad;
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         m = *mp;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         if (m == NULL)</span>
<span class="lineNum">     344 </span>            :                 goto bad;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :         srcrt = !IN6_ARE_ADDR_EQUAL(&amp;odst, &amp;ip6-&gt;ip6_dst);</span>
<span class="lineNum">     348 </span>            : #endif
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :         /*
<span class="lineNum">     351 </span>            :          * Without embedded scope ID we cannot find link-local
<span class="lineNum">     352 </span>            :          * addresses in the routing table.
<span class="lineNum">     353 </span>            :          */
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         if (ifp-&gt;if_flags &amp; IFF_LOOPBACK) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src))</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                         ip6-&gt;ip6_src.s6_addr16[1] = src_scope;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                         ip6-&gt;ip6_dst.s6_addr16[1] = dst_scope;</span>
<span class="lineNum">     359 </span>            :         } else {
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src))</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                         ip6-&gt;ip6_src.s6_addr16[1] = htons(ifp-&gt;if_index);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :                         ip6-&gt;ip6_dst.s6_addr16[1] = htons(ifp-&gt;if_index);</span>
<span class="lineNum">     364 </span>            :         }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :         /*
<span class="lineNum">     367 </span>            :          * Be more secure than RFC5095 and scan for type 0 routing headers.
<span class="lineNum">     368 </span>            :          * If pf has already scanned the header chain, do not do it twice.
<span class="lineNum">     369 </span>            :          */
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         if (!(m-&gt;m_pkthdr.pf.flags &amp; PF_TAG_PROCESSED) &amp;&amp;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :             ip6_check_rh0hdr(m, offp)) {</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :                 icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, *offp);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                 m = *mp = NULL;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     376 </span>            :         }
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         if (IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_src) ||</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :             IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_dst)) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                 nxt = ip6_ours(mp, offp, nxt, af);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :                 goto out;</span>
<span class="lineNum">     382 </span>            :         }
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : #if NPF &gt; 0
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         if (pf_ouraddr(m) == 1) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :                 nxt = ip6_ours(mp, offp, nxt, af);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :                 goto out;</span>
<span class="lineNum">     388 </span>            :         }
<span class="lineNum">     389 </span>            : #endif
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :         /*
<span class="lineNum">     392 </span>            :          * Multicast check
<span class="lineNum">     393 </span>            :          */
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         if (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {</span>
<span class="lineNum">     395 </span>            :                 /*
<span class="lineNum">     396 </span>            :                  * Make sure M_MCAST is set.  It should theoretically
<span class="lineNum">     397 </span>            :                  * already be there, but let's play safe because upper
<span class="lineNum">     398 </span>            :                  * layers check for this flag.
<span class="lineNum">     399 </span>            :                  */
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                 m-&gt;m_flags |= M_MCAST;</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :                 /*
<span class="lineNum">     403 </span>            :                  * See if we belong to the destination multicast group on the
<span class="lineNum">     404 </span>            :                  * arrival interface.
<span class="lineNum">     405 </span>            :                  */
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                 if (in6_hasmulti(&amp;ip6-&gt;ip6_dst, ifp))</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                         ours = 1;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : #ifdef MROUTING
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                 if (ip6_mforwarding &amp;&amp; ip6_mrouter[ifp-&gt;if_rdomain]) {</span>
<span class="lineNum">     411 </span>            :                         int error;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :                         if (ip6_hbhchcheck(m, offp, &amp;nxt, &amp;ours))</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                                 goto out;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                         ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :                         /*
<span class="lineNum">     419 </span>            :                          * If we are acting as a multicast router, all
<span class="lineNum">     420 </span>            :                          * incoming multicast packets are passed to the
<span class="lineNum">     421 </span>            :                          * kernel-level multicast forwarding function.
<span class="lineNum">     422 </span>            :                          * The packet is returned (relatively) intact; if
<span class="lineNum">     423 </span>            :                          * ip6_mforward() returns a non-zero value, the packet
<span class="lineNum">     424 </span>            :                          * must be discarded, else it may be accepted below.
<span class="lineNum">     425 </span>            :                          */
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                         KERNEL_LOCK();</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                         error = ip6_mforward(ip6, ifp, m);</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                         KERNEL_UNLOCK();</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                         if (error) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_cantforward);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                                 goto bad;</span>
<span class="lineNum">     432 </span>            :                         }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                         if (ours) {</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                                 if (af == AF_UNSPEC) {</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                                         KERNEL_LOCK();</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                                         nxt = ip_deliver(mp, offp, nxt,</span>
<span class="lineNum">     438 </span>            :                                             AF_INET6);
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :                                         KERNEL_UNLOCK();</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                                 }</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                                 goto out;</span>
<span class="lineNum">     442 </span>            :                         }
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                         goto bad;</span>
<span class="lineNum">     444 </span>            :                 }
<span class="lineNum">     445 </span>            : #endif
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                 if (!ours) {</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                         ip6stat_inc(ip6s_notmember);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                         if (!IN6_IS_ADDR_MC_LINKLOCAL(&amp;ip6-&gt;ip6_dst))</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_cantforward);</span>
<span class="lineNum">     450 </span>            :                         goto bad;
<span class="lineNum">     451 </span>            :                 }
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                 nxt = ip6_ours(mp, offp, nxt, af);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 goto out;</span>
<span class="lineNum">     454 </span>            :         }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :         /*
<span class="lineNum">     458 </span>            :          *  Unicast check
<span class="lineNum">     459 </span>            :          */
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         memset(&amp;sin6, 0, sizeof(struct sockaddr_in6));</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         sin6.sin6_len = sizeof(struct sockaddr_in6);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :         sin6.sin6_family = AF_INET6;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         sin6.sin6_addr = ip6-&gt;ip6_dst;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         rt = rtalloc_mpath(sin6tosa(&amp;sin6), &amp;ip6-&gt;ip6_src.s6_addr32[0],</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             m-&gt;m_pkthdr.ph_rtableid);</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :         /*
<span class="lineNum">     468 </span>            :          * Accept the packet if the route to the destination is marked
<span class="lineNum">     469 </span>            :          * as local.
<span class="lineNum">     470 </span>            :          */
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         if (rtisvalid(rt) &amp;&amp; ISSET(rt-&gt;rt_flags, RTF_LOCAL)) {</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 struct in6_ifaddr *ia6 = ifatoia6(rt-&gt;rt_ifa);</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                 if (ia6-&gt;ia6_flags &amp; IN6_IFF_ANYCAST)</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         m-&gt;m_flags |= M_ACAST;</span>
<span class="lineNum">     475 </span>            :                 /*
<span class="lineNum">     476 </span>            :                  * packets to a tentative, duplicated, or somehow invalid
<span class="lineNum">     477 </span>            :                  * address must not be accepted.
<span class="lineNum">     478 </span>            :                  */
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                 if ((ia6-&gt;ia6_flags &amp; (IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED))) {</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                         char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                         inet_ntop(AF_INET6, &amp;ip6-&gt;ip6_src, src, sizeof(src));</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                         inet_ntop(AF_INET6, &amp;ip6-&gt;ip6_dst, dst, sizeof(dst));</span>
<span class="lineNum">     484 </span>            :                         /* address is not ready, so discard the packet. */
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                         nd6log((LOG_INFO,</span>
<span class="lineNum">     486 </span>            :                             &quot;%s: packet to an unready address %s-&gt;%s\n&quot;,
<span class="lineNum">     487 </span>            :                             __func__, src, dst));
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :                         goto bad;
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                         nxt = ip6_ours(mp, offp, nxt, af);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                         goto out;</span>
<span class="lineNum">     493 </span>            :                 }
<span class="lineNum">     494 </span>            :         }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : #if NCARP &gt; 0
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         if (ip6-&gt;ip6_nxt == IPPROTO_ICMPV6 &amp;&amp;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :             carp_lsdrop(ifp, m, AF_INET6, ip6-&gt;ip6_src.s6_addr32,</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :             ip6-&gt;ip6_dst.s6_addr32, 1))</span>
<span class="lineNum">     500 </span>            :                 goto bad;
<span class="lineNum">     501 </span>            : #endif
<span class="lineNum">     502 </span>            :         /*
<span class="lineNum">     503 </span>            :          * Now there is no reason to process the packet if it's not our own
<span class="lineNum">     504 </span>            :          * and we're not a router.
<span class="lineNum">     505 </span>            :          */
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :         if (!ip6_forwarding) {</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_cantforward);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     509 </span>            :         }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         if (ip6_hbhchcheck(m, offp, &amp;nxt, &amp;ours))</span>
<span class="lineNum">     512 </span>            :                 goto out;
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         if (ours) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                 if (af == AF_UNSPEC) {</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                         KERNEL_LOCK();</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                         nxt = ip_deliver(mp, offp, nxt, AF_INET6);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                         KERNEL_UNLOCK();</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     520 </span>            :                 goto out;
<span class="lineNum">     521 </span>            :         }
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            : #ifdef IPSEC
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         if (ipsec_in_use) {</span>
<span class="lineNum">     525 </span>            :                 int rv;
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                 rv = ipsec_forward_check(m, *offp, AF_INET6);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 if (rv != 0) {</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                         ip6stat_inc(ip6s_cantforward);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                         goto bad;</span>
<span class="lineNum">     531 </span>            :                 }
<span class="lineNum">     532 </span>            :                 /*
<span class="lineNum">     533 </span>            :                  * Fall through, forward packet. Outbound IPsec policy
<span class="lineNum">     534 </span>            :                  * checking will occur in ip6_forward().
<span class="lineNum">     535 </span>            :                  */
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     537 </span>            : #endif /* IPSEC */
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         ip6_forward(m, rt, srcrt);</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         *mp = NULL;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         return IPPROTO_DONE;</span>
<span class="lineNum">     542 </span>            :  bad:
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         nxt = IPPROTO_DONE;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         m_freemp(mp);</span>
<span class="lineNum">     545 </span>            :  out:
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         rtfree(rt);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         return nxt;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 : }</span>
<a name="549"><span class="lineNum">     549 </span>            : </a>
<span class="lineNum">     550 </span>            : int
<span class="lineNum">     551 </span><span class="lineNoCov">          0 : ip6_local(struct mbuf **mp, int *offp, int nxt, int af)</span>
<span class="lineNum">     552 </span>            : {
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         if (ip6_hbhchcheck(*mp, offp, &amp;nxt, NULL))</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :                 return IPPROTO_DONE;</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :         /* Check wheter we are already in a IPv4/IPv6 local deliver loop. */
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         if (af == AF_UNSPEC)</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 nxt = ip_deliver(mp, offp, nxt, AF_INET6);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         return nxt;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 : }</span>
<a name="561"><span class="lineNum">     561 </span>            : </a>
<span class="lineNum">     562 </span>            : int
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : ip6_hbhchcheck(struct mbuf *m, int *offp, int *nxtp, int *oursp)</span>
<span class="lineNum">     564 </span>            : {
<span class="lineNum">     565 </span>            :         struct ip6_hdr *ip6;
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :         u_int32_t plen, rtalert = ~0;</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :         /*
<span class="lineNum">     571 </span>            :          * Process Hop-by-Hop options header if it's contained.
<span class="lineNum">     572 </span>            :          * m may be modified in ip6_hopopts_input().
<span class="lineNum">     573 </span>            :          * If a JumboPayload option is included, plen will also be modified.
<span class="lineNum">     574 </span>            :          */
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         plen = (u_int32_t)ntohs(ip6-&gt;ip6_plen);</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         *offp = sizeof(struct ip6_hdr);</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         if (ip6-&gt;ip6_nxt == IPPROTO_HOPOPTS) {</span>
<span class="lineNum">     578 </span>            :                 struct ip6_hbh *hbh;
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :                 if (ip6_hopopts_input(&amp;plen, &amp;rtalert, &amp;m, offp)) {</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                         goto bad;       /* m have already been freed */</span>
<span class="lineNum">     582 </span>            :                 }
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :                 /* adjust pointer */
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                 ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :                 /*
<span class="lineNum">     588 </span>            :                  * if the payload length field is 0 and the next header field
<span class="lineNum">     589 </span>            :                  * indicates Hop-by-Hop Options header, then a Jumbo Payload
<span class="lineNum">     590 </span>            :                  * option MUST be included.
<span class="lineNum">     591 </span>            :                  */
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 if (ip6-&gt;ip6_plen == 0 &amp;&amp; plen == 0) {</span>
<span class="lineNum">     593 </span>            :                         /*
<span class="lineNum">     594 </span>            :                          * Note that if a valid jumbo payload option is
<span class="lineNum">     595 </span>            :                          * contained, ip6_hopopts_input() must set a valid
<span class="lineNum">     596 </span>            :                          * (non-zero) payload length to the variable plen.
<span class="lineNum">     597 </span>            :                          */
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                         ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                         icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     600 </span>            :                                     ICMP6_PARAMPROB_HEADER,
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                                     (caddr_t)&amp;ip6-&gt;ip6_plen - (caddr_t)ip6);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                         goto bad;</span>
<span class="lineNum">     603 </span>            :                 }
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m, sizeof(struct ip6_hdr),</span>
<span class="lineNum">     605 </span>            :                         sizeof(struct ip6_hbh));
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                 if (hbh == NULL) {</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                         ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                         goto bad;</span>
<span class="lineNum">     609 </span>            :                 }
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :                 *nxtp = hbh-&gt;ip6h_nxt;</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :                 /*
<span class="lineNum">     613 </span>            :                  * accept the packet if a router alert option is included
<span class="lineNum">     614 </span>            :                  * and we act as an IPv6 router.
<span class="lineNum">     615 </span>            :                  */
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                 if (rtalert != ~0 &amp;&amp; ip6_forwarding &amp;&amp; oursp != NULL)</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                         *oursp = 1;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         } else</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                 *nxtp = ip6-&gt;ip6_nxt;</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :         /*
<span class="lineNum">     622 </span>            :          * Check that the amount of data in the buffers
<span class="lineNum">     623 </span>            :          * is as at least much as the IPv6 header would have us expect.
<span class="lineNum">     624 </span>            :          * Trim mbufs if longer than we expect.
<span class="lineNum">     625 </span>            :          * Drop packet if shorter than we expect.
<span class="lineNum">     626 </span>            :          */
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :         if (m-&gt;m_pkthdr.len - sizeof(struct ip6_hdr) &lt; plen) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :                 m_freem(m);</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                 goto bad;</span>
<span class="lineNum">     631 </span>            :         }
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         if (m-&gt;m_pkthdr.len &gt; sizeof(struct ip6_hdr) + plen) {</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_len == m-&gt;m_pkthdr.len) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                         m-&gt;m_len = sizeof(struct ip6_hdr) + plen;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :                         m-&gt;m_pkthdr.len = sizeof(struct ip6_hdr) + plen;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :                 } else {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                         m_adj(m,</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                             sizeof(struct ip6_hdr) + plen - m-&gt;m_pkthdr.len);</span>
<span class="lineNum">     639 </span>            :                 }
<span class="lineNum">     640 </span>            :         }
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :  bad:
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         *nxtp = IPPROTO_DONE;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         return (-1);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     648 </span>            : 
<a name="649"><span class="lineNum">     649 </span>            : /* scan packet for RH0 routing header. Mostly stolen from pf.c:pf_test() */</a>
<span class="lineNum">     650 </span>            : int
<span class="lineNum">     651 </span><span class="lineNoCov">          0 : ip6_check_rh0hdr(struct mbuf *m, int *offp)</span>
<span class="lineNum">     652 </span>            : {
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :         struct ip6_rthdr rthdr;</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         struct ip6_ext opt6;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         u_int8_t proto = ip6-&gt;ip6_nxt;</span>
<span class="lineNum">     657 </span>            :         int done = 0, lim, off, rh_cnt = 0;
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         off = ((caddr_t)ip6 - m-&gt;m_data) + sizeof(struct ip6_hdr);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         lim = min(m-&gt;m_pkthdr.len, ntohs(ip6-&gt;ip6_plen) + sizeof(*ip6));</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :                 switch (proto) {</span>
<span class="lineNum">     663 </span>            :                 case IPPROTO_ROUTING:
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                         *offp = off;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                         if (rh_cnt++) {</span>
<span class="lineNum">     666 </span>            :                                 /* more than one rh header present */
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                                 return (1);</span>
<span class="lineNum">     668 </span>            :                         }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                         if (off + sizeof(rthdr) &gt; lim) {</span>
<span class="lineNum">     671 </span>            :                                 /* packet to short to make sense */
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :                                 return (1);</span>
<span class="lineNum">     673 </span>            :                         }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :                         m_copydata(m, off, sizeof(rthdr), (caddr_t)&amp;rthdr);</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :                         if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                                 *offp += offsetof(struct ip6_rthdr, ip6r_type);</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :                                 return (1);</span>
<span class="lineNum">     680 </span>            :                         }
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :                         off += (rthdr.ip6r_len + 1) * 8;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :                         proto = rthdr.ip6r_nxt;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     685 </span>            :                 case IPPROTO_AH:
<span class="lineNum">     686 </span>            :                 case IPPROTO_HOPOPTS:
<span class="lineNum">     687 </span>            :                 case IPPROTO_DSTOPTS:
<span class="lineNum">     688 </span>            :                         /* get next header and header length */
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :                         if (off + sizeof(opt6) &gt; lim) {</span>
<span class="lineNum">     690 </span>            :                                 /*
<span class="lineNum">     691 </span>            :                                  * Packet to short to make sense, we could
<span class="lineNum">     692 </span>            :                                  * reject the packet but as a router we
<span class="lineNum">     693 </span>            :                                  * should not do that so forward it.
<span class="lineNum">     694 </span>            :                                  */
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                                 return (0);</span>
<span class="lineNum">     696 </span>            :                         }
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                         m_copydata(m, off, sizeof(opt6), (caddr_t)&amp;opt6);</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :                         if (proto == IPPROTO_AH)</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :                                 off += (opt6.ip6e_len + 2) * 4;</span>
<span class="lineNum">     702 </span>            :                         else
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                                 off += (opt6.ip6e_len + 1) * 8;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :                         proto = opt6.ip6e_nxt;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     706 </span>            :                 case IPPROTO_FRAGMENT:
<span class="lineNum">     707 </span>            :                 default:
<span class="lineNum">     708 </span>            :                         /* end of header stack */
<span class="lineNum">     709 </span>            :                         done = 1;
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     711 </span>            :                 }
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         } while (!done);</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : /*
<span class="lineNum">     718 </span>            :  * Hop-by-Hop options header processing. If a valid jumbo payload option is
<span class="lineNum">     719 </span>            :  * included, the real payload length will be stored in plenp.
<span class="lineNum">     720 </span>            :  *
<span class="lineNum">     721 </span>            :  * rtalertp - XXX: should be stored in a more smart way
<a name="722"><span class="lineNum">     722 </span>            :  */</a>
<span class="lineNum">     723 </span>            : int
<span class="lineNum">     724 </span><span class="lineNoCov">          0 : ip6_hopopts_input(u_int32_t *plenp, u_int32_t *rtalertp, struct mbuf **mp,</span>
<span class="lineNum">     725 </span>            :     int *offp)
<span class="lineNum">     726 </span>            : {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         struct mbuf *m = *mp;</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :         int off = *offp, hbhlen;</span>
<span class="lineNum">     729 </span>            :         struct ip6_hbh *hbh;
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :         /* validation of the length of the header */
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m,</span>
<span class="lineNum">     733 </span>            :                 sizeof(struct ip6_hdr), sizeof(struct ip6_hbh));
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         if (hbh == NULL) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     737 </span>            :         }
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         hbhlen = (hbh-&gt;ip6h_len + 1) &lt;&lt; 3;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :         IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m, sizeof(struct ip6_hdr),</span>
<span class="lineNum">     740 </span>            :                 hbhlen);
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         if (hbh == NULL) {</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     744 </span>            :         }
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         off += hbhlen;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         hbhlen -= sizeof(struct ip6_hbh);</span>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         if (ip6_process_hopopts(m, (u_int8_t *)hbh + sizeof(struct ip6_hbh),</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :                                 hbhlen, rtalertp, plenp) &lt; 0)</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :                 return (-1);</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         *offp = off;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         *mp = m;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : /*
<span class="lineNum">     758 </span>            :  * Search header for all Hop-by-hop options and process each option.
<span class="lineNum">     759 </span>            :  * This function is separate from ip6_hopopts_input() in order to
<span class="lineNum">     760 </span>            :  * handle a case where the sending node itself process its hop-by-hop
<span class="lineNum">     761 </span>            :  * options header. In such a case, the function is called from ip6_output().
<span class="lineNum">     762 </span>            :  *
<span class="lineNum">     763 </span>            :  * The function assumes that hbh header is located right after the IPv6 header
<span class="lineNum">     764 </span>            :  * (RFC2460 p7), opthead is pointer into data content in m, and opthead to
<span class="lineNum">     765 </span>            :  * opthead + hbhlen is located in continuous memory region.
<a name="766"><span class="lineNum">     766 </span>            :  */</a>
<span class="lineNum">     767 </span>            : int
<span class="lineNum">     768 </span><span class="lineNoCov">          0 : ip6_process_hopopts(struct mbuf *m, u_int8_t *opthead, int hbhlen,</span>
<span class="lineNum">     769 </span>            :     u_int32_t *rtalertp, u_int32_t *plenp)
<span class="lineNum">     770 </span>            : {
<span class="lineNum">     771 </span>            :         struct ip6_hdr *ip6;
<span class="lineNum">     772 </span>            :         int optlen = 0;
<span class="lineNum">     773 </span>            :         u_int8_t *opt = opthead;
<span class="lineNum">     774 </span>            :         u_int16_t rtalert_val;
<span class="lineNum">     775 </span>            :         u_int32_t jumboplen;
<span class="lineNum">     776 </span>            :         const int erroff = sizeof(struct ip6_hdr) + sizeof(struct ip6_hbh);
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         for (; hbhlen &gt; 0; hbhlen -= optlen, opt += optlen) {</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :                 switch (*opt) {</span>
<span class="lineNum">     780 </span>            :                 case IP6OPT_PAD1:
<span class="lineNum">     781 </span>            :                         optlen = 1;
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     783 </span>            :                 case IP6OPT_PADN:
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :                         if (hbhlen &lt; IP6OPT_MINLEN) {</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_toosmall);</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                                 goto bad;</span>
<span class="lineNum">     787 </span>            :                         }
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :                         optlen = *(opt + 1) + 2;</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     790 </span>            :                 case IP6OPT_ROUTER_ALERT:
<span class="lineNum">     791 </span>            :                         /* XXX may need check for alignment */
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :                         if (hbhlen &lt; IP6OPT_RTALERT_LEN) {</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_toosmall);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :                                 goto bad;</span>
<span class="lineNum">     795 </span>            :                         }
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                         if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2) {</span>
<span class="lineNum">     797 </span>            :                                 /* XXX stat */
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                                 icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     799 </span>            :                                     ICMP6_PARAMPROB_HEADER,
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :                                     erroff + opt + 1 - opthead);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :                                 return (-1);</span>
<span class="lineNum">     802 </span>            :                         }
<span class="lineNum">     803 </span>            :                         optlen = IP6OPT_RTALERT_LEN;
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :                         memcpy((caddr_t)&amp;rtalert_val, (caddr_t)(opt + 2), 2);</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                         *rtalertp = ntohs(rtalert_val);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     807 </span>            :                 case IP6OPT_JUMBO:
<span class="lineNum">     808 </span>            :                         /* XXX may need check for alignment */
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                         if (hbhlen &lt; IP6OPT_JUMBO_LEN) {</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_toosmall);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                                 goto bad;</span>
<span class="lineNum">     812 </span>            :                         }
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :                         if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2) {</span>
<span class="lineNum">     814 </span>            :                                 /* XXX stat */
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                                 icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     816 </span>            :                                     ICMP6_PARAMPROB_HEADER,
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :                                     erroff + opt + 1 - opthead);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :                                 return (-1);</span>
<span class="lineNum">     819 </span>            :                         }
<span class="lineNum">     820 </span>            :                         optlen = IP6OPT_JUMBO_LEN;
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :                         /*
<span class="lineNum">     823 </span>            :                          * IPv6 packets that have non 0 payload length
<span class="lineNum">     824 </span>            :                          * must not contain a jumbo payload option.
<span class="lineNum">     825 </span>            :                          */
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                         ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :                         if (ip6-&gt;ip6_plen) {</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :                                 icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     830 </span>            :                                     ICMP6_PARAMPROB_HEADER,
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :                                     erroff + opt - opthead);</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :                                 return (-1);</span>
<span class="lineNum">     833 </span>            :                         }
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :                         /*
<span class="lineNum">     836 </span>            :                          * We may see jumbolen in unaligned location, so
<span class="lineNum">     837 </span>            :                          * we'd need to perform memcpy().
<span class="lineNum">     838 </span>            :                          */
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :                         memcpy(&amp;jumboplen, opt + 2, sizeof(jumboplen));</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                         jumboplen = (u_int32_t)htonl(jumboplen);</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : #if 1
<span class="lineNum">     843 </span>            :                         /*
<span class="lineNum">     844 </span>            :                          * if there are multiple jumbo payload options,
<span class="lineNum">     845 </span>            :                          * *plenp will be non-zero and the packet will be
<span class="lineNum">     846 </span>            :                          * rejected.
<span class="lineNum">     847 </span>            :                          * the behavior may need some debate in ipngwg -
<span class="lineNum">     848 </span>            :                          * multiple options does not make sense, however,
<span class="lineNum">     849 </span>            :                          * there's no explicit mention in specification.
<span class="lineNum">     850 </span>            :                          */
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :                         if (*plenp != 0) {</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                                 icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     854 </span>            :                                     ICMP6_PARAMPROB_HEADER,
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                                     erroff + opt + 2 - opthead);</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                                 return (-1);</span>
<span class="lineNum">     857 </span>            :                         }
<span class="lineNum">     858 </span>            : #endif
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :                         /*
<span class="lineNum">     861 </span>            :                          * jumbo payload length must be larger than 65535.
<span class="lineNum">     862 </span>            :                          */
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                         if (jumboplen &lt;= IPV6_MAXPACKET) {</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :                                 icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     866 </span>            :                                     ICMP6_PARAMPROB_HEADER,
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :                                     erroff + opt + 2 - opthead);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :                                 return (-1);</span>
<span class="lineNum">     869 </span>            :                         }
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                         *plenp = jumboplen;</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     873 </span>            :                 default:                /* unknown option */
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :                         if (hbhlen &lt; IP6OPT_MINLEN) {</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_toosmall);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :                                 goto bad;</span>
<span class="lineNum">     877 </span>            :                         }
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :                         optlen = ip6_unknown_opt(opt, m,</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :                             erroff + opt - opthead);</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                         if (optlen == -1)</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                                 return (-1);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :                         optlen += 2;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     884 </span>            :                 }
<span class="lineNum">     885 </span>            :         }
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         return (0);</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   bad:
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         m_freem(m);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         return (-1);</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            : /*
<span class="lineNum">     895 </span>            :  * Unknown option processing.
<span class="lineNum">     896 </span>            :  * The third argument `off' is the offset from the IPv6 header to the option,
<span class="lineNum">     897 </span>            :  * which allows returning an ICMPv6 error even if the IPv6 header and the
<span class="lineNum">     898 </span>            :  * option header are not continuous.
<a name="899"><span class="lineNum">     899 </span>            :  */</a>
<span class="lineNum">     900 </span>            : int
<span class="lineNum">     901 </span><span class="lineNoCov">          0 : ip6_unknown_opt(u_int8_t *optp, struct mbuf *m, int off)</span>
<span class="lineNum">     902 </span>            : {
<span class="lineNum">     903 </span>            :         struct ip6_hdr *ip6;
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :         switch (IP6OPT_TYPE(*optp)) {</span>
<span class="lineNum">     906 </span>            :         case IP6OPT_TYPE_SKIP: /* ignore the option */
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                 return ((int)*(optp + 1));</span>
<span class="lineNum">     908 </span>            :         case IP6OPT_TYPE_DISCARD:       /* silently discard */
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                 m_freem(m);</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :                 return (-1);</span>
<span class="lineNum">     911 </span>            :         case IP6OPT_TYPE_FORCEICMP: /* send ICMP even if multicasted */
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                 icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, off);</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                 return (-1);</span>
<span class="lineNum">     915 </span>            :         case IP6OPT_TYPE_ICMP: /* send ICMP if not multicasted */
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 ip6stat_inc(ip6s_badoptions);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                 ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                 if (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst) ||</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                     (m-&gt;m_flags &amp; (M_BCAST|M_MCAST)))</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                         m_freem(m);</span>
<span class="lineNum">     921 </span>            :                 else
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                         icmp6_error(m, ICMP6_PARAM_PROB,</span>
<span class="lineNum">     923 </span>            :                                     ICMP6_PARAMPROB_OPTION, off);
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                 return (-1);</span>
<span class="lineNum">     925 </span>            :         }
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            :         m_freem(m);             /* XXX: NOTREACHED */
<span class="lineNum">     928 </span>            :         return (-1);
<span class="lineNum">     929 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            : /*
<span class="lineNum">     932 </span>            :  * Create the &quot;control&quot; list for this pcb.
<span class="lineNum">     933 </span>            :  *
<span class="lineNum">     934 </span>            :  * The routine will be called from upper layer handlers like udp_input().
<span class="lineNum">     935 </span>            :  * Thus the routine assumes that the caller (udp_input) have already
<span class="lineNum">     936 </span>            :  * called IP6_EXTHDR_CHECK() and all the extension headers are located in the
<span class="lineNum">     937 </span>            :  * very first mbuf on the mbuf chain.
<span class="lineNum">     938 </span>            :  * We may want to add some infinite loop prevention or sanity checks for safety.
<span class="lineNum">     939 </span>            :  * (This applies only when you are using KAME mbuf chain restriction, i.e.
<span class="lineNum">     940 </span>            :  * you are using IP6_EXTHDR_CHECK() not m_pulldown())
<a name="941"><span class="lineNum">     941 </span>            :  */</a>
<span class="lineNum">     942 </span>            : void
<span class="lineNum">     943 </span><span class="lineNoCov">          0 : ip6_savecontrol(struct inpcb *in6p, struct mbuf *m, struct mbuf **mp)</span>
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :         if (in6p-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) {</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :                 struct timeval tv;</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :                 microtime(&amp;tv);</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :                 *mp = sbcreatecontrol((caddr_t) &amp;tv, sizeof(tv),</span>
<span class="lineNum">     952 </span>            :                     SCM_TIMESTAMP, SOL_SOCKET);
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :                 if (*mp)</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :                         mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :         /* RFC 2292 sec. 5 */
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         if ((in6p-&gt;inp_flags &amp; IN6P_PKTINFO) != 0) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                 struct in6_pktinfo pi6;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :                 memcpy(&amp;pi6.ipi6_addr, &amp;ip6-&gt;ip6_dst, sizeof(struct in6_addr));</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                 if (IN6_IS_SCOPE_EMBED(&amp;pi6.ipi6_addr))</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                         pi6.ipi6_addr.s6_addr16[1] = 0;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                 pi6.ipi6_ifindex = m ? m-&gt;m_pkthdr.ph_ifidx : 0;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                 *mp = sbcreatecontrol((caddr_t) &amp;pi6,</span>
<span class="lineNum">     965 </span>            :                     sizeof(struct in6_pktinfo),
<span class="lineNum">     966 </span>            :                     IPV6_PKTINFO, IPPROTO_IPV6);
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :                 if (*mp)</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :                         mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         if ((in6p-&gt;inp_flags &amp; IN6P_HOPLIMIT) != 0) {</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :                 int hlim = ip6-&gt;ip6_hlim &amp; 0xff;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :                 *mp = sbcreatecontrol((caddr_t) &amp;hlim, sizeof(int),</span>
<span class="lineNum">     974 </span>            :                     IPV6_HOPLIMIT, IPPROTO_IPV6);
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :                 if (*mp)</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :                         mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         if ((in6p-&gt;inp_flags &amp; IN6P_TCLASS) != 0) {</span>
<span class="lineNum">     980 </span>            :                 u_int32_t flowinfo;
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :                 int tclass;</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :                 flowinfo = (u_int32_t)ntohl(ip6-&gt;ip6_flow &amp; IPV6_FLOWINFO_MASK);</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 flowinfo &gt;&gt;= 20;</span>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :                 tclass = flowinfo &amp; 0xff;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :                 *mp = sbcreatecontrol((caddr_t)&amp;tclass, sizeof(tclass),</span>
<span class="lineNum">     988 </span>            :                     IPV6_TCLASS, IPPROTO_IPV6);
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :                 if (*mp)</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :                         mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :         /*
<span class="lineNum">     994 </span>            :          * IPV6_HOPOPTS socket option.  Recall that we required super-user
<span class="lineNum">     995 </span>            :          * privilege for the option (see ip6_ctloutput), but it might be too
<span class="lineNum">     996 </span>            :          * strict, since there might be some hop-by-hop options which can be
<span class="lineNum">     997 </span>            :          * returned to normal user.
<span class="lineNum">     998 </span>            :          * See also RFC 2292 section 6 (or RFC 3542 section 8).
<span class="lineNum">     999 </span>            :          */
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :         if ((in6p-&gt;inp_flags &amp; IN6P_HOPOPTS) != 0) {</span>
<span class="lineNum">    1001 </span>            :                 /*
<span class="lineNum">    1002 </span>            :                  * Check if a hop-by-hop options header is contained in the
<span class="lineNum">    1003 </span>            :                  * received packet, and if so, store the options as ancillary
<span class="lineNum">    1004 </span>            :                  * data. Note that a hop-by-hop options header must be
<span class="lineNum">    1005 </span>            :                  * just after the IPv6 header, which is assured through the
<span class="lineNum">    1006 </span>            :                  * IPv6 input processing.
<span class="lineNum">    1007 </span>            :                  */
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                 struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :                 if (ip6-&gt;ip6_nxt == IPPROTO_HOPOPTS) {</span>
<span class="lineNum">    1010 </span>            :                         struct ip6_hbh *hbh;
<span class="lineNum">    1011 </span>            :                         int hbhlen = 0;
<span class="lineNum">    1012 </span>            :                         struct mbuf *ext;
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :                         ext = ip6_pullexthdr(m, sizeof(struct ip6_hdr),</span>
<span class="lineNum">    1015 </span>            :                             ip6-&gt;ip6_nxt);
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :                         if (ext == NULL) {</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1019 </span>            :                         }
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                         hbh = mtod(ext, struct ip6_hbh *);</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                         hbhlen = (hbh-&gt;ip6h_len + 1) &lt;&lt; 3;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                         if (hbhlen != ext-&gt;m_len) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :                                 m_freem(ext);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1026 </span>            :                         }
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :                         /*
<span class="lineNum">    1029 </span>            :                          * XXX: We copy the whole header even if a
<span class="lineNum">    1030 </span>            :                          * jumbo payload option is included, the option which
<span class="lineNum">    1031 </span>            :                          * is to be removed before returning according to
<span class="lineNum">    1032 </span>            :                          * RFC2292.
<span class="lineNum">    1033 </span>            :                          * Note: this constraint is removed in RFC3542.
<span class="lineNum">    1034 </span>            :                          */
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                         *mp = sbcreatecontrol((caddr_t)hbh, hbhlen,</span>
<span class="lineNum">    1036 </span>            :                             IPV6_HOPOPTS,
<span class="lineNum">    1037 </span>            :                             IPPROTO_IPV6);
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :                         if (*mp)</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                                 mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :                         m_freem(ext);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :         /* IPV6_DSTOPTS and IPV6_RTHDR socket options */
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :         if ((in6p-&gt;inp_flags &amp; (IN6P_RTHDR | IN6P_DSTOPTS)) != 0) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                 struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                 int nxt = ip6-&gt;ip6_nxt, off = sizeof(struct ip6_hdr);</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            :                 /*
<span class="lineNum">    1050 </span>            :                  * Search for destination options headers or routing
<span class="lineNum">    1051 </span>            :                  * header(s) through the header chain, and stores each
<span class="lineNum">    1052 </span>            :                  * header as ancillary data.
<span class="lineNum">    1053 </span>            :                  * Note that the order of the headers remains in
<span class="lineNum">    1054 </span>            :                  * the chain of ancillary data.
<span class="lineNum">    1055 </span>            :                  */
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :                 while (1) {     /* is explicit loop prevention necessary? */</span>
<span class="lineNum">    1057 </span>            :                         struct ip6_ext *ip6e = NULL;
<span class="lineNum">    1058 </span>            :                         int elen;
<span class="lineNum">    1059 </span>            :                         struct mbuf *ext = NULL;
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :                         /*
<span class="lineNum">    1062 </span>            :                          * if it is not an extension header, don't try to
<span class="lineNum">    1063 </span>            :                          * pull it from the chain.
<span class="lineNum">    1064 </span>            :                          */
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :                         switch (nxt) {</span>
<span class="lineNum">    1066 </span>            :                         case IPPROTO_DSTOPTS:
<span class="lineNum">    1067 </span>            :                         case IPPROTO_ROUTING:
<span class="lineNum">    1068 </span>            :                         case IPPROTO_HOPOPTS:
<span class="lineNum">    1069 </span>            :                         case IPPROTO_AH: /* is it possible? */
<span class="lineNum">    1070 </span>            :                                 break;
<span class="lineNum">    1071 </span>            :                         default:
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                                 goto loopend;</span>
<span class="lineNum">    1073 </span>            :                         }
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                         ext = ip6_pullexthdr(m, off, nxt);</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :                         if (ext == NULL) {</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1079 </span>            :                         }
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                         ip6e = mtod(ext, struct ip6_ext *);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :                         if (nxt == IPPROTO_AH)</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :                                 elen = (ip6e-&gt;ip6e_len + 2) &lt;&lt; 2;</span>
<span class="lineNum">    1083 </span>            :                         else
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                                 elen = (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                         if (elen != ext-&gt;m_len) {</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                                 m_freem(ext);</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :                                 ip6stat_inc(ip6s_tooshort);</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1089 </span>            :                         }
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                         switch (nxt) {</span>
<span class="lineNum">    1092 </span>            :                         case IPPROTO_DSTOPTS:
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :                                 if (!(in6p-&gt;inp_flags &amp; IN6P_DSTOPTS))</span>
<span class="lineNum">    1094 </span>            :                                         break;
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :                                 *mp = sbcreatecontrol((caddr_t)ip6e, elen,</span>
<span class="lineNum">    1097 </span>            :                                     IPV6_DSTOPTS,
<span class="lineNum">    1098 </span>            :                                     IPPROTO_IPV6);
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                                 if (*mp)</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                                         mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">    1101 </span>            :                                 break;
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span>            :                         case IPPROTO_ROUTING:
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                                 if (!(in6p-&gt;inp_flags &amp; IN6P_RTHDR))</span>
<span class="lineNum">    1105 </span>            :                                         break;
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                                 *mp = sbcreatecontrol((caddr_t)ip6e, elen,</span>
<span class="lineNum">    1108 </span>            :                                     IPV6_RTHDR,
<span class="lineNum">    1109 </span>            :                                     IPPROTO_IPV6);
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                                 if (*mp)</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :                                         mp = &amp;(*mp)-&gt;m_next;</span>
<span class="lineNum">    1112 </span>            :                                 break;
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            :                         case IPPROTO_HOPOPTS:
<span class="lineNum">    1115 </span>            :                         case IPPROTO_AH: /* is it possible? */
<span class="lineNum">    1116 </span>            :                                 break;
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            :                         default:
<span class="lineNum">    1119 </span>            :                                 /*
<span class="lineNum">    1120 </span>            :                                  * other cases have been filtered in the above.
<span class="lineNum">    1121 </span>            :                                  * none will visit this case.  here we supply
<span class="lineNum">    1122 </span>            :                                  * the code just in case (nxt overwritten or
<span class="lineNum">    1123 </span>            :                                  * other cases).
<span class="lineNum">    1124 </span>            :                                  */
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                                 m_freem(ext);</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :                                 goto loopend;</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :                         }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :                         /* proceed with the next header. */
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                         off += elen;</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :                         nxt = ip6e-&gt;ip6e_nxt;</span>
<span class="lineNum">    1133 </span>            :                         ip6e = NULL;
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                         m_freem(ext);</span>
<span class="lineNum">    1135 </span>            :                         ext = NULL;
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1137 </span>            : loopend:
<span class="lineNum">    1138 </span>            :                 ;
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : /*
<span class="lineNum">    1143 </span>            :  * pull single extension header from mbuf chain.  returns single mbuf that
<span class="lineNum">    1144 </span>            :  * contains the result, or NULL on error.
<a name="1145"><span class="lineNum">    1145 </span>            :  */</a>
<span class="lineNum">    1146 </span>            : struct mbuf *
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 : ip6_pullexthdr(struct mbuf *m, size_t off, int nxt)</span>
<span class="lineNum">    1148 </span>            : {
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         struct ip6_ext ip6e;</span>
<span class="lineNum">    1150 </span>            :         size_t elen;
<span class="lineNum">    1151 </span>            :         struct mbuf *n;
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            : #ifdef DIAGNOSTIC
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :         switch (nxt) {</span>
<span class="lineNum">    1155 </span>            :         case IPPROTO_DSTOPTS:
<span class="lineNum">    1156 </span>            :         case IPPROTO_ROUTING:
<span class="lineNum">    1157 </span>            :         case IPPROTO_HOPOPTS:
<span class="lineNum">    1158 </span>            :         case IPPROTO_AH: /* is it possible? */
<span class="lineNum">    1159 </span>            :                 break;
<span class="lineNum">    1160 </span>            :         default:
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                 printf(&quot;ip6_pullexthdr: invalid nxt=%d\n&quot;, nxt);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1163 </span>            : #endif
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :         m_copydata(m, off, sizeof(ip6e), (caddr_t)&amp;ip6e);</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         if (nxt == IPPROTO_AH)</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :                 elen = (ip6e.ip6e_len + 2) &lt;&lt; 2;</span>
<span class="lineNum">    1168 </span>            :         else
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :                 elen = (ip6e.ip6e_len + 1) &lt;&lt; 3;</span>
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         MGET(n, M_DONTWAIT, MT_DATA);</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         if (n &amp;&amp; elen &gt;= MLEN) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                 MCLGET(n, M_DONTWAIT);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 if ((n-&gt;m_flags &amp; M_EXT) == 0) {</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                         m_free(n);</span>
<span class="lineNum">    1176 </span>            :                         n = NULL;
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1178 </span>            :         }
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         if (!n)</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         n-&gt;m_len = 0;</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         if (elen &gt;= M_TRAILINGSPACE(n)) {</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                 m_free(n);</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1186 </span>            :         }
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :         m_copydata(m, off, elen, mtod(n, caddr_t));</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :         n-&gt;m_len = elen;</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :         return n;</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            : /*
<span class="lineNum">    1194 </span>            :  * Get offset to the previous header followed by the header
<span class="lineNum">    1195 </span>            :  * currently processed.
<a name="1196"><span class="lineNum">    1196 </span>            :  */</a>
<span class="lineNum">    1197 </span>            : int
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 : ip6_get_prevhdr(struct mbuf *m, int off)</span>
<span class="lineNum">    1199 </span>            : {
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :         struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         if (off == sizeof(struct ip6_hdr)) {</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                 return offsetof(struct ip6_hdr, ip6_nxt);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         } else if (off &lt; sizeof(struct ip6_hdr)) {</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                 panic(&quot;%s: off &lt; sizeof(struct ip6_hdr)&quot;, __func__);</span>
<span class="lineNum">    1206 </span>            :         } else {
<span class="lineNum">    1207 </span>            :                 int len, nlen, nxt;
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :                 struct ip6_ext ip6e;</span>
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :                 nxt = ip6-&gt;ip6_nxt;</span>
<span class="lineNum">    1211 </span>            :                 len = sizeof(struct ip6_hdr);
<span class="lineNum">    1212 </span>            :                 nlen = 0;
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                 while (len &lt; off) {</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                         m_copydata(m, len, sizeof(ip6e), (caddr_t)&amp;ip6e);</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                         switch (nxt) {</span>
<span class="lineNum">    1217 </span>            :                         case IPPROTO_FRAGMENT:
<span class="lineNum">    1218 </span>            :                                 nlen = sizeof(struct ip6_frag);
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1220 </span>            :                         case IPPROTO_AH:
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                                 nlen = (ip6e.ip6e_len + 2) &lt;&lt; 2;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1223 </span>            :                         default:
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :                                 nlen = (ip6e.ip6e_len + 1) &lt;&lt; 3;</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1226 </span>            :                         }
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :                         len += nlen;</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :                         nxt = ip6e.ip6e_nxt;</span>
<span class="lineNum">    1229 </span>            :                 }
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                 return (len - nlen);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            : /*
<span class="lineNum">    1236 </span>            :  * get next header offset.  m will be retained.
<a name="1237"><span class="lineNum">    1237 </span>            :  */</a>
<span class="lineNum">    1238 </span>            : int
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 : ip6_nexthdr(struct mbuf *m, int off, int proto, int *nxtp)</span>
<span class="lineNum">    1240 </span>            : {
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :         struct ip6_hdr ip6;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :         struct ip6_ext ip6e;</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :         struct ip6_frag fh;</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :         /* just in case */
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :         if (m == NULL)</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :                 panic(&quot;ip6_nexthdr: m == NULL&quot;);</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :         if ((m-&gt;m_flags &amp; M_PKTHDR) == 0 || m-&gt;m_pkthdr.len &lt; off)</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :         switch (proto) {</span>
<span class="lineNum">    1252 </span>            :         case IPPROTO_IPV6:
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_pkthdr.len &lt; off + sizeof(ip6))</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :                 m_copydata(m, off, sizeof(ip6), (caddr_t)&amp;ip6);</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :                 if (nxtp)</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :                         *nxtp = ip6.ip6_nxt;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                 off += sizeof(ip6);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :                 return off;</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :         case IPPROTO_FRAGMENT:
<span class="lineNum">    1262 </span>            :                 /*
<span class="lineNum">    1263 </span>            :                  * terminate parsing if it is not the first fragment,
<span class="lineNum">    1264 </span>            :                  * it does not make sense to parse through it.
<span class="lineNum">    1265 </span>            :                  */
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_pkthdr.len &lt; off + sizeof(fh))</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :                 m_copydata(m, off, sizeof(fh), (caddr_t)&amp;fh);</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                 if ((fh.ip6f_offlg &amp; IP6F_OFF_MASK) != 0)</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :                 if (nxtp)</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :                         *nxtp = fh.ip6f_nxt;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :                 off += sizeof(struct ip6_frag);</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                 return off;</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            :         case IPPROTO_AH:
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_pkthdr.len &lt; off + sizeof(ip6e))</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :                 m_copydata(m, off, sizeof(ip6e), (caddr_t)&amp;ip6e);</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :                 if (nxtp)</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                         *nxtp = ip6e.ip6e_nxt;</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :                 off += (ip6e.ip6e_len + 2) &lt;&lt; 2;</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_pkthdr.len &lt; off)</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :                 return off;</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :         case IPPROTO_HOPOPTS:
<span class="lineNum">    1288 </span>            :         case IPPROTO_ROUTING:
<span class="lineNum">    1289 </span>            :         case IPPROTO_DSTOPTS:
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_pkthdr.len &lt; off + sizeof(ip6e))</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :                 m_copydata(m, off, sizeof(ip6e), (caddr_t)&amp;ip6e);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :                 if (nxtp)</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :                         *nxtp = ip6e.ip6e_nxt;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :                 off += (ip6e.ip6e_len + 1) &lt;&lt; 3;</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :                 if (m-&gt;m_pkthdr.len &lt; off)</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :                 return off;</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            :         case IPPROTO_NONE:
<span class="lineNum">    1301 </span>            :         case IPPROTO_ESP:
<span class="lineNum">    1302 </span>            :         case IPPROTO_IPCOMP:
<span class="lineNum">    1303 </span>            :                 /* give up */
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :         default:
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1308 </span>            :         }
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :         return -1;
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : /*
<span class="lineNum">    1314 </span>            :  * get offset for the last header in the chain.  m will be kept untainted.
<a name="1315"><span class="lineNum">    1315 </span>            :  */</a>
<span class="lineNum">    1316 </span>            : int
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 : ip6_lasthdr(struct mbuf *m, int off, int proto, int *nxtp)</span>
<span class="lineNum">    1318 </span>            : {
<span class="lineNum">    1319 </span>            :         int newoff;
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :         int nxt;</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :         if (!nxtp) {</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                 nxt = -1;</span>
<span class="lineNum">    1324 </span>            :                 nxtp = &amp;nxt;
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         while (1) {</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                 newoff = ip6_nexthdr(m, off, proto, nxtp);</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                 if (newoff &lt; 0)</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                         return off;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                 else if (newoff &lt; off)</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :                         return -1;      /* invalid */</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                 else if (newoff == off)</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                         return newoff;</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :                 off = newoff;
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :                 proto = *nxtp;</span>
<span class="lineNum">    1337 </span>            :         }
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            : /*
<span class="lineNum">    1341 </span>            :  * System control for IP6
<span class="lineNum">    1342 </span>            :  */
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            : const u_char inet6ctlerrmap[PRC_NCMDS] = {
<span class="lineNum">    1345 </span>            :         0,              0,              0,              0,
<span class="lineNum">    1346 </span>            :         0,              EMSGSIZE,       EHOSTDOWN,      EHOSTUNREACH,
<span class="lineNum">    1347 </span>            :         EHOSTUNREACH,   EHOSTUNREACH,   ECONNREFUSED,   ECONNREFUSED,
<span class="lineNum">    1348 </span>            :         EMSGSIZE,       EHOSTUNREACH,   0,              0,
<span class="lineNum">    1349 </span>            :         0,              0,              0,              0,
<span class="lineNum">    1350 </span>            :         ENOPROTOOPT
<span class="lineNum">    1351 </span>            : };
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            : int *ipv6ctl_vars[IPV6CTL_MAXID] = IPV6CTL_VARS;
<a name="1354"><span class="lineNum">    1354 </span>            : </a>
<span class="lineNum">    1355 </span>            : int
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 : ip6_sysctl_ip6stat(void *oldp, size_t *oldlenp, void *newp)</span>
<span class="lineNum">    1357 </span>            : {
<span class="lineNum">    1358 </span>            :         struct ip6stat *ip6stat;
<span class="lineNum">    1359 </span>            :         int ret;
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :         CTASSERT(sizeof(*ip6stat) == (ip6s_ncounters * sizeof(uint64_t)));
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :         ip6stat = malloc(sizeof(*ip6stat), M_TEMP, M_WAITOK);</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :         counters_read(ip6counters, (uint64_t *)ip6stat, ip6s_ncounters);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :         ret = sysctl_rdstruct(oldp, oldlenp, newp,</span>
<span class="lineNum">    1366 </span>            :             ip6stat, sizeof(*ip6stat));
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :         free(ip6stat, M_TEMP, sizeof(*ip6stat));</span>
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         return (ret);</span>
<span class="lineNum">    1370 </span>            : }
<a name="1371"><span class="lineNum">    1371 </span>            : </a>
<span class="lineNum">    1372 </span>            : int
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 : ip6_sysctl_soiikey(void *oldp, size_t *oldlenp, void *newp, size_t newlen)</span>
<span class="lineNum">    1374 </span>            : {
<span class="lineNum">    1375 </span>            :         struct ifnet *ifp;
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :         uint8_t oldkey[IP6_SOIIKEY_LEN];</span>
<span class="lineNum">    1377 </span>            :         int error;
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :         error = suser(curproc);</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :         if (error != 0)</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :         memcpy(oldkey, ip6_soiikey, sizeof(oldkey));</span>
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :         error = sysctl_struct(oldp, oldlenp, newp, newlen, ip6_soiikey,</span>
<span class="lineNum">    1386 </span>            :             sizeof(ip6_soiikey));
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :         if (!error &amp;&amp; memcmp(ip6_soiikey, oldkey, sizeof(oldkey)) != 0) {</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :                 TAILQ_FOREACH(ifp, &amp;ifnet, if_list) {</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :                         if (ifp-&gt;if_flags &amp; IFF_LOOPBACK)</span>
<span class="lineNum">    1391 </span>            :                                 continue;
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :                         NET_LOCK();</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :                         in6_soiiupdate(ifp);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :                         NET_UNLOCK();</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1396 </span>            :         }
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         return (error);</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 : }</span>
<a name="1400"><span class="lineNum">    1400 </span>            : </a>
<span class="lineNum">    1401 </span>            : int
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 : ip6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,</span>
<span class="lineNum">    1403 </span>            :     void *newp, size_t newlen)
<span class="lineNum">    1404 </span>            : {
<span class="lineNum">    1405 </span>            : #ifdef MROUTING
<span class="lineNum">    1406 </span>            :         extern int ip6_mrtproto;
<span class="lineNum">    1407 </span>            :         extern struct mrt6stat mrt6stat;
<span class="lineNum">    1408 </span>            : #endif
<span class="lineNum">    1409 </span>            :         int error;
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :         /* Almost all sysctl names at this level are terminal. */
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :         if (namelen != 1 &amp;&amp; name[0] != IPV6CTL_IFQUEUE)</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                 return (ENOTDIR);</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :         switch (name[0]) {</span>
<span class="lineNum">    1416 </span>            :         case IPV6CTL_DAD_PENDING:
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :                 return sysctl_rdint(oldp, oldlenp, newp, ip6_dad_pending);</span>
<span class="lineNum">    1418 </span>            :         case IPV6CTL_STATS:
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                 return (ip6_sysctl_ip6stat(oldp, oldlenp, newp));</span>
<span class="lineNum">    1420 </span>            : #ifdef MROUTING
<span class="lineNum">    1421 </span>            :         case IPV6CTL_MRTSTATS:
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                 if (newp != NULL)</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :                         return (EPERM);</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                 NET_LOCK();</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :                 error = sysctl_struct(oldp, oldlenp, newp, newlen,</span>
<span class="lineNum">    1426 </span>            :                     &amp;mrt6stat, sizeof(mrt6stat));
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :                 NET_UNLOCK();</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">    1429 </span>            :         case IPV6CTL_MRTPROTO:
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :                 return sysctl_rdint(oldp, oldlenp, newp, ip6_mrtproto);</span>
<span class="lineNum">    1431 </span>            :         case IPV6CTL_MRTMIF:
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :                 if (newp)</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :                         return (EPERM);</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :                 NET_LOCK();</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                 error = mrt6_sysctl_mif(oldp, oldlenp);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :                 NET_UNLOCK();</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">    1438 </span>            :         case IPV6CTL_MRTMFC:
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :                 if (newp)</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :                         return (EPERM);</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :                 NET_LOCK();</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :                 error = mrt6_sysctl_mfc(oldp, oldlenp);</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :                 NET_UNLOCK();</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">    1445 </span>            : #else
<span class="lineNum">    1446 </span>            :         case IPV6CTL_MRTSTATS:
<span class="lineNum">    1447 </span>            :         case IPV6CTL_MRTPROTO:
<span class="lineNum">    1448 </span>            :         case IPV6CTL_MRTMIF:
<span class="lineNum">    1449 </span>            :         case IPV6CTL_MRTMFC:
<span class="lineNum">    1450 </span>            :                 return (EOPNOTSUPP);
<span class="lineNum">    1451 </span>            : #endif
<span class="lineNum">    1452 </span>            :         case IPV6CTL_MTUDISCTIMEOUT:
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                 NET_LOCK();</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                 error = sysctl_int(oldp, oldlenp, newp, newlen,</span>
<span class="lineNum">    1455 </span>            :                     &amp;ip6_mtudisc_timeout);
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                 if (icmp6_mtudisc_timeout_q != NULL)</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                         rt_timer_queue_change(icmp6_mtudisc_timeout_q,</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :                             ip6_mtudisc_timeout);</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                 NET_UNLOCK();</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">    1461 </span>            :         case IPV6CTL_IFQUEUE:
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :                 return (sysctl_niq(name + 1, namelen - 1,</span>
<span class="lineNum">    1463 </span>            :                     oldp, oldlenp, newp, newlen, &amp;ip6intrq));
<span class="lineNum">    1464 </span>            :         case IPV6CTL_SOIIKEY:
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :                 return (ip6_sysctl_soiikey(oldp, oldlenp, newp, newlen));</span>
<span class="lineNum">    1466 </span>            :         default:
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :                 if (name[0] &lt; IPV6CTL_MAXID) {</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :                         NET_LOCK();</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :                         error = sysctl_int_arr(ipv6ctl_vars, name, namelen,</span>
<span class="lineNum">    1470 </span>            :                             oldp, oldlenp, newp, newlen);
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :                         NET_UNLOCK();</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :                         return (error);</span>
<span class="lineNum">    1473 </span>            :                 }
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :                 return (EOPNOTSUPP);</span>
<span class="lineNum">    1475 </span>            :         }
<span class="lineNum">    1476 </span>            :         /* NOTREACHED */
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 : }</span>
<a name="1478"><span class="lineNum">    1478 </span>            : </a>
<span class="lineNum">    1479 </span>            : void
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 : ip6_send_dispatch(void *xmq)</span>
<span class="lineNum">    1481 </span>            : {
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :         struct mbuf_queue *mq = xmq;</span>
<span class="lineNum">    1483 </span>            :         struct mbuf *m;
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :         struct mbuf_list ml;</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :         mq_delist(mq, &amp;ml);</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :         if (ml_empty(&amp;ml))</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         NET_RLOCK();</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :         while ((m = ml_dequeue(&amp;ml)) != NULL) {</span>
<span class="lineNum">    1492 </span>            :                 /*
<span class="lineNum">    1493 </span>            :                  * To avoid a &quot;too big&quot; situation at an intermediate router and
<span class="lineNum">    1494 </span>            :                  * the path MTU discovery process, specify the IPV6_MINMTU
<span class="lineNum">    1495 </span>            :                  * flag.  Note that only echo and node information replies are
<span class="lineNum">    1496 </span>            :                  * affected, since the length of ICMP6 errors is limited to the
<span class="lineNum">    1497 </span>            :                  * minimum MTU.
<span class="lineNum">    1498 </span>            :                  */
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :                 ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, NULL);</span>
<span class="lineNum">    1500 </span>            :         }
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         NET_RUNLOCK();</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 : }</span>
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<span class="lineNum">    1504 </span>            : void
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 : ip6_send(struct mbuf *m)</span>
<span class="lineNum">    1506 </span>            : {
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :         mq_enqueue(&amp;ip6send_mq, m);</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :         task_add(net_tq(0), &amp;ip6send_task);</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
