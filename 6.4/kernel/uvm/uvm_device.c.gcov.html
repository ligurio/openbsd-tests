<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 6.4 - uvm/uvm_device.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">uvm</a> - uvm_device.c<span style="font-size: 80%;"> (source / <a href="uvm_device.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">6.4</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">97</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-10-19 03:25:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*      $OpenBSD: uvm_device.c,v 1.55 2018/08/20 10:00:04 kettenis Exp $        */</a>
<span class="lineNum">       2 </span>            : /*      $NetBSD: uvm_device.c,v 1.30 2000/11/25 06:27:59 chs Exp $      */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /*
<span class="lineNum">       5 </span>            :  * Copyright (c) 1997 Charles D. Cranor and Washington University.
<span class="lineNum">       6 </span>            :  * All rights reserved.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       9 </span>            :  * modification, are permitted provided that the following conditions
<span class="lineNum">      10 </span>            :  * are met:
<span class="lineNum">      11 </span>            :  * 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      12 </span>            :  *    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      13 </span>            :  * 2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      14 </span>            :  *    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      15 </span>            :  *    documentation and/or other materials provided with the distribution.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
<span class="lineNum">      18 </span>            :  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
<span class="lineNum">      19 </span>            :  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
<span class="lineNum">      20 </span>            :  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
<span class="lineNum">      21 </span>            :  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
<span class="lineNum">      22 </span>            :  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      23 </span>            :  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      24 </span>            :  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      25 </span>            :  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
<span class="lineNum">      26 </span>            :  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      27 </span>            :  *
<span class="lineNum">      28 </span>            :  * from: Id: uvm_device.c,v 1.1.2.9 1998/02/06 05:11:47 chs Exp
<span class="lineNum">      29 </span>            :  */
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : /*
<span class="lineNum">      32 </span>            :  * uvm_device.c: the device pager.
<span class="lineNum">      33 </span>            :  */
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;sys/systm.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;sys/conf.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;sys/malloc.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;sys/mutex.h&gt;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #include &lt;uvm/uvm.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;uvm/uvm_device.h&gt;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #if defined(__amd64__) || defined(__arm64__) || \
<span class="lineNum">      45 </span>            :     defined(__i386__) || defined(__loongson__) || \
<span class="lineNum">      46 </span>            :     defined(__macppc__) || defined(__sparc64__)
<span class="lineNum">      47 </span>            : #include &quot;drm.h&quot;
<span class="lineNum">      48 </span>            : #endif
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /*
<span class="lineNum">      51 </span>            :  * private global data structure
<span class="lineNum">      52 </span>            :  *
<span class="lineNum">      53 </span>            :  * we keep a list of active device objects in the system.
<span class="lineNum">      54 </span>            :  */
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : LIST_HEAD(, uvm_device) udv_list = LIST_HEAD_INITIALIZER(udv_list);
<span class="lineNum">      57 </span>            : struct mutex udv_lock = MUTEX_INITIALIZER(IPL_NONE);
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /*
<span class="lineNum">      60 </span>            :  * functions
<span class="lineNum">      61 </span>            :  */
<span class="lineNum">      62 </span>            : static void             udv_reference(struct uvm_object *);
<span class="lineNum">      63 </span>            : static void             udv_detach(struct uvm_object *);
<span class="lineNum">      64 </span>            : static int              udv_fault(struct uvm_faultinfo *, vaddr_t,
<span class="lineNum">      65 </span>            :                                        vm_page_t *, int, int, vm_fault_t,
<span class="lineNum">      66 </span>            :                                        vm_prot_t, int);
<span class="lineNum">      67 </span>            : static boolean_t        udv_flush(struct uvm_object *, voff_t, voff_t,
<span class="lineNum">      68 </span>            :                                        int);
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : /*
<span class="lineNum">      71 </span>            :  * master pager structure
<span class="lineNum">      72 </span>            :  */
<span class="lineNum">      73 </span>            : struct uvm_pagerops uvm_deviceops = {
<span class="lineNum">      74 </span>            :         NULL,           /* inited statically */
<span class="lineNum">      75 </span>            :         udv_reference,
<span class="lineNum">      76 </span>            :         udv_detach,
<span class="lineNum">      77 </span>            :         udv_fault,
<span class="lineNum">      78 </span>            :         udv_flush,
<span class="lineNum">      79 </span>            : };
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : /*
<span class="lineNum">      82 </span>            :  * udv_attach
<span class="lineNum">      83 </span>            :  *
<span class="lineNum">      84 </span>            :  * get a VM object that is associated with a device.   allocate a new
<span class="lineNum">      85 </span>            :  * one if needed.
<span class="lineNum">      86 </span>            :  *
<span class="lineNum">      87 </span>            :  * =&gt; nothing should be locked so that we can sleep here.
<span class="lineNum">      88 </span>            :  *
<span class="lineNum">      89 </span>            :  * The last two arguments (off and size) are only used for access checking.
<a name="90"><span class="lineNum">      90 </span>            :  */</a>
<span class="lineNum">      91 </span>            : struct uvm_object *
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : udv_attach(dev_t device, vm_prot_t accessprot, voff_t off, vsize_t size)</span>
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span>            :         struct uvm_device *udv, *lcv;
<span class="lineNum">      95 </span>            :         paddr_t (*mapfn)(dev_t, off_t, int);
<span class="lineNum">      96 </span>            : #if NDRM &gt; 0
<span class="lineNum">      97 </span>            :         struct uvm_object *obj;
<span class="lineNum">      98 </span>            : #endif
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :         /* before we do anything, ensure this device supports mmap */
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         mapfn = cdevsw[major(device)].d_mmap;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         if (mapfn == NULL ||</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :             mapfn == (paddr_t (*)(dev_t, off_t, int)) enodev ||</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :             mapfn == (paddr_t (*)(dev_t, off_t, int)) nullop)</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :                 return(NULL);</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :         /* Negative offsets on the object are not allowed. */
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :         if (off &lt; 0)</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :                 return(NULL);</span>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #if NDRM &gt; 0
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         obj = udv_attach_drm(device, accessprot, off, size);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :         if (obj)</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :                 return(obj);</span>
<span class="lineNum">     115 </span>            : #endif
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :         /*
<span class="lineNum">     118 </span>            :          * Check that the specified range of the device allows the
<span class="lineNum">     119 </span>            :          * desired protection.
<span class="lineNum">     120 </span>            :          * 
<span class="lineNum">     121 </span>            :          * XXX clobbers off and size, but nothing else here needs them.
<span class="lineNum">     122 </span>            :          */
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :         while (size != 0) {</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                 if ((*mapfn)(device, off, accessprot) == -1)</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :                         return (NULL);</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :                 off += PAGE_SIZE; size -= PAGE_SIZE;</span>
<span class="lineNum">     127 </span>            :         }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :         /* keep looping until we get it */
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :         for (;;) {</span>
<span class="lineNum">     131 </span>            :                 /* first, attempt to find it on the main list */
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :                 mtx_enter(&amp;udv_lock);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :                 LIST_FOREACH(lcv, &amp;udv_list, u_list) {</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                         if (device == lcv-&gt;u_device)</span>
<span class="lineNum">     135 </span>            :                                 break;
<span class="lineNum">     136 </span>            :                 }
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :                 /* got it on main list.  put a hold on it and unlock udv_lock. */
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :                 if (lcv) {</span>
<span class="lineNum">     140 </span>            :                         /*
<span class="lineNum">     141 </span>            :                          * if someone else has a hold on it, sleep and start
<span class="lineNum">     142 </span>            :                          * over again. Else, we need take HOLD flag so we
<span class="lineNum">     143 </span>            :                          * don't have to re-order locking here.
<span class="lineNum">     144 </span>            :                          */
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :                         if (lcv-&gt;u_flags &amp; UVM_DEVICE_HOLD) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :                                 lcv-&gt;u_flags |= UVM_DEVICE_WANTED;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                                 msleep(lcv, &amp;udv_lock, PVM | PNORELOCK,</span>
<span class="lineNum">     148 </span>            :                                     &quot;udv_attach&quot;, 0);
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     150 </span>            :                         }
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :                         /* we are now holding it */
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                         lcv-&gt;u_flags |= UVM_DEVICE_HOLD;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                         mtx_leave(&amp;udv_lock);</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :                         /* bump reference count, unhold, return. */
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                         lcv-&gt;u_obj.uo_refs++;</span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                         mtx_enter(&amp;udv_lock);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :                         if (lcv-&gt;u_flags &amp; UVM_DEVICE_WANTED)</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :                                 wakeup(lcv);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :                         lcv-&gt;u_flags &amp;= ~(UVM_DEVICE_WANTED|UVM_DEVICE_HOLD);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                         mtx_leave(&amp;udv_lock);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :                         return(&amp;lcv-&gt;u_obj);</span>
<span class="lineNum">     165 </span>            :                 }
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :                 /* did not find it on main list.   need to malloc a new one. */
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                 mtx_leave(&amp;udv_lock);</span>
<span class="lineNum">     169 </span>            :                 /* NOTE: we could sleep in the following malloc() */
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :                 udv = malloc(sizeof(*udv), M_TEMP, M_WAITOK);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 mtx_enter(&amp;udv_lock);</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :                 /*
<span class="lineNum">     174 </span>            :                  * now we have to double check to make sure no one added it
<span class="lineNum">     175 </span>            :                  * to the list while we were sleeping...
<span class="lineNum">     176 </span>            :                  */
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 LIST_FOREACH(lcv, &amp;udv_list, u_list) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                         if (device == lcv-&gt;u_device)</span>
<span class="lineNum">     179 </span>            :                                 break;
<span class="lineNum">     180 </span>            :                 }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :                 /*
<span class="lineNum">     183 </span>            :                  * did we lose a race to someone else?
<span class="lineNum">     184 </span>            :                  * free our memory and retry.
<span class="lineNum">     185 </span>            :                  */
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                 if (lcv) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :                         mtx_leave(&amp;udv_lock);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :                         free(udv, M_TEMP, sizeof(*udv));</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     190 </span>            :                 }
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :                 /*
<span class="lineNum">     193 </span>            :                  * we have it!   init the data structures, add to list
<span class="lineNum">     194 </span>            :                  * and return.
<span class="lineNum">     195 </span>            :                  */
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 uvm_objinit(&amp;udv-&gt;u_obj, &amp;uvm_deviceops, 1);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                 udv-&gt;u_flags = 0;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :                 udv-&gt;u_device = device;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 LIST_INSERT_HEAD(&amp;udv_list, udv, u_list);</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :                 mtx_leave(&amp;udv_lock);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 return(&amp;udv-&gt;u_obj);</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span>            :         /*NOTREACHED*/
<span class="lineNum">     204 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     205 </span>            :         
<span class="lineNum">     206 </span>            : /*
<span class="lineNum">     207 </span>            :  * udv_reference
<span class="lineNum">     208 </span>            :  *
<span class="lineNum">     209 </span>            :  * add a reference to a VM object.   Note that the reference count must
<span class="lineNum">     210 </span>            :  * already be one (the passed in reference) so there is no chance of the
<span class="lineNum">     211 </span>            :  * udv being released or locked out here.
<a name="212"><span class="lineNum">     212 </span>            :  */</a>
<span class="lineNum">     213 </span>            : static void
<span class="lineNum">     214 </span><span class="lineNoCov">          0 : udv_reference(struct uvm_object *uobj)</span>
<span class="lineNum">     215 </span>            : {
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         uobj-&gt;uo_refs++;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : /*
<span class="lineNum">     221 </span>            :  * udv_detach
<span class="lineNum">     222 </span>            :  *
<span class="lineNum">     223 </span>            :  * remove a reference to a VM object.
<a name="224"><span class="lineNum">     224 </span>            :  */</a>
<span class="lineNum">     225 </span>            : static void
<span class="lineNum">     226 </span><span class="lineNoCov">          0 : udv_detach(struct uvm_object *uobj)</span>
<span class="lineNum">     227 </span>            : {
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         struct uvm_device *udv = (struct uvm_device *)uobj;</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :         /* loop until done */
<span class="lineNum">     231 </span>            : again:
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         if (uobj-&gt;uo_refs &gt; 1) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                 uobj-&gt;uo_refs--;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     235 </span>            :         }
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         KASSERT(uobj-&gt;uo_npages == 0 &amp;&amp; RBT_EMPTY(uvm_objtree, &amp;uobj-&gt;memt));</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :         /* is it being held?   if so, wait until others are done. */
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         mtx_enter(&amp;udv_lock);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         if (udv-&gt;u_flags &amp; UVM_DEVICE_HOLD) {</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                 udv-&gt;u_flags |= UVM_DEVICE_WANTED;</span>
<span class="lineNum">     242 </span>            :                 /*
<span class="lineNum">     243 </span>            :                  * lock interleaving. -- this is ok in this case since the
<span class="lineNum">     244 </span>            :                  * locks are both IPL_NONE
<span class="lineNum">     245 </span>            :                  */
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                 msleep(udv, &amp;udv_lock, PVM | PNORELOCK, &quot;udv_detach&quot;, 0);</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :                 goto again;</span>
<span class="lineNum">     248 </span>            :         }
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :         /* got it!   nuke it now. */
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         LIST_REMOVE(udv, u_list);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         if (udv-&gt;u_flags &amp; UVM_DEVICE_WANTED)</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :                 wakeup(udv);</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         mtx_leave(&amp;udv_lock);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         free(udv, M_TEMP, sizeof(*udv));</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /*
<span class="lineNum">     260 </span>            :  * udv_flush
<span class="lineNum">     261 </span>            :  *
<span class="lineNum">     262 </span>            :  * flush pages out of a uvm object.   a no-op for devices.
<a name="263"><span class="lineNum">     263 </span>            :  */</a>
<span class="lineNum">     264 </span>            : static boolean_t
<span class="lineNum">     265 </span><span class="lineNoCov">          0 : udv_flush(struct uvm_object *uobj, voff_t start, voff_t stop, int flags)</span>
<span class="lineNum">     266 </span>            : {
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         return(TRUE);</span>
<span class="lineNum">     269 </span>            : }
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /*
<span class="lineNum">     272 </span>            :  * udv_fault: non-standard fault routine for device &quot;pages&quot;
<span class="lineNum">     273 </span>            :  *
<span class="lineNum">     274 </span>            :  * =&gt; rather than having a &quot;get&quot; function, we have a fault routine
<span class="lineNum">     275 </span>            :  *      since we don't return vm_pages we need full control over the
<span class="lineNum">     276 </span>            :  *      pmap_enter map in
<span class="lineNum">     277 </span>            :  * =&gt; on return, we unlock all fault data structures
<span class="lineNum">     278 </span>            :  * =&gt; flags: PGO_ALLPAGES: get all of the pages
<span class="lineNum">     279 </span>            :  *           PGO_LOCKED: fault data structures are locked
<span class="lineNum">     280 </span>            :  *    XXX: currently PGO_LOCKED is always required ... consider removing
<span class="lineNum">     281 </span>            :  *      it as a flag
<span class="lineNum">     282 </span>            :  * =&gt; NOTE: vaddr is the VA of pps[0] in ufi-&gt;entry, _NOT_ pps[centeridx]
<a name="283"><span class="lineNum">     283 </span>            :  */</a>
<span class="lineNum">     284 </span>            : static int
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : udv_fault(struct uvm_faultinfo *ufi, vaddr_t vaddr, vm_page_t *pps, int npages,</span>
<span class="lineNum">     286 </span>            :     int centeridx, vm_fault_t fault_type, vm_prot_t access_type, int flags)
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         struct vm_map_entry *entry = ufi-&gt;entry;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         struct uvm_object *uobj = entry-&gt;object.uvm_obj;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         struct uvm_device *udv = (struct uvm_device *)uobj;</span>
<span class="lineNum">     291 </span>            :         vaddr_t curr_va;
<span class="lineNum">     292 </span>            :         off_t curr_offset;
<span class="lineNum">     293 </span>            :         paddr_t paddr;
<span class="lineNum">     294 </span>            :         int lcv, retval;
<span class="lineNum">     295 </span>            :         dev_t device;
<span class="lineNum">     296 </span>            :         paddr_t (*mapfn)(dev_t, off_t, int);
<span class="lineNum">     297 </span>            :         vm_prot_t mapprot;
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :         /*
<span class="lineNum">     300 </span>            :          * we do not allow device mappings to be mapped copy-on-write
<span class="lineNum">     301 </span>            :          * so we kill any attempt to do so here.
<span class="lineNum">     302 </span>            :          */
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         if (UVM_ET_ISCOPYONWRITE(entry)) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :                 uvmfault_unlockall(ufi, ufi-&gt;entry-&gt;aref.ar_amap, uobj, NULL);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                 return(VM_PAGER_ERROR);</span>
<span class="lineNum">     306 </span>            :         }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :         /* get device map function. */
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         device = udv-&gt;u_device;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         mapfn = cdevsw[major(device)].d_mmap;</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :         /*
<span class="lineNum">     313 </span>            :          * now we must determine the offset in udv to use and the VA to
<span class="lineNum">     314 </span>            :          * use for pmap_enter.  note that we always use orig_map's pmap
<span class="lineNum">     315 </span>            :          * for pmap_enter (even if we have a submap).   since virtual
<span class="lineNum">     316 </span>            :          * addresses in a submap must match the main map, this is ok.
<span class="lineNum">     317 </span>            :          */
<span class="lineNum">     318 </span>            :         /* udv offset = (offset from start of entry) + entry's offset */
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         curr_offset = entry-&gt;offset + (vaddr - entry-&gt;start);</span>
<span class="lineNum">     320 </span>            :         /* pmap va = vaddr (virtual address of pps[0]) */
<span class="lineNum">     321 </span>            :         curr_va = vaddr;
<span class="lineNum">     322 </span>            :         
<span class="lineNum">     323 </span>            :         /* loop over the page range entering in as needed */
<span class="lineNum">     324 </span>            :         retval = VM_PAGER_OK;
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         for (lcv = 0 ; lcv &lt; npages ; lcv++, curr_offset += PAGE_SIZE,</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :             curr_va += PAGE_SIZE) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                 if ((flags &amp; PGO_ALLPAGES) == 0 &amp;&amp; lcv != centeridx)</span>
<span class="lineNum">     328 </span>            :                         continue;
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                 if (pps[lcv] == PGO_DONTCARE)</span>
<span class="lineNum">     331 </span>            :                         continue;
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                 paddr = (*mapfn)(device, curr_offset, access_type);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                 if (paddr == -1) {</span>
<span class="lineNum">     335 </span>            :                         retval = VM_PAGER_ERROR;
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     337 </span>            :                 }
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :                 mapprot = ufi-&gt;entry-&gt;protection;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                 if (pmap_enter(ufi-&gt;orig_map-&gt;pmap, curr_va, paddr,</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                     mapprot, PMAP_CANFAIL | mapprot) != 0) {</span>
<span class="lineNum">     341 </span>            :                         /*
<span class="lineNum">     342 </span>            :                          * pmap_enter() didn't have the resource to
<span class="lineNum">     343 </span>            :                          * enter this mapping.  Unlock everything,
<span class="lineNum">     344 </span>            :                          * wait for the pagedaemon to free up some
<span class="lineNum">     345 </span>            :                          * pages, and then tell uvm_fault() to start
<span class="lineNum">     346 </span>            :                          * the fault again.
<span class="lineNum">     347 </span>            :                          *
<span class="lineNum">     348 </span>            :                          * XXX Needs some rethinking for the PGO_ALLPAGES
<span class="lineNum">     349 </span>            :                          * XXX case.
<span class="lineNum">     350 </span>            :                          */
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                         uvmfault_unlockall(ufi, ufi-&gt;entry-&gt;aref.ar_amap,</span>
<span class="lineNum">     352 </span>            :                             uobj, NULL);
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :                         /* sync what we have so far */
<span class="lineNum">     355 </span>            :                         pmap_update(ufi-&gt;orig_map-&gt;pmap);      
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                         uvm_wait(&quot;udv_fault&quot;);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                         return (VM_PAGER_REFAULT);</span>
<span class="lineNum">     358 </span>            :                 }
<span class="lineNum">     359 </span>            :         }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         uvmfault_unlockall(ufi, ufi-&gt;entry-&gt;aref.ar_amap, uobj, NULL);</span>
<span class="lineNum">     362 </span>            :         pmap_update(ufi-&gt;orig_map-&gt;pmap);
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         return (retval);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
