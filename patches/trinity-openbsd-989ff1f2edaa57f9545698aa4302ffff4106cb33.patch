diff --git a/Makefile b/Makefile
index d0938b0..a0d7dde 100644
--- a/Makefile
+++ b/Makefile
@@ -6,7 +6,6 @@ INSTALL_PREFIX ?= $(HOME)
 CC := gcc
 CC := $(CROSS_COMPILE)$(CC)
 LD := $(CROSS_COMPILE)$(LD)
-OS := $(shell uname)
 
 CFLAGS := -Wall -W -g -O2 -I. -Iinclude/ -Wimplicit -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE
 ifneq ($(SYSROOT),)
@@ -16,9 +15,7 @@ endif
 CFLAGS += -Wdeclaration-after-statement
 CFLAGS += -Wformat=2
 CFLAGS += -Winit-self
-ifeq ($(OS),Linux)
-	CFLAGS += -Wlogical-op
-endif
+CFLAGS += -Wlogical-op
 CFLAGS += -Wnested-externs
 CFLAGS += -Wpacked
 CFLAGS += -Wshadow
@@ -30,12 +27,13 @@ CFLAGS += -Wwrite-strings
 CFLAGS += -Wstrict-prototypes -Wmissing-prototypes
 
 # Only enabled during development.
-#CFLAGS += -Werror
+CFLAGS += -Werror
 
 V	= @
 Q	= $(V:1=)
 QUIET_CC = $(Q:@=@echo    '  CC	'$@;)
 
+
 all: trinity
 
 test:
@@ -50,75 +48,19 @@ SYSCALLS_ARCH	= $(shell case "$(MACHINE)" in \
 
 HEADERS		= $(patsubst %.h,%.h,$(wildcard *.h)) $(patsubst %.h,%.h,$(wildcard syscalls/*.h)) $(patsubst %.h,%.h,$(wildcard ioctls/*.h))
 
-OPENBSD_IOCTLS = ioctls/drm.c ioctls/ioctls.c ioctls/socket.c
-OPENBSD_SYSCALLS = syscalls/read.c syscalls/write.c syscalls/open.c syscalls/close.c \
-		   syscalls/poll.c syscalls/lseek.c syscalls/munmap.c syscalls/brk.c \
-		   syscalls/mprotect.c syscalls/readv.c syscalls/writev.c syscalls/access.c \
-		   syscalls/pipe.c syscalls/select.c syscalls/msync.c syscalls/mincore.c \
- 		   syscalls/madvise.c syscalls/shmat.c syscalls/shmctl.c syscalls/shmget.c \
- 		   syscalls/dup.c syscalls/dup2.c syscalls/pause.c syscalls/nanosleep.c \
-		   syscalls/getitimer.c syscalls/alarm.c syscalls/setitimer.c syscalls/getpid.c \
-		   syscalls/accept.c syscalls/connect.c syscalls/sendto.c syscalls/recvfrom.c \
-		   syscalls/recvmsg.c syscalls/sendmsg.c syscalls/shutdown.c syscalls/bind.c \
-		   syscalls/listen.c syscalls/getsockname.c syscalls/getpeername.c syscalls/socketpair.c \
-		   syscalls/getsockopt.c syscalls/socket.c \
-		syscalls/fork.c syscalls/vfork.c syscalls/execve.c syscalls/exit.c  \
-		syscalls/wait4.c syscalls/kill.c syscalls/semget.c syscalls/semop.c \
-		syscalls/semctl.c syscalls/msgget.c syscalls/msgsnd.c syscalls/msgrcv.c \
-		syscalls/msgctl.c syscalls/fcntl.c syscalls/flock.c syscalls/fsync.c \
-		syscalls/shmdt.c syscalls/fdatasync.c syscalls/truncate.c syscalls/ftruncate.c \
-		syscalls/getdents.c syscalls/chdir.c syscalls/fchdir.c \
-		syscalls/rename.c syscalls/mkdir.c syscalls/rmdir.c syscalls/creat.c \
-		syscalls/link.c syscalls/unlink.c syscalls/symlink.c syscalls/readlink.c \
-		syscalls/chmod.c syscalls/fchmod.c syscalls/chown.c syscalls/fchown.c \
-		syscalls/lchown.c syscalls/umask.c syscalls/gettimeofday.c syscalls/getrlimit.c \
-		syscalls/getrusage.c syscalls/ptrace.c syscalls/getuid.c syscalls/getgid.c \
-		syscalls/setuid.c syscalls/setgid.c syscalls/geteuid.c syscalls/getegid.c \
-		syscalls/setpgid.c syscalls/getppid.c syscalls/getpgrp.c syscalls/setsid.c \
-		syscalls/setreuid.c syscalls/setregid.c syscalls/getgroups.c syscalls/setgroups.c \
-		syscalls/setresuid.c syscalls/getresuid.c syscalls/setresgid.c syscalls/getresgid.c \
-		syscalls/getpgid.c syscalls/setfsuid.c syscalls/setfsgid.c syscalls/getsid.c \
-		syscalls/sigaltstack.c syscalls/mknod.c syscalls/ustat.c syscalls/statfs.c \
-		syscalls/fstatfs.c syscalls/getpriority.c syscalls/setpriority.c syscalls/mlock.c \
-		syscalls/munlock.c syscalls/mlockall.c syscalls/munlockall.c syscalls/vhangup.c \
-		syscalls/sysctl.c syscalls/setrlimit.c \
-		syscalls/chroot.c syscalls/sync.c syscalls/acct.c syscalls/settimeofday.c syscalls/mount.c \
-		syscalls/clock_settime.c syscalls/clock_gettime.c syscalls/clock_getres.c syscalls/quotactl.c \
-		syscalls/openat.c syscalls/mkdirat.c syscalls/mknodat.c syscalls/fchownat.c syscalls/fstatat64.c \
-		syscalls/unlinkat.c syscalls/renameat.c syscalls/linkat.c syscalls/symlinkat.c syscalls/readlinkat.c \
-		syscalls/fchmodat.c syscalls/faccessat.c syscalls/ppoll.c syscalls/utimensat.c \
-		syscalls/accept4.c syscalls/pselect6.c syscalls/reboot.c
-
-OPENBSD_NET = 	   net/sockaddr.c net/ipv4.c net/ipv6.c net/unix.c net/protocols.c
-
-ifeq ($(OS),Linux)
 SRCS		= $(wildcard *.c) \
 		  $(wildcard children/*.c) \
-		  $(wildcard syscalls/*.c) \
 		  $(wildcard ioctls/*.c) \
 		  $(wildcard net/*.c) \
-
-OBJS		= $(sort $(patsubst %.c,%.o,$(wildcard *.c))) \
-		  $(sort $(patsubst %.c,%.o,$(wildcard children/*.c))) \
-		  $(sort $(patsubst %.c,%.o,$(wildcard syscalls/*.c))) \
-		  $(sort $(patsubst %.c,%.o,$(wildcard ioctls/*.c))) \
-		  $(sort $(patsubst %.c,%.o,$(wildcard net/*.c)))
-else
-SRCS		= $(wildcard *.c) \
-		  $(wildcard children/*.c) \
-		  $(OPENBSD_IOCTLS) \
-		  $(OPENBSD_SYSCALLS) \
-		  $(OPENBSD_NET) \
+		  $(wildcard syscalls/*.c) \
 		  $(SYSCALLS_ARCH)
 
 OBJS		= $(sort $(patsubst %.c,%.o,$(wildcard *.c))) \
 		  $(sort $(patsubst %.c,%.o,$(wildcard children/*.c))) \
-		  $(sort $(patsubst %.c,%.o,$(OPENBSD_IOCTLS))) \
-		  $(sort $(patsubst %.c,%.o,$(OPENBSD_SYSCALLS))) \
-		  $(sort $(patsubst %.c,%.o,$(OPENBSD_NET))) \
+		  $(sort $(patsubst %.c,%.o,$(wildcard ioctls/*.c))) \
+		  $(sort $(patsubst %.c,%.o,$(wildcard net/*.c))) \
+		  $(sort $(patsubst %.c,%.o,$(wildcard syscalls/*.c))) \
 		  $(sort $(patsubst %.c,%.o,$(SYSCALLS_ARCH)))
-endif
-
 
 DEPDIR= .deps
 
@@ -169,7 +111,7 @@ install: trinity
 	install -d -m 755 $(INSTALL_PREFIX)/bin
 	install trinity $(INSTALL_PREFIX)/bin
 
-tags:
+tags:	$(SRCS)
 	@ctags -R --exclude=tmp
 
 mirror:
diff --git a/child.c b/child.c
index 0369be7..9dd5494 100644
--- a/child.c
+++ b/child.c
@@ -11,9 +11,8 @@
 #include <sched.h>
 #include <sys/time.h>
 #include <sys/resource.h>
-#ifdef __LINUX__
 #include <sys/prctl.h>
-#endif /* __LINUX__ */
+
 #include "child.h"
 #include "syscall.h"
 #include "log.h"
@@ -48,9 +47,8 @@ static void reenable_coredumps(void)
 {
 	if (debug == TRUE)
 		return;
-#ifdef __LINUX__
+
 	prctl(PR_SET_DUMPABLE, TRUE);
-#endif /* __LINUX__ */
 
 	if (setrlimit(RLIMIT_CORE, &oldrlimit) != 0) {
 		outputerr("[%d] Error restoring rlimits to cur:%d max:%d (%s)\n",
@@ -96,10 +94,8 @@ static void use_fpu(void)
 
 void init_child(int childno)
 {
-#ifdef __LINUX__
 	cpu_set_t set;
 	pid_t pid = getpid();
-#endif /* __LINUX__ */
 
 	set_seed(childno);
 
@@ -107,23 +103,17 @@ void init_child(int childno)
 
 	disable_coredumps();
 
-#ifdef __LINUX__
 	if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 		CPU_ZERO(&set);
 		CPU_SET(childno, &set);
 		sched_setaffinity(pid, sizeof(set), &set);
 	}
-#endif /* __LINUX__ */
 
 	shm->child_syscall_count[childno] = 0;
 
 	set_make_it_fail();
 
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 100 < 50)
-#else
 	if (rand() % 100 < 50)
-#endif
 		use_fpu();
 }
 
@@ -139,7 +129,7 @@ void check_parent_pid(void)
 
 	parent_check_time = 10;
 
-	if (getppid() == mainpid)
+	if (getppid() == shm->mainpid)
 		return;
 
 	pid = getpid();
@@ -147,7 +137,7 @@ void check_parent_pid(void)
 	//FIXME: Add locking so only one child does this output.
 	output(0, BUGTXT "CHILD (pid:%d) GOT REPARENTED! "
 		"parent pid:%d. Watchdog pid:%d\n",
-		pid, mainpid, watchdog_pid);
+		pid, shm->mainpid, watchdog_pid);
 	output(0, BUGTXT "Last syscalls:\n");
 
 	for (i = 0; i < MAX_NR_CHILDREN; i++) {
@@ -185,11 +175,7 @@ int child_process(int childno)
 	int ret;
 	unsigned int i;
 
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random() % ARRAY_SIZE(child_functions);
-#else
 	i = rand() % ARRAY_SIZE(child_functions);
-#endif
 
 #ifdef DEBUG_MULTI
 	output(0, "Chose %s.\n", child_functions[i].name);
diff --git a/children/random-syscalls.c b/children/random-syscalls.c
index 618c28f..610a6c6 100644
--- a/children/random-syscalls.c
+++ b/children/random-syscalls.c
@@ -50,11 +50,7 @@ static void choose_syscall_table(int childno)
 			 */
 			shm->do32bit[childno] = FALSE;
 
-#ifdef HAVE_ARC4RANDOM
-			if (arc4random() % 100 < 10)
-#else
 			if (rand() % 100 < 10)
-#endif
 				shm->do32bit[childno] = TRUE;
 		}
 
@@ -79,6 +75,37 @@ static void choose_syscall_table(int childno)
 
 extern int sigwas;
 
+static unsigned int handle_sigreturn(int childno)
+{
+	static unsigned int count = 0;
+	static unsigned int last = -1;
+
+	output(2, "<timed out>\n");	/* Flush out the previous syscall output. */
+
+	/* Check if we're making any progress at all. */
+	if (shm->child_syscall_count[childno] == last) {
+		count++;
+		//output(1, "no progress for %d tries.\n", count);
+	} else {
+		count = 0;
+		last = shm->child_syscall_count[childno];
+	}
+	if (count == 3) {
+		output(1, "no progress for 3 tries, exiting child.\n");
+		return 0;
+	}
+
+	if (shm->kill_count[childno] > 0) {
+		output(1, "[%d] Missed a kill signal, exiting\n", getpid());
+		return 0;
+	}
+
+	if (sigwas != SIGALRM)
+		output(1, "[%d] Back from signal handler! (sig was %s)\n", getpid(), strsignal(sigwas));
+
+	return 1;
+}
+
 int child_random_syscalls(int childno)
 {
 	int ret;
@@ -86,18 +113,11 @@ int child_random_syscalls(int childno)
 
 	ret = sigsetjmp(ret_jump, 1);
 	if (ret != 0) {
-		output(1, "<timed out>\n");	/* Flush out the previous syscall output. */
-		if (sigwas != SIGALRM)
-			output(1, "[%d] Back from signal handler! (sig was %s)\n", getpid(), strsignal(sigwas));
-
-		if (shm->kill_count[childno] > 0) {
-			output(1, "[%d] Missed a kill signal, exiting\n", getpid());
+		if (handle_sigreturn(childno) == 0)
 			return 0;
-		}
+		ret = 0;
 	}
 
-	ret = 0;
-
 	while (shm->exit_reason == STILL_RUNNING) {
 
 		check_parent_pid();
@@ -121,11 +141,7 @@ int child_random_syscalls(int childno)
 			goto out;
 		}
 
-#ifdef HAVE_ARC4RANDOM
-		syscallnr = arc4random() % nr_active_syscalls;
-#else
 		syscallnr = rand() % nr_active_syscalls;
-#endif
 		/* If we got a syscallnr which is not actvie repeat the attempt, since another child has switched that syscall off already.*/
 		if (active_syscalls[syscallnr] == 0)
 			continue;
diff --git a/configure.sh b/configure.sh
index a9fee60..91916ba 100755
--- a/configure.sh
+++ b/configure.sh
@@ -15,6 +15,11 @@ MISSING_DEFS=0
 # expand tilde
 CC="$(eval echo ${CROSS_COMPILE}${CC})"
 
+CFLAGS=""
+if [ "${SYSROOT}xx" != "xx" ]; then
+	CFLAGS="$(eval echo --sysroot=${SYSROOT} )"
+fi
+
 echo "/* This file is auto-generated by configure.sh */" > config.h
 
 TMP=$(mktemp)
@@ -26,7 +31,7 @@ check_header()
 	rm -f "$TMP" || exit 1
 	echo "#include <$1>" >"$TMP.c"
 
-	${CC} "$TMP.c" -E &>"$TMP.log"
+	${CC} ${CFLAGS} "$TMP.c" -E &>"$TMP.log"
 	if [ $? -eq 0 ]; then
 		echo $GREEN "[YES]" $COL_RESET
 		echo "#define $2 1" >> config.h
@@ -36,20 +41,6 @@ check_header()
 	fi
 }
 
-os()
-{
-	echo "[*] Checking operation system... "
-	OS=`uname`
-	echo -n "#define " >> config.h
-	if [ $OS = "Linux" ]; then
-		echo "__LINUX__" >> config.h
-	elif [ $OS = "OpenBSD" ]; then
-		echo "__BSD__" >> config.h
-	else
-		echo $OS >> config.h
-	fi
-}
-
 #############################################################################################
 
 echo -n "#define " >> config.h
@@ -78,8 +69,7 @@ void main()
 }
 EOF
 
-${CC} "$TMP.c" -o "$TMP" &>"$TMP.log"
-
+${CC} ${CFLAGS} "$TMP.c" -o "$TMP" &>"$TMP.log"
 if [ ! -x "$TMP" ]; then
 	echo $RED "[NO]" $COL_RESET
 	MISSING_DEFS=1
@@ -107,8 +97,7 @@ void main()
 }
 EOF
 
-${CC} "$TMP.c" -o "$TMP" &>"$TMP.log"
-
+${CC} ${CFLAGS} "$TMP.c" -o "$TMP" &>"$TMP.log"
 if [ ! -x "$TMP" ]; then
 	echo $RED "[NO]" $COL_RESET
 	MISSING_DEFS=1
@@ -136,8 +125,7 @@ void main()
 }
 EOF
 
-${CC} "$TMP.c" -o "$TMP" &>"$TMP.log"
-
+${CC} ${CFLAGS} "$TMP.c" -o "$TMP" &>"$TMP.log"
 if [ ! -x "$TMP" ]; then
 	echo $RED "[NO]" $COL_RESET
 	MISSING_DEFS=1
@@ -163,8 +151,7 @@ void main()
 }
 EOF
 
-${CC} "$TMP.c" -o "$TMP" &>"$TMP.log"
-
+${CC} ${CFLAGS} "$TMP.c" -o "$TMP" &>"$TMP.log"
 if [ ! -x "$TMP" ]; then
 	echo $RED "[NO]" $COL_RESET
 	MISSING_DEFS=1
@@ -190,8 +177,7 @@ int main()
 }
 EOF
 
-${CC} "$TMP.c" -o "$TMP" &>"$TMP.log"
-
+${CC} ${CFLAGS} "$TMP.c" -o "$TMP" &>"$TMP.log"
 if [ ! -x "$TMP" ]; then
 	echo $RED "[NO]" $COL_RESET
 	MISSING_DEFS=1
@@ -202,32 +188,6 @@ fi
 
 #############################################################################################
 
-# Do libc headers provides arc4random
-
-echo -n "[*] Checking if libc headers provides arc4random... "
-rm -f "$TMP" || exit 1
-
-cat >"$TMP.c" << EOF
-#include <stdlib.h>
-
-int main()
-{
-	arc4random();
-}
-EOF
-
-${CC} "$TMP.c" -o "$TMP" &>"$TMP.log"
-
-if [ ! -x "$TMP" ]; then
-	echo $RED "[NO]" $COL_RESET
-	MISSING_DEFS=1
-else
-	echo $GREEN "[YES]" $COL_RESET
-	echo "#define HAVE_ARC4RANDOM" >> config.h
-fi
-
-#############################################################################################
-
 check_header linux/caif/caif_socket.h USE_CAIF
 check_header linux/if_alg.h USE_IF_ALG
 check_header linux/rds.h USE_RDS
@@ -239,10 +199,6 @@ check_header sound/compress_offload.h USE_SNDDRV_COMPRESS_OFFLOAD
 check_header linux/kvm.h USE_KVM
 check_header linux/seccomp.h USE_SECCOMP
 check_header linux/vhost.h USE_VHOST
-check_header sys/epoll.h USE_EPOLL
-check_header sys/eventfd.h USE_EVENTFD
-
-os
 
 rm -f "$TMP" "$TMP.log" "$TMP.c"
 
@@ -253,13 +209,13 @@ if [ "$DEVEL" == "1" ]; then
 fi
 
 #############################################################################################
-[ `uname` = "Linux" ] && M="make" || M="gmake"
+
 if [ "$MISSING_DEFS" == "1" ]; then
   echo "[-] Some header definitions were missing. This is not fatal."
   echo "    It usually means you're building on an older distribution which doesn't"
   echo "    have header files describing newer kernel features."
   echo "    Trinity will still compile and run, it just won't use those new features."
-  echo "    Go ahead, and run '$M'"
+  echo "    Go ahead, and run 'make'"
 fi
 
 exit 0
diff --git a/devices.c b/devices.c
index 9028fc1..fe1a8f8 100644
--- a/devices.c
+++ b/devices.c
@@ -6,10 +6,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <config.h>
-#ifdef __LINUX__
 #include <linux/kdev_t.h>
-#endif /* __LINUX__ */
 #include "files.h"
 
 #include "log.h"
@@ -120,15 +117,8 @@ const char *map_dev(dev_t st_rdev, mode_t st_mode)
 	int major, minor;
 	size_t i, j;
 
-#ifdef __LINUX__
 	major = MAJOR(st_rdev);
 	minor = MINOR(st_rdev);
-#endif /* __LINUX__ */
-
-#ifdef __BSD__
-	major = major(st_rdev);
-	minor = minor(st_rdev);
-#endif /* __BSD__ */
 
 	if (S_ISCHR(st_mode)) {
 		for (i = 0; i < chrdevs; ++i) {
diff --git a/fds.c b/fds.c
index 2040687..c7510b9 100644
--- a/fds.c
+++ b/fds.c
@@ -3,12 +3,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#ifdef USE_EPOLL
 #include <sys/epoll.h>
-#endif
-#ifdef USE_EVENTFD
 #include <sys/eventfd.h>
-#endif
+
 #include "perf.h"
 #include "random.h"
 #include "shm.h"
@@ -18,7 +15,6 @@
 #include "log.h"
 #include "sanitise.h"
 #include "params.h"
-#include "config.h"	// arc4random
 
 /* Pipe FD related functions. */
 static void open_pipes(void)
@@ -41,24 +37,15 @@ static void open_pipes(void)
 
 static int rand_pipe_fd(void)
 {
-#ifdef HAVE_ARC4RANDOM
-	return shm->pipe_fds[arc4random() % MAX_PIPE_FDS];
-#else
 	return shm->pipe_fds[rand() % MAX_PIPE_FDS];
-#endif
 }
 
 /* perf related fds (see also perf.c & syscalls/perf_event_open.c) */
 static int rand_perf_fd(void)
 {
-#ifdef HAVE_ARC4RANDOM
-	return shm->perf_fds[arc4random() % MAX_PERF_FDS];
-#else
 	return shm->perf_fds[rand() % MAX_PERF_FDS];
-#endif
 }
 
-#ifdef USE_EPOLL
 /* epoll related fds */
 static void open_epoll_fds(void)
 {
@@ -88,9 +75,7 @@ static int rand_epoll_fd(void)
 {
 	return shm->epoll_fds[rand() % MAX_EPOLL_FDS];
 }
-#endif /* USE_EPOLL */
 
-#ifdef USE_EVENTFD
 /* eventfd FDs */
 static void open_eventfd_fds(void)
 {
@@ -113,7 +98,6 @@ static int rand_eventfd_fd(void)
 {
 	return shm->eventfd_fds[rand() % MAX_EVENTFD_FDS];
 }
-#endif /* USE_EVENTFD */
 
 /* regular file FDs  */
 unsigned int nr_file_fds = 0;
@@ -122,11 +106,7 @@ static int rand_file_fd(void)
 {
 	unsigned int fd_index;
 
-#ifdef HAVE_ARC4RANDOM
-	fd_index = arc4random() % nr_file_fds;
-#else
 	fd_index = rand() % nr_file_fds;
-#endif
 	return shm->file_fds[fd_index];
 }
 
@@ -137,11 +117,7 @@ static int get_new_random_fd(void)
 	int fd = 0;
 
 retry:
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random() % 6;
-#else
 	i = rand() % 6;
-#endif
 
 	if (do_specific_proto == TRUE)
 		i = 1;
@@ -177,11 +153,7 @@ retry:
 				fd = rand_pipe_fd();
 			return fd;
 		}
-#ifdef HAVE_ARC4RANDOM
-		fd = shm->socket_fds[arc4random() % nr_sockets];
-#else
-		fd = shm->socket_fds[rand() % nr_sockets];
-#endif
+		fd = shm->sockets[rand() % nr_sockets].fd;
 		break;
 
 	case 2:
@@ -195,17 +167,13 @@ retry:
 		fd = rand_perf_fd();
 		break;
 
-#ifdef USE_EPOLL
 	case 4:
 		fd = rand_epoll_fd();
 		break;
-#endif
 
-#ifdef USE_EVENT_FD
 	case 5:
 		fd = rand_eventfd_fd();
 		break;
-#endif
 
 	default:
 		break;
@@ -217,22 +185,14 @@ retry:
 int get_random_fd(void)
 {
 	/* 25% chance of returning something new. */
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 4) == 0)
-#else
 	if ((rand() % 4) == 0)
-#endif
 		return get_new_random_fd();
 
 	/* the rest of the time, return the same fd as last time. */
 regen:
 	if (shm->fd_lifetime == 0) {
 		shm->current_fd = get_new_random_fd();
-#ifdef HAVE_ARC4RANDOM
-		shm->fd_lifetime = (arc4random() % shm->max_children) + 5;
-#else
 		shm->fd_lifetime = (rand() % shm->max_children) + 5;
-#endif
 	} else
 		shm->fd_lifetime--;
 
@@ -246,20 +206,17 @@ regen:
 
 void setup_fds(void)
 {
-	open_sockets();
+	/* If we have victim files, don't worry about sockets. */
+	if (victim_path == NULL)
+		open_sockets();
 
 	open_pipes();
-#ifdef __LINUX__
+
 	open_perf_fds();
-#endif
 
-#ifdef USE_EPOLL
 	open_epoll_fds();
-#endif
 
-#ifdef USE_EVENTFD
 	open_eventfd_fds();
-#endif
 
 	if (no_files == FALSE) {
 		generate_filelist();
diff --git a/files.c b/files.c
index 5596b7c..8f4ff2d 100644
--- a/files.c
+++ b/files.c
@@ -19,9 +19,6 @@
 #include "constants.h"
 #include "list.h"
 #include "random.h"
-#ifdef __BSD__
-#include <fts.h>
-#endif
 
 static int files_added = 0;
 const char **fileindex;
@@ -171,44 +168,29 @@ static int check_stat_file(const struct stat *sb)
 
 static int file_tree_callback(const char *fpath, const struct stat *sb, __unused__ int typeflag, __unused__ struct FTW *ftwbuf)
 {
+
 	if (ignore_files(fpath)) {
-#ifdef __LINUX__
 		return FTW_SKIP_SUBTREE;
-#endif
-#ifdef __BSD__
-		return FTS_SKIP;
-#endif
 	}
 
 	// Check we can read it.
 	if (check_stat_file(sb) == -1)
-#ifdef __LINUX__
 		return FTW_CONTINUE;
-#endif /* __LINUX__ */
-#ifdef __BSD__
-		return FTW_NS;
-#endif /* __BSD__ */
 
-#ifdef __LINUX__
 	if (shm->exit_reason != STILL_RUNNING)
 		return FTW_STOP;
-#endif /* __LINUX__ */
+
 	add_to_namelist(fpath);
 	files_added++;
 
-#ifdef __LINUX__
 	return FTW_CONTINUE;
-#endif /* __LINUX__ */
 }
 
+
 static void open_fds(const char *dirpath)
 {
 	int before = files_added;
-#ifdef __BSD__
-	int flags = FTW_DEPTH | FTW_MOUNT;
-#else
 	int flags = FTW_DEPTH | FTW_ACTIONRETVAL | FTW_MOUNT;
-#endif /* __BSD__ */
 	int ret;
 
 	/* By default, don't follow symlinks so we only get each file once.
@@ -226,6 +208,7 @@ static void open_fds(const char *dirpath)
 				dirpath, ret, strerror(errno));
 		return;
 	}
+
 	output(0, "Added %d filenames from %s\n", files_added - before, dirpath);
 }
 
@@ -350,9 +333,5 @@ const char * get_filename(void)
 	if (files_in_index == 0)	/* This can happen if we run with -n. Should we do something else ? */
 		return NULL;
 
-#ifdef HAVE_ARC4RANDOM
-	return fileindex[arc4random() % files_in_index];
-#else
 	return fileindex[rand() % files_in_index];
-#endif
 }
diff --git a/generic-sanitise.c b/generic-sanitise.c
index 36ddf25..db61bb3 100644
--- a/generic-sanitise.c
+++ b/generic-sanitise.c
@@ -18,26 +18,8 @@
 static unsigned int get_cpu(void)
 {
 	int i;
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random() % 100;
-#else
 	i = rand() % 100;
-#endif
 
-#ifdef HAVE_ARC4RANDOM
-	switch (i) {
-	case 0: return -1;
-	case 1: return arc4random() % 4095;
-	case 2: return arc4random() % 15;
-
-	case 3 ... 99:
-		return arc4random() % num_online_cpus;
-
-	default:
-		BUG("unreachable!\n");
-		break;
-	}
-#else
 	switch (i) {
 	case 0: return -1;
 	case 1: return rand() % 4095;
@@ -50,7 +32,6 @@ static unsigned int get_cpu(void)
 		BUG("unreachable!\n");
 		break;
 	}
-#endif
 	return 0;
 }
 
@@ -66,11 +47,7 @@ static unsigned long handle_arg_address(int childno, int call, int argnum)
 
 	addr = find_previous_arg_address(argnum, call, childno);
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 4) {
-#else
 	switch (rand() % 4) {
-#endif
 	case 0:	break;	/* return unmodified */
 	case 1:	addr++;
 		break;
@@ -162,11 +139,7 @@ static unsigned long handle_arg_op(unsigned long call, unsigned long argnum)
 	if (values == NULL)
 		BUG("ARG_OP with no values.\n");
 
-#ifdef HAVE_ARC4RANDOM
-	mask |= values[arc4random() % num];
-#else
 	mask |= values[rand() % num];
-#endif
 	return mask;
 }
 
@@ -206,17 +179,9 @@ static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 	if (values == NULL)
 		BUG("ARG_LIST with no values.\n");
 
-#ifdef HAVE_ARC4RANDOM
-	bits = arc4random() % (num + 1);	/* num of bits to OR */
-#else
 	bits = rand() % (num + 1);	/* num of bits to OR */
-#endif
 	for (i = 0; i < bits; i++)
-#ifdef HAVE_ARC4RANDOM
-		mask |= values[arc4random() % num];
-#else
 		mask |= values[rand() % num];
-#endif
 	return mask;
 }
 
@@ -235,11 +200,7 @@ static unsigned long handle_arg_iovec(int childno, unsigned long call, unsigned
 {
 	unsigned long i;
 
-#ifdef HAVE_ARC4RANDOM
-	i = (arc4random() % 5) + 1;
-#else
 	i = (rand() % 5) + 1;
-#endif
 
 	switch (argnum) {
 	case 1:	if (syscalls[call].entry->arg2type == ARG_IOVECLEN)
@@ -315,24 +276,12 @@ static unsigned long handle_arg_mode_t(void)
 	unsigned int i, j, count, bit;
 	mode_t mode = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	count = arc4random() % 9;
-#else
 	count = rand() % 9;
-#endif
 
 	for (i = 0; i < count; i++) {
-#ifdef HAVE_ARC4RANDOM
-		bit = arc4random() % 3;
-#else
 		bit = rand() % 3;
-#endif
 		mode |= 1 << bit;
-#ifdef HAVE_ARC4RANDOM
-		j = arc4random() % 12;
-#else
 		j = rand() % 12;
-#endif
 		switch (j) {
 		case 0: mode |= S_IRUSR; break;
 		case 1: mode |= S_IWUSR; break;
diff --git a/include/arch-parisc.h b/include/arch-parisc.h
new file mode 100644
index 0000000..757facf
--- /dev/null
+++ b/include/arch-parisc.h
@@ -0,0 +1,22 @@
+// FIXME: depends on kernel bit size, userspace is always 32 bit
+
+#define PAGE_OFFSET 0x10000000
+
+#if 0
+// for 64 bit
+#define PAGE_OFFSET 0x40000000
+#endif
+
+#define KERNEL_ADDR	0xa0000000	// FIXME: Placeholder
+#define MODULE_ADDR     0xa0000000L	// FIXME: Placeholder
+#define TASK_SIZE 0xa0000000	// FIXME: Placeholder
+
+#define PAGE_SHIFT 		12
+#define PTE_FILE_MAX_BITS	(32 - 11)
+
+#define PTRACE_GETREGS		0
+#define PTRACE_GETFPREGS	0
+#define PTRACE_SETREGS		0
+#define PTRACE_SETFPREGS	0
+
+#define SYSCALLS syscalls_parisc
diff --git a/include/arch-syscalls.h b/include/arch-syscalls.h
index 03b701d..22866f5 100644
--- a/include/arch-syscalls.h
+++ b/include/arch-syscalls.h
@@ -2,13 +2,8 @@
 #define _ARCH_SYSCALLS_H 1
 
 #ifdef __x86_64__
-#ifdef __BSD__
-#include "syscalls-x86_64-openbsd.h"
-#include "syscalls-i386-openbsd.h"
-#elif
 #include "syscalls-x86_64.h"
 #include "syscalls-i386.h"
-#endif /* __BSD__ */
 #endif
 #ifdef __i386__
 #include "syscalls-i386.h"
@@ -43,4 +38,7 @@
 #ifdef __aarch64__
 #include "syscalls-aarch64.h"
 #endif
+#ifdef __hppa__
+#include "syscalls-parisc.h"
+#endif
 #endif  /* _ARCH_SYSCALLS_H */
diff --git a/include/arch.h b/include/arch.h
index 1835204..fe91660 100644
--- a/include/arch.h
+++ b/include/arch.h
@@ -45,6 +45,10 @@
 #include "arch-aarch64.h"
 #endif
 
+#ifdef __hppa__
+#include "arch-parisc.h"
+#endif
+
 #ifndef SYSCALL_OFFSET
 #define SYSCALL_OFFSET 0
 #endif
diff --git a/include/compat.h b/include/compat.h
index 1e33ae9..dfd8714 100644
--- a/include/compat.h
+++ b/include/compat.h
@@ -332,6 +332,10 @@ enum kcmp_type {
 #define SO_BUSY_POLL		46
 #endif
 
+#ifndef SO_MAX_PACING_RATE
+#define SO_MAX_PACING_RATE	47
+#endif
+
 /* linux/tcp.h */
 #ifndef TCP_COOKIE_TRANSACTIONS
 #define TCP_COOKIE_TRANSACTIONS	15
@@ -441,7 +445,6 @@ enum kcmp_type {
 #define IP_UNICAST_IF		50
 #endif
 
-#ifdef __LINUX__
 /* linux/in6.h */
 #ifndef IPV6_FLOWINFO
 #define IPV6_FLOWINFO 11
@@ -555,7 +558,6 @@ enum kcmp_type {
 #ifndef sockaddr_nfc
 #include <bits/sockaddr.h>
 #include <linux/types.h>
-#endif
 
 struct sockaddr_nfc {
 	sa_family_t sa_family;
@@ -586,7 +588,6 @@ struct sockaddr_nfc {
 #define MS_BORN		(1<<29)
 #endif
 
-#ifdef __LINUX__
 /* linux/kvm.h */
 #ifndef KVM_GET_REG_LIST
 struct kvm_reg_list {
@@ -782,7 +783,6 @@ struct kvm_get_htab_fd {
 #ifndef MRT_DEL_MFC_PROXY
 #define MRT_DEL_MFC_PROXY	(MRT_BASE+11)
 #endif
-#endif /* __LINUX__ */
 
 /* sys/mount.h */
 #ifndef MNT_DETACH
@@ -798,6 +798,15 @@ struct kvm_get_htab_fd {
 #endif
 
 /* if_ether.h */
+#ifndef ETH_P_CANFD
+#define ETH_P_CANFD	0x000D
+#endif
+#ifndef ETH_P_CAIF
+#define ETH_P_CAIF	0x00F7
+#endif
+#ifndef ETH_P_802_3_MIN
+#define ETH_P_802_3_MIN	0x0600
+#endif
 #ifndef ETH_P_BATMAN
 #define ETH_P_BATMAN	0x4305
 #endif
@@ -816,6 +825,9 @@ struct kvm_get_htab_fd {
 #ifndef ETH_P_MVRP
 #define ETH_P_MVRP	0x88F5
 #endif
+#ifndef ETH_P_PRP
+#define ETH_P_PRP	0x88FB
+#endif
 #ifndef ETH_P_QINQ1
 #define ETH_P_QINQ1	0x9100
 #endif
@@ -825,14 +837,5 @@ struct kvm_get_htab_fd {
 #ifndef ETH_P_QINQ3
 #define ETH_P_QINQ3	0x9300
 #endif
-#ifndef ETH_P_802_3_MIN
-#define ETH_P_802_3_MIN	0x0600
-#endif
-#ifndef ETH_P_CANFD
-#define ETH_P_CANFD	0x000D
-#endif
-#ifndef ETH_P_CAIF
-#define ETH_P_CAIF	0x00F7
-#endif
 
 #endif	/* _TRINITY_COMPAT_H */
diff --git a/include/log.h b/include/log.h
index b257b53..22ad80a 100644
--- a/include/log.h
+++ b/include/log.h
@@ -1,7 +1,10 @@
 #ifndef _LOG_H
 #define _LOG_H 1
 
+#include <unistd.h>
 #include "types.h"
+#include "exit.h"
+#include "shm.h"
 
 #define ANSI_RED	"[1;31m"
 #define ANSI_GREEN	"[1;32m"
@@ -47,6 +50,15 @@ void debugf(const char *fmt, ...);
 #define BUGTXT ANSI_RED "BUG!: " ANSI_RESET GIT_VERSION
 #endif
 
-#define BUG(bugtxt)	{ printf("%s:%s:%d %s", __FILE__, __func__, __LINE__, bugtxt); while(1); }
+#define BUG(bugtxt)	{ \
+	printf("[%d] %s:%s:%d %s", getpid(), __FILE__, __func__, __LINE__, bugtxt); \
+	while(1) { \
+		if (shm->exit_reason == EXIT_SIGINT) \
+			exit(EXIT_FAILURE);	\
+		sleep(1); \
+	}\
+}
+
+#define BUG_ON(condition)	do { if ((condition)) BUG(BUGTXT); } while (0)
 
 #endif	/* _LOG_H */
diff --git a/include/net.h b/include/net.h
index 78665d2..0b1b156 100644
--- a/include/net.h
+++ b/include/net.h
@@ -4,13 +4,9 @@
 #include <netinet/in.h>
 
 extern unsigned int nr_sockets;
-void open_sockets(void);
-void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf);
 
 /* protocol decoding */
 extern unsigned int specific_proto;
-const char * get_proto_name(unsigned int proto);
-void find_specific_proto(const char *protoarg);
 
 
 /* glibc headers might be older than the kernel, so chances are we know
@@ -35,10 +31,26 @@ struct sockopt {
 	unsigned long optlen;
 };
 
+/* We create one of these per socket fd we open, and store them in shm->sockets */
+struct socketinfo {
+	struct socket_triplet triplet;
+	int fd;
+};
+
+void open_sockets(void);
+void close_sockets(void);
+
+void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf);
+
+void do_setsockopt(struct sockopt *so);
+
 void rand_proto_type(struct socket_triplet *st);
 int sanitise_socket_triplet(struct socket_triplet *st);
 void gen_socket_args(struct socket_triplet *st);
 
+/* Ethernet */
+int get_random_ether_type(void);
+
 /* ipv4 */
 in_addr_t random_ipv4_address(void);
 void ipv4_gen_sockaddr(unsigned long *addr, unsigned long *addrlen);
diff --git a/include/params.h b/include/params.h
index 159ea60..e05727e 100644
--- a/include/params.h
+++ b/include/params.h
@@ -2,6 +2,7 @@
 #define _PARAMS_H 1
 
 #include "types.h"
+#include "net.h"
 
 #define TAINT_PROPRIETARY_MODULE        0
 #define TAINT_FORCED_MODULE             1
@@ -30,6 +31,7 @@ extern bool do_exclude_syscall;
 extern unsigned int specific_proto;
 extern bool do_specific_proto;
 extern char *specific_proto_optarg;
+extern bool no_protos[TRINITY_PF_MAX];
 extern bool dopause;
 extern bool show_syscall_list;
 extern bool show_ioctl_list;
diff --git a/include/perf.h b/include/perf.h
index 0ec5ae4..eeb6094 100644
--- a/include/perf.h
+++ b/include/perf.h
@@ -1,8 +1,6 @@
-#ifdef __LINUX__
 #ifndef _TRINITY_PERF_H
 #define _TRINITY_PERF_H
 
 void open_perf_fds(void);
 
 #endif /* _TRINITY_PERF_H */
-#endif /* __LINUX__ */
diff --git a/include/protocols.h b/include/protocols.h
new file mode 100644
index 0000000..6414d65
--- /dev/null
+++ b/include/protocols.h
@@ -0,0 +1,9 @@
+#ifndef _PROTOCOLS_H
+#define _PROTOCOLS_H 1
+
+extern const char * get_proto_name(unsigned int proto);
+extern void find_specific_proto(const char *protoarg);
+extern void parse_exclude_protos(const char *arg);
+extern unsigned int find_next_enabled_proto(unsigned int from);
+
+#endif /* _PROTOCOLS_H */
diff --git a/include/shm.h b/include/shm.h
index 0493eb0..353f78a 100644
--- a/include/shm.h
+++ b/include/shm.h
@@ -6,9 +6,10 @@
 
 #include <stdio.h>
 
-#include "types.h"
-#include "exit.h"
 #include "constants.h"
+#include "exit.h"
+#include "net.h"
+#include "types.h"
 
 struct shm_s {
 	unsigned long total_syscalls_done;
@@ -30,6 +31,7 @@ struct shm_s {
 	unsigned int nr_active_32bit_syscalls;
 	unsigned int nr_active_64bit_syscalls;
 
+	pid_t mainpid;
 	pid_t pids[MAX_NR_CHILDREN];
 	unsigned char child_type[MAX_NR_CHILDREN];
 
@@ -45,11 +47,12 @@ struct shm_s {
 
 	int pipe_fds[MAX_PIPE_FDS*2];
 	int file_fds[NR_FILE_FDS];		/* All children inherit these */
-	int socket_fds[NR_SOCKET_FDS];
 	int perf_fds[MAX_PERF_FDS];
 	int epoll_fds[MAX_EPOLL_FDS];
 	int eventfd_fds[MAX_EPOLL_FDS];
 
+	struct socketinfo sockets[NR_SOCKET_FDS];
+
 	/* state for the syscall currently in progress. */
 	unsigned int previous_syscallno[MAX_NR_CHILDREN];
 	unsigned long previous_a1[MAX_NR_CHILDREN];
diff --git a/include/syscall.h b/include/syscall.h
index 38bbd48..7701c66 100644
--- a/include/syscall.h
+++ b/include/syscall.h
@@ -105,6 +105,6 @@ struct syscalltable {
 #define NEED_ALARM (1<<5)
 #define TO_BE_DEACTIVATED (1<<6)
 
-long syscall32(int num_args, unsigned int call, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6);
+long syscall32(unsigned int call, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6);
 
 #endif	/* _TRINITY_SYSCALL_H */
diff --git a/include/syscalls-i386-openbsd.h b/include/syscalls-i386-openbsd.h
deleted file mode 100644
index 71e222e..0000000
--- a/include/syscalls-i386-openbsd.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/* Syscalls from arch/x86/syscalls/syscall_32.tbl as of 3.8rc1 */
-
-#include "sanitise.h"
-#include "syscall.h"
-#include "syscalls/syscalls.h"
-
-struct syscalltable syscalls_i386[] = {
-  /* { .entry = &syscall_syscall }, */
-  { .entry = &syscall_exit },
-  { .entry = &syscall_fork },
-  { .entry = &syscall_read },
-  { .entry = &syscall_write },
-  { .entry = &syscall_open },
-  { .entry = &syscall_close },
-  /* { .entry = &syscall___tfork }, */
-  { .entry = &syscall_link },
-  { .entry = &syscall_unlink },
-  { .entry = &syscall_wait4 },
-  { .entry = &syscall_chdir },
-  { .entry = &syscall_fchdir },
-  { .entry = &syscall_mknod },
-  { .entry = &syscall_chmod },
-  { .entry = &syscall_chown },
-  /* { .entry = &syscall_break }, */
-  /* { .entry = &syscall_getdtablecount }, */
-  { .entry = &syscall_getrusage },
-  { .entry = &syscall_getpid },
-  { .entry = &syscall_mount },
-  /* { .entry = &syscall_unmount }, */
-  { .entry = &syscall_setuid },
-  { .entry = &syscall_getuid },
-  { .entry = &syscall_geteuid },
-  { .entry = &syscall_ptrace },
-  { .entry = &syscall_recvmsg },
-  { .entry = &syscall_sendmsg },
-  { .entry = &syscall_recvfrom },
-  { .entry = &syscall_accept },
-  { .entry = &syscall_getpeername },
-  { .entry = &syscall_getsockname },
-  { .entry = &syscall_access },
-  /* { .entry = &syscall_chflags }, */
-  /* { .entry = &syscall_fchflags }, */
-  { .entry = &syscall_sync },
-  { .entry = &syscall_kill },
-  //{ .entry = &syscall_stat },
-  { .entry = &syscall_getppid },
-  //{ .entry = &syscall_lstat },
-  { .entry = &syscall_dup },
-  /* { .entry = &syscall_fstatat }, */
-  { .entry = &syscall_getegid },
-  /* { .entry = &syscall_profil }, */
-  /* { .entry = &syscall_ktrace }, */
-  //{ .entry = &syscall_sigaction },
-  { .entry = &syscall_getgid },
-  //{ .entry = &syscall_sigprocmask },
-  /* { .entry = &syscall_getlogin }, */
-  /* { .entry = &syscall_setlogin }, */
-  { .entry = &syscall_acct },
-  //{ .entry = &syscall_sigpending },
-  /* { .entry = &syscall_fstat }, */
-  //{ .entry = &syscall_ioctl },
-  { .entry = &syscall_reboot },
-  /* { .entry = &syscall_revoke }, */
-  { .entry = &syscall_symlink },
-  { .entry = &syscall_readlink },
-  { .entry = &syscall_execve },
-  { .entry = &syscall_umask },
-  { .entry = &syscall_chroot },
-  /* { .entry = &syscall_getfsstat }, */
-  { .entry = &syscall_statfs },
-  { .entry = &syscall_fstatfs },
-  /* { .entry = &syscall_fhstatfs }, */
-  { .entry = &syscall_vfork },
-  { .entry = &syscall_gettimeofday },
-  { .entry = &syscall_settimeofday },
-  { .entry = &syscall_setitimer },
-  { .entry = &syscall_getitimer },
-  { .entry = &syscall_select },
-  /* { .entry = &syscall_kevent }, */
-  { .entry = &syscall_munmap },
-  { .entry = &syscall_mprotect },
-  { .entry = &syscall_madvise },
-  //{ .entry = &syscall_utimes },
-  /* { .entry = &syscall_futimes }, */
-  { .entry = &syscall_mincore },
-  { .entry = &syscall_getgroups },
-  { .entry = &syscall_setgroups },
-  { .entry = &syscall_getpgrp },
-  { .entry = &syscall_setpgid },
-  { .entry = &syscall_utimensat },
-  /* { .entry = &syscall_futimens }, */
-  { .entry = &syscall_clock_gettime },
-  { .entry = &syscall_clock_settime },
-  { .entry = &syscall_clock_getres },
-  { .entry = &syscall_dup2 },
-  { .entry = &syscall_nanosleep },
-  { .entry = &syscall_fcntl },
-  /* { .entry = &syscall___thrsleep }, */
-  { .entry = &syscall_fsync },
-  { .entry = &syscall_setpriority },
-  { .entry = &syscall_socket },
-  { .entry = &syscall_connect },
-  { .entry = &syscall_getdents },
-  { .entry = &syscall_getpriority },
-  //{ .entry = &syscall_sigreturn },
-  { .entry = &syscall_bind },
-  //{ .entry = &syscall_setsockopt },
-  { .entry = &syscall_listen },
-  { .entry = &syscall_ppoll },
-  /* { .entry = &syscall_pselect }, */
-  //{ .entry = &syscall_sigsuspend },
-  { .entry = &syscall_getsockopt },
-  { .entry = &syscall_readv },
-  { .entry = &syscall_writev },
-  { .entry = &syscall_fchown },
-  { .entry = &syscall_fchmod },
-  { .entry = &syscall_setreuid },
-  { .entry = &syscall_setregid },
-  { .entry = &syscall_rename },
-  { .entry = &syscall_flock },
-  /* { .entry = &syscall_mkfifo }, */
-  { .entry = &syscall_sendto },
-  { .entry = &syscall_shutdown },
-  { .entry = &syscall_socketpair },
-  { .entry = &syscall_mkdir },
-  { .entry = &syscall_rmdir },
-  /* { .entry = &syscall_adjtime }, */
-  { .entry = &syscall_setsid },
-  { .entry = &syscall_quotactl },
-  /* { .entry = &syscall_nfssvc }, */
-  /* { .entry = &syscall_getfh }, */
-  /* { .entry = &syscall_sysarch }, */
-  /* { .entry = &syscall_pread }, */
-  /* { .entry = &syscall_pwrite }, */
-  { .entry = &syscall_setgid },
-  /* { .entry = &syscall_setegid }, */
-  /* { .entry = &syscall_seteuid }, */
-  /* { .entry = &syscall_pathconf }, */
-  /* { .entry = &syscall_fpathconf }, */
-  /* { .entry = &syscall_swapctl }, */
-  { .entry = &syscall_getrlimit },
-  { .entry = &syscall_setrlimit },
-  //{ .entry = &syscall_mmap },
-  /* { .entry = &syscall___syscall }, */
-  { .entry = &syscall_lseek },
-  { .entry = &syscall_truncate },
-  { .entry = &syscall_ftruncate },
-  /* { .entry = &syscall___sysctl }, */
-  { .entry = &syscall_mlock },
-  { .entry = &syscall_munlock },
-  { .entry = &syscall_getpgid },
-  /* { .entry = &syscall_utrace }, */
-  { .entry = &syscall_semget },
-  { .entry = &syscall_msgget },
-  { .entry = &syscall_msgsnd },
-  { .entry = &syscall_msgrcv },
-  { .entry = &syscall_shmat },
-  { .entry = &syscall_shmdt },
-  /* { .entry = &syscall_minherit }, */
-  { .entry = &syscall_poll },
-  /* { .entry = &syscall_issetugid }, */
-  { .entry = &syscall_lchown },
-  { .entry = &syscall_getsid },
-  { .entry = &syscall_msync },
-  { .entry = &syscall_pipe },
-  /* { .entry = &syscall_fhopen }, */
-  //{ .entry = &syscall_preadv },
-  //{ .entry = &syscall_pwritev },
-  /* { .entry = &syscall_kqueue }, */
-  { .entry = &syscall_mlockall },
-  { .entry = &syscall_munlockall },
-  { .entry = &syscall_getresuid },
-  { .entry = &syscall_setresuid },
-  { .entry = &syscall_getresgid },
-  { .entry = &syscall_setresgid },
-  /* { .entry = &syscall_mquery }, */
-  /* { .entry = &syscall_closefrom }, */
-  { .entry = &syscall_sigaltstack },
-  { .entry = &syscall_shmget },
-  { .entry = &syscall_semop },
-  /* { .entry = &syscall_fhstat }, */
-  /* { .entry = &syscall___semctl }, */
-  { .entry = &syscall_shmctl },
-  { .entry = &syscall_msgctl },
-  //{ .entry = &syscall_sched_yield },
-  /* { .entry = &syscall_getthrid }, */
-  /* { .entry = &syscall___thrwakeup }, */
-  /* { .entry = &syscall___threxit }, */
-  /* { .entry = &syscall___thrsigdivert }, */
-  /* { .entry = &syscall___getcwd }, */
-  /* { .entry = &syscall_adjfreq }, */
-  /* { .entry = &syscall_setrtable }, */
-  /* { .entry = &syscall_getrtable }, */
-  { .entry = &syscall_faccessat },
-  { .entry = &syscall_fchmodat },
-  { .entry = &syscall_fchownat },
-  { .entry = &syscall_linkat },
-  { .entry = &syscall_mkdirat },
-  /* { .entry = &syscall_mkfifoat }, */
-  { .entry = &syscall_mknodat },
-  { .entry = &syscall_openat },
-  { .entry = &syscall_readlinkat },
-  { .entry = &syscall_renameat },
-  { .entry = &syscall_symlinkat },
-  { .entry = &syscall_unlinkat },
-  /* { .entry = &syscall___set_tcb }, */
-  /* { .entry = &syscall___get_tcb }, */
-};
diff --git a/include/syscalls-i386.h b/include/syscalls-i386.h
index d4e51c6..f2212b6 100644
--- a/include/syscalls-i386.h
+++ b/include/syscalls-i386.h
@@ -5,39 +5,13 @@
 #include "syscalls/syscalls.h"
 
 struct syscalltable syscalls_i386[] = {
-#ifdef __LINUX__ /* temp close */
 	{ .entry = &syscall_restart_syscall },
 	{ .entry = &syscall_exit },
 	{ .entry = &syscall_fork },
-#endif /* temp close */
 	{ .entry = &syscall_read },
 	{ .entry = &syscall_write },
 	{ .entry = &syscall_open },
 	{ .entry = &syscall_close },
-	{ .entry = &syscall_poll },
-	{ .entry = &syscall_lseek },
-	{ .entry = &syscall_mprotect },
-	{ .entry = &syscall_munmap },
-	{ .entry = &syscall_brk },
-	{ .entry = &syscall_readv },
-	{ .entry = &syscall_writev },
-	{ .entry = &syscall_access },
-	{ .entry = &syscall_pipe },
-	{ .entry = &syscall_select },
-	{ .entry = &syscall_msync },
-	{ .entry = &syscall_mincore },
-	{ .entry = &syscall_madvise },
-	{ .entry = &syscall_dup },
-	{ .entry = &syscall_dup2 },
-	{ .entry = &syscall_pause },
-	{ .entry = &syscall_nanosleep },
-	{ .entry = &syscall_alarm },
-	{ .entry = &syscall_getitimer },
-	{ .entry = &syscall_setitimer },
-	{ .entry = &syscall_getpid },
-
-#ifdef __LINUX__ /* temp close */
-	{ .entry = &syscall_restart_syscall },
 	{ .entry = &syscall_waitpid },
 	{ .entry = &syscall_creat },
 	{ .entry = &syscall_link },
@@ -50,16 +24,21 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_lchown16 },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "break" syscall */
 	{ .entry = &syscall_statfs },
+	{ .entry = &syscall_lseek },
+	{ .entry = &syscall_getpid },
 	{ .entry = &syscall_mount },
 	{ .entry = &syscall_oldumount },
 	{ .entry = &syscall_setuid16 },
 	{ .entry = &syscall_getuid16 },
 	{ .entry = &syscall_stime },
 	{ .entry = &syscall_ptrace },
+	{ .entry = &syscall_alarm },
 	{ .entry = &syscall_fstatfs },
+	{ .entry = &syscall_pause },
 	{ .entry = &syscall_utime },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "stty" syscall */
 	{ .entry = &syscall_ni_syscall },	/* obsolete "gtty" syscall */
+	{ .entry = &syscall_access },
 	{ .entry = &syscall_nice },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "ftime" syscall */
 	{ .entry = &syscall_sync },
@@ -67,15 +46,20 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_rename },
 	{ .entry = &syscall_mkdir },
 	{ .entry = &syscall_rmdir },
+	{ .entry = &syscall_dup },
+	{ .entry = &syscall_pipe },
 	{ .entry = &syscall_times },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "prof" syscall */
+	{ .entry = &syscall_brk },
 	{ .entry = &syscall_setgid16 },
 	{ .entry = &syscall_getgid16 },
 	{ .entry = &syscall_signal },
 	{ .entry = &syscall_geteuid16 },
 	{ .entry = &syscall_getegid16 },
 	{ .entry = &syscall_acct },
+	{ .entry = &syscall_umount },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "lock" syscall */
+	{ .entry = &syscall_ioctl },
 	{ .entry = &syscall_fcntl },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "mpx" syscall */
 	{ .entry = &syscall_setpgid },
@@ -84,6 +68,7 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_umask },
 	{ .entry = &syscall_chroot },
 	{ .entry = &syscall_ustat },
+	{ .entry = &syscall_dup2 },
 	{ .entry = &syscall_getppid },
 	{ .entry = &syscall_getpgrp },
 	{ .entry = &syscall_setsid },
@@ -102,6 +87,7 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_settimeofday },
 	{ .entry = &syscall_getgroups16 },
 	{ .entry = &syscall_setgroups16 },
+	{ .entry = &syscall_select },
 	{ .entry = &syscall_symlink },
 	{ .entry = &syscall_lstat },
 	{ .entry = &syscall_readlink },
@@ -109,6 +95,8 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_swapon },
 	{ .entry = &syscall_reboot },
 	{ .entry = &syscall_oldreaddir },
+	{ .entry = &syscall_mmap },
+	{ .entry = &syscall_munmap },
 	{ .entry = &syscall_truncate },
 	{ .entry = &syscall_ftruncate },
 	{ .entry = &syscall_fchmod },
@@ -119,7 +107,10 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_statfs },
 	{ .entry = &syscall_fstatfs },
 	{ .entry = &syscall_ioperm },
+	{ .entry = &syscall_socketcall },
 	{ .entry = &syscall_syslog },
+	{ .entry = &syscall_setitimer },
+	{ .entry = &syscall_getitimer },
 	{ .entry = &syscall_newstat },
 	{ .entry = &syscall_newlstat },
 	{ .entry = &syscall_newfstat },
@@ -134,9 +125,12 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_ipc },
 	{ .entry = &syscall_fsync },
 	{ .entry = &syscall_sigreturn },
+	{ .entry = &syscall_clone },
 	{ .entry = &syscall_setdomainname },
 	{ .entry = &syscall_uname },
+	{ .entry = &syscall_modify_ldt },
 	{ .entry = &syscall_adjtimex },
+	{ .entry = &syscall_mprotect },
 	{ .entry = &syscall_sigprocmask },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "create_module" syscall */
 	{ .entry = &syscall_init_module },
@@ -155,6 +149,9 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_getdents },
 	{ .entry = &syscall_select },
 	{ .entry = &syscall_flock },
+	{ .entry = &syscall_msync },
+	{ .entry = &syscall_readv },
+	{ .entry = &syscall_writev },
 	{ .entry = &syscall_getsid },
 	{ .entry = &syscall_fdatasync },
 	{ .entry = &syscall_sysctl },
@@ -170,19 +167,16 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_sched_get_priority_max },
 	{ .entry = &syscall_sched_get_priority_min },
 	{ .entry = &syscall_sched_rr_get_interval },
+	{ .entry = &syscall_nanosleep },
+	{ .entry = &syscall_mremap },
 	{ .entry = &syscall_setresuid16 },
 	{ .entry = &syscall_getresuid16 },
 	{ .entry = &syscall_vm86 },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "query_module" syscall */
+	{ .entry = &syscall_poll },
 	{ .entry = &syscall_nfsservctl },
 	{ .entry = &syscall_setresgid16 },
 	{ .entry = &syscall_getresgid16 },
-#endif /* temp close */
-#ifdef __LINUX__
-	{ .entry = &syscall_ioctl },
-	{ .entry = &syscall_mmap },
-	{ .entry = &syscall_mremap },
-	{ .entry = &syscall_socketcall },
 	{ .entry = &syscall_prctl },
 	{ .entry = &syscall_rt_sigreturn },
 	{ .entry = &syscall_rt_sigaction },
@@ -191,50 +185,6 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_rt_sigtimedwait },
 	{ .entry = &syscall_rt_sigqueueinfo },
 	{ .entry = &syscall_rt_sigsuspend },
-	{ .entry = &syscall_setxattr },
-	{ .entry = &syscall_lsetxattr },
-	{ .entry = &syscall_fsetxattr },
-	{ .entry = &syscall_getxattr },
-	{ .entry = &syscall_lgetxattr },
-	{ .entry = &syscall_fgetxattr },
-	{ .entry = &syscall_listxattr },
-	{ .entry = &syscall_llistxattr },
-	{ .entry = &syscall_flistxattr },
-	{ .entry = &syscall_removexattr },
-	{ .entry = &syscall_lremovexattr },
-	{ .entry = &syscall_fremovexattr },
-	{ .entry = &syscall_futex },
-	{ .entry = &syscall_sched_setaffinity },
-	{ .entry = &syscall_sched_getaffinity },
-	{ .entry = &syscall_clock_nanosleep },
-	{ .entry = &syscall_mbind },
-	{ .entry = &syscall_keyctl },
-	{ .entry = &syscall_vmsplice },
-	{ .entry = &syscall_timerfd_settime },
-	{ .entry = &syscall_timerfd_gettime },
-	{ .entry = &syscall_dup3 },
-	{ .entry = &syscall_pipe2 },
-	{ .entry = &syscall_inotify_init1 },
-	{ .entry = &syscall_perf_event_open },
-	{ .entry = &syscall_name_to_handle_at },
-	{ .entry = &syscall_open_by_handle_at },
-	{ .entry = &syscall_setns },
-	{ .entry = &syscall_kcmp },
-	{ .entry = &syscall_recvmmsg },
-	{ .entry = &syscall_timerfd_create },
-	{ .entry = &syscall_sync_file_range },
-	{ .entry = &syscall_set_robust_list },
-	{ .entry = &syscall_get_robust_list },
-	{ .entry = &syscall_unshare },
-	{ .entry = &syscall_inotify_rm_watch },
-	{ .entry = &syscall_inotify_init },
-	{ .entry = &syscall_inotify_add_watch },
-	{ .entry = &syscall_clone },
-	{ .entry = &syscall_modify_ldt },
-	{ .entry = &syscall_umount },
-	{ .entry = &syscall_mmap_pgoff },
-#endif
-#ifdef __LINUX__ /* temp close */
 	{ .entry = &syscall_pread64 },
 	{ .entry = &syscall_pwrite64 },
 	{ .entry = &syscall_chown16 },
@@ -247,6 +197,7 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_ni_syscall },	/* obsolete "streams2" syscall */
 	{ .entry = &syscall_vfork },
 	{ .entry = &syscall_getrlimit },
+	{ .entry = &syscall_mmap_pgoff },
 	{ .entry = &syscall_truncate64 },
 	{ .entry = &syscall_ftruncate64 },
 	{ .entry = &syscall_stat64 },
@@ -272,14 +223,31 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_setfsuid },
 	{ .entry = &syscall_setfsgid },
 	{ .entry = &syscall_pivot_root },
+	{ .entry = &syscall_mincore },
+	{ .entry = &syscall_madvise },
 	{ .entry = &syscall_getdents64 },
 	{ .entry = &syscall_fcntl },	/* fcntl64 */
 	{ .entry = &syscall_ni_syscall },	/* obsolete "tux" syscall */
 	{ .entry = &syscall_ni_syscall },	/* unused slot */
 	{ .entry = &syscall_gettid },
 	{ .entry = &syscall_readahead },
+	{ .entry = &syscall_setxattr },
+	{ .entry = &syscall_lsetxattr },
+	{ .entry = &syscall_fsetxattr },
+	{ .entry = &syscall_getxattr },
+	{ .entry = &syscall_lgetxattr },
+	{ .entry = &syscall_fgetxattr },
+	{ .entry = &syscall_listxattr },
+	{ .entry = &syscall_llistxattr },
+	{ .entry = &syscall_flistxattr },
+	{ .entry = &syscall_removexattr },
+	{ .entry = &syscall_lremovexattr },
+	{ .entry = &syscall_fremovexattr },
 	{ .entry = &syscall_tkill },
 	{ .entry = &syscall_sendfile64 },
+	{ .entry = &syscall_futex },
+	{ .entry = &syscall_sched_setaffinity },
+	{ .entry = &syscall_sched_getaffinity },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "set_thread_area" syscall */
 	{ .entry = &syscall_ni_syscall },	/* obsolete "get_thread_area" syscall */
 	{ .entry = &syscall_io_setup },
@@ -291,15 +259,10 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_ni_syscall },	/* obsolete "set_zone_reclaim" syscall */
 	{ .entry = &syscall_exit_group },
 	{ .entry = &syscall_lookup_dcookie },
-#endif /* temp close */
-#ifdef USE_EPOLL
 	{ .entry = &syscall_epoll_create },
 	{ .entry = &syscall_epoll_ctl },
 	{ .entry = &syscall_epoll_wait },
-	{ .entry = &syscall_epoll_pwait },
-	{ .entry = &syscall_epoll_create1 },
-#endif
-#ifdef __LINUX__ /* temp close */
+	{ .entry = &syscall_remap_file_pages },
 	{ .entry = &syscall_set_tid_address },
 	{ .entry = &syscall_timer_create },
 	{ .entry = &syscall_timer_settime },
@@ -309,12 +272,14 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_clock_settime },
 	{ .entry = &syscall_clock_gettime },
 	{ .entry = &syscall_clock_getres },
+	{ .entry = &syscall_clock_nanosleep },
 	{ .entry = &syscall_statfs64 },
 	{ .entry = &syscall_fstatfs64 },
 	{ .entry = &syscall_tgkill },
 	{ .entry = &syscall_utimes },
 	{ .entry = &syscall_fadvise64_64 },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "vserver" syscall */
+	{ .entry = &syscall_mbind },
 	{ .entry = &syscall_get_mempolicy },
 	{ .entry = &syscall_set_mempolicy },
 	{ .entry = &syscall_mq_open },
@@ -328,8 +293,12 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_ni_syscall },	/* obsolete "setaltroot" syscall */
 	{ .entry = &syscall_add_key },
 	{ .entry = &syscall_request_key },
+	{ .entry = &syscall_keyctl },
 	{ .entry = &syscall_ioprio_set },
 	{ .entry = &syscall_ioprio_get },
+	{ .entry = &syscall_inotify_init },
+	{ .entry = &syscall_inotify_add_watch },
+	{ .entry = &syscall_inotify_rm_watch },
 	{ .entry = &syscall_migrate_pages },
 	{ .entry = &syscall_openat },
 	{ .entry = &syscall_mkdirat },
@@ -346,27 +315,45 @@ struct syscalltable syscalls_i386[] = {
 	{ .entry = &syscall_faccessat },
 	{ .entry = &syscall_pselect6 },
 	{ .entry = &syscall_ppoll },
+	{ .entry = &syscall_unshare },
+	{ .entry = &syscall_set_robust_list },
+	{ .entry = &syscall_get_robust_list },
 	{ .entry = &syscall_splice },
+	{ .entry = &syscall_sync_file_range },
 	{ .entry = &syscall_tee },
+	{ .entry = &syscall_vmsplice },
 	{ .entry = &syscall_move_pages },
 	{ .entry = &syscall_getcpu },
+	{ .entry = &syscall_epoll_pwait },
 	{ .entry = &syscall_utimensat },
 	{ .entry = &syscall_signalfd },
+	{ .entry = &syscall_timerfd_create },
 	{ .entry = &syscall_eventfd },
 	{ .entry = &syscall_fallocate },
+	{ .entry = &syscall_timerfd_settime },
+	{ .entry = &syscall_timerfd_gettime },
 	{ .entry = &syscall_signalfd4 },
 	{ .entry = &syscall_eventfd2 },
+	{ .entry = &syscall_epoll_create1 },
+	{ .entry = &syscall_dup3 },
+	{ .entry = &syscall_pipe2 },
+	{ .entry = &syscall_inotify_init1 },
 	{ .entry = &syscall_preadv },
 	{ .entry = &syscall_pwritev },
 	{ .entry = &syscall_rt_tgsigqueueinfo },
+	{ .entry = &syscall_perf_event_open },
+	{ .entry = &syscall_recvmmsg },
 	{ .entry = &syscall_fanotify_init },
 	{ .entry = &syscall_fanotify_mark },
 	{ .entry = &syscall_prlimit64 },
+	{ .entry = &syscall_name_to_handle_at },
+	{ .entry = &syscall_open_by_handle_at },
 	{ .entry = &syscall_clock_adjtime },
 	{ .entry = &syscall_syncfs },
 	{ .entry = &syscall_sendmmsg },
+	{ .entry = &syscall_setns },
 	{ .entry = &syscall_process_vm_readv },
 	{ .entry = &syscall_process_vm_writev },
+	{ .entry = &syscall_kcmp },
 	{ .entry = &syscall_finit_module },
-#endif /* temp close */
 };
diff --git a/include/syscalls-parisc.h b/include/syscalls-parisc.h
new file mode 100644
index 0000000..041d11e
--- /dev/null
+++ b/include/syscalls-parisc.h
@@ -0,0 +1,347 @@
+#ifndef _SYSCALLS_PARISC_H
+#define _SYSCALLS_PARISC_H 1
+
+/* Syscalls from arch/parisc/kernel/syscall_table.S as of 3.12-rc6 */
+
+#include "sanitise.h"
+#include "syscall.h"
+#include "syscalls/syscalls.h"
+
+struct syscalltable syscalls_parisc[] = {
+	{ .entry = &syscall_restart_syscall },
+	{ .entry = &syscall_exit },
+	{ .entry = &syscall_fork },	/* FIXME: fork_wrapper */
+	{ .entry = &syscall_read },
+	{ .entry = &syscall_write },
+	{ .entry = &syscall_open },
+	{ .entry = &syscall_close },
+	{ .entry = &syscall_waitpid },
+	{ .entry = &syscall_creat },
+	{ .entry = &syscall_link },
+	{ .entry = &syscall_unlink },
+	{ .entry = &syscall_execve },
+	{ .entry = &syscall_chdir },
+	{ .entry = &syscall_time },
+	{ .entry = &syscall_mknod },
+	{ .entry = &syscall_chmod },
+	{ .entry = &syscall_lchown },
+	{ .entry = &syscall_socket },
+	{ .entry = &syscall_newstat },
+	{ .entry = &syscall_lseek },
+	{ .entry = &syscall_getpid },
+	{ .entry = &syscall_mount },
+	{ .entry = &syscall_bind },
+	{ .entry = &syscall_setuid },
+	{ .entry = &syscall_getuid },
+	{ .entry = &syscall_stime },
+	{ .entry = &syscall_ptrace },
+	{ .entry = &syscall_alarm },
+	{ .entry = &syscall_newfstat },
+	{ .entry = &syscall_pause },
+	{ .entry = &syscall_utime },
+	{ .entry = &syscall_connect },
+	{ .entry = &syscall_listen },
+	{ .entry = &syscall_access },
+	{ .entry = &syscall_nice },
+	{ .entry = &syscall_accept },
+	{ .entry = &syscall_sync },
+	{ .entry = &syscall_kill },
+	{ .entry = &syscall_rename },
+	{ .entry = &syscall_mkdir },
+	{ .entry = &syscall_rmdir },
+	{ .entry = &syscall_dup },
+	{ .entry = &syscall_pipe },
+	{ .entry = &syscall_times },
+	{ .entry = &syscall_getsockname },
+	{ .entry = &syscall_brk },
+	{ .entry = &syscall_setgid },
+	{ .entry = &syscall_getgid },
+	{ .entry = &syscall_signal },
+	{ .entry = &syscall_geteuid },
+	{ .entry = &syscall_getegid },
+	{ .entry = &syscall_acct },
+	{ .entry = &syscall_umount },
+	{ .entry = &syscall_getpeername },
+	{ .entry = &syscall_ioctl },
+	{ .entry = &syscall_fcntl },
+	{ .entry = &syscall_socketpair },
+	{ .entry = &syscall_setpgid },
+	{ .entry = &syscall_send },
+	{ .entry = &syscall_newuname },
+	{ .entry = &syscall_umask },
+	{ .entry = &syscall_chroot },
+	{ .entry = &syscall_ustat },
+	{ .entry = &syscall_dup2 },
+	{ .entry = &syscall_getppid },
+	{ .entry = &syscall_getpgrp },
+	{ .entry = &syscall_setsid },
+	{ .entry = &syscall_pivot_root },
+	{ .entry = &syscall_sgetmask },
+	{ .entry = &syscall_ssetmask },
+	{ .entry = &syscall_setreuid },
+	{ .entry = &syscall_setregid },
+	{ .entry = &syscall_mincore },
+	{ .entry = &syscall_sigpending },
+	{ .entry = &syscall_sethostname },
+	{ .entry = &syscall_setrlimit },
+	{ .entry = &syscall_getrlimit },
+	{ .entry = &syscall_getrusage },
+	{ .entry = &syscall_gettimeofday },
+	{ .entry = &syscall_settimeofday },
+	{ .entry = &syscall_getgroups },
+	{ .entry = &syscall_setgroups },
+	{ .entry = &syscall_sendto },
+	{ .entry = &syscall_symlink },
+	{ .entry = &syscall_newlstat },
+	{ .entry = &syscall_readlink },
+	{ .entry = &syscall_ni_syscall },	/* was uselib */
+	{ .entry = &syscall_swapon },
+	{ .entry = &syscall_reboot },
+	{ .entry = &syscall_mmap2 },
+	{ .entry = &syscall_mmap },
+	{ .entry = &syscall_munmap },
+	{ .entry = &syscall_truncate },
+	{ .entry = &syscall_ftruncate },
+	{ .entry = &syscall_fchmod },
+	{ .entry = &syscall_fchown },
+	{ .entry = &syscall_getpriority },
+	{ .entry = &syscall_setpriority },
+	{ .entry = &syscall_recv },
+	{ .entry = &syscall_statfs },
+	{ .entry = &syscall_fstatfs },
+	{ .entry = &syscall_stat64 },
+	{ .entry = &syscall_ni_syscall },	/* was socketcall */
+	{ .entry = &syscall_syslog },
+	{ .entry = &syscall_setitimer },
+	{ .entry = &syscall_getitimer },
+	{ .entry = &syscall_capget },
+	{ .entry = &syscall_capset },
+	{ .entry = &syscall_pread64 },
+	{ .entry = &syscall_pwrite64 },
+	{ .entry = &syscall_getcwd },
+	{ .entry = &syscall_vhangup },
+	{ .entry = &syscall_fstat64 },
+	{ .entry = &syscall_vfork },
+	{ .entry = &syscall_wait4 },
+	{ .entry = &syscall_swapoff },
+	{ .entry = &syscall_sysinfo },
+	{ .entry = &syscall_shutdown },
+	{ .entry = &syscall_fsync },
+	{ .entry = &syscall_madvise },
+	{ .entry = &syscall_clone },
+	{ .entry = &syscall_setdomainname },
+	{ .entry = &syscall_sendfile },
+	{ .entry = &syscall_recvfrom },
+	{ .entry = &syscall_adjtimex },
+	{ .entry = &syscall_mprotect },
+	{ .entry = &syscall_sigprocmask },
+	{ .entry = &syscall_ni_syscall },	/* obsolete "create_module" syscall */
+	{ .entry = &syscall_init_module },
+	{ .entry = &syscall_delete_module },
+	{ .entry = &syscall_ni_syscall },	/* was get_kernel_syms */
+	{ .entry = &syscall_quotactl },
+	{ .entry = &syscall_getpgid },
+	{ .entry = &syscall_fchdir },
+	{ .entry = &syscall_bdflush },
+	{ .entry = &syscall_sysfs },
+	{ .entry = &syscall_personality },
+	{ .entry = &syscall_ni_syscall },	/* obsolete "afs" syscall */
+	{ .entry = &syscall_setfsuid },
+	{ .entry = &syscall_setfsgid },
+	{ .entry = &syscall_llseek },
+	{ .entry = &syscall_getdents },
+	{ .entry = &syscall_select },
+	{ .entry = &syscall_flock },
+	{ .entry = &syscall_msync },
+	{ .entry = &syscall_readv },
+	{ .entry = &syscall_writev },
+	{ .entry = &syscall_getsid },
+	{ .entry = &syscall_fdatasync },
+	{ .entry = &syscall_sysctl },
+	{ .entry = &syscall_mlock },
+	{ .entry = &syscall_munlock },
+	{ .entry = &syscall_mlockall },
+	{ .entry = &syscall_munlockall },
+	{ .entry = &syscall_sched_setparam },
+	{ .entry = &syscall_sched_getparam },
+	{ .entry = &syscall_sched_setscheduler },
+	{ .entry = &syscall_sched_getscheduler },
+	{ .entry = &syscall_sched_yield },
+	{ .entry = &syscall_sched_get_priority_max },
+	{ .entry = &syscall_sched_get_priority_min },
+	{ .entry = &syscall_sched_rr_get_interval },
+	{ .entry = &syscall_nanosleep },
+	{ .entry = &syscall_mremap },
+	{ .entry = &syscall_setresuid },
+	{ .entry = &syscall_getresuid },
+	{ .entry = &syscall_sigaltstack },
+	{ .entry = &syscall_ni_syscall },	/* obsolete "query_module" syscall */
+	{ .entry = &syscall_poll },
+	{ .entry = &syscall_ni_syscall },	/* was nfsserverctl */
+	{ .entry = &syscall_setresgid },
+	{ .entry = &syscall_getresgid },
+	{ .entry = &syscall_prctl },
+	{ .entry = &syscall_rt_sigreturn },
+	{ .entry = &syscall_rt_sigaction },
+	{ .entry = &syscall_rt_sigprocmask },
+	{ .entry = &syscall_rt_sigpending },
+	{ .entry = &syscall_rt_sigtimedwait },
+	{ .entry = &syscall_rt_sigqueueinfo },
+	{ .entry = &syscall_rt_sigsuspend },
+	{ .entry = &syscall_chown },
+	{ .entry = &syscall_setsockopt },
+	{ .entry = &syscall_getsockopt },
+	{ .entry = &syscall_sendmsg },
+	{ .entry = &syscall_recvmsg },
+	{ .entry = &syscall_semop },
+	{ .entry = &syscall_semget },
+	{ .entry = &syscall_semctl },
+	{ .entry = &syscall_msgsnd },
+	{ .entry = &syscall_msgrcv },
+	{ .entry = &syscall_msgget },
+	{ .entry = &syscall_msgctl },
+	{ .entry = &syscall_shmat },
+	{ .entry = &syscall_shmdt },
+	{ .entry = &syscall_shmget },
+	{ .entry = &syscall_shmctl },
+	{ .entry = &syscall_ni_syscall },	/* streams1 */
+	{ .entry = &syscall_ni_syscall },	/* streams2 */
+	{ .entry = &syscall_lstat64 },
+	{ .entry = &syscall_truncate64 },
+	{ .entry = &syscall_ftruncate64 },
+	{ .entry = &syscall_getdents64 },
+	{ .entry = &syscall_ni_syscall },	// FIXME: fcntl64
+	{ .entry = &syscall_ni_syscall },	/* obsolete "attrctl" syscall */
+	{ .entry = &syscall_ni_syscall },	/* obsolete "acl_get" syscall */
+	{ .entry = &syscall_ni_syscall },	/* obsolete "acl_set" syscall */
+	{ .entry = &syscall_gettid },
+	{ .entry = &syscall_readahead },
+	{ .entry = &syscall_tkill },
+	{ .entry = &syscall_sendfile64 },
+	{ .entry = &syscall_futex },
+	{ .entry = &syscall_sched_setaffinity },
+	{ .entry = &syscall_sched_getaffinity },
+	{ .entry = &syscall_ni_syscall },	/* set_thread_area */
+	{ .entry = &syscall_ni_syscall },	/* get_thread_area */
+	{ .entry = &syscall_io_setup },
+	{ .entry = &syscall_io_destroy },
+	{ .entry = &syscall_io_getevents },
+	{ .entry = &syscall_io_submit },
+	{ .entry = &syscall_io_cancel },
+	{ .entry = &syscall_ni_syscall },	/* FIXME alloc_hugepages */
+	{ .entry = &syscall_ni_syscall },	/* FIXME free_hugepages */
+	{ .entry = &syscall_exit_group },
+	{ .entry = &syscall_lookup_dcookie },
+	{ .entry = &syscall_epoll_create },
+	{ .entry = &syscall_epoll_ctl },
+	{ .entry = &syscall_epoll_wait },
+	{ .entry = &syscall_remap_file_pages },
+	{ .entry = &syscall_semtimedop },
+	{ .entry = &syscall_mq_open },
+	{ .entry = &syscall_mq_unlink },
+	{ .entry = &syscall_mq_timedsend },
+	{ .entry = &syscall_mq_timedreceive },
+	{ .entry = &syscall_mq_notify },
+	{ .entry = &syscall_mq_getsetattr },
+	{ .entry = &syscall_waitid },
+	{ .entry = &syscall_fadvise64_64 },
+	{ .entry = &syscall_set_tid_address },
+	{ .entry = &syscall_setxattr },
+	{ .entry = &syscall_lsetxattr },
+	{ .entry = &syscall_fsetxattr },
+	{ .entry = &syscall_getxattr },
+	{ .entry = &syscall_lgetxattr },
+	{ .entry = &syscall_fgetxattr },
+	{ .entry = &syscall_listxattr },
+	{ .entry = &syscall_llistxattr },
+	{ .entry = &syscall_flistxattr },
+	{ .entry = &syscall_removexattr },
+	{ .entry = &syscall_lremovexattr },
+	{ .entry = &syscall_fremovexattr },
+	{ .entry = &syscall_timer_create },
+	{ .entry = &syscall_timer_settime },
+	{ .entry = &syscall_timer_gettime },
+	{ .entry = &syscall_timer_getoverrun },
+	{ .entry = &syscall_timer_delete },
+	{ .entry = &syscall_clock_settime },
+	{ .entry = &syscall_clock_gettime },
+	{ .entry = &syscall_clock_getres },
+	{ .entry = &syscall_clock_nanosleep },
+	{ .entry = &syscall_tgkill },
+	{ .entry = &syscall_mbind },
+	{ .entry = &syscall_get_mempolicy },
+	{ .entry = &syscall_set_mempolicy },
+	{ .entry = &syscall_ni_syscall },	/* obsolete "vserver" syscall */
+	{ .entry = &syscall_add_key },
+	{ .entry = &syscall_request_key },
+	{ .entry = &syscall_keyctl },
+	{ .entry = &syscall_ioprio_set },
+	{ .entry = &syscall_ioprio_get },
+	{ .entry = &syscall_inotify_init },
+	{ .entry = &syscall_inotify_add_watch },
+	{ .entry = &syscall_inotify_rm_watch },
+	{ .entry = &syscall_migrate_pages },
+	{ .entry = &syscall_pselect6 },
+	{ .entry = &syscall_ppoll },
+	{ .entry = &syscall_openat },
+	{ .entry = &syscall_mkdirat },
+	{ .entry = &syscall_mknodat },
+	{ .entry = &syscall_fchownat },
+	{ .entry = &syscall_futimesat },
+	{ .entry = &syscall_fstatat64 },
+	{ .entry = &syscall_unlinkat },
+	{ .entry = &syscall_renameat },
+	{ .entry = &syscall_linkat },
+	{ .entry = &syscall_symlinkat },
+	{ .entry = &syscall_readlinkat },
+	{ .entry = &syscall_fchmodat },
+	{ .entry = &syscall_faccessat },
+	{ .entry = &syscall_unshare },
+	{ .entry = &syscall_set_robust_list },
+	{ .entry = &syscall_get_robust_list },
+	{ .entry = &syscall_splice },
+	{ .entry = &syscall_sync_file_range },
+	{ .entry = &syscall_tee },
+	{ .entry = &syscall_vmsplice },
+	{ .entry = &syscall_move_pages },
+	{ .entry = &syscall_getcpu },
+	{ .entry = &syscall_epoll_pwait },
+	{ .entry = &syscall_statfs64 },
+	{ .entry = &syscall_fstatfs64 },
+	{ .entry = &syscall_kexec_load },
+	{ .entry = &syscall_utimensat },
+	{ .entry = &syscall_signalfd },
+	{ .entry = &syscall_ni_syscall },	/* was timerfd */
+	{ .entry = &syscall_eventfd },
+	{ .entry = &syscall_fallocate },
+	{ .entry = &syscall_timerfd_create },
+	{ .entry = &syscall_timerfd_settime },
+	{ .entry = &syscall_timerfd_gettime },
+	{ .entry = &syscall_signalfd4 },
+	{ .entry = &syscall_eventfd2 },
+	{ .entry = &syscall_epoll_create1 },
+	{ .entry = &syscall_dup3 },
+	{ .entry = &syscall_pipe2 },
+	{ .entry = &syscall_inotify_init1 },
+	{ .entry = &syscall_preadv },
+	{ .entry = &syscall_pwritev },
+	{ .entry = &syscall_rt_tgsigqueueinfo },
+	{ .entry = &syscall_perf_event_open },
+	{ .entry = &syscall_recvmmsg },
+	{ .entry = &syscall_accept4 },
+	{ .entry = &syscall_prlimit64 },
+	{ .entry = &syscall_fanotify_init },
+	{ .entry = &syscall_fanotify_mark },
+	{ .entry = &syscall_clock_adjtime },
+	{ .entry = &syscall_name_to_handle_at },
+	{ .entry = &syscall_open_by_handle_at },
+	{ .entry = &syscall_syncfs },
+	{ .entry = &syscall_setns },
+	{ .entry = &syscall_sendmmsg },	/* obsolete "putpmsg" syscall */
+	{ .entry = &syscall_process_vm_readv },
+	{ .entry = &syscall_process_vm_writev },
+	{ .entry = &syscall_kcmp },
+	{ .entry = &syscall_finit_module },
+};
+
+#endif	/* _SYSCALLS_PARISC_H */
diff --git a/include/syscalls-x86_64-openbsd.h b/include/syscalls-x86_64-openbsd.h
deleted file mode 100644
index 026e59e..0000000
--- a/include/syscalls-x86_64-openbsd.h
+++ /dev/null
@@ -1,213 +0,0 @@
-#ifndef _SYSCALLS_x86_64_H
-#define _SYSCALLS_x86_64_H 1
-
-/* Syscalls from arch/x86/syscalls/syscall_64.tbl as of 3.8rc1 */
-
-#include "sanitise.h"
-#include "syscall.h"
-#include "syscalls/syscalls.h"
-
-struct syscalltable syscalls_x86_64[] = {
-  /* { .entry = &syscall_syscall }, */
-  { .entry = &syscall_exit },
-  { .entry = &syscall_fork },
-  { .entry = &syscall_read },
-  { .entry = &syscall_write },
-  { .entry = &syscall_open },
-  { .entry = &syscall_close },
-  /* { .entry = &syscall___tfork }, */
-  { .entry = &syscall_link },
-  { .entry = &syscall_unlink },
-  { .entry = &syscall_wait4 },
-  { .entry = &syscall_chdir },
-  { .entry = &syscall_fchdir },
-  { .entry = &syscall_mknod },
-  { .entry = &syscall_chmod },
-  { .entry = &syscall_chown },
-  /* { .entry = &syscall_break }, */
-  /* { .entry = &syscall_getdtablecount }, */
-  { .entry = &syscall_getrusage },
-  { .entry = &syscall_getpid },
-  { .entry = &syscall_mount },
-  /* { .entry = &syscall_unmount }, */
-  { .entry = &syscall_setuid },
-  { .entry = &syscall_getuid },
-  { .entry = &syscall_geteuid },
-  { .entry = &syscall_ptrace },
-  { .entry = &syscall_recvmsg },
-  { .entry = &syscall_sendmsg },
-  { .entry = &syscall_recvfrom },
-  { .entry = &syscall_accept },
-  { .entry = &syscall_getpeername },
-  { .entry = &syscall_getsockname },
-  { .entry = &syscall_access },
-  /* { .entry = &syscall_chflags }, */
-  /* { .entry = &syscall_fchflags }, */
-  { .entry = &syscall_sync },
-  { .entry = &syscall_kill },
-  //{ .entry = &syscall_stat },
-  { .entry = &syscall_getppid },
-  //{ .entry = &syscall_lstat },
-  { .entry = &syscall_dup },
-  /* { .entry = &syscall_fstatat }, */
-  { .entry = &syscall_getegid },
-  /* { .entry = &syscall_profil }, */
-  /* { .entry = &syscall_ktrace }, */
-  //{ .entry = &syscall_sigaction },
-  { .entry = &syscall_getgid },
-  //{ .entry = &syscall_sigprocmask },
-  /* { .entry = &syscall_getlogin }, */
-  /* { .entry = &syscall_setlogin }, */
-  { .entry = &syscall_acct },
-  //{ .entry = &syscall_sigpending },
-  /* { .entry = &syscall_fstat }, */
-  //{ .entry = &syscall_ioctl },
-  { .entry = &syscall_reboot },
-  /* { .entry = &syscall_revoke }, */
-  { .entry = &syscall_symlink },
-  { .entry = &syscall_readlink },
-  { .entry = &syscall_execve },
-  { .entry = &syscall_umask },
-  { .entry = &syscall_chroot },
-  /* { .entry = &syscall_getfsstat }, */
-  { .entry = &syscall_statfs },
-  { .entry = &syscall_fstatfs },
-  /* { .entry = &syscall_fhstatfs }, */
-  { .entry = &syscall_vfork },
-  { .entry = &syscall_gettimeofday },
-  { .entry = &syscall_settimeofday },
-  { .entry = &syscall_setitimer },
-  { .entry = &syscall_getitimer },
-  { .entry = &syscall_select },
-  /* { .entry = &syscall_kevent }, */
-  { .entry = &syscall_munmap },
-  { .entry = &syscall_mprotect },
-  { .entry = &syscall_madvise },
-  //{ .entry = &syscall_utimes },
-  /* { .entry = &syscall_futimes }, */
-  { .entry = &syscall_mincore },
-  { .entry = &syscall_getgroups },
-  { .entry = &syscall_setgroups },
-  { .entry = &syscall_getpgrp },
-  { .entry = &syscall_setpgid },
-  { .entry = &syscall_utimensat },
-  /* { .entry = &syscall_futimens }, */
-  { .entry = &syscall_clock_gettime },
-  { .entry = &syscall_clock_settime },
-  { .entry = &syscall_clock_getres },
-  { .entry = &syscall_dup2 },
-  { .entry = &syscall_nanosleep },
-  { .entry = &syscall_fcntl },
-  /* { .entry = &syscall___thrsleep }, */
-  { .entry = &syscall_fsync },
-  { .entry = &syscall_setpriority },
-  { .entry = &syscall_socket },
-  { .entry = &syscall_connect },
-  { .entry = &syscall_getdents },
-  { .entry = &syscall_getpriority },
-  //{ .entry = &syscall_sigreturn },
-  { .entry = &syscall_bind },
-  //{ .entry = &syscall_setsockopt },
-  { .entry = &syscall_listen },
-  { .entry = &syscall_ppoll },
-  /* { .entry = &syscall_pselect }, */
-  //{ .entry = &syscall_sigsuspend },
-  { .entry = &syscall_getsockopt },
-  { .entry = &syscall_readv },
-  { .entry = &syscall_writev },
-  { .entry = &syscall_fchown },
-  { .entry = &syscall_fchmod },
-  { .entry = &syscall_setreuid },
-  { .entry = &syscall_setregid },
-  { .entry = &syscall_rename },
-  { .entry = &syscall_flock },
-  /* { .entry = &syscall_mkfifo }, */
-  { .entry = &syscall_sendto },
-  { .entry = &syscall_shutdown },
-  { .entry = &syscall_socketpair },
-  { .entry = &syscall_mkdir },
-  { .entry = &syscall_rmdir },
-  /* { .entry = &syscall_adjtime }, */
-  { .entry = &syscall_setsid },
-  { .entry = &syscall_quotactl },
-  /* { .entry = &syscall_nfssvc }, */
-  /* { .entry = &syscall_getfh }, */
-  /* { .entry = &syscall_sysarch }, */
-  /* { .entry = &syscall_pread }, */
-  /* { .entry = &syscall_pwrite }, */
-  { .entry = &syscall_setgid },
-  /* { .entry = &syscall_setegid }, */
-  /* { .entry = &syscall_seteuid }, */
-  /* { .entry = &syscall_pathconf }, */
-  /* { .entry = &syscall_fpathconf }, */
-  /* { .entry = &syscall_swapctl }, */
-  { .entry = &syscall_getrlimit },
-  { .entry = &syscall_setrlimit },
-  //{ .entry = &syscall_mmap },
-  /* { .entry = &syscall___syscall }, */
-  { .entry = &syscall_lseek },
-  { .entry = &syscall_truncate },
-  { .entry = &syscall_ftruncate },
-  /* { .entry = &syscall___sysctl }, */
-  { .entry = &syscall_mlock },
-  { .entry = &syscall_munlock },
-  { .entry = &syscall_getpgid },
-  /* { .entry = &syscall_utrace }, */
-  { .entry = &syscall_semget },
-  { .entry = &syscall_msgget },
-  { .entry = &syscall_msgsnd },
-  { .entry = &syscall_msgrcv },
-  { .entry = &syscall_shmat },
-  { .entry = &syscall_shmdt },
-  /* { .entry = &syscall_minherit }, */
-  { .entry = &syscall_poll },
-  /* { .entry = &syscall_issetugid }, */
-  { .entry = &syscall_lchown },
-  { .entry = &syscall_getsid },
-  { .entry = &syscall_msync },
-  { .entry = &syscall_pipe },
-  /* { .entry = &syscall_fhopen }, */
-  //{ .entry = &syscall_preadv },
-  //{ .entry = &syscall_pwritev },
-  /* { .entry = &syscall_kqueue }, */
-  { .entry = &syscall_mlockall },
-  { .entry = &syscall_munlockall },
-  { .entry = &syscall_getresuid },
-  { .entry = &syscall_setresuid },
-  { .entry = &syscall_getresgid },
-  { .entry = &syscall_setresgid },
-  /* { .entry = &syscall_mquery }, */
-  /* { .entry = &syscall_closefrom }, */
-  { .entry = &syscall_sigaltstack },
-  { .entry = &syscall_shmget },
-  { .entry = &syscall_semop },
-  /* { .entry = &syscall_fhstat }, */
-  /* { .entry = &syscall___semctl }, */
-  { .entry = &syscall_shmctl },
-  { .entry = &syscall_msgctl },
-  //{ .entry = &syscall_sched_yield },
-  /* { .entry = &syscall_getthrid }, */
-  /* { .entry = &syscall___thrwakeup }, */
-  /* { .entry = &syscall___threxit }, */
-  /* { .entry = &syscall___thrsigdivert }, */
-  /* { .entry = &syscall___getcwd }, */
-  /* { .entry = &syscall_adjfreq }, */
-  /* { .entry = &syscall_setrtable }, */
-  /* { .entry = &syscall_getrtable }, */
-  { .entry = &syscall_faccessat },
-  { .entry = &syscall_fchmodat },
-  { .entry = &syscall_fchownat },
-  { .entry = &syscall_linkat },
-  { .entry = &syscall_mkdirat },
-  /* { .entry = &syscall_mkfifoat }, */
-  { .entry = &syscall_mknodat },
-  { .entry = &syscall_openat },
-  { .entry = &syscall_readlinkat },
-  { .entry = &syscall_renameat },
-  { .entry = &syscall_symlinkat },
-  { .entry = &syscall_unlinkat },
-  /* { .entry = &syscall___set_tcb }, */
-  /* { .entry = &syscall___get_tcb }, */
-};
-
-#endif  /* _SYSCALLS_x86_64_H */
diff --git a/include/syscalls-x86_64.h b/include/syscalls-x86_64.h
index ea51726..9ceb65c 100644
--- a/include/syscalls-x86_64.h
+++ b/include/syscalls-x86_64.h
@@ -12,16 +12,28 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_write },
 	{ .entry = &syscall_open },
 	{ .entry = &syscall_close },
+	{ .entry = &syscall_newstat },
+	{ .entry = &syscall_newfstat },
+	{ .entry = &syscall_newlstat },
 	{ .entry = &syscall_poll },
 	{ .entry = &syscall_lseek },
+	{ .entry = &syscall_mmap },
 	{ .entry = &syscall_mprotect },
 	{ .entry = &syscall_munmap },
 	{ .entry = &syscall_brk },
+	{ .entry = &syscall_rt_sigaction },
+	{ .entry = &syscall_rt_sigprocmask },
+	{ .entry = &syscall_rt_sigreturn },
+	{ .entry = &syscall_ioctl },
+	{ .entry = &syscall_pread64 },
+	{ .entry = &syscall_pwrite64 },
 	{ .entry = &syscall_readv },
 	{ .entry = &syscall_writev },
 	{ .entry = &syscall_access },
 	{ .entry = &syscall_pipe },
 	{ .entry = &syscall_select },
+	{ .entry = &syscall_sched_yield },
+	{ .entry = &syscall_mremap },
 	{ .entry = &syscall_msync },
 	{ .entry = &syscall_mincore },
 	{ .entry = &syscall_madvise },
@@ -36,6 +48,8 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_alarm },
 	{ .entry = &syscall_setitimer },
 	{ .entry = &syscall_getpid },
+	{ .entry = &syscall_sendfile },
+	{ .entry = &syscall_socket },
 	{ .entry = &syscall_connect },
 	{ .entry = &syscall_accept },
 	{ .entry = &syscall_sendto },
@@ -48,17 +62,20 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_getsockname },
 	{ .entry = &syscall_getpeername },
 	{ .entry = &syscall_socketpair },
+	{ .entry = &syscall_setsockopt },
 	{ .entry = &syscall_getsockopt },
-	{ .entry = &syscall_socket },
+	{ .entry = &syscall_clone },
 	{ .entry = &syscall_fork },
 	{ .entry = &syscall_vfork },
 	{ .entry = &syscall_execve },
 	{ .entry = &syscall_exit },
 	{ .entry = &syscall_wait4 },
 	{ .entry = &syscall_kill },
+	{ .entry = &syscall_uname },
 	{ .entry = &syscall_semget },
 	{ .entry = &syscall_semop },
 	{ .entry = &syscall_semctl },
+	{ .entry = &syscall_shmdt },
 	{ .entry = &syscall_msgget },
 	{ .entry = &syscall_msgsnd },
 	{ .entry = &syscall_msgrcv },
@@ -66,11 +83,11 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_fcntl },
 	{ .entry = &syscall_flock },
 	{ .entry = &syscall_fsync },
-	{ .entry = &syscall_shmdt },
 	{ .entry = &syscall_fdatasync },
 	{ .entry = &syscall_truncate },
 	{ .entry = &syscall_ftruncate },
 	{ .entry = &syscall_getdents },
+	{ .entry = &syscall_getcwd },
 	{ .entry = &syscall_chdir },
 	{ .entry = &syscall_fchdir },
 	{ .entry = &syscall_rename },
@@ -90,8 +107,11 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_gettimeofday },
 	{ .entry = &syscall_getrlimit },
 	{ .entry = &syscall_getrusage },
+	{ .entry = &syscall_sysinfo },
+	{ .entry = &syscall_times },
 	{ .entry = &syscall_ptrace },
 	{ .entry = &syscall_getuid },
+	{ .entry = &syscall_syslog },
 	{ .entry = &syscall_getgid },
 	{ .entry = &syscall_setuid },
 	{ .entry = &syscall_setgid },
@@ -113,86 +133,51 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_setfsuid },
 	{ .entry = &syscall_setfsgid },
 	{ .entry = &syscall_getsid },
+	{ .entry = &syscall_capget },
+	{ .entry = &syscall_capset },
+	{ .entry = &syscall_rt_sigpending },
+	{ .entry = &syscall_rt_sigtimedwait },
+	{ .entry = &syscall_rt_sigqueueinfo },
+	{ .entry = &syscall_rt_sigsuspend },
 	{ .entry = &syscall_sigaltstack },
+	{ .entry = &syscall_utime },
 	{ .entry = &syscall_mknod },
+	{ .entry = &syscall_uselib },
+	{ .entry = &syscall_personality },
 	{ .entry = &syscall_ustat },
 	{ .entry = &syscall_statfs },
 	{ .entry = &syscall_fstatfs },
+	{ .entry = &syscall_sysfs },
 	{ .entry = &syscall_getpriority },
 	{ .entry = &syscall_setpriority },
+	{ .entry = &syscall_sched_setparam },
+	{ .entry = &syscall_sched_getparam },
+	{ .entry = &syscall_sched_setscheduler },
+	{ .entry = &syscall_sched_getscheduler },
+	{ .entry = &syscall_sched_get_priority_max },
+	{ .entry = &syscall_sched_get_priority_min },
+	{ .entry = &syscall_sched_rr_get_interval },
 	{ .entry = &syscall_mlock },
 	{ .entry = &syscall_munlock },
 	{ .entry = &syscall_mlockall },
 	{ .entry = &syscall_munlockall },
 	{ .entry = &syscall_vhangup },
+	{ .entry = &syscall_modify_ldt },
+	{ .entry = &syscall_pivot_root },
 	{ .entry = &syscall_sysctl },
+	{ .entry = &syscall_prctl },
+	{ .entry = &syscall_arch_prctl },
+	{ .entry = &syscall_adjtimex },
 	{ .entry = &syscall_setrlimit },
 	{ .entry = &syscall_chroot },
 	{ .entry = &syscall_sync },
 	{ .entry = &syscall_acct },
 	{ .entry = &syscall_settimeofday },
 	{ .entry = &syscall_mount },
-	{ .entry = &syscall_reboot },
-	{ .entry = &syscall_clock_settime },
-	{ .entry = &syscall_clock_gettime },
-	{ .entry = &syscall_clock_getres },
-	{ .entry = &syscall_quotactl },
-	{ .entry = &syscall_openat },
-	{ .entry = &syscall_mkdirat },
-	{ .entry = &syscall_mknodat },
-	{ .entry = &syscall_fchownat },
-	{ .entry = &syscall_fstatat64 },
-	{ .entry = &syscall_unlinkat },
-	{ .entry = &syscall_renameat },
-	{ .entry = &syscall_linkat },
-	{ .entry = &syscall_symlinkat },
-	{ .entry = &syscall_readlinkat },
-	{ .entry = &syscall_fchmodat },
-	{ .entry = &syscall_faccessat },
-	{ .entry = &syscall_ppoll },
-	{ .entry = &syscall_utimensat },
-	{ .entry = &syscall_accept4 },
-	{ .entry = &syscall_pselect6 },
-#ifdef __LINUX__
 	{ .entry = &syscall_umount },
-	{ .entry = &syscall_mmap },
-	{ .entry = &syscall_ioctl },
-	{ .entry = &syscall_newstat },
-	{ .entry = &syscall_newfstat },
-	{ .entry = &syscall_newlstat },
-	{ .entry = &syscall_rt_sigaction },
-	{ .entry = &syscall_rt_sigprocmask },
-	{ .entry = &syscall_rt_sigreturn },
-	{ .entry = &syscall_pread64 },
-	{ .entry = &syscall_pwrite64 },
-	{ .entry = &syscall_sched_yield },
-	{ .entry = &syscall_sendfile },
-	{ .entry = &syscall_uname },
-	{ .entry = &syscall_getcwd },
-	{ .entry = &syscall_sysinfo },
-	{ .entry = &syscall_times },
-	{ .entry = &syscall_syslog },
-	{ .entry = &syscall_capget },
-	{ .entry = &syscall_capset },
-	{ .entry = &syscall_rt_sigpending },
-	{ .entry = &syscall_rt_sigtimedwait },
-	{ .entry = &syscall_rt_sigqueueinfo },
-	{ .entry = &syscall_rt_sigsuspend },
-	{ .entry = &syscall_utime },
-	{ .entry = &syscall_uselib },
-	{ .entry = &syscall_personality },
-	{ .entry = &syscall_sysfs },
-	{ .entry = &syscall_sched_setparam },
-	{ .entry = &syscall_sched_getparam },
-	{ .entry = &syscall_sched_setscheduler },
-	{ .entry = &syscall_sched_getscheduler },
-	{ .entry = &syscall_sched_get_priority_max },
-	{ .entry = &syscall_sched_get_priority_min },
-	{ .entry = &syscall_sched_rr_get_interval },
-	{ .entry = &syscall_pivot_root },
-	{ .entry = &syscall_adjtimex },
 	{ .entry = &syscall_swapon },
 	{ .entry = &syscall_swapoff },
+	{ .entry = &syscall_reboot },
 	{ .entry = &syscall_sethostname },
 	{ .entry = &syscall_setdomainname },
 	{ .entry = &syscall_iopl },
@@ -202,6 +187,7 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_delete_module },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "get_kernel_syms" syscall */
 	{ .entry = &syscall_ni_syscall },	/* obsolete "query_module" syscall */
+	{ .entry = &syscall_quotactl },
 	{ .entry = &syscall_nfsservctl },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "getpmsg" syscall */
 	{ .entry = &syscall_ni_syscall },	/* obsolete "putpmsg" syscall */
@@ -210,8 +196,23 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_ni_syscall },	/* obsolete "security" syscall */
 	{ .entry = &syscall_gettid },
 	{ .entry = &syscall_readahead },
+	{ .entry = &syscall_setxattr },
+	{ .entry = &syscall_lsetxattr },
+	{ .entry = &syscall_fsetxattr },
+	{ .entry = &syscall_getxattr },
+	{ .entry = &syscall_lgetxattr },
+	{ .entry = &syscall_fgetxattr },
+	{ .entry = &syscall_listxattr },
+	{ .entry = &syscall_llistxattr },
+	{ .entry = &syscall_flistxattr },
+	{ .entry = &syscall_removexattr },
+	{ .entry = &syscall_lremovexattr },
+	{ .entry = &syscall_fremovexattr },
 	{ .entry = &syscall_tkill },
 	{ .entry = &syscall_time },
+	{ .entry = &syscall_futex },
+	{ .entry = &syscall_sched_setaffinity },
+	{ .entry = &syscall_sched_getaffinity },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "set_thread_area" syscall */
 	{ .entry = &syscall_io_setup },
 	{ .entry = &syscall_io_destroy },
@@ -220,8 +221,10 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_io_cancel },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "get_thread_area" syscall */
 	{ .entry = &syscall_lookup_dcookie },
+	{ .entry = &syscall_epoll_create },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "epoll_ctl_old" syscall */
 	{ .entry = &syscall_ni_syscall },	/* obsolete "epoll_wait_old" syscall */
+	{ .entry = &syscall_remap_file_pages },
 	{ .entry = &syscall_getdents64 },
 	{ .entry = &syscall_set_tid_address },
 	{ .entry = &syscall_restart_syscall },
@@ -232,10 +235,17 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_timer_gettime },
 	{ .entry = &syscall_timer_getoverrun },
 	{ .entry = &syscall_timer_delete },
+	{ .entry = &syscall_clock_settime },
+	{ .entry = &syscall_clock_gettime },
+	{ .entry = &syscall_clock_getres },
+	{ .entry = &syscall_clock_nanosleep },
 	{ .entry = &syscall_exit_group },
+	{ .entry = &syscall_epoll_wait },
+	{ .entry = &syscall_epoll_ctl },
 	{ .entry = &syscall_tgkill },
 	{ .entry = &syscall_utimes },
 	{ .entry = &syscall_ni_syscall },	/* obsolete "vserver" syscall */
+	{ .entry = &syscall_mbind },
 	{ .entry = &syscall_set_mempolicy },
 	{ .entry = &syscall_get_mempolicy },
 	{ .entry = &syscall_mq_open },
@@ -248,84 +258,70 @@ struct syscalltable syscalls_x86_64[] = {
 	{ .entry = &syscall_waitid },
 	{ .entry = &syscall_add_key },
 	{ .entry = &syscall_request_key },
+	{ .entry = &syscall_keyctl },
 	{ .entry = &syscall_ioprio_set },
 	{ .entry = &syscall_ioprio_get },
+	{ .entry = &syscall_inotify_init },
+	{ .entry = &syscall_inotify_add_watch },
+	{ .entry = &syscall_inotify_rm_watch },
 	{ .entry = &syscall_migrate_pages },
+	{ .entry = &syscall_openat },
+	{ .entry = &syscall_mkdirat },
+	{ .entry = &syscall_mknodat },
+	{ .entry = &syscall_fchownat },
 	{ .entry = &syscall_futimesat },
+	{ .entry = &syscall_fstatat64 },
+	{ .entry = &syscall_unlinkat },
+	{ .entry = &syscall_renameat },
+	{ .entry = &syscall_linkat },
+	{ .entry = &syscall_symlinkat },
+	{ .entry = &syscall_readlinkat },
+	{ .entry = &syscall_fchmodat },
+	{ .entry = &syscall_faccessat },
+	{ .entry = &syscall_pselect6 },
+	{ .entry = &syscall_ppoll },
+	{ .entry = &syscall_unshare },
+	{ .entry = &syscall_set_robust_list },
 	{ .entry = &syscall_get_robust_list },
 	{ .entry = &syscall_splice },
 	{ .entry = &syscall_tee },
+	{ .entry = &syscall_sync_file_range },
+	{ .entry = &syscall_vmsplice },
 	{ .entry = &syscall_move_pages },
+	{ .entry = &syscall_utimensat },
+	{ .entry = &syscall_epoll_pwait },
 	{ .entry = &syscall_signalfd },
+	{ .entry = &syscall_timerfd_create },
 	{ .entry = &syscall_eventfd },
 	{ .entry = &syscall_fallocate },
 	{ .entry = &syscall_timerfd_settime },
 	{ .entry = &syscall_timerfd_gettime },
+	{ .entry = &syscall_accept4 },
 	{ .entry = &syscall_signalfd4 },
 	{ .entry = &syscall_eventfd2 },
-#ifdef USE_EPOLL
-	{ .entry = &syscall_epoll_create },
-	{ .entry = &syscall_epoll_wait },
-	{ .entry = &syscall_epoll_ctl },
-	{ .entry = &syscall_epoll_pwait },
 	{ .entry = &syscall_epoll_create1 },
-#endif
+	{ .entry = &syscall_dup3 },
+	{ .entry = &syscall_pipe2 },
 	{ .entry = &syscall_inotify_init1 },
 	{ .entry = &syscall_preadv },
 	{ .entry = &syscall_pwritev },
 	{ .entry = &syscall_rt_tgsigqueueinfo },
+	{ .entry = &syscall_perf_event_open },
+	{ .entry = &syscall_recvmmsg },
 	{ .entry = &syscall_fanotify_init },
 	{ .entry = &syscall_fanotify_mark },
 	{ .entry = &syscall_prlimit64 },
-	{ .entry = &syscall_setsockopt },
-	{ .entry = &syscall_remap_file_pages },
-	{ .entry = &syscall_arch_prctl },
-	{ .entry = &syscall_mremap },
-	{ .entry = &syscall_unshare },
-	{ .entry = &syscall_keyctl },
-	{ .entry = &syscall_prctl },
-	{ .entry = &syscall_inotify_init },
-	{ .entry = &syscall_inotify_add_watch },
-	{ .entry = &syscall_inotify_rm_watch },
-	{ .entry = &syscall_clone },
-	{ .entry = &syscall_modify_ldt },
-	{ .entry = &syscall_mbind },
-	{ .entry = &syscall_sync_file_range },
-	{ .entry = &syscall_vmsplice },
-	{ .entry = &syscall_timerfd_create },
-	{ .entry = &syscall_perf_event_open },
-	{ .entry = &syscall_setxattr },
-	{ .entry = &syscall_lsetxattr },
-	{ .entry = &syscall_fsetxattr },
-	{ .entry = &syscall_getxattr },
-	{ .entry = &syscall_lgetxattr },
-	{ .entry = &syscall_fgetxattr },
-	{ .entry = &syscall_listxattr },
-	{ .entry = &syscall_llistxattr },
-	{ .entry = &syscall_flistxattr },
-	{ .entry = &syscall_removexattr },
-	{ .entry = &syscall_lremovexattr },
-	{ .entry = &syscall_fremovexattr },
-	{ .entry = &syscall_futex },
-	{ .entry = &syscall_sched_setaffinity },
-	{ .entry = &syscall_sched_getaffinity },
-	{ .entry = &syscall_clock_nanosleep },
-	{ .entry = &syscall_dup3 },
-	{ .entry = &syscall_pipe2 },
-	{ .entry = &syscall_recvmmsg },
 	{ .entry = &syscall_name_to_handle_at },
 	{ .entry = &syscall_open_by_handle_at },
-	{ .entry = &syscall_setns },
-	{ .entry = &syscall_kcmp },
-	{ .entry = &syscall_set_robust_list },
 	{ .entry = &syscall_clock_adjtime },
 	{ .entry = &syscall_syncfs },
 	{ .entry = &syscall_sendmmsg },
+	{ .entry = &syscall_setns },
 	{ .entry = &syscall_getcpu },
 	{ .entry = &syscall_process_vm_readv },
 	{ .entry = &syscall_process_vm_writev },
+	{ .entry = &syscall_kcmp },
 	{ .entry = &syscall_finit_module },
-#endif
 };
 
 #endif	/* _SYSCALLS_x86_64_H */
diff --git a/include/trinity.h b/include/trinity.h
index 8d51e6c..961a77b 100644
--- a/include/trinity.h
+++ b/include/trinity.h
@@ -1,5 +1,3 @@
-#include <config.h>
-
 #ifndef _TRINITY_H
 #define _TRINITY_H 1
 
@@ -27,6 +25,8 @@ unsigned int check_if_fd(unsigned int child);
 
 extern unsigned int user_specified_children;
 
+void regenerate(void);
+
 #define UNUSED(x) (void)(x)
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
diff --git a/interesting-numbers.c b/interesting-numbers.c
index 4a740af..d639605 100644
--- a/interesting-numbers.c
+++ b/interesting-numbers.c
@@ -6,34 +6,16 @@
 #include "sanitise.h"
 #include "trinity.h"	// page_size
 
-#if defined(__x86_64__) || defined(__amd64__) || defined(__LP64__)
-#  define __WORDSIZE 64
-#else
-#  define __WORDSIZE 32
-#endif
-
 unsigned int get_interesting_32bit_value(void)
 {
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 11) {
-#else
 	switch (rand() % 11) {
-#endif
 
 	/* common case, return small values*/
 	case 0 ... 7:
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 9) {
-#else
 		switch (rand() % 9) {
-#endif
 		case 0:	return 0x00000000;
 		case 1:	return 0x00000001;
-#ifdef HAVE_ARC4RANDOM
-		case 2:	return arc4random() % 256;
-#else
 		case 2:	return rand() % 256;
-#endif
 		case 3:	return 0x00000fff;	// 4095
 		case 4:	return 0x00001000;	// 4096
 		case 5:	return 0x00001001;	// 4097
@@ -48,11 +30,7 @@ unsigned int get_interesting_32bit_value(void)
 
 	/* less common case, go crazy */
 	case 8 ... 10:
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 15) {
-#else
 		switch (rand() % 15) {
-#endif
 		case 0:	return 0x00010000;
 		case 1:	return 0x0fffffff;
 		case 2:	return 0x40000000;
@@ -65,11 +43,7 @@ unsigned int get_interesting_32bit_value(void)
 		case 9:	return 0xff000000;
 		case 10: return 0xffff0000;
 		case 11: return 0xffffe000;
-#ifdef HAVE_ARC4RANDOM
-		case 12: return 0xffffff00 | (arc4random() % 256);
-#else
 		case 12: return 0xffffff00 | (rand() % 256);
-#endif
 		case 13: return 0xffffffff;
 		case 14: return 0xffffffff - page_size;
 		default:
@@ -93,11 +67,7 @@ static unsigned long per_arch_interesting_addr(unsigned long low)
 	int i = 0;
 
 #if defined(__x86_64__)
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random() % 4;
-#else
 	i = rand() % 4;
-#endif
 
 	switch (i) {
 	case 0: return 0x00007fffffffffffUL;			// x86-64 canonical addr end.
@@ -126,22 +96,14 @@ unsigned long get_interesting_value(void)
 	if (rand_bool())
 		low = get_interesting_32bit_value();
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 13) {
-#else
 	switch (rand() % 13) {
-#endif
 	case 0: return 0;
 	case 1: return low;
 	case 2: return 0x0000000100000000UL | low;
 	case 3: return 0x7fffffff00000000UL | low;
 	case 4: return 0x8000000000000000UL | low;
 	case 5: return 0xffffffff00000000UL | low;
-#ifdef HAVE_ARC4RANDOM
-	case 6: return 0xffffffffffffff00UL | (arc4random() % 256);
-#else
 	case 6: return 0xffffffffffffff00UL | (rand() % 256);
-#endif
 	case 7: return 0xffffffffffffffffUL - page_size;
 	case 8: return PAGE_OFFSET | (low << 4);
 	case 9: return KERNEL_ADDR | (low & 0xffffff);
diff --git a/ioctls/ioctls.c b/ioctls/ioctls.c
index 51db7aa..e43bc3c 100644
--- a/ioctls/ioctls.c
+++ b/ioctls/ioctls.c
@@ -82,22 +82,14 @@ const struct ioctl_group *get_random_ioctl_group(void)
 	if (grps_cnt == 0)
 		return NULL;
 
-#ifdef HAVE_ARC4RANDOM
-	return grps[arc4random() % grps_cnt];
-#else
 	return grps[rand() % grps_cnt];
-#endif
 }
 
 void pick_random_ioctl(const struct ioctl_group *grp, int childno)
 {
 	int ioctlnr;
 
-#ifdef HAVE_ARC4RANDOM
-	ioctlnr = arc4random() % grp->ioctls_cnt;
-#else
 	ioctlnr = rand() % grp->ioctls_cnt;
-#endif
 
 	shm->a2[childno] = grp->ioctls[ioctlnr].request;
 }
diff --git a/ioctls/socket.c b/ioctls/socket.c
index 4f82ef3..3496148 100644
--- a/ioctls/socket.c
+++ b/ioctls/socket.c
@@ -8,7 +8,7 @@ static int socket_fd_test(int fd, const struct stat *st __attribute__((unused)))
 	unsigned i;
 
 	for (i=0; i < nr_sockets; ++i)
-		if (shm->socket_fds[i] == fd)
+		if (shm->sockets[i].fd == fd)
 			return 0;
 
 	return -1;
diff --git a/log.c b/log.c
index c81d2a0..02d5d8c 100644
--- a/log.c
+++ b/log.c
@@ -65,7 +65,7 @@ static FILE * find_logfile_handle(void)
 	if (pid == initpid)
 		return mainlogfile;
 
-	if (pid == mainpid)
+	if (pid == shm->mainpid)
 		return mainlogfile;
 
 	if (pid == watchdog_pid)
@@ -132,7 +132,7 @@ void synclogs(void)
 	fsync(fileno(mainlogfile));
 }
 
-static void output_arg(unsigned int call, unsigned int argnum, const char *name, unsigned long oldreg, unsigned long reg, int type, FILE *fd, bool mono)
+static void output_arg(unsigned int call, unsigned int argnum, const char *name, unsigned long reg, int type, FILE *fd, bool mono)
 {
 	if (syscalls[call].entry->num_args >= argnum) {
 		if (!name)
@@ -145,13 +145,6 @@ static void output_arg(unsigned int call, unsigned int argnum, const char *name,
 		if (name)
 			fprintf(fd, "%s=", name);
 
-		if (oldreg == reg) {
-			CRESETFD
-		} else {
-			if (mono == FALSE)
-				fprintf(fd, "%s", ANSI_CYAN);
-		}
-
 		switch (type) {
 		case ARG_PATHNAME:
 			fprintf(fd, "\"%s\"", (char *) reg);
@@ -252,7 +245,7 @@ void output(unsigned char level, const char *fmt, ...)
 	if (pid == initpid)
 		prefix = init_prefix;
 
-	if (pid == mainpid)
+	if (pid == shm->mainpid)
 		prefix = main_prefix;
 
 	if (prefix == NULL) {
@@ -344,17 +337,17 @@ static void output_syscall_prefix_to_fd(const unsigned int childno, const pid_t
 
 	CRESETFD
 	fprintf(fd, "(");
-	output_arg(syscallno, 1, syscalls[syscallno].entry->arg1name, shm->previous_a1[childno], shm->a1[childno],
+	output_arg(syscallno, 1, syscalls[syscallno].entry->arg1name, shm->a1[childno],
 			syscalls[syscallno].entry->arg1type, fd, mono);
-	output_arg(syscallno, 2, syscalls[syscallno].entry->arg2name, shm->previous_a2[childno], shm->a2[childno],
+	output_arg(syscallno, 2, syscalls[syscallno].entry->arg2name, shm->a2[childno],
 			syscalls[syscallno].entry->arg2type, fd, mono);
-	output_arg(syscallno, 3, syscalls[syscallno].entry->arg3name, shm->previous_a3[childno], shm->a3[childno],
+	output_arg(syscallno, 3, syscalls[syscallno].entry->arg3name, shm->a3[childno],
 			syscalls[syscallno].entry->arg3type, fd, mono);
-	output_arg(syscallno, 4, syscalls[syscallno].entry->arg4name, shm->previous_a4[childno], shm->a4[childno],
+	output_arg(syscallno, 4, syscalls[syscallno].entry->arg4name, shm->a4[childno],
 			syscalls[syscallno].entry->arg4type, fd, mono);
-	output_arg(syscallno, 5, syscalls[syscallno].entry->arg5name, shm->previous_a5[childno], shm->a5[childno],
+	output_arg(syscallno, 5, syscalls[syscallno].entry->arg5name, shm->a5[childno],
 			syscalls[syscallno].entry->arg5type, fd, mono);
-	output_arg(syscallno, 6, syscalls[syscallno].entry->arg6name, shm->previous_a6[childno], shm->a6[childno],
+	output_arg(syscallno, 6, syscalls[syscallno].entry->arg6name, shm->a6[childno],
 			syscalls[syscallno].entry->arg6type, fd, mono);
 	CRESETFD
 	fprintf(fd, ") ");
diff --git a/main.c b/main.c
index bf7ea09..8d59c11 100644
--- a/main.c
+++ b/main.c
@@ -3,14 +3,11 @@
 #include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
-#ifdef __LINUX__
 #include <sys/prctl.h>
-#endif /* __LINUX__ */
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <sys/ptrace.h>
-#include <signal.h>
 
 #include "trinity.h"
 #include "child.h"
@@ -22,36 +19,7 @@
 #include "pids.h"
 #include "log.h"
 #include "params.h"
-#include "maps.h"
 
-static void regenerate(void)
-{
-	if (no_files == TRUE)	/* We don't regenerate sockets */
-		return;
-
-	/* we're about to exit. */
-	if (shm->spawn_no_more)
-		return;
-
-	shm->regenerating = TRUE;
-
-	sleep(1);	/* give children time to finish with fds. */
-
-	shm->regenerate = 0;
-
-	output(0, "Regenerating random pages, fd's etc.\n");
-
-	regenerate_fds();
-
-	destroy_maps();
-	setup_maps();
-
-	generate_random_page(page_rand);
-
-	shm->regenerating = FALSE;
-}
-
-#ifdef __LINUX__
 int check_tainted(void)
 {
 	int fd;
@@ -75,9 +43,7 @@ int check_tainted(void)
 
 	return ret;
 }
-#endif /* __LINUX__ */
 
-#ifdef __LINUX__
 static void oom_score_adj(int adj)
 {
 	FILE *fp;
@@ -89,7 +55,6 @@ static void oom_score_adj(int adj)
 	fprintf(fp, "%d", adj);
 	fclose(fp);
 }
-#endif /* __LINUX__ */
 
 static void fork_children(void)
 {
@@ -100,6 +65,7 @@ static void fork_children(void)
 
 	while (shm->running_childs < shm->max_children) {
 		int pid = 0;
+		int fd;
 
 		if (shm->spawn_no_more == TRUE)
 			return;
@@ -119,6 +85,12 @@ static void fork_children(void)
 			exit(EXIT_FAILURE);
 		}
 
+		if (logging == TRUE) {
+			fd = fileno(shm->logfiles[pidslot]);
+			if (ftruncate(fd, 0) == 0)
+				lseek(fd, 0, SEEK_SET);
+		}
+
 		(void)alarm(0);
 		fflush(stdout);
 		pid = fork();
@@ -132,18 +104,17 @@ static void fork_children(void)
 
 			memset(childname, 0, sizeof(childname));
 			sprintf(childname, "trinity-child%d", pidslot);
-#ifdef __LINUX__
 			prctl(PR_SET_NAME, (unsigned long) &childname);
+
 			oom_score_adj(500);
-#endif /* __LINUX__ */
 
 			/* Wait for parent to set our pidslot */
 			while (shm->pids[pidslot] != getpid()) {
 				/* Make sure parent is actually alive to wait for us. */
-				ret = pid_alive(mainpid);
+				ret = pid_alive(shm->mainpid);
 				if (ret != 0) {
 					shm->exit_reason = EXIT_SHM_CORRUPTION;
-					outputerr(BUGTXT "parent (%d) went away!\n", mainpid);
+					outputerr(BUGTXT "parent (%d) went away!\n", shm->mainpid);
 					sleep(20000);
 				}
 			}
@@ -279,14 +250,8 @@ static void handle_child(pid_t childpid, int childstatus)
 				debugf("got an alarm signal from pid %d\n", childpid);
 				break;
 			case SIGSTOP:
-#ifdef __LINUX__
 				debugf("Sending PTRACE_DETACH (and then KILL)\n");
 				ptrace(PTRACE_DETACH, childpid, NULL, NULL);
-#endif /* __LINUX__ */
-#ifdef __BSD__
-				debugf("Sending PT_DETACH (and then KILL)\n");
-				ptrace(PT_DETACH, childpid, NULL, NULL);
-#endif /* __BSD__ */
 				kill(childpid, SIGKILL);
 				reap_child(childpid);
 				break;
@@ -376,6 +341,7 @@ static void main_loop(void)
 			if (shm->running_childs < shm->max_children)
 				fork_children();
 
+			/* Periodic regenation of fd's etc. */
 			if (shm->regenerate >= REGENERATION_POINT)
 				regenerate();
 
@@ -390,9 +356,7 @@ static void main_loop(void)
 
 void do_main_loop(void)
 {
-#ifdef __LINUX__
 	const char taskname[13]="trinity-main";
-#endif
 	int childstatus;
 	pid_t pid;
 
@@ -402,11 +366,9 @@ void do_main_loop(void)
 	if (pid == 0) {
 		setup_main_signals();
 
-		mainpid = getpid();
+		shm->mainpid = getpid();
 		output(0, "Main thread is alive.\n");
-#ifdef __LINUX__
 		prctl(PR_SET_NAME, (unsigned long) &taskname);
-#endif /* __LINUX__ */
 		set_seed(0);
 
 		setup_fds();
diff --git a/maps.c b/maps.c
index 8bbbb88..c5d739b 100644
--- a/maps.c
+++ b/maps.c
@@ -1,8 +1,6 @@
 #include <errno.h>
 #include <fcntl.h>
-#ifdef __LINUX__
 #include <malloc.h>
-#endif /* __LINUX__ */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -77,11 +75,7 @@ static void * alloc_zero_map(struct map *map, int prot, const char *name)
 	}
 
 	/* Pick a random sized mmap. */
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 4) {
-#else
 	switch (rand() % 4) {
-#endif
 	case 0:	size = page_size;
 		break;
 	case 1:	size = 1024*1024;
@@ -100,10 +94,7 @@ static void * alloc_zero_map(struct map *map, int prot, const char *name)
 	 */
 	size *= 2;
 
-#ifdef __LINUX__
 	tmpmap->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_SHARED, fd, 0);
-#endif /* __LINUX__ */
-	tmpmap->ptr = mmap(NULL, size, prot, MAP_ANON|MAP_SHARED, fd, 0);
 
 	if (tmpmap->ptr == MAP_FAILED) {
 		outputerr("mmap /dev/zero failure\n");
@@ -153,11 +144,7 @@ void * get_map(void)
 	struct map *tmpmap = maps_list;
 	unsigned int i, j;
 
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random() % num_mappings;
-#else
 	i = rand() % num_mappings;
-#endif
 	for (j = 0; j < i; j++)
 		tmpmap = tmpmap->next;
 
@@ -185,37 +172,25 @@ void init_buffers(void)
 
 	output(2, "shm is at %p\n", shm);
 
-#ifdef __LINUX__
 	page_zeros = memalign(page_size, page_size * 2);
-#endif /* __LINUX__ */
-	// FIXME page_zeros = (int*)posix_memalign(page_size, page_size * 2);
 	if (!page_zeros)
 		exit(EXIT_FAILURE);
 	memset(page_zeros, 0, page_size);
 	output(2, "page_zeros @ %p\n", page_zeros);
 
-#ifdef __LINUX__
 	page_0xff = memalign(page_size, page_size * 2);
-#endif /* __LINUX__ */
-	// FIXME page_0xff = posix_memalign(page_size, page_size * 2);
 	if (!page_0xff)
 		exit(EXIT_FAILURE);
 	memset(page_0xff, 0xff, page_size);
 	output(2, "page_0xff @ %p\n", page_0xff);
 
-#ifdef __LINUX__
 	page_rand = memalign(page_size, page_size * 2);
-#endif /* __LINUX__ */
-	// FIXME page_rand = posix_memalign(page_size, page_size * 2);
 	if (!page_rand)
 		exit(EXIT_FAILURE);
 	memset(page_rand, 0x55, page_size);	/* overwritten below */
 	output(2, "page_rand @ %p\n", page_rand);
 
-#ifdef __LINUX__
 	page_allocs = memalign(page_size, page_size * 2);
-#endif /* __LINUX__ */
-	// FIXME page_allocs = posix_memalign(page_size, page_size * 2);
 	if (!page_allocs)
 		exit(EXIT_FAILURE);
 	memset(page_allocs, 0xff, page_size);
diff --git a/net/bpf.c b/net/bpf.c
index eea3fdd..fc94125 100644
--- a/net/bpf.c
+++ b/net/bpf.c
@@ -312,7 +312,7 @@ static int seccomp_choose(const float probs[__STATE_GEN_MAX])
 			return i;
 	}
 
-	BUG("wrong state");
+	BUG("wrong state\n");
 	return -1;
 }
 
diff --git a/net/caif_setsockopt.c b/net/caif_setsockopt.c
index fcc42c0..c829521 100644
--- a/net/caif_setsockopt.c
+++ b/net/caif_setsockopt.c
@@ -17,7 +17,9 @@ static const unsigned int caif_opts[] = { CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM }
 
 void caif_setsockopt(struct sockopt *so)
 {
+#ifdef USE_CAIF
 	unsigned char val;
+#endif
 
 	so->level = SOL_CAIF;
 
diff --git a/net/ether.c b/net/ether.c
index 58e2598..1ccb67f 100644
--- a/net/ether.c
+++ b/net/ether.c
@@ -19,7 +19,7 @@ static const int ether_types[] = {
 	ETH_P_ATMMPOA, ETH_P_LINK_CTL, ETH_P_ATMFATE,
 
 	ETH_P_PAE, ETH_P_AOE, ETH_P_8021AD, ETH_P_802_EX1,
-	ETH_P_TIPC, ETH_P_8021AH, ETH_P_MVRP, ETH_P_1588,
+	ETH_P_TIPC, ETH_P_8021AH, ETH_P_MVRP, ETH_P_1588, ETH_P_PRP,
 	ETH_P_FCOE, ETH_P_TDLS, ETH_P_FIP, ETH_P_QINQ1,
 	ETH_P_QINQ2, ETH_P_QINQ3, ETH_P_EDSA, ETH_P_AF_IUCV,
 
diff --git a/net/ip_setsockopt.c b/net/ip_setsockopt.c
index af4b873..26686ba 100644
--- a/net/ip_setsockopt.c
+++ b/net/ip_setsockopt.c
@@ -1,8 +1,10 @@
 #include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <linux/types.h>
 #include <netinet/in.h>
+#include <arpa/inet.h>
 #include <linux/mroute.h>
 #include "sanitise.h"
 #include "compat.h"
@@ -39,6 +41,9 @@ static const unsigned int ip_opts[] = { IP_TOS, IP_TTL, IP_HDRINCL, IP_OPTIONS,
 void ip_setsockopt(struct sockopt *so)
 {
 	unsigned char val;
+	struct ip_mreqn *mr;
+	struct ip_mreq_source *ms;
+	int mcaddr;
 
 	so->level = SOL_IP;
 
@@ -80,13 +85,18 @@ void ip_setsockopt(struct sockopt *so)
 	case IP_MULTICAST_IF:
 	case IP_ADD_MEMBERSHIP:
 	case IP_DROP_MEMBERSHIP:
-		if (rand_bool())
-			so->optval = (unsigned long) page_allocs;
-
-		if (rand_bool())
-			so->optlen = sizeof(struct in_addr);
-		else
-			so->optlen = sizeof(struct ip_mreqn);
+		mcaddr = 0xe0000000 | rand() % 0xff;
+
+		mr = malloc(sizeof(struct ip_mreqn));
+		if (!mr)
+			break;
+		memset(mr, 0, sizeof(struct ip_mreqn));
+		mr->imr_multiaddr.s_addr = mcaddr;
+		mr->imr_address.s_addr = random_ipv4_address();
+		mr->imr_ifindex = rand32();
+
+		so->optval = (unsigned long) mr;
+		so->optlen = sizeof(struct ip_mreqn);
 		break;
 
 	case MRT_ADD_VIF:
@@ -115,6 +125,17 @@ void ip_setsockopt(struct sockopt *so)
 	case IP_UNBLOCK_SOURCE:
 	case IP_ADD_SOURCE_MEMBERSHIP:
 	case IP_DROP_SOURCE_MEMBERSHIP:
+		mcaddr = 0xe0000000 | rand() % 0xff;
+
+		ms = malloc(sizeof(struct ip_mreq_source));
+		if (!ms)
+			break;
+		memset(ms, 0, sizeof(struct ip_mreq_source));
+		ms->imr_multiaddr.s_addr = mcaddr;
+		ms->imr_interface.s_addr = random_ipv4_address();
+		ms->imr_sourceaddr.s_addr = random_ipv4_address();
+
+		so->optval = (unsigned long) ms;
 		so->optlen = sizeof(struct ip_mreq_source);
 		break;
 
diff --git a/net/ipv4.c b/net/ipv4.c
index 9822259..2f25ca9 100644
--- a/net/ipv4.c
+++ b/net/ipv4.c
@@ -5,18 +5,13 @@
 #include <stdlib.h>
 #include "net.h"
 #include "random.h"
-#include "config.h"	// arc4random
 
 in_addr_t random_ipv4_address(void)
 {
 	int addr = 0;
 	int class = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 9) {
-#else
 	switch (rand() % 9) {
-#endif
 	case 0:	addr = 0;		/* 0.0.0.0 */
 		break;
 	case 1:	addr = 0x0a000000;	/* 10.0.0.0/8 */
@@ -37,8 +32,8 @@ in_addr_t random_ipv4_address(void)
 	case 6:	addr = 0xc0a80000;	/* 192.168.0.0/16 */
 		class = 16;
 		break;
-	case 7:	addr = 0xe0000000;	/* 224.0.0.0/4 (multicast)*/
-		class = 4;
+	case 7:	addr = 0xe0000000;	/* 224.0.0.0/24 (multicast)*/
+		class = 24;
 		break;
 	case 8:	addr = 0xffffffff;	/* 255.255.255.255 */
 		break;
@@ -46,27 +41,8 @@ in_addr_t random_ipv4_address(void)
 		break;
 	}
 
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 100 < 50) {
-		switch (class) {
-		case 4:	addr |= arc4random() % 0xfffffff;
-			break;
-		case 8:	addr |= arc4random() % 0xffffff;
-			break;
-		case 12: addr |= arc4random() % 0xfffff;
-			break;
-		case 16: addr |= arc4random() % 0xffff;
-			break;
-		case 24: addr |= arc4random() % 0xff;
-			break;
-		default: break;
-		}
-	}
-#else
 	if (rand() % 100 < 50) {
 		switch (class) {
-		case 4:	addr |= rand() % 0xfffffff;
-			break;
 		case 8:	addr |= rand() % 0xffffff;
 			break;
 		case 12: addr |= rand() % 0xfffff;
@@ -78,7 +54,6 @@ in_addr_t random_ipv4_address(void)
 		default: break;
 		}
 	}
-#endif
 	return htonl(addr);
 }
 
@@ -92,22 +67,14 @@ void ipv4_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 
 	ipv4->sin_family = PF_INET;
 	ipv4->sin_addr.s_addr = random_ipv4_address();
-#ifdef HAVE_ARC4RANDOM
-	ipv4->sin_port = arc4random() % 65535;
-#else
 	ipv4->sin_port = rand() % 65535;
-#endif
 	*addr = (unsigned long) ipv4;
 	*addrlen = sizeof(struct sockaddr_in);
 }
 
 void inet_rand_socket(struct socket_triplet *st)
 {
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0: st->type = SOCK_STREAM;     // TCP
 		if (rand_bool())
 			st->protocol = 0;
@@ -123,11 +90,7 @@ void inet_rand_socket(struct socket_triplet *st)
 		break;
 
 	case 2: st->type = SOCK_RAW;
-#ifdef HAVE_ARC4RANDOM
-		st->protocol = arc4random() % PROTO_MAX;
-#else
 		st->protocol = rand() % PROTO_MAX;
-#endif
 		break;
 
 	default:break;
diff --git a/net/ipv6.c b/net/ipv6.c
index 53de36c..7f12240 100644
--- a/net/ipv6.c
+++ b/net/ipv6.c
@@ -2,26 +2,12 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <netinet/in.h>
-#ifdef __LINUX__
 #include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/if_packet.h>
-#endif
 #include <stdlib.h>
 #include "net.h"
 #include "random.h"
-#include "config.h"	// arc4random
-
-/* 
- * OpenBSD, FreeBSD and NexentaCore don't
- * define s6_addr32 for user land settings.
- */
-#if !defined s6_addr32 && defined __sun__
-#	define s6_addr32 _S6_un._S6_u32
-#elif !defined s6_addr32 && \
-	( defined __OpenBSD__ || defined __FreeBSD__ )
-#	define s6_addr32 __u6_addr.__u6_addr32
-#endif
 
 void ipv6_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 {
@@ -36,23 +22,14 @@ void ipv6_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 	ipv6->sin6_addr.s6_addr32[1] = 0;
 	ipv6->sin6_addr.s6_addr32[2] = 0;
 	ipv6->sin6_addr.s6_addr32[3] = htonl(1);
-#ifdef HAVE_ARC4RANDOM
-	ipv6->sin6_port = arc4random() % 65535;
-#else
 	ipv6->sin6_port = rand() % 65535;
-#endif
-
 	*addr = (unsigned long) ipv6;
 	*addrlen = sizeof(struct sockaddr_in6);
 }
 
 void inet6_rand_socket(struct socket_triplet *st)
 {
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0: st->type = SOCK_STREAM;     // TCP
 		st->protocol = 0;
 		break;
@@ -65,11 +42,7 @@ void inet6_rand_socket(struct socket_triplet *st)
 		break;
 
 	case 2: st->type = SOCK_RAW;
-#ifdef HAVE_ARC4RANDOM
-		st->protocol = arc4random() % PROTO_MAX;
-#else
 		st->protocol = rand() % PROTO_MAX;
-#endif
 		break;
 
 	default:break;
diff --git a/net/packet.c b/net/packet.c
index a74e512..51bcf6a 100644
--- a/net/packet.c
+++ b/net/packet.c
@@ -29,11 +29,8 @@ void packet_rand_socket(struct socket_triplet *st)
 {
 	st->protocol = htons(ETH_P_ALL);
 
-	if (rand() % 8 == 0) {
-		st->protocol = rand();
-		if (rand_bool())
-			st->protocol = (uint16_t) rand();
-	}
+	if (rand() % 8 == 0)		// FIXME: 8 ? Why?
+		st->protocol = get_random_ether_type();
 
 	switch (rand() % 3) {
 	case 0: st->type = SOCK_DGRAM;
diff --git a/net/pppox.c b/net/pppox.c
index 95b214e..11d9098 100644
--- a/net/pppox.c
+++ b/net/pppox.c
@@ -19,11 +19,7 @@ void pppox_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 	unsigned int proto;
 	unsigned int i;
 
-#ifdef HAVE_ARC4RANDOM
-	proto = arc4random() % 3;
-#else
 	proto = rand() % 3;
-#endif
 
 	switch (proto) {
 
@@ -35,19 +31,11 @@ void pppox_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 		pppox->sa_family = PF_PPPOX;
 		pppox->sa_protocol = proto;
 
-#ifdef HAVE_ARC4RANDOM
-		pppox->sa_addr.pppoe.sid = arc4random();
-		for (i = 0; i < ETH_ALEN; i++)
-			pppox->sa_addr.pppoe.remote[i] = arc4random();
-		for (i = 0; i < IFNAMSIZ; i++)
-			pppox->sa_addr.pppoe.dev[i] = arc4random();
-#else
 		pppox->sa_addr.pppoe.sid = rand();
 		for (i = 0; i < ETH_ALEN; i++)
 			pppox->sa_addr.pppoe.remote[i] = rand();
 		for (i = 0; i < IFNAMSIZ; i++)
 			pppox->sa_addr.pppoe.dev[i] = rand();
-#endif
 
 #ifdef USE_PPPOX_PPTP
 		pppox->sa_addr.pptp.call_id = rand();
diff --git a/net/protocols.c b/net/protocols.c
index 0b57d2b..0ebeff0 100644
--- a/net/protocols.c
+++ b/net/protocols.c
@@ -5,13 +5,10 @@
 
 #include "trinity.h"
 #include "constants.h"
+#include "protocols.h"
+#include "params.h"
 #include "net.h"
 #include "log.h"
-#include "config.h"
-
-#ifdef __BSD__
-#include <sys/socket.h>
-#endif
 
 struct protocol {
 	const char *name;
@@ -24,8 +21,6 @@ static const struct protocol protocols[] = {
 	{ "PF_UNIX",         PF_LOCAL },
 	{ "PF_FILE",         PF_LOCAL },
 	{ "PF_INET",         2 },
-	{ "PF_INET6",        10 },
-#ifdef __LINUX__
 	{ "PF_AX25",         3 },
 	{ "PF_IPX",          4 },
 	{ "PF_APPLETALK",    5 },
@@ -33,6 +28,7 @@ static const struct protocol protocols[] = {
 	{ "PF_BRIDGE",       7 },
 	{ "PF_ATMPVC",       8 },
 	{ "PF_X25",          9 },
+	{ "PF_INET6",        10 },
 	{ "PF_ROSE",         11 },
 	{ "PF_DECnet",       12 },
 	{ "PF_NETBEUI",      13 },
@@ -62,48 +58,95 @@ static const struct protocol protocols[] = {
 	{ "PF_ALG",          38 },
 	{ "PF_NFC",          39 },
 	{ "PF_VSOCK",        40 },
-#endif
 };
 
+static const struct protocol *lookup_proto(const char *name, unsigned int proto)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(protocols); i++) {
+		if ((name && strcmp(name, protocols[i].name) == 0) ||
+		    (proto != -1u && protocols[i].proto == proto))
+			return &protocols[i];
+	}
+
+	return NULL;
+}
+
 const char * get_proto_name(unsigned int proto)
 {
 	unsigned int i;
 
-	for (i = 0; i < TRINITY_PF_MAX; i++)
+	for (i = 0; i < ARRAY_SIZE(protocols); i++)
 		if (protocols[i].proto == proto)
 			return protocols[i].name;
 	return NULL;
 }
 
 void find_specific_proto(const char *protoarg)
+{
+	const struct protocol *p;
+	unsigned int i;
+
+	p = lookup_proto(protoarg, specific_proto ? : -1u);
+	if (p) {
+		specific_proto = p->proto;
+		output(2, "Using protocol %s (%u) for all sockets\n", p->name, p->proto);
+		return;
+	}
+
+	outputerr("Protocol unknown. Pass a numeric value [0-%d] or one of ", TRINITY_PF_MAX);
+	for (i = 0; i < ARRAY_SIZE(protocols); i++)
+		outputerr("%s ", protocols[i].name);
+	outputerr("\n");
+
+	exit(EXIT_FAILURE);
+}
+
+unsigned int find_next_enabled_proto(unsigned int from)
 {
 	unsigned int i;
 
-	if (specific_proto == 0) {
-		/* we were passed a string */
-		for (i = 0; i < ARRAY_SIZE(protocols); i++) {
-			if (strcmp(protoarg, protocols[i].name) == 0) {
-				specific_proto = protocols[i].proto;
-				output(2, "Proto %s = %d\n", protoarg, specific_proto);
-				break;
-			}
-		}
-	} else {
-		/* we were passed a numeric arg. */
-		for (i = 0; i < TRINITY_PF_MAX; i++) {
-			if (specific_proto == protocols[i].proto)
-				break;
-		}
+	from %= ARRAY_SIZE(no_protos);
+
+	for (i = from; i < ARRAY_SIZE(no_protos); i++) {
+		if (no_protos[i] == FALSE)
+			return no_protos[i];
+	}
+
+	for (i = 0; i < from; i++) {
+		if (no_protos[i] == FALSE)
+			return no_protos[i];
 	}
 
-	if (i > TRINITY_PF_MAX) {
-		outputerr("Protocol unknown. Pass a numeric value [0-%d] or one of ", TRINITY_PF_MAX);
-		for (i = 0; i < ARRAY_SIZE(protocols); i++)
-			outputerr("%s ", protocols[i].name);
-		outputerr("\n");
+	return -1u;
+}
+
+void parse_exclude_protos(const char *arg)
+{
+	char *_arg = strdup(arg);
+	const struct protocol *p;
+	char *tok;
 
+	if (!_arg) {
+		outputerr("No free memory\n");
 		exit(EXIT_FAILURE);
 	}
 
-	output(2, "Using protocol %s (%u) for all sockets\n", protocols[i].name, protocols[i].proto);
+	for (tok = strtok(_arg, ","); tok; tok = strtok(NULL, ",")) {
+		p = lookup_proto(tok, (unsigned int)atoi(tok));
+		if (p) {
+			BUG_ON(p->proto >= ARRAY_SIZE(no_protos));
+			no_protos[p->proto] = TRUE;
+		} else
+			goto err;
+	}
+
+	free(_arg);
+	return;
+
+err:
+	free(_arg);
+	outputerr("Protocol unknown in argument %s\n", arg);
+	exit(EXIT_FAILURE);
 }
diff --git a/net/rds_setsockopt.c b/net/rds_setsockopt.c
index 9cb4652..6ad6e2a 100644
--- a/net/rds_setsockopt.c
+++ b/net/rds_setsockopt.c
@@ -20,15 +20,13 @@ static const unsigned int rds_opts[] = {
 
 void rds_setsockopt(struct sockopt *so)
 {
+#ifdef USE_RDS
 	unsigned char val;
+#endif
 
 	so->level = SOL_RDS;
 #ifdef USE_RDS
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_RDS_OPTS;
-#else
 	val = rand() % NR_SOL_RDS_OPTS;
-#endif
 	so->optname = rds_opts[val];
 #endif
 }
diff --git a/net/rose.c b/net/rose.c
index bf9b39a..8e36799 100644
--- a/net/rose.c
+++ b/net/rose.c
@@ -17,27 +17,15 @@ void rose_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 		return;
 
 	rose->srose_family = PF_ROSE;
-#ifdef HAVE_ARC4RANDOM
-	rose->srose_addr.rose_addr[0] = arc4random();
-	rose->srose_addr.rose_addr[1] = arc4random();
-	rose->srose_addr.rose_addr[2] = arc4random();
-	rose->srose_addr.rose_addr[3] = arc4random();
-	rose->srose_addr.rose_addr[4] = arc4random();
-#else
 	rose->srose_addr.rose_addr[0] = rand();
 	rose->srose_addr.rose_addr[1] = rand();
 	rose->srose_addr.rose_addr[2] = rand();
 	rose->srose_addr.rose_addr[3] = rand();
 	rose->srose_addr.rose_addr[4] = rand();
-#endif
 
 	memcpy(rose->srose_call.ax25_call, page_rand, 7);
 
-#ifdef HAVE_ARC4RANDOM
-	rose->srose_ndigis = arc4random();
-#else
 	rose->srose_ndigis = rand();
-#endif
 
 	memcpy(rose->srose_digi.ax25_call, page_rand + 7, 7);
 
diff --git a/net/rose_setsockopt.c b/net/rose_setsockopt.c
index 1802832..f08ed5f 100644
--- a/net/rose_setsockopt.c
+++ b/net/rose_setsockopt.c
@@ -18,10 +18,6 @@ void rose_setsockopt(struct sockopt *so)
 
 	so->level = SOL_ROSE;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_ROSE_OPTS;
-#else
 	val = rand() % NR_SOL_ROSE_OPTS;
-#endif
 	so->optname = rose_opts[val];
 }
diff --git a/net/rxrpc_setsockopt.c b/net/rxrpc_setsockopt.c
index 8d162cc..dd3d207 100644
--- a/net/rxrpc_setsockopt.c
+++ b/net/rxrpc_setsockopt.c
@@ -16,10 +16,6 @@ void rxrpc_setsockopt(struct sockopt *so)
 
 	so->level = SOL_RXRPC;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_RXRPC_OPTS;
-#else
 	val = rand() % NR_SOL_RXRPC_OPTS;
-#endif
 	so->optname = rxrpc_opts[val];
 }
diff --git a/net/sctp_setsockopt.c b/net/sctp_setsockopt.c
index 426d152..ce951da 100644
--- a/net/sctp_setsockopt.c
+++ b/net/sctp_setsockopt.c
@@ -26,10 +26,6 @@ void sctp_setsockopt(struct sockopt *so)
 
 	so->level = SOL_SCTP;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_SCTP_OPTS;
-#else
 	val = rand() % NR_SOL_SCTP_OPTS;
-#endif
 	so->optname = sctp_opts[val];
 }
diff --git a/net/sockaddr.c b/net/sockaddr.c
index 952855c..ce0f4a4 100644
--- a/net/sockaddr.c
+++ b/net/sockaddr.c
@@ -20,19 +20,14 @@ static const struct sa_func_entry sa_funcs[] = {
 //TODO	{ .pf = PF_UNSPEC, .func = &unspec_gen_sockaddr },
 	{ .pf = PF_UNIX, .func = &unix_gen_sockaddr },
 	{ .pf = PF_INET, .func = &ipv4_gen_sockaddr },
-#ifdef __LINUX__
 	{ .pf = PF_AX25, .func = &ax25_gen_sockaddr },
 	{ .pf = PF_IPX, .func = &ipx_gen_sockaddr },
 	{ .pf = PF_APPLETALK, .func = &atalk_gen_sockaddr },
-#endif
 //TODO	{ .pf = PF_NETROM, .func = &netrom_gen_sockaddr },
 //TODO	{ .pf = PF_BRIDGE, .func = &bridge_gen_sockaddr },
-#ifdef __LINUX__
 	{ .pf = PF_ATMPVC, .func = &atmpvc_gen_sockaddr },
 	{ .pf = PF_X25, .func = &x25_gen_sockaddr },
-#endif
 	{ .pf = PF_INET6, .func = &ipv6_gen_sockaddr },
-#ifdef __LINUX__
 	{ .pf = PF_ROSE, .func = &rose_gen_sockaddr },
 	{ .pf = PF_DECnet, .func = &decnet_gen_sockaddr },
 	{ .pf = PF_NETBEUI, .func = &llc_gen_sockaddr },
@@ -65,7 +60,6 @@ static const struct sa_func_entry sa_funcs[] = {
 #endif
 	{ .pf = PF_NFC, .func = &nfc_gen_sockaddr },
 //TODO	{ .pf = PF_VSOCK, .func = &vsock_gen_sockaddr },
-#endif /* __LINUX__ */
 };
 
 void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf)
@@ -78,11 +72,7 @@ void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf)
 
 	/* If we got no hint passed down, pick a random proto. */
 	if (pf == -1)
-#ifdef HAVE_ARC4RANDOM
-		pf = arc4random() % TRINITY_PF_MAX;
-#else
 		pf = rand() % TRINITY_PF_MAX;
-#endif
 
 	for (i = 0; i < ARRAY_SIZE(sa_funcs); i++) {
 		if (sa_funcs[i].pf == (unsigned int) pf)
diff --git a/net/socket_setsockopt.c b/net/socket_setsockopt.c
index c85de7e..e903a9a 100644
--- a/net/socket_setsockopt.c
+++ b/net/socket_setsockopt.c
@@ -17,7 +17,7 @@ static const unsigned int socket_opts[] = { SO_DEBUG, SO_REUSEADDR, SO_TYPE, SO_
 	SO_PASSSEC, SO_TIMESTAMPNS, SO_MARK, SO_TIMESTAMPING,
 	SO_PROTOCOL, SO_DOMAIN, SO_RXQ_OVFL, SO_WIFI_STATUS,
 	SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
-	SO_BUSY_POLL };
+	SO_BUSY_POLL, SO_MAX_PACING_RATE };
 
 void socket_setsockopt(struct sockopt *so)
 {
@@ -25,11 +25,7 @@ void socket_setsockopt(struct sockopt *so)
 
 	so->level = SOL_SOCKET;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_SOCKET_OPTS;
-#else
 	val = rand() % NR_SOL_SOCKET_OPTS;
-#endif
 	so->optname = socket_opts[val];
 
 	/* Adjust length according to operation set. */
diff --git a/net/tcp_setsockopt.c b/net/tcp_setsockopt.c
index e686280..bee6f14 100644
--- a/net/tcp_setsockopt.c
+++ b/net/tcp_setsockopt.c
@@ -21,10 +21,6 @@ void tcp_setsockopt(struct sockopt *so)
 
 	so->level = SOL_TCP;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_TCP_OPTS;
-#else
 	val = rand() % NR_SOL_TCP_OPTS;
-#endif
 	so->optname = tcp_opts[val];
 }
diff --git a/net/tipc.c b/net/tipc.c
index 3fca227..a6bfb69 100644
--- a/net/tipc.c
+++ b/net/tipc.c
@@ -15,18 +15,6 @@ void tipc_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 	if (tipc == NULL)
 		return;
 	tipc->family = AF_TIPC;
-#ifdef HAVE_ARC4RANDOM
-	tipc->addrtype = arc4random();
-	tipc->scope = arc4random();
-	tipc->addr.id.ref = arc4random();
-	tipc->addr.id.node = arc4random();
-	tipc->addr.nameseq.type = arc4random();
-	tipc->addr.nameseq.lower = arc4random();
-	tipc->addr.nameseq.upper = arc4random();
-	tipc->addr.name.name.type = arc4random();
-	tipc->addr.name.name.instance = arc4random();
-	tipc->addr.name.domain = arc4random();
-#else
 	tipc->addrtype = rand();
 	tipc->scope = rand();
 	tipc->addr.id.ref = rand();
@@ -37,7 +25,6 @@ void tipc_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 	tipc->addr.name.name.type = rand();
 	tipc->addr.name.name.instance = rand();
 	tipc->addr.name.domain = rand();
-#endif
 	*addr = (unsigned long) tipc;
 	*addrlen = sizeof(struct sockaddr_tipc);
 }
@@ -46,11 +33,7 @@ void tipc_rand_socket(struct socket_triplet *st)
 {
 	st->protocol = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0: st->type = SOCK_STREAM;
 		break;
 	case 1: st->type = SOCK_SEQPACKET;
diff --git a/net/tipc_setsockopt.c b/net/tipc_setsockopt.c
index 9e9cbc5..f31ec91 100644
--- a/net/tipc_setsockopt.c
+++ b/net/tipc_setsockopt.c
@@ -15,11 +15,7 @@ void tipc_setsockopt(struct sockopt *so)
 
 	so->level = SOL_TIPC;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_TIPC_OPTS;
-#else
 	val = rand() % NR_SOL_TIPC_OPTS;
-#endif
 	so->optname = tipc_opts[val];
 
 	so->optval = sizeof(__u32);
diff --git a/net/udplite_setsockopt.c b/net/udplite_setsockopt.c
index e4d64e2..3597434 100644
--- a/net/udplite_setsockopt.c
+++ b/net/udplite_setsockopt.c
@@ -16,22 +16,14 @@ void udplite_setsockopt(struct sockopt *so)
 
 	so->level = SOL_UDPLITE;
 
-#ifdef HAVE_ARC4RANDOM
-	val = arc4random() % NR_SOL_UDPLITE_OPTS;
-#else
 	val = rand() % NR_SOL_UDPLITE_OPTS;
-#endif
 	so->optname = udplite_opts[val];
 
 	switch (so->optname) {
 	case UDP_CORK:
 		break;
 	case UDP_ENCAP:
-#ifdef HAVE_ARC4RANDOM
-		page_rand[0] = (arc4random() % 3) + 1;        // Encapsulation types.
-#else
 		page_rand[0] = (rand() % 3) + 1;        // Encapsulation types.
-#endif
 		break;
 	case UDPLITE_SEND_CSCOV:
 		break;
diff --git a/net/unix.c b/net/unix.c
index 0cfc5b1..74576fb 100644
--- a/net/unix.c
+++ b/net/unix.c
@@ -2,14 +2,10 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <netinet/in.h>
-#ifdef __LINUX__
 #include <linux/dn.h>
-#endif
 #include <stdlib.h>
-#include <string.h>
 #include "maps.h"
 #include "net.h"
-#include "config.h"	// arc4random
 
 void unix_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 {
@@ -21,11 +17,7 @@ void unix_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 		return;
 
 	unixsock->sun_family = PF_UNIX;
-#ifdef HAVE_ARC4RANDOM
-	len = arc4random() % 20;
-#else
 	len = rand() % 20;
-#endif
 	memset(&page_rand[len], 0, 1);
 	strncpy(unixsock->sun_path, page_rand, len);
 	*addr = (unsigned long) unixsock;
@@ -36,11 +28,7 @@ void unix_rand_socket(struct socket_triplet *st)
 {
 	st->protocol = PF_UNIX;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0: st->type = SOCK_STREAM;
 		break;
 	case 1: st->type = SOCK_DGRAM;
diff --git a/net/x25.c b/net/x25.c
index 4919c11..26c8888 100644
--- a/net/x25.c
+++ b/net/x25.c
@@ -17,11 +17,7 @@ void x25_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 		return;
 
 	x25->sx25_family = PF_X25;
-#ifdef HAVE_ARC4RANDOM
-	len = arc4random() % 15;
-#else
 	len = rand() % 15;
-#endif
 	memset(&page_rand[len], 0, 1);
 	strncpy(x25->sx25_addr.x25_addr, page_rand, len);
 	*addr = (unsigned long) x25;
diff --git a/params.c b/params.c
index ee0472b..86d15cc 100644
--- a/params.c
+++ b/params.c
@@ -10,7 +10,9 @@
 #include "random.h"
 #include "syscall.h"
 #include "log.h"
+#include "net.h"
 #include "params.h"
+#include "protocols.h"
 #include "tables.h"
 
 #define TAINT_NAME_LEN 32
@@ -27,6 +29,7 @@ unsigned int specific_proto = 0;
 unsigned int user_specified_children = 0;
 
 bool do_specific_proto = FALSE;
+bool no_protos[TRINITY_PF_MAX];
 
 bool dopause = FALSE;
 bool show_syscall_list = FALSE;
@@ -49,30 +52,26 @@ char *specific_proto_optarg;
 
 char *victim_path;
 
-#ifndef __BSD__
 int kernel_taint_initial = 0;
 int kernel_taint_mask = 0xFFFFFFFF;
 bool kernel_taint_param_occured = FALSE;
-#endif
 
 static void usage(void)
 {
 	outputerr("%s\n", progname);
 	outputerr(" --arch, -a: selects syscalls for the specified architecture (32 or 64). Both by default.\n");
 	outputerr(" --children,-C: specify number of child processes\n");
-	outputerr(" --dangerous,-d: enable dangerous syscalls\n");
 	outputerr(" --debug,-D: enable debug\n");
 	outputerr(" --exclude,-x: don't call a specific syscall\n");
 	outputerr(" --group,-g: only run syscalls from a certain group (So far just 'vm').\n");
 	outputerr(" --ioctls,-I: list all ioctls.\n");
-#ifndef __BSD__
 	outputerr(" --kernel_taint, -T: controls which kernel taint flags should be considered, for more details refer to README file. \n");
-#endif /* __BSD__ */
 	outputerr(" --list,-L: list all syscalls known on this architecture.\n");
 	outputerr(" --logging,-l: (off=disable logging).\n");
 	outputerr(" --monochrome,-m: don't output ANSI codes\n");
 	outputerr(" --no_files,-n: Only pass sockets as fd's, not files\n");
 	outputerr(" --proto,-P: specify specific network protocol for sockets.\n");
+	outputerr(" --no_proto,-E: specify network protocols to be excluded from testing.\n");
 	outputerr(" --quiet,-q: less output.\n");
 	outputerr(" --random,-r#: pick N syscalls at random and just fuzz those\n");
 	outputerr(" --syslog,-S: log important info to syslog. (useful if syslog is remote)\n");
@@ -92,9 +91,7 @@ static const struct option longopts[] = {
 	{ "debug", no_argument, NULL, 'D' },
 	{ "exclude", required_argument, NULL, 'x' },
 	{ "group", required_argument, NULL, 'g' },
-#ifndef __BSD__
 	{ "kernel_taint", required_argument, NULL, 'T' },
-#endif
 	{ "help", no_argument, NULL, 'h' },
 	{ "list", no_argument, NULL, 'L' },
 	{ "ioctls", no_argument, NULL, 'I' },
@@ -102,6 +99,7 @@ static const struct option longopts[] = {
 	{ "monochrome", no_argument, NULL, 'm' },
 	{ "no_files", no_argument, NULL, 'n' },
 	{ "proto", required_argument, NULL, 'P' },
+	{ "no_proto", required_argument, NULL, 'E' },
 	{ "random", required_argument, NULL, 'r' },
 	{ "quiet", no_argument, NULL, 'q' },
 	{ "syslog", no_argument, NULL, 'S' },
@@ -110,7 +108,6 @@ static const struct option longopts[] = {
 	{ "arch", required_argument, NULL, 'a' },
 	{ NULL, 0, NULL, 0 } };
 
-#ifndef __BSD__
 static void toggle_taint_flag(int bit) {
 	kernel_taint_mask |= (1 << bit);
 }
@@ -180,13 +177,12 @@ static void process_taint_arg(char *taintarg) {
 	}
 	toggle_taint_flag_by_name(beg,end);
 }
-#endif /* __BSD__ */
 
 void parse_args(int argc, char *argv[])
 {
 	int opt;
 
-	while ((opt = getopt_long(argc, argv, "a:c:C:dDg:hIl:LN:mnP:pqr:s:T:SV:vx:", longopts, NULL)) != -1) {
+	while ((opt = getopt_long(argc, argv, "a:c:C:dDg:hIl:LN:mnP:E:pqr:s:T:SV:vx:", longopts, NULL)) != -1) {
 		switch (opt) {
 		default:
 			if (opt == '?')
@@ -264,7 +260,7 @@ void parse_args(int argc, char *argv[])
 
 		/* Set number of syscalls to do */
 		case 'N':
-			syscalls_todo = strtoll(optarg, NULL, 10) + 1;
+			syscalls_todo = strtoll(optarg, NULL, 10);
 			break;
 
 		/* Pause after each syscall */
@@ -278,6 +274,10 @@ void parse_args(int argc, char *argv[])
 			specific_proto_optarg = optarg;
 			break;
 
+		case 'E':
+			parse_exclude_protos(optarg);
+			break;
+
 		case 'q':
 			quiet_level++;
 			break;
@@ -302,12 +302,10 @@ void parse_args(int argc, char *argv[])
 			do_syslog = TRUE;
 			break;
 
-#ifndef __BSD__
 		case 'T':
 			//Load mask for kernel taint flags.
 			process_taint_arg(optarg);
 			break;
-#endif
 
 		case 'v':
 			verbose = TRUE;
diff --git a/perf.c b/perf.c
index d6fac13..f8219c6 100644
--- a/perf.c
+++ b/perf.c
@@ -4,16 +4,13 @@
 #include <string.h>
 #include <unistd.h>
 //#include <sys/syscall.h>   /* For SYS_xxx definitions */
-#ifdef __LINUX__
 #include <asm/unistd.h>
-#endif
 
 #include "perf.h"
 #include "shm.h"
 #include "log.h"
 #include "sanitise.h"
 
-#ifdef __LINUX__
 void open_perf_fds(void)
 {
 	int fd;
@@ -32,4 +29,3 @@ void open_perf_fds(void)
 		}
 	}
 }
-#endif
diff --git a/pids.c b/pids.c
index 3fc8a07..afbd15c 100644
--- a/pids.c
+++ b/pids.c
@@ -7,9 +7,7 @@
 #include "pids.h"
 #include "log.h"
 #include "sanitise.h"
-#include "config.h" 	// arc4random
 
-pid_t mainpid;
 pid_t initpid;
 
 int find_pid_slot(pid_t mypid)
@@ -122,17 +120,9 @@ unsigned int get_pid(void)
 	if (shm->running_childs == 0)
 		return 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0:
-#ifdef HAVE_ARC4RANDOM
-retry:		i = arc4random() % shm->max_children;
-#else
 retry:		i = rand() % shm->max_children;
-#endif
 		pid = shm->pids[i];
 		if (pid == EMPTY_PIDSLOT)
 			goto retry;
diff --git a/random-address.c b/random-address.c
index 5cd9dfe..52c5366 100644
--- a/random-address.c
+++ b/random-address.c
@@ -2,14 +2,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
-#include <config.h>
-#ifdef __LINUX__
-#include <linux/uio.h>
-#endif
-
-#ifdef __BSD__
 #include <sys/uio.h>
-#endif
 
 #include "trinity.h"	// page_size
 #include "arch.h"	// KERNEL_ADDR etc
@@ -52,17 +45,10 @@ static void * _get_address(unsigned char null_allowed)
 	int i;
 	void *addr = NULL;
 
-#ifdef HAVE_ARC4RANDOM
-	if (null_allowed == TRUE)
-		i = arc4random() % 9;
-	else
-		i = (arc4random() % 8) + 1;
-#else
 	if (null_allowed == TRUE)
 		i = rand() % 9;
 	else
 		i = (rand() % 8) + 1;
-#endif
 
 
 	switch (i) {
@@ -98,11 +84,7 @@ static void * _get_address(unsigned char null_allowed)
 	 * But sometimes, we return an address just before the end of the page.
 	 * The idea here is that we might see some bugs that are caused by page boundary failures.
 	 */
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random() % 100;
-#else
 	i = rand() % 100;
-#endif
 	switch (i) {
 	case 0:	addr += (page_size - sizeof(char));
 		break;
@@ -162,7 +144,7 @@ unsigned long find_previous_arg_address(unsigned int argnum, unsigned int call,
 	return addr;
 }
 
-//#ifdef __LINUX__
+
 /*
  * iovec's are just special cases of the ARG_ADDRESS's
  */
@@ -180,4 +162,3 @@ struct iovec * alloc_iovec(unsigned int num)
 	}
 	return iov;
 }
-//#endif /* __LINUX__ */
diff --git a/random-length.c b/random-length.c
index 7478f50..40b2d5f 100644
--- a/random-length.c
+++ b/random-length.c
@@ -3,7 +3,6 @@
 #include "arch.h"	// page_size
 #include "sanitise.h"
 #include "random.h"
-#include "config.h"	// arc4random
 
 unsigned long get_len(void)
 {
@@ -15,11 +14,7 @@ unsigned long get_len(void)
 	if (i == 0)
 		return 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 6) {
-#else
 	switch (rand() % 6) {
-#endif
 
 	case 0:	i &= 0xff;
 		break;
@@ -41,22 +36,9 @@ unsigned long get_len(void)
 		return 0;
 
 	/* we might get lucky if something is counting ints/longs etc. */
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 100 < 25) {
-		switch (arc4random() % 3) {
-#else
 	if (rand() % 100 < 25) {
-		switch (rand() % 3) {
-#endif
-		case 0:	i /= sizeof(int);
-			break;
-		case 1:	i /= sizeof(long);
-			break;
-		case 2:	i /= sizeof(long long);
-			break;
-		default:
-			break;
-		}
+		int _div = 1 << ((rand() % 4) + 1);      /* 2,4,8 or 16 */
+		i /= _div;
 	}
 
 	return i;
diff --git a/random-page.c b/random-page.c
index 517c681..da5c803 100644
--- a/random-page.c
+++ b/random-page.c
@@ -6,7 +6,6 @@
 #include "sanitise.h"	// get_address
 #include "maps.h"
 #include "log.h"	// For BUG
-#include "config.h"	// arc4random
 
 static void fabricate_onepage_struct(char *page)
 {
@@ -15,11 +14,7 @@ static void fabricate_onepage_struct(char *page)
 
 	for (i = 0; i < page_size; ) {
 		ptr = (void*)&page[i];
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 4) {
-#else
 		switch (rand() % 4) {
-#endif
 		case 0:
 			i += sizeof(unsigned int);
 			if (i > page_size)
@@ -42,11 +37,7 @@ static void fabricate_onepage_struct(char *page)
 			i += sizeof(unsigned int);
 			if (i > page_size)
 				return;
-#ifdef HAVE_ARC4RANDOM
-			*(unsigned int *)ptr = arc4random() % page_size;
-#else
 			*(unsigned int *)ptr = rand() % page_size;
-#endif
 			break;
 		default:
 			BUG("unreachable!\n");
@@ -58,30 +49,19 @@ static void fabricate_onepage_struct(char *page)
 void generate_random_page(char *page)
 {
 	unsigned int i;
+	unsigned int p = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 7) {
-#else
-	switch (rand() % 7) {
-#endif
+	switch (rand() % 8) {
 	/* return a page of complete trash */
 	case 0:	/* bytes */
 		for (i = 0; i < page_size; )
-#ifdef HAVE_ARC4RANDOM
-			page[i++] = (unsigned char)arc4random();
-#else
 			page[i++] = (unsigned char)rand();
-#endif
 		return;
 
 	case 1:	/* words */
 		for (i = 0; i < (page_size / 2); ) {
 			page[i++] = 0;
-#ifdef HAVE_ARC4RANDOM
-			page[i++] = (unsigned char)arc4random();
-#else
 			page[i++] = (unsigned char)rand();
-#endif
 		}
 		return;
 
@@ -90,11 +70,7 @@ void generate_random_page(char *page)
 			page[i++] = 0;
 			page[i++] = 0;
 			page[i++] = 0;
-#ifdef HAVE_ARC4RANDOM
-			page[i++] = (unsigned char)arc4random();
-#else
 			page[i++] = (unsigned char)rand();
-#endif
 		}
 		return;
 
@@ -124,13 +100,56 @@ void generate_random_page(char *page)
 			default: break;
 			}
 		}
-#ifdef HAVE_ARC4RANDOM
-		page[arc4random() % page_size] = 0;
-#else
+		page_size = getpagesize();	// Hack for clang 3.3 false positive.
 		page[rand() % page_size] = 0;
-#endif
 		return;
 
+	/* ascii representation of a random number */
+	case 7:
+		switch (rand() % 3) {
+		case 0:
+			switch (rand() % 3) {
+			case 0:	p = sprintf(page_rand, "%lu", (unsigned long) rand64());
+				break;
+			case 1:	p = sprintf(page_rand, "%ld", (unsigned long) rand64());
+				break;
+			case 2:	p = sprintf(page_rand, "%lx", (unsigned long) rand64());
+				break;
+			default: break;
+			}
+			break;
+
+		case 1:
+			switch (rand() % 3) {
+			case 0:	p = sprintf(page_rand, "%u", (unsigned int) rand64());
+				break;
+			case 1:	p = sprintf(page_rand, "%d", (int) rand64());
+				break;
+			case 2:	p = sprintf(page_rand, "%x", (int) rand64());
+				break;
+			default: break;
+			}
+			break;
+
+		case 2:
+			switch (rand() % 3) {
+			case 0:	p = sprintf(page_rand, "%u", (unsigned char) rand64());
+				break;
+			case 1:	p = sprintf(page_rand, "%d", (char) rand64());
+				break;
+			case 2:	p = sprintf(page_rand, "%x", (char) rand64());
+				break;
+			default: break;
+			}
+			break;
+
+		default: break;
+		}
+
+		page_rand[p] = 0;
+
+		break;
+
 	default:
 		BUG("unreachable!\n");
 		return;
diff --git a/random-pathname.c b/random-pathname.c
index 7dc304f..004996b 100644
--- a/random-pathname.c
+++ b/random-pathname.c
@@ -6,7 +6,6 @@
 #include "maps.h"
 #include "random.h"
 #include "sanitise.h"
-#include "config.h"	// arc4random
 
 const char * generate_pathname(void)
 {
@@ -19,13 +18,8 @@ const char * generate_pathname(void)
 		return NULL;
 
 	/* 90% chance of returning an unmangled filename */
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 100) < 90)
-		return pathname;
-#else
 	if ((rand() % 100) < 90)
 		return pathname;
-#endif
 
 	/* Create a bogus filename. */
 	newpath = malloc(page_size);	// FIXME: We leak this.
@@ -35,11 +29,7 @@ const char * generate_pathname(void)
 	len = strlen(pathname);
 
 	/* empty string. */
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 100) == 0) {
-#else
 	if ((rand() % 100) == 0) {
-#endif
 		memset(newpath, 0, page_size);
 		goto out;
 	}
@@ -64,11 +54,7 @@ const char * generate_pathname(void)
 	if (rand_bool()) {
 		for (i = 0; i < len; i++) {
 			if (newpath[i] == '/')
-#ifdef HAVE_ARC4RANDOM
-				newpath[i] = arc4random();
-#else
 				newpath[i] = rand();
-#endif
 		}
 	}
 out:
diff --git a/random.c b/random.c
index d79564a..7def9ff 100644
--- a/random.c
+++ b/random.c
@@ -10,30 +10,15 @@
 #include "random.h"
 #include "sanitise.h"	// interesting_numbers
 #include "types.h"
-#include "config.h"	// arc4random
-
-#if defined(__x86_64__) || defined(__amd64__) || defined(__LP64__)
-#  define __WORDSIZE 64
-#else
-#  define __WORDSIZE 32
-#endif
 
 unsigned int rand_bool(void)
 {
-#ifdef HAVE_ARC4RANDOM
-	return arc4random() % 2;
-#else
 	return rand() % 2;
-#endif
 }
 
 static unsigned int rand_single_bit(unsigned char size)
 {
-#ifdef HAVE_ARC4RANDOM
-	return (1L << (arc4random() % size));
-#else
 	return (1L << (rand() % size));
-#endif
 }
 
 /*
@@ -41,20 +26,12 @@ static unsigned int rand_single_bit(unsigned char size)
  */
 static unsigned long randbits(int limit)
 {
-#ifdef HAVE_ARC4RANDOM
-	unsigned int num = arc4random() % limit / 2;
-#else
 	unsigned int num = rand() % limit / 2;
-#endif
 	unsigned int i;
 	unsigned long r = 0;
 
 	for (i = 0; i < num; i++)
-#ifdef HAVE_ARC4RANDOM
-		r |= (1 << (arc4random() % (limit - 1)));
-#else
 		r |= (1 << (rand() % (limit - 1)));
-#endif
 
 	return r;
 }
@@ -66,48 +43,8 @@ static unsigned long taviso(void)
 {
 	unsigned long r = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 4) {
-	case 0:	r = arc4random() & arc4random();
-#else
 	switch (rand() % 4) {
 	case 0:	r = rand() & rand();
-#endif
-
-#ifdef HAVE_ARC4RANDOM
-#if __WORDSIZE == 64
-		r <<= 32;
-		r |= arc4random() & arc4random();
-#endif
-		break;
-
-	case 1:	r = arc4random() % arc4random();
-#if __WORDSIZE == 64
-		r <<= 32;
-		r |= arc4random() % arc4random();
-#endif
-		break;
-
-	case 2:	r = arc4random() | arc4random();
-#if __WORDSIZE == 64
-		r <<= 32;
-		r |= arc4random() | arc4random();
-#endif
-		break;
-
-	case 3:	r = arc4random();
-#if __WORDSIZE == 64
-		r <<= 32;
-		r |= arc4random();
-#endif
-		break;
-
-	default:
-		break;
-	}
-
-	return r;
-#else
 #if __WORDSIZE == 64
 		r <<= 32;
 		r |= rand() & rand();
@@ -140,7 +77,6 @@ static unsigned long taviso(void)
 	}
 
 	return r;
-#endif /* HAVE_ARC4RANDOM */
 }
 
 /*
@@ -151,13 +87,9 @@ static unsigned long rand8x8(void)
 	unsigned long r = 0UL;
 	unsigned int i;
 
-#ifdef HAVE_ARC4RANDOM
-	for (i = (arc4random() % 7) + 1; i > 0; --i)
-		r = (r << 8) | arc4random() % 256;
-#else
 	for (i = (rand() % 7) + 1; i > 0; --i)
 		r = (r << 8) | rand() % 256;
-#endif
+
 	return r;
 }
 
@@ -170,15 +102,9 @@ static unsigned long rept8(unsigned int num)
 	unsigned int i;
 	unsigned char c;
 
-#ifdef HAVE_ARC4RANDOM
-	c = arc4random() % 256;
-	for (i = arc4random() % (num - 1) ; i > 0; --i)
-		r = (r << 8) | c;
-#else
 	c = rand() % 256;
 	for (i = rand() % (num - 1) ; i > 0; --i)
 		r = (r << 8) | c;
-#endif
 
 	return r;
 }
@@ -191,20 +117,12 @@ static unsigned int __rand32(void)
 {
 	unsigned long r = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 7) {
-#else
 	switch (rand() % 7) {
-#endif
 	case 0: r = rand_single_bit(32);
 		break;
 	case 1:	r = randbits(32);
 		break;
-#ifdef HAVE_ARC4RANDOM
-	case 2: r = arc4random();
-#else
 	case 2: r = rand();
-#endif
 		break;
 	case 3:	r = taviso();
 		break;
@@ -234,11 +152,7 @@ unsigned int rand32(void)
 		unsigned int rounds;
 
 		/* mangle it. */
-#ifdef HAVE_ARC4RANDOM
-		rounds = arc4random() % 3;
-#else
 		rounds = rand() % 3;
-#endif
 		for (i = 0; i < rounds; i++) {
 			switch (rand_bool()) {
 			case 0: r |= __rand32();
@@ -259,12 +173,14 @@ unsigned int rand32(void)
 	if (rand_bool())
 		r |= (1L << 31);
 
+	/* we might get lucky if something is counting ints/longs etc. */
+	if (rand() % 100 < 25) {
+		int _div = 1 << ((rand() % 4) + 1);	/* 2,4,8 or 16 */
+		r /= _div;
+	}
+
 	/* limit the size */
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 4) {
-#else
 	switch (rand() % 4) {
-#endif
 	case 0: r &= 0xff;
 		break;
 	case 1: r &= 0xffff;
@@ -291,11 +207,7 @@ u64 rand64(void)
 
 	} else {
 		/* 33:64-bit ranges. */
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 7) {
-#else
 		switch (rand() % 7) {
-#endif
 		case 0:	r = rand_single_bit(64);
 			break;
 		case 1:	r = randbits(64);
@@ -315,11 +227,7 @@ u64 rand64(void)
 		}
 
 		/* limit the size */
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 4) {
-#else
 		switch (rand() % 4) {
-#endif
 		case 0: r &= 0x000000ffffffffffULL;
 			break;
 		case 1: r &= 0x0000ffffffffffffULL;
@@ -336,25 +244,13 @@ u64 rand64(void)
 		r = ~r;
 
 	/* increase distribution in MSB */
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 10)) {
-#else
 	if ((rand() % 10)) {
-#endif
 		unsigned int i;
 		unsigned int rounds;
 
-#ifdef HAVE_ARC4RANDOM
-		rounds = arc4random() % 4;
-#else
 		rounds = rand() % 4;
-#endif
 		for (i = 0; i < rounds; i++)
-#ifdef HAVE_ARC4RANDOM
-			r |= (1L << ((__WORDSIZE - 1) - (arc4random() % 8)));
-#else
 			r |= (1L << ((__WORDSIZE - 1) - (rand() % 8)));
-#endif
 	}
 
 	/* randomly flip sign bit. */
diff --git a/regenerate.c b/regenerate.c
index 25b6f0d..5041693 100644
--- a/regenerate.c
+++ b/regenerate.c
@@ -1,5 +1,4 @@
 #include <unistd.h>
-#include <sys/socket.h>
 #include "files.h"
 #include "log.h"
 #include "maps.h"
@@ -9,9 +8,6 @@
 #include "shm.h"
 #include "trinity.h"
 
-void regenerate(void);
-static void do_sso_sockets(void);
-
 static void do_sso_sockets(void)
 {
 	struct sockopt so = { 0, 0, 0, 0 };
@@ -19,10 +15,8 @@ static void do_sso_sockets(void)
 	int fd, ret;
 
 	for (i = 0; i < nr_sockets; i++) {
-		fd = shm->socket_fds[i];
-#ifdef __LINUX__
+		fd = shm->sockets[i].fd;
 		do_setsockopt(&so);
-#endif
 		ret = setsockopt(fd, so.level, so.optname, (void *)so.optval, so.optlen);
 		if (ret == 0)
 			output(1, "Setsockopt(%lx %lx %lx %lx) on fd %d\n",
diff --git a/scripts/find.sh b/scripts/find.sh
index 5688854..4c970c1 100755
--- a/scripts/find.sh
+++ b/scripts/find.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/bin/bash
 #
 # This is an example of how to search for an interaction between
 # two syscalls.   In the example below I was chasing an oops in
diff --git a/scripts/load-all-modules.sh b/scripts/load-all-modules.sh
index 6e46964..ba5d6d2 100755
--- a/scripts/load-all-modules.sh
+++ b/scripts/load-all-modules.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/bin/bash
 
 DIR=/lib/modules/`uname -r`
 
diff --git a/scripts/rmmod-all.sh b/scripts/rmmod-all.sh
index eb7ecca..f1e625f 100755
--- a/scripts/rmmod-all.sh
+++ b/scripts/rmmod-all.sh
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 
 for j in `lsmod |awk '{ print $1}' | grep -v caif | grep -v Module`
 do
diff --git a/scripts/test-all-syscalls-parallel.sh b/scripts/test-all-syscalls-parallel.sh
index 9d8d79d..7206364 100755
--- a/scripts/test-all-syscalls-parallel.sh
+++ b/scripts/test-all-syscalls-parallel.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/bin/bash
 
 TRINITY_PATH=${TRINITY_PATH:-.}
 TRINITY_TMP=$(mktemp -d /tmp/trinity.XXXXXX)
diff --git a/scripts/test-all-syscalls-sequentially.sh b/scripts/test-all-syscalls-sequentially.sh
index e025355..14fb4c3 100755
--- a/scripts/test-all-syscalls-sequentially.sh
+++ b/scripts/test-all-syscalls-sequentially.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/bin/bash
 #
 # This is a useful test to run occasionally, to see which syscalls are
 # causing trinity to segfault.
diff --git a/scripts/test-multi.sh b/scripts/test-multi.sh
index 9926554..6b44b1e 100755
--- a/scripts/test-multi.sh
+++ b/scripts/test-multi.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/bin/bash
 
 OLDPATH=$(pwd)
 TRINITY_PATH=${TRINITY_PATH:-$OLDPATH}
diff --git a/scripts/test-vm.sh b/scripts/test-vm.sh
index 7ea1d82..6804c0e 100755
--- a/scripts/test-vm.sh
+++ b/scripts/test-vm.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/bin/bash
 
 TRINITY_PATH=${TRINITY_PATH:-.}
 TRINITY_TMP=$(mktemp -d /tmp/trinity.XXXXXX)
diff --git a/seed.c b/seed.c
index 1097ef3..a9e7458 100644
--- a/seed.c
+++ b/seed.c
@@ -12,7 +12,6 @@
 #include "pids.h"
 #include "log.h"
 #include "random.h"
-#include "config.h"	// arc4random
 
 /* The actual seed lives in the shm. This variable is used
  * to store what gets passed in from the command line -s argument */
@@ -34,11 +33,7 @@ unsigned int new_seed(void)
 
 	if ((fd = open("/dev/urandom", O_RDONLY)) < 0 ||
 	    read(fd, &r, sizeof(r)) != sizeof(r)) {
-#ifdef HAVE_ARC4RANDOM
-		r = arc4random();
-#else
 		r = rand();
-#endif
 		if (!(rand_bool())) {
 			gettimeofday(&t, 0);
 			r |= t.tv_usec;
@@ -74,11 +69,7 @@ unsigned int init_seed(unsigned int seedparam)
  */
 void set_seed(unsigned int pidslot)
 {
-#ifdef HAVE_ARC4RANDOM
-	arc4random_uniform(shm->seed + (pidslot + 1));
-#else
 	srand(shm->seed + (pidslot + 1));
-#endif
 	shm->seeds[pidslot] = shm->seed;
 }
 
@@ -94,7 +85,7 @@ void reseed(void)
 	shm->need_reseed = FALSE;
 	shm->reseed_counter = 0;
 
-	if (getpid() != mainpid) {
+	if (getpid() != shm->mainpid) {
 		outputerr("Reseeding should only happen from parent!\n");
 		exit(EXIT_FAILURE);
 	}
diff --git a/signals.c b/signals.c
index 6021b10..94c690b 100644
--- a/signals.c
+++ b/signals.c
@@ -78,10 +78,8 @@ void mask_signals_child(void)
 	(void)signal(SIGPIPE, SIG_IGN);
 
 	/* Ignore the RT signals. */
-#ifdef __LINUX__
 	for (i = SIGRTMIN; i <= SIGRTMAX; i++)
 		(void)signal(i, SIG_IGN);
-#endif /* __LINUX__ */
 
 	/* If we are in debug mode, we want segfaults and core dumps */
 	if (debug == TRUE)
diff --git a/sockets.c b/sockets.c
index e016321..a4a0a48 100644
--- a/sockets.c
+++ b/sockets.c
@@ -13,9 +13,9 @@
 #include "shm.h"
 #include "net.h"
 #include "log.h"
-#include "params.h"	// victim_path, verbose, do_specific_proto
+#include "params.h"	// verbose, do_specific_proto
 #include "random.h"
-#include "config.h"	// arc4random
+#include "protocols.h"
 
 unsigned int nr_sockets = 0;
 
@@ -26,25 +26,37 @@ static const char *cachefilename="trinity.socketcache";
 
 static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
 {
-	int fd;
+	int fd, ret;
 	struct sockaddr sa;
 	socklen_t salen;
+	struct sockopt so = { 0, 0, 0, 0 };
 
 	fd = socket(domain, type, protocol);
 	if (fd == -1)
 		return fd;
 
-	shm->socket_fds[nr_sockets] = fd;
+	shm->sockets[nr_sockets].fd = fd;
+	shm->sockets[nr_sockets].triplet.family = domain;
+	shm->sockets[nr_sockets].triplet.type = type;
+	shm->sockets[nr_sockets].triplet.protocol = protocol;
 
-	//output(2, "fd[%i] = domain:%i (%s) type:0x%x protocol:%i\n",
-	//	fd, domain, get_proto_name(domain), type, protocol);
+	output(2, "fd[%i] = domain:%i (%s) type:0x%x protocol:%i\n",
+		fd, domain, get_proto_name(domain), type, protocol);
 
 	nr_sockets++;
 
+	/* Set some random socket options. */
+retry_sso:
+	do_setsockopt(&so);
+	ret = setsockopt(fd, so.level, so.optname, (void *)so.optval, so.optlen);
+	if (ret == 0)
+		output(1, "Setsockopt(%lx %lx %lx %lx) on fd %d\n",
+			so.level, so.optname, so.optval, so.optlen, fd);
+	else
+		goto retry_sso;
+
 	/* Sometimes, listen on created sockets. */
 	if (rand_bool()) {
-		__unused__ int ret;
-
 		/* fake a sockaddr. */
 		generate_sockaddr((unsigned long *) &sa, (unsigned long *) &salen, domain);
 
@@ -54,11 +66,7 @@ static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 		else
 			debugf("bind: success!\n");
 */
-#ifdef HAVE_ARC4RANDOM
-		ret = listen(fd, (arc4random() % 2) + 1);
-#else
 		ret = listen(fd, (rand() % 2) + 1);
-#endif
 /*		if (ret == -1)
 			debugf("listen: %s\n", strerror(errno));
 		else
@@ -128,6 +136,19 @@ static void generate_sockets(void)
 
 	lock_cachefile(cachefile, F_WRLCK);
 
+	/*
+	 * Don't loop forever if all protos all are disabled.
+	 */
+	if (!do_specific_proto) {
+		for (n = 0; n < (int)ARRAY_SIZE(no_protos); n++) {
+			if (!no_protos[n])
+				break;
+		}
+
+		if (n >= (int)ARRAY_SIZE(no_protos))
+			nr_to_create = 0;
+	}
+
 	while (nr_to_create > 0) {
 
 		struct socket_triplet st;
@@ -145,6 +166,10 @@ static void generate_sockets(void)
 			if (get_proto_name(st.family) == NULL)
 				goto skip;
 
+			BUG_ON(st.family >= ARRAY_SIZE(no_protos));
+			if (no_protos[st.family])
+				goto skip;
+
 			if (sanitise_socket_triplet(&st) == -1)
 				rand_proto_type(&st);
 
@@ -186,17 +211,40 @@ done:
 }
 
 
-static void close_sockets(void)
+void close_sockets(void)
 {
 	unsigned int i;
 	int fd;
+	int r = 0;
+	struct linger ling = { .l_onoff = FALSE, };
 
 	for (i = 0; i < nr_sockets; i++) {
-		fd = shm->socket_fds[i];
-		shm->socket_fds[i] = 0;
-		if (close(fd) != 0) {
-			output(1, "failed to close socket.(%s)\n", strerror(errno));
-		}
+
+		//FIXME: This is a workaround for a weird bug where we hang forevre
+		// waiting for bluetooth sockets when we setsockopt.
+		// Hopefully at some point we can remove this when someone figures out what's going on.
+		if (shm->sockets[i].triplet.family == PF_BLUETOOTH)
+			continue;
+
+		/* Grab an fd, and nuke it before someone else uses it. */
+		fd = shm->sockets[i].fd;
+		shm->sockets[i].fd = 0;
+
+		/* disable linger */
+		r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
+		if (r)
+			perror("setsockopt");
+
+		r = shutdown(fd, SHUT_RDWR);
+		if (r)
+			perror("shutdown");
+
+		if (close(fd) != 0)
+			output(1, "failed to close socket [%d:%d:%d].(%s)\n",
+				shm->sockets[i].triplet.family,
+				shm->sockets[i].triplet.type,
+				shm->sockets[i].triplet.protocol,
+				strerror(errno));
 	}
 
 	nr_sockets = 0;
@@ -210,10 +258,6 @@ void open_sockets(void)
 	int bytesread=-1;
 	int fd;
 
-	/* If we have victim files, don't worry about sockets. */
-	if (victim_path != NULL)
-		return;
-
 	cachefile = open(cachefilename, O_RDONLY);
 	if (cachefile < 0) {
 		output(1, "Couldn't find socket cachefile. Regenerating.\n");
@@ -232,16 +276,17 @@ void open_sockets(void)
 		type = buffer[1];
 		protocol = buffer[2];
 
-		if (do_specific_proto == TRUE) {
-			if (domain != specific_proto) {
-				output(1, "ignoring socket cachefile due to specific protocol request, and stale data in cachefile.\n");
+		if ((do_specific_proto == TRUE && domain != specific_proto) ||
+		    (domain < ARRAY_SIZE(no_protos) && no_protos[domain] == TRUE)) {
+			output(1, "ignoring socket cachefile due to specific "
+			       "protocol request (or protocol disabled), "
+			       "and stale data in cachefile.\n");
 regenerate:
 				unlock_cachefile(cachefile);	/* drop the reader lock. */
 				close(cachefile);
 				unlink(cachefilename);
 				generate_sockets();
 				return;
-			}
 		}
 
 		fd = open_socket(domain, type, protocol);
@@ -268,3 +313,4 @@ regenerate:
 	unlock_cachefile(cachefile);
 	close(cachefile);
 }
+
diff --git a/syscall.c b/syscall.c
index 03126b8..4b5a8e8 100644
--- a/syscall.c
+++ b/syscall.c
@@ -34,62 +34,43 @@
 	return (type) (res); \
 } while (0)
 
-long syscall32(int num_args, unsigned int call,
+#ifdef ARCH_IS_BIARCH
+/*
+ * This routine does 32 bit syscalls on 64 bit kernel.
+ * 32-on-32 will just use syscall() directly from do_syscall() because shm->do32bit is biarch only.
+ */
+long syscall32(unsigned int call,
 	unsigned long a1, unsigned long a2, unsigned long a3,
 	unsigned long a4, unsigned long a5, unsigned long a6)
 {
-#if defined(__i386__) || defined (__x86_64__)
-
-	if (num_args <= 6) {
-		long __res;
-#if defined( __i386__)
-		__asm__ volatile (
-			"pushl %%ebp\n\t"
-			"movl %7, %%ebp\n\t"
-			"int $0x80\n\t"
-			"popl %%ebp\n\t"
-			: "=a" (__res)
-			: "0" (call),"b" ((long)(a1)),"c" ((long)(a2)),"d" ((long)(a3)), "S" ((long)(a4)),"D" ((long)(a5)), "g" ((long)(a6))
-			: "%ebp" /* mark EBP reg as dirty */
-			);
-#elif defined(__x86_64__)
-		__asm__ volatile (
-			"pushq %%rbp\n\t"
-			"movq %7, %%rbp\n\t"
-			"int $0x80\n\t"
-			"popq %%rbp\n\t"
-			: "=a" (__res)
-			: "0" (call),"b" ((long)(a1)),"c" ((long)(a2)),"d" ((long)(a3)), "S" ((long)(a4)),"D" ((long)(a5)), "g" ((long)(a6))
-			: "%rbp" /* mark EBP reg as dirty */
-			);
-#else
-	//To shut up gcc on unused args. This code should never be reached.
-	__res = 0;
-	UNUSED(num_args);
-	UNUSED(call);
-	UNUSED(a1);
-	UNUSED(a2);
-	UNUSED(a3);
-	UNUSED(a4);
-	UNUSED(a5);
-	UNUSED(a6);
-#endif
-		__syscall_return(long,__res);
-	}
+	long __res = 0;
+
+//FIXME: Move the implementations out to arch header files.
+
+#if defined(__x86_64__)
+	__asm__ volatile (
+		"pushq %%rbp\n\t"
+		"pushq %%r10\n\t"
+		"movq %7, %%rbp\n\t"
+		"int $0x80\n\t"
+		"popq %%r10\n\t"
+		"popq %%rbp\n\t"
+		: "=a" (__res)
+		: "0" (call),"b" ((long)(a1)),"c" ((long)(a2)),"d" ((long)(a3)), "S" ((long)(a4)),"D" ((long)(a5)), "g" ((long)(a6))
+		: "%rbp" /* mark EBP reg as dirty */
+	);
+	__syscall_return(long, __res);
+
 #else
+	/* non-x86 implementations go here. */
+	#error Implement 32-on-64 syscall in syscall.c:syscall32() for this architecture.
 
-// TODO: 32-bit syscall entry for non-x86 archs goes here.
-	UNUSED(num_args);
-	UNUSED(call);
-	UNUSED(a1);
-	UNUSED(a2);
-	UNUSED(a3);
-	UNUSED(a4);
-	UNUSED(a5);
-	UNUSED(a6);
 #endif
-	return 0;
+	return __res;
 }
+#else
+#define syscall32(a,b,c,d,e,f,g) 0
+#endif /* ARCH_IS_BIARCH */
 
 static void check_uid(uid_t olduid)
 {
@@ -112,7 +93,6 @@ static void check_uid(uid_t olduid)
 static unsigned long do_syscall(int childno, int *errno_saved)
 {
 	int nr = shm->syscallno[childno];
-	unsigned int num_args = syscalls[nr].entry->num_args;
 	unsigned long a1, a2, a3, a4, a5, a6;
 	unsigned long ret = 0;
 	int pidslot;
@@ -139,7 +119,7 @@ static unsigned long do_syscall(int childno, int *errno_saved)
 	if (shm->do32bit[childno] == FALSE)
 		ret = syscall(nr, a1, a2, a3, a4, a5, a6);
 	else
-		ret = syscall32(num_args, nr, a1, a2, a3, a4, a5, a6);
+		ret = syscall32(nr, a1, a2, a3, a4, a5, a6);
 
 	*errno_saved = errno;
 
diff --git a/syscalls/epoll_create.c b/syscalls/epoll_create.c
index 530c7fb..fc004a8 100644
--- a/syscalls/epoll_create.c
+++ b/syscalls/epoll_create.c
@@ -4,7 +4,6 @@
  * On success, returns a nonnegative file descriptor.
  * On error, -1 is returned, and errno is set to indicate the error.
  */
-#ifdef USE_EPOLL
 #include "sanitise.h"
 
 struct syscall syscall_epoll_create = {
@@ -14,4 +13,3 @@ struct syscall syscall_epoll_create = {
 	.arg1type = ARG_LEN,
 	.rettype = RET_FD,
 };
-#endif
diff --git a/syscalls/epoll_create1.c b/syscalls/epoll_create1.c
index 77a4d38..d6cfa6e 100644
--- a/syscalls/epoll_create1.c
+++ b/syscalls/epoll_create1.c
@@ -9,7 +9,6 @@
 
 #include "sanitise.h"
 
-#ifdef USE_EPOLL
 struct syscall syscall_epoll_create1 = {
 	.name = "epoll_create1",
 	.num_args = 1,
@@ -21,4 +20,3 @@ struct syscall syscall_epoll_create1 = {
 	},
 	.rettype = RET_FD,
 };
-#endif
diff --git a/syscalls/epoll_ctl.c b/syscalls/epoll_ctl.c
index d8f1c0a..e364f87 100644
--- a/syscalls/epoll_ctl.c
+++ b/syscalls/epoll_ctl.c
@@ -4,7 +4,6 @@
  * When successful, epoll_ctl() returns zero.
  * When an error occurs, epoll_ctl() returns -1 and errno is set appropriately.
  */
-#ifdef USE_EPOLL
 #include <sys/epoll.h>
 #include "sanitise.h"
 
@@ -26,4 +25,3 @@ struct syscall syscall_epoll_ctl = {
 	.rettype = RET_ZERO_SUCCESS,
 	.flags = NEED_ALARM,
 };
-#endif
diff --git a/syscalls/epoll_pwait.c b/syscalls/epoll_pwait.c
index 4de5830..2e6fdf6 100644
--- a/syscalls/epoll_pwait.c
+++ b/syscalls/epoll_pwait.c
@@ -6,8 +6,6 @@
  * or zero if no file descriptor became ready during the requested timeout milliseconds.
  * When an error occurs, returns -1 and errno is set appropriately.
  */
-
-#ifdef USE_EPOLL
 #include "sanitise.h"
 
 struct syscall syscall_epoll_pwait = {
@@ -22,4 +20,3 @@ struct syscall syscall_epoll_pwait = {
 	.rettype = RET_BORING,
 	.flags = NEED_ALARM,
 };
-#endif
diff --git a/syscalls/epoll_wait.c b/syscalls/epoll_wait.c
index 90cbd9a..c2ae9a2 100644
--- a/syscalls/epoll_wait.c
+++ b/syscalls/epoll_wait.c
@@ -5,7 +5,6 @@
  * or zero if no file descriptor became ready during the requested timeout milliseconds.
  * When an error occurs, returns -1 and errno is set appropriately.
  */
-#ifdef USE_EPOLL
 #include "sanitise.h"
 
 struct syscall syscall_epoll_wait = {
@@ -20,4 +19,3 @@ struct syscall syscall_epoll_wait = {
 	.rettype = RET_BORING,
 	.flags = NEED_ALARM,
 };
-#endif
diff --git a/syscalls/execve.c b/syscalls/execve.c
index 4f1d240..05f1368 100644
--- a/syscalls/execve.c
+++ b/syscalls/execve.c
@@ -21,11 +21,7 @@ static unsigned long ** gen_ptrs_to_crap(void)
 {
 	void **ptr;
 	unsigned int i;
-#ifdef HAVE_ARC4RANDOM
-	unsigned int count = arc4random() % 32;
-#else
 	unsigned int count = rand() % 32;
-#endif
 
 	/* Fabricate argv */
 	ptr = malloc(count * sizeof(void *));	// FIXME: LEAK
diff --git a/syscalls/fanotify_mark.c b/syscalls/fanotify_mark.c
index 52ec1b6..3d63bb3 100644
--- a/syscalls/fanotify_mark.c
+++ b/syscalls/fanotify_mark.c
@@ -38,11 +38,7 @@ static void sanitise_fanotify_mark(int childno)
 				    FAN_MARK_IGNORED_MASK, FAN_MARK_IGNORED_SURV_MODIFY };
 
 	unsigned int i;
-#ifdef HAVE_ARC4RANDOM
-	unsigned int numflags = arc4random() % 5;
-#else
 	unsigned int numflags = rand() % 5;
-#endif
 
 	// set additional flags
 	for (i = 0; i < numflags; i++)
diff --git a/syscalls/fcntl.c b/syscalls/fcntl.c
index 59fba4f..6eee22b 100644
--- a/syscalls/fcntl.c
+++ b/syscalls/fcntl.c
@@ -24,11 +24,9 @@
 #include "shm.h"
 #include "compat.h"
 
-#ifdef __LINUX__
 #if F_GETLK64 != F_GETLK
 #define HAVE_LK64
 #endif
-#endif
 
 static void sanitise_fcntl(int childno)
 {
@@ -36,21 +34,17 @@ static void sanitise_fcntl(int childno)
 	/* arg = fd */
 	case F_DUPFD:
 	case F_DUPFD_CLOEXEC:
-#ifdef __LINUX__
 	case F_SETLEASE:
 		shm->a3[childno] = (unsigned long) get_random_fd();
 		break;
 		break;
-#endif /* __LINUX__ */
 
 	/* no arg */
 	case F_GETFD:
 	case F_GETFL:
 	case F_GETOWN:
-#ifdef __LINUX__
 	case F_GETSIG:
 	case F_GETLEASE:
-#endif
 	case F_GETPIPE_SZ:
 		break;
 
@@ -64,12 +58,10 @@ static void sanitise_fcntl(int childno)
 			shm->a3[childno] |= O_APPEND;
 		if (rand_bool())
 			shm->a3[childno] |= O_ASYNC;
-#ifdef __LINUX__
 		if (rand_bool())
 			shm->a3[childno] |= O_DIRECT;
 		if (rand_bool())
 			shm->a3[childno] |= O_NOATIME;
-#endif
 		if (rand_bool())
 			shm->a3[childno] |= O_NONBLOCK;
 		break;
@@ -80,14 +72,12 @@ static void sanitise_fcntl(int childno)
 	case F_SETLKW:
 		break;
 #ifdef HAVE_LK64
-#ifdef __LINUX__
 	case F_GETLK64:
 		break;
 	case F_SETLK64:
 		break;
 	case F_SETLKW64:
 		break;
-#endif
 #endif
 
 	case F_SETOWN:
@@ -99,7 +89,6 @@ static void sanitise_fcntl(int childno)
 	case F_SETOWN_EX:
 		break;
 
-#ifdef __LINUX__
 	case F_SETSIG:
 		shm->a3[childno] = (unsigned long) rand32();
 		if (shm->a3[childno] == SIGINT)
@@ -121,7 +110,6 @@ static void sanitise_fcntl(int childno)
 		if (rand_bool())
 			shm->a3[childno] |= DN_ATTRIB;
 		break;
-#endif
 
 	case F_SETPIPE_SZ:
 		shm->a3[childno] = rand32();
@@ -146,17 +134,12 @@ struct syscall syscall_fcntl = {
 #else
 		.num = 23,
 #endif
-#ifdef __LINUX__
 		.values = { F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK,
 		  F_SETLKW, F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, F_SETSIG, F_GETLEASE,
 		  F_SETLEASE, F_NOTIFY, F_SETPIPE_SZ, F_GETPIPE_SZ,
 #ifdef HAVE_LK64
 		  F_GETLK64, F_SETLK64, F_SETLKW64,
 #endif
-#endif /* __LINUX__ */
-		.values = { F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK,
-		  F_SETLKW, F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX,
-		  F_SETPIPE_SZ, F_GETPIPE_SZ,
 		},
 	},
 	.arg3name = "arg",
@@ -165,6 +148,3 @@ struct syscall syscall_fcntl = {
 	.group = GROUP_VFS,
 	.sanitise = sanitise_fcntl,
 };
-
-
-//O_DIRECT O_NOATIME DN_ACCESS DN_MODIFY DN_CREATE DN_DELETE DN_RENAME DN_ATTRIB
diff --git a/syscalls/getrlimit.c b/syscalls/getrlimit.c
index c1c9fc2..3c91d4e 100644
--- a/syscalls/getrlimit.c
+++ b/syscalls/getrlimit.c
@@ -4,9 +4,9 @@
 #include <stdlib.h>
 #include <sys/time.h>
 #include <sys/resource.h>
-#include "compat.h"
 #include "sanitise.h"
 #include "shm.h"
+#include "compat.h"
 
 struct syscall syscall_getrlimit = {
 	.name = "getrlimit",
@@ -16,29 +16,21 @@ struct syscall syscall_getrlimit = {
 	.arg1list = {
 		.num = 16,
 		.values = {
-#ifdef __LINUX__
 			RLIMIT_AS,
-#endif /* __LINUX__ */
 			RLIMIT_CORE,
 			RLIMIT_CPU,
 			RLIMIT_DATA,
 			RLIMIT_FSIZE,
-#ifdef __LINUX__
 			RLIMIT_LOCKS,
-#endif /* __LINUX__ */
 			RLIMIT_MEMLOCK,
-#ifdef __LINUX__
 			RLIMIT_MSGQUEUE,
 			RLIMIT_NICE,
-#endif /* __LINUX__ */
 			RLIMIT_NOFILE,
 			RLIMIT_NPROC,
 			RLIMIT_RSS,
-#ifdef __LINUX__
 			RLIMIT_RTPRIO,
 			RLIMIT_RTTIME,
 			RLIMIT_SIGPENDING,
-#endif /* __LINUX__ */
 			RLIMIT_STACK,
 		},
 	},
diff --git a/syscalls/ioctl.c b/syscalls/ioctl.c
index 0ca6d01..aa5148c 100644
--- a/syscalls/ioctl.c
+++ b/syscalls/ioctl.c
@@ -1,8 +1,6 @@
 /*
  * SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
  */
-
-#ifdef __LINUX__
 #include <stdlib.h>
 #include <linux/ioctl.h>
 #include <linux/major.h>
@@ -17,21 +15,12 @@ static void ioctl_mangle_cmd(int childno)
 	unsigned int i;
 
 	/* mangle the cmd by ORing up to 4 random bits */
-#ifdef HAVE_ARC4RANDOM
-	for (i=0; i < (unsigned int)(arc4random() % 4); i++)
-		shm->a2[childno] |= 1L << (arc4random() % 32);
-
-	/* mangle the cmd by ANDing up to 4 random bits */
-	for (i=0; i < (unsigned int)(arc4random() % 4); i++)
-		shm->a2[childno] &= 1L << (arc4random() % 32);
-#else
 	for (i=0; i < (unsigned int)(rand() % 4); i++)
 		shm->a2[childno] |= 1L << (rand() % 32);
 
 	/* mangle the cmd by ANDing up to 4 random bits */
 	for (i=0; i < (unsigned int)(rand() % 4); i++)
 		shm->a2[childno] &= 1L << (rand() % 32);
-#endif
 }
 
 static void ioctl_mangle_arg(int childno)
@@ -50,13 +39,8 @@ static void ioctl_mangle_arg(int childno)
 
 static void generic_sanitise_ioctl(int childno)
 {
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 50)==0)
-		ioctl_mangle_cmd(childno);
-#else
 	if ((rand() % 50)==0)
 		ioctl_mangle_cmd(childno);
-#endif
 
 	ioctl_mangle_arg(childno);
 }
@@ -65,11 +49,7 @@ static void sanitise_ioctl(int childno)
 {
 	const struct ioctl_group *grp;
 
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 100 == 0)
-#else
 	if (rand() % 100 == 0)
-#endif
 		grp = get_random_ioctl_group();
 	else
 		grp = find_ioctl_group(shm->a1[childno]);
@@ -79,11 +59,7 @@ static void sanitise_ioctl(int childno)
 
 		grp->sanitise(grp, childno);
 
-#ifdef HAVE_ARC4RANDOM
-		if (arc4random() % 100 == 0)
-#else
 		if (rand() % 100 == 0)
-#endif
 			ioctl_mangle_cmd(childno);
 	} else
 		generic_sanitise_ioctl(childno);
@@ -100,4 +76,3 @@ struct syscall syscall_ioctl = {
 	.sanitise = sanitise_ioctl,
 	.flags = NEED_ALARM,
 };
-#endif /* __LINUX__ */
diff --git a/syscalls/linkat.c b/syscalls/linkat.c
index 5ad3877..3487bdc 100644
--- a/syscalls/linkat.c
+++ b/syscalls/linkat.c
@@ -4,22 +4,16 @@
  */
 #include <fcntl.h>
 #include <stdlib.h>
-#include "compat.h"
 #include "shm.h"
 #include "sanitise.h"
-#include "config.h"	// arc4random
+#include "compat.h"
 
 static void sanitise_linkat(int childno)
 {
 	/* .. If oldpath is relative and olddirfd is the special value AT_FDCWD, then oldpath is
 	 * interpreted relative to the current working directory of the calling process  */
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 100) == 0)
-		shm->a1[childno] = AT_FDCWD;
-#else
 	if ((rand() % 100) == 0)
 		shm->a1[childno] = AT_FDCWD;
-#endif
 }
 
 struct syscall syscall_linkat = {
@@ -37,12 +31,7 @@ struct syscall syscall_linkat = {
 	.arg5type = ARG_LIST,
 	.arg5list = {
 		.num = 2,
-		.values = {
-				AT_SYMLINK_FOLLOW,
-#ifdef __LINUX__
-				AT_EMPTY_PATH
-#endif /* __LINUX__ */
-			},
+		.values = { AT_SYMLINK_FOLLOW , AT_EMPTY_PATH },
 	},
 	.flags = NEED_ALARM,
 	.group = GROUP_VFS,
diff --git a/syscalls/madvise.c b/syscalls/madvise.c
index 9ccc7e8..bf9d8b9 100644
--- a/syscalls/madvise.c
+++ b/syscalls/madvise.c
@@ -5,19 +5,12 @@
 #include <sys/mman.h>
 #include "arch.h"	// page_size
 #include "sanitise.h"
-#ifdef __LINUX__
-#include "compat.h"
-#endif /* __LINUX__ */
 #include "shm.h"
-#include "config.h"	// arc4random
+#include "compat.h"
 
 static void sanitise_madvise(int childno)
 {
-#ifdef HAVE_ARC4RANDOM
-	shm->a2[childno] = arc4random() % page_size;
-#else
 	shm->a2[childno] = rand() % page_size;
-#endif
 }
 
 struct syscall syscall_madvise = {
@@ -31,26 +24,9 @@ struct syscall syscall_madvise = {
 	.arg3type = ARG_OP,
 	.arg3list = {
 		.num = 12,
-		.values = {
-				MADV_NORMAL,
-				MADV_RANDOM,
-				MADV_SEQUENTIAL,
-				MADV_WILLNEED,
-			    	MADV_DONTNEED,
-#ifdef __LINUX__
-				MADV_REMOVE,
-				MADV_DONTFORK,
-				MADV_DOFORK,
-			    	MADV_MERGEABLE,
-				MADV_UNMERGEABLE,
-				MADV_HUGEPAGE,
-				MADV_NOHUGEPAGE
-#endif /* __LINUX__ */
-#ifdef __BSD__
-				MADV_SPACEAVAIL,
-				MADV_FREE
-#endif /* __BSD__ */
-		},
+		.values = { MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED,
+			    MADV_DONTNEED, MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK,
+			    MADV_MERGEABLE, MADV_UNMERGEABLE, MADV_HUGEPAGE, MADV_NOHUGEPAGE },
 	},
 	.group = GROUP_VM,
 	.sanitise = sanitise_madvise,
diff --git a/syscalls/mmap.c b/syscalls/mmap.c
index c4c738a..3a64fc0 100644
--- a/syscalls/mmap.c
+++ b/syscalls/mmap.c
@@ -4,18 +4,12 @@
 	unsigned long, fd, unsigned long, off)
  */
 #include <stdlib.h>
-#ifdef __LINUX__
 #include <asm/mman.h>
-#endif /* __LINUX__ */
 #include "trinity.h"	// page_size
 #include "sanitise.h"
 #include "shm.h"
 #include "arch.h"
 #include "compat.h"
-#ifdef __BSD__
-#include <sys/types.h>
-#include <sys/mman.h>
-#endif /* __BSD__ */
 
 #ifdef __x86_64__
 #define NUM_FLAGS 13
@@ -29,26 +23,15 @@
 void sanitise_mmap(int childno)
 {
 	unsigned int i;
-#ifdef __LINUX__
 	unsigned int flagvals[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
 			MAP_GROWSDOWN, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_LOCKED,
 			MAP_NORESERVE, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK,
 			MAP_HUGETLB, MAP_UNINITIALIZED,
-#endif /* __LINUX__ */
-	unsigned int flagvals[NUM_FLAGS] = { MAP_FIXED, MAP_ANON,
-			MAP_NORESERVE, MAP_STACK,
-			MAP_HUGETLB, MAP_UNINITIALIZED,
 #ifdef __x86_64__
-#ifdef __LINUX__
 			MAP_32BIT,
-#endif /* __LINUX__ */
 #endif
 	};
-#ifdef HAVE_ARC4RANDOM
-	unsigned int numflags = arc4random() % NUM_FLAGS;
-#else
 	unsigned int numflags = rand() % NUM_FLAGS;
-#endif
 
 	/* Don't actually set a hint right now, in case we give out
 	   something that we don't want changed.  One day, we'll recycle
@@ -64,37 +47,20 @@ void sanitise_mmap(int childno)
 
 	// set additional flags
 	for (i = 0; i < numflags; i++)
-#ifdef HAVE_ARC4RANDOM
-		shm->a4[childno] |= flagvals[arc4random() % NUM_FLAGS];
-#else
 		shm->a4[childno] |= flagvals[rand() % NUM_FLAGS];
-#endif
 
 	/* no fd if anonymous mapping. */
-#ifdef __LINUX__
 	if (shm->a4[childno] & MAP_ANONYMOUS)
-#endif /* __LINUX__ */
-#ifdef __BSD__
-	if (shm->a4[childno] & MAP_ANON)
-#endif
 		shm->a5[childno] = -1;
 
 	/* page align non-anonymous mappings. */
-#ifdef __LINUX__
 	if (shm->a4[childno] & MAP_ANONYMOUS)
 		shm->a6[childno] &= PAGE_MASK;
 	else
 		shm->a6[childno] = 0;
-#endif /* __LINUX__ */
-#ifdef __BSD__
-	if (shm->a4[childno] & MAP_ANON)
-		shm->a6[childno] &= PAGE_MASK;
-	else
-		shm->a6[childno] = 0;
-#endif /* __BSD__ */
+
 }
 
-/*
 struct syscall syscall_mmap = {
 	.name = "mmap",
 	.num_args = 6,
@@ -107,26 +73,13 @@ struct syscall syscall_mmap = {
 	.arg3type = ARG_LIST,
 	.arg3list = {
 		.num = 4,
-		.values = {
-				PROT_READ,
-				PROT_WRITE,
-				PROT_EXEC,
-#ifdef __LINUX__
-				PROT_SEM
-#endif
-#ifdef __BSD__
-				PROT_NONE
-#endif
-			},
+		.values = { PROT_READ, PROT_WRITE, PROT_EXEC, PROT_SEM },
 	},
 	.arg4name = "flags",
 	.arg4type = ARG_OP,
 	.arg4list = {
 		.num = 2,
-		.values = {
-					MAP_SHARED,
-					MAP_PRIVATE
-		},
+		.values = { MAP_SHARED, MAP_PRIVATE },
 	},
 	.arg5name = "fd",
 	.arg5type = ARG_FD,
@@ -135,4 +88,3 @@ struct syscall syscall_mmap = {
 	.group = GROUP_VM,
 	.flags = NEED_ALARM,
 };
-*/
diff --git a/syscalls/mount.c b/syscalls/mount.c
index 2756e18..48302b0 100644
--- a/syscalls/mount.c
+++ b/syscalls/mount.c
@@ -3,13 +3,9 @@
 	 char __user *, type, unsigned long, flags, void __user *, data)
  */
 
-#ifdef __LINUX__
 #include <linux/fs.h>
-#endif /* __LINUX__ */
 #include "sanitise.h"
 #include "compat.h"
-#include <sys/param.h>
-#include <sys/mount.h>
 
 //TODO: fill out 'type' with something random from /proc/filesystems
 
@@ -26,7 +22,6 @@ struct syscall syscall_mount = {
 	.arg4type = ARG_LIST,
 	.arg4list = {
 		.num = 29,
-#ifdef __LINUX__
 		.values = {
 			MS_RDONLY, MS_NOSUID, MS_NODEV, MS_NOEXEC,
 			MS_SYNCHRONOUS, MS_REMOUNT, MS_MANDLOCK, MS_DIRSYNC,
@@ -36,10 +31,6 @@ struct syscall syscall_mount = {
 			MS_RELATIME, MS_KERNMOUNT, MS_I_VERSION, MS_STRICTATIME,
 			MS_SNAP_STABLE, MS_NOSEC, MS_BORN, MS_ACTIVE,
 			MS_NOUSER, },
-#endif /* __LINUX__ */
-		.values = {
-			MNT_RDONLY, MNT_NOSUID, MNT_NODEV, MNT_NOEXEC,
-			MNT_SYNCHRONOUS, MNT_NOATIME, },
 	},
 	.arg5name = "data",
 	.arg5type = ARG_ADDRESS,
diff --git a/syscalls/move_pages.c b/syscalls/move_pages.c
index e1da6d4..705c6c7 100644
--- a/syscalls/move_pages.c
+++ b/syscalls/move_pages.c
@@ -36,11 +36,7 @@ static void sanitise_move_pages(int childno)
 	if (page_alloc == NULL)
 		return;
 
-#ifdef HAVE_ARC4RANDOM
-	count = arc4random() % (page_size / sizeof(void *));
-#else
 	count = rand() % (page_size / sizeof(void *));
-#endif
 	count = max(1, count);
 
 	shm->a2[childno] = count;
@@ -56,11 +52,7 @@ static void sanitise_move_pages(int childno)
 
 	nodes = malloc(count * sizeof(int));
 	for (i = 0; i < count; i++)
-#ifdef HAVE_ARC4RANDOM
-		nodes[i] = (int) arc4random() % 2;
-#else
 		nodes[i] = (int) rand() % 2;
-#endif
 	shm->a4[childno] = (unsigned long) nodes;
 
 	shm->a5[childno] = (unsigned long) malloc(count * sizeof(int));
diff --git a/syscalls/mprotect.c b/syscalls/mprotect.c
index 40e6989..66fb712 100644
--- a/syscalls/mprotect.c
+++ b/syscalls/mprotect.c
@@ -1,13 +1,7 @@
 /*
  * sys_mprotect(unsigned long start, size_t len, unsigned long prot)
  */
-#include "config.h"
-#ifdef __LINUX__
 #include <asm/mman.h>
-#endif
-#ifdef __BSD__
-#include <sys/mman.h>
-#endif
 #include "trinity.h"	// page_size
 #include "arch.h"
 #include "random.h"
@@ -46,17 +40,7 @@ struct syscall syscall_mprotect = {
 	.arg3type = ARG_LIST,
 	.arg3list = {
 		.num = 6,
-		.values = {
-				PROT_READ,
-				PROT_WRITE,
-				PROT_EXEC,
-#ifdef __LINUX__
-				PROT_NONE,
-				PROT_SEM,
-				PROT_GROWSDOWN,
-				PROT_GROWSUP
-#endif
-		},
+		.values = { PROT_READ, PROT_WRITE, PROT_EXEC, PROT_SEM, PROT_GROWSDOWN, PROT_GROWSUP },
 	},
 	.sanitise = sanitise_mprotect,
 	.group = GROUP_VM,
diff --git a/syscalls/msgctl.c b/syscalls/msgctl.c
index b8a8dd4..4bf543a 100644
--- a/syscalls/msgctl.c
+++ b/syscalls/msgctl.c
@@ -14,17 +14,8 @@ struct syscall syscall_msgctl = {
 	.arg2type = ARG_OP,
 	.arg2list = {
 		.num = 6,
-		.values = {
-				IPC_STAT,
-				IPC_SET,
-				IPC_RMID,
-#ifdef __LINUX__
-				IPC_INFO,
-			    MSG_INFO,
-				MSG_STAT
-#endif
-
-		},
+		.values = { IPC_STAT, IPC_SET, IPC_RMID, IPC_INFO,
+			    MSG_INFO, MSG_STAT },
 	},
 	.arg3name = "buf",
 	.arg3type = ARG_ADDRESS,
diff --git a/syscalls/msgrcv.c b/syscalls/msgrcv.c
index 87e5ebf..5585b99 100644
--- a/syscalls/msgrcv.c
+++ b/syscalls/msgrcv.c
@@ -1,16 +1,11 @@
 /*
  * SYSCALL_DEFINE5(msgrcv, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz, long, msgtyp, int, msgflg)
  */
-#ifdef __LINUX__
+#include <sys/types.h>
 #include <linux/msg.h>
-#endif /* __LINUX__ */
 #include "compat.h"
 #include "sanitise.h"
 
-#include <sys/types.h>
-#include <sys/ipc.h>
-#include <sys/msg.h>
-
 struct syscall syscall_msgrcv = {
 	.name = "msgrcv",
 	.num_args = 5,
@@ -24,9 +19,6 @@ struct syscall syscall_msgrcv = {
 	.arg5type = ARG_LIST,
 	.arg5list = {
 		.num = 4,
-#ifdef __LINUX__
 		.values = { MSG_NOERROR, MSG_EXCEPT, MSG_COPY, IPC_NOWAIT },
-#endif /* __LINUX__ */
-		.values = { MSG_NOERROR, MSG_COPY, IPC_NOWAIT },
 	},
 };
diff --git a/syscalls/msgsnd.c b/syscalls/msgsnd.c
index 00e7b2c..9eaf3d6 100644
--- a/syscalls/msgsnd.c
+++ b/syscalls/msgsnd.c
@@ -1,16 +1,11 @@
 /*
  * SYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz, int, msgflg)
  */
-#ifdef __LINUX__
+#include <sys/types.h>
 #include <linux/msg.h>
-#endif
 #include "compat.h"
 #include "sanitise.h"
 
-#include <sys/types.h>
-#include <sys/ipc.h>
-#include <sys/msg.h>
-
 struct syscall syscall_msgsnd = {
 	.name = "msgsnd",
 	.num_args = 4,
@@ -23,9 +18,6 @@ struct syscall syscall_msgsnd = {
 	.arg4type = ARG_LIST,
 	.arg4list = {
 		.num = 4,
-#ifdef __LINUX__
 		.values = { MSG_NOERROR, MSG_EXCEPT, MSG_COPY, IPC_NOWAIT },
-#endif
-		.values = { MSG_NOERROR, MSG_COPY, IPC_NOWAIT },
 	},
 };
diff --git a/syscalls/name_to_handle_at.c b/syscalls/name_to_handle_at.c
index fa88841..3e67143 100644
--- a/syscalls/name_to_handle_at.c
+++ b/syscalls/name_to_handle_at.c
@@ -3,7 +3,6 @@
  *	struct file_handle __user *, handle, int __user *, mnt_id,
  *	int, flag)
  */
-
 #include <fcntl.h>
 #include "sanitise.h"
 #include "compat.h"
diff --git a/syscalls/open.c b/syscalls/open.c
index e81b695..a485e43 100644
--- a/syscalls/open.c
+++ b/syscalls/open.c
@@ -5,9 +5,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include "sanitise.h"
-#ifdef __LINUX__
 #include "compat.h"
-#endif
 
 struct syscall syscall_open = {
 	.name = "open",
@@ -18,7 +16,6 @@ struct syscall syscall_open = {
 	.arg2type = ARG_LIST,
 	.arg2list = {
 		.num = 20,
-#ifdef __LINUX__
 		.values = { O_RDONLY, O_WRONLY, O_RDWR,
 				O_CREAT, O_EXCL, O_NOCTTY,
 				O_TRUNC, O_APPEND, O_NONBLOCK,
@@ -26,13 +23,6 @@ struct syscall syscall_open = {
 				O_DIRECTORY, O_NOFOLLOW, O_CLOEXEC,
 				O_DIRECT, O_NOATIME, O_PATH,
 				O_DSYNC, O_LARGEFILE, O_TMPFILE },
-#endif
-		.values = { O_RDONLY, O_WRONLY, O_RDWR,
-				O_CREAT, O_EXCL, O_NOCTTY,
-				O_TRUNC, O_APPEND, O_NONBLOCK,
-				O_SYNC, O_ASYNC,
-				O_DIRECTORY, O_NOFOLLOW, O_CLOEXEC,
-				O_DSYNC },
 	},
 	.arg3name = "mode",
 	.arg3type = ARG_MODE_T,
diff --git a/syscalls/openat.c b/syscalls/openat.c
index 9efd230..cf2941b 100644
--- a/syscalls/openat.c
+++ b/syscalls/openat.c
@@ -16,7 +16,6 @@ struct syscall syscall_openat = {
 	.arg3type = ARG_LIST,
 	.arg3list = {
 		.num = 20,
-#ifdef __LINUX__
 		.values = { O_RDONLY, O_WRONLY, O_RDWR,
 				O_CREAT, O_EXCL, O_NOCTTY,
 				O_TRUNC, O_APPEND, O_NONBLOCK,
@@ -24,13 +23,6 @@ struct syscall syscall_openat = {
 				O_DIRECTORY, O_NOFOLLOW, O_CLOEXEC,
 				O_DIRECT, O_NOATIME, O_PATH,
 				O_DSYNC, O_LARGEFILE, O_TMPFILE },
-#endif
-		.values = { O_RDONLY, O_WRONLY, O_RDWR,
-				O_CREAT, O_EXCL, O_NOCTTY,
-				O_TRUNC, O_APPEND, O_NONBLOCK,
-				O_SYNC, O_ASYNC,
-				O_DIRECTORY, O_NOFOLLOW, O_CLOEXEC,
-				O_PATH, O_DSYNC, O_TMPFILE },
 	},
 	.arg4name = "mode",
 	.arg4type = ARG_MODE_T,
diff --git a/syscalls/perf_event_open.c b/syscalls/perf_event_open.c
index c6bbd14..516172a 100644
--- a/syscalls/perf_event_open.c
+++ b/syscalls/perf_event_open.c
@@ -6,16 +6,17 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 #include <sys/types.h>
 #include <dirent.h>
 #include <errno.h>
 #include "perf_event.h"
 #include "random.h"
 #include "sanitise.h"
-#include "compat.h"
 #include "maps.h"
 #include "shm.h"
 #include "log.h"
+#include "compat.h"
 
 #define SYSFS "/sys/bus/event_source/devices/"
 
@@ -476,29 +477,17 @@ static long long random_sysfs_config(__u32 *type,
 		return rand64();
 	}
 
-#ifdef HAVE_ARC4RANDOM
-	i = arc4random()%num_pmus;
-#else
-	i = rand()%num_pmus;
-#endif
+	i=rand()%num_pmus;
 
 	*type=pmus[i].type;
 
-#ifdef HAVE_ARC4RANDOM
-	switch(arc4random()%3) {
-#else
 	switch(rand()%3) {
-#endif
 		/* Random by Format */
 		case 0:
 			if (pmus[i].num_formats==0) goto out;
 			for(j=0;j<pmus[i].num_formats;j++) {
 				/* 50% chance of having field set */
-#ifdef HAVE_ARC4RANDOM
-				if (arc4random()%2) {
-#else
 				if (rand()%2) {
-#endif
 					if (pmus[i].formats[j].field==FIELD_CONFIG) {
 						c|=(rand64()&pmus[i].formats[j].mask);
 					} else if (pmus[i].formats[j].field==FIELD_CONFIG1) {
@@ -514,11 +503,7 @@ static long long random_sysfs_config(__u32 *type,
 		/* Random by generic event */
 		case 1:
 			if (pmus[i].num_generic_events==0) goto out;
-#ifdef HAVE_ARC4RANDOM
-			j=arc4random()%pmus[i].num_generic_events;
-#else
 			j=rand()%pmus[i].num_generic_events;
-#endif
 			c=pmus[i].generic_events[j].config;
 			c1=pmus[i].generic_events[j].config1;
 			c2=pmus[i].generic_events[j].config2;
@@ -536,13 +521,8 @@ static long long random_sysfs_config(__u32 *type,
 	*config2=c2;
 	return c;
 out:
-#ifdef HAVE_ARC4RANDOM
-	*config1=arc4random()%64;
-	return arc4random()%64;
-#else
 	*config1=rand()%64;
 	return rand()%64;
-#endif
 }
 
 /* arbitrary high number unlikely to be used by perf_event */
@@ -554,11 +534,7 @@ static long long random_cache_config(void)
 
 	int cache_id, hw_cache_op_id, hw_cache_op_result_id;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 8) {
-#else
 	switch (rand() % 8) {
-#endif
 	case 0:
 		cache_id = PERF_COUNT_HW_CACHE_L1D;
 		break;
@@ -581,22 +557,14 @@ static long long random_cache_config(void)
 		cache_id = PERF_COUNT_HW_CACHE_NODE;
 		break;
 	case 7:
-#ifdef HAVE_ARC4RANDOM
-		cache_id = arc4random() % 256;
-#else
 		cache_id = rand() % 256;
-#endif
 		break;
 	default:
 		cache_id = 0;
 		break;
 	}
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 4) {
-#else
 	switch (rand() % 4) {
-#endif
 	case 0:
 		hw_cache_op_id = PERF_COUNT_HW_CACHE_OP_READ;
 		break;
@@ -607,22 +575,14 @@ static long long random_cache_config(void)
 		hw_cache_op_id = PERF_COUNT_HW_CACHE_OP_PREFETCH;
 		break;
 	case 3:
-#ifdef HAVE_ARC4RANDOM
-		hw_cache_op_id = arc4random() % 256;
-#else
 		hw_cache_op_id = rand() % 256;
-#endif
 		break;
 	default:
 		hw_cache_op_id = 0;
 		break;
 	}
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0:
 		hw_cache_op_result_id = PERF_COUNT_HW_CACHE_RESULT_ACCESS;
 		break;
@@ -630,11 +590,7 @@ static long long random_cache_config(void)
 		hw_cache_op_result_id = PERF_COUNT_HW_CACHE_RESULT_MISS;
 		break;
 	case 2:
-#ifdef HAVE_ARC4RANDOM
-		hw_cache_op_result_id = arc4random() % 256;
-#else
 		hw_cache_op_result_id = rand() % 256;
-#endif
 		break;
 	default:
 		hw_cache_op_result_id = 0;
@@ -649,11 +605,7 @@ static int random_event_type(void)
 
 	int type=0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 8) {
-#else
 	switch (rand() % 8) {
-#endif
 	case 0:
 		type = PERF_TYPE_HARDWARE;
 		break;
@@ -692,11 +644,7 @@ static long long random_event_config(__u32 *event_type,
 
 	switch (*event_type) {
 	case PERF_TYPE_HARDWARE:
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 11) {
-#else
 		switch (rand() % 11) {
-#endif
 		case 0:
 			config = PERF_COUNT_HW_CPU_CYCLES;
 			break;
@@ -735,11 +683,7 @@ static long long random_event_config(__u32 *event_type,
 		}
 		break;
 	case PERF_TYPE_SOFTWARE:
-#ifdef HAVE_ARC4RANDOM
-		switch (arc4random() % 11) {
-#else
 		switch (rand() % 11) {
-#endif
 		case 0:
 			config = PERF_COUNT_SW_CPU_CLOCK;
 			break;
@@ -779,9 +723,20 @@ static long long random_event_config(__u32 *event_type,
 		break;
 	case PERF_TYPE_TRACEPOINT:
 		/* Actual values to use can be found under */
-		/* debugfs tracing/events// *//*/id        */
-		/* usually a small < 1024 number           */
-		config = rand64();
+		/* debugfs tracing/events/?*?/?*?/id       */
+		/* usually a small < 4096 number           */
+		switch(rand()%2) {
+		case 0:
+			/* Try a value < 4096 */
+			config = rand()&0xfff;
+			break;
+		case 1:
+			config = rand64();
+			break;
+		default:
+			config = rand64();
+			break;
+		}
 		break;
 	case PERF_TYPE_HW_CACHE:
 		config = random_cache_config();
@@ -817,11 +772,7 @@ static long long random_event_config(__u32 *event_type,
 static void setup_breakpoints(struct perf_event_attr *attr)
 {
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 6) {
-#else
 	switch (rand() % 6) {
-#endif
 	case 0:
 		attr->bp_type = HW_BREAKPOINT_EMPTY;
 		break;
@@ -849,11 +800,7 @@ static void setup_breakpoints(struct perf_event_attr *attr)
 	/* or a valid mem location for R/W/RW             */
 	attr->bp_addr = (long)get_address();
 
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 5) {
-#else
 	switch (rand() % 5) {
-#endif
 	case 0:
 		attr->bp_len = HW_BREAKPOINT_LEN_1;
 		break;
@@ -944,11 +891,7 @@ static int random_attr_size(void) {
 
 	int size=0;
 
-#ifdef HAVE_ARC4RANDOM
-	switch(arc4random() % 8) {
-#else
 	switch(rand() % 8) {
-#endif
 	case 0:	size = PERF_ATTR_SIZE_VER0;
 		break;
 	case 1: size = PERF_ATTR_SIZE_VER1;
@@ -977,11 +920,7 @@ static long long random_branch_sample_type(void)
 
 	long long branch_sample = 0;
 
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 2)
-#else
 	if (rand() % 2)
-#endif
 		return rand64();
 
 	if (rand_bool())
@@ -1045,11 +984,7 @@ static void create_mostly_valid_counting_event(struct perf_event_attr *attr,
 	attr->enable_on_exec = rand_bool();
 	attr->task = rand_bool();
 	attr->watermark = rand_bool();
-#ifdef HAVE_ARC4RANDOM
-	attr->precise_ip = arc4random() % 4;	// two bits
-#else
 	attr->precise_ip = rand() % 4;	// two bits
-#endif
 	attr->mmap_data = rand_bool();
 	attr->sample_id_all = rand_bool();
 	attr->exclude_host = rand_bool();
@@ -1110,11 +1045,7 @@ static void create_mostly_valid_sampling_event(struct perf_event_attr *attr,
 	attr->enable_on_exec = rand_bool();
 	attr->task = rand_bool();
 	attr->watermark = rand_bool();
-#ifdef HAVE_ARC4RANDOM
-	attr->precise_ip = arc4random() % 4;	// two bits
-#else
 	attr->precise_ip = rand() % 4;	// two bits
-#endif
 	attr->mmap_data = rand_bool();
 	attr->sample_id_all = rand_bool();
 	attr->exclude_host = rand_bool();
@@ -1137,18 +1068,6 @@ static void create_mostly_valid_sampling_event(struct perf_event_attr *attr,
 	/* sample_regs_user is a bitmask of CPU registers to record.     */
 	/* The values come from arch/ARCH/include/uapi/asm/perf_regs.h   */
 	/* Most architectures have fewer than 64 registers...            */
-#ifdef HAVE_ARC4RANDOM
-	switch(arc4random()%3) {
-		case 0:		attr->sample_regs_user = arc4random()%16;
-				break;
-		case 1:		attr->sample_regs_user = arc4random()%64;
-				break;
-		case 2:		attr->sample_regs_user = rand64();
-				break;
-		default:
-				break;
-	}
-#else
 	switch(rand()%3) {
 		case 0:		attr->sample_regs_user = rand()%16;
 				break;
@@ -1159,7 +1078,6 @@ static void create_mostly_valid_sampling_event(struct perf_event_attr *attr,
 		default:
 				break;
 	}
-#endif
 
 	/* sample_stack_user is the size of user stack backtrace we want  */
 	/* if we pick too large of a value the kernel in theory truncates */
@@ -1199,11 +1117,7 @@ static void create_random_event(struct perf_event_attr *attr)
 	attr->enable_on_exec = rand_bool();
 	attr->task = rand_bool();
 	attr->watermark = rand_bool();
-#ifdef HAVE_ARC4RANDOM
-	attr->precise_ip = arc4random() % 4;
-#else
 	attr->precise_ip = rand() % 4;
-#endif
 	attr->mmap_data = rand_bool();
 	attr->sample_id_all = rand_bool();
 	attr->exclude_host = rand_bool();
@@ -1242,20 +1156,26 @@ void sanitise_perf_event_open(int childno)
 	memset(page_rand, 0, sizeof(struct perf_event_attr));
 
 	/* cpu */
-	/* requires ROOT to select CPU if paranoid level not 0 */
+	/* requires ROOT to select specific CPU if pid==-1 (all processes) */
 	/* -1 means all CPUs */
-	//shm->a3[childno] = cpu;
-	// the default get_cpu() is good enough here
+
+	switch(rand() % 2) {
+	case 0:
+		/* Any CPU */
+		shm->a3[childno] = -1;
+		break;
+	case 1:
+		/* Default to the get_cpu() value */
+		/* set by ARG_CPU                 */
+	default:
+		break;
+	}
 
 	/* group_fd */
 	/* should usually be -1 or another perf_event fd         */
 	/* Anything but -1 unlikely to work unless the other pid */
 	/* was properly set up to be a group master              */
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0:
 		shm->a4[childno] = -1;
 		group_leader = 1;
@@ -1263,11 +1183,7 @@ void sanitise_perf_event_open(int childno)
 	case 1:
 		/* Try to get a previous random perf_event_open() fd  */
 		/* It's unclear whether get_random_fd() would do this */
-#ifdef HAVE_ARC4RANDOM
-		shm->a4[childno] = arc4random() % 1024;
-#else
 		shm->a4[childno] = rand() % 1024;
-#endif
 		break;
 	case 2:
 		/* Rely on ARG_FD */
@@ -1293,28 +1209,34 @@ void sanitise_perf_event_open(int childno)
 
 	/* pid */
 	/* requires ROOT to select pid that doesn't belong to us */
-	/* pid of 0 means current process */
-	/* pid of -1 means all processes  */
 
 	if (flags & PERF_FLAG_PID_CGROUP) {
 		/* In theory in this case we should pass in */
 		/* a file descriptor from /dev/cgroup       */
 		pid = get_random_fd();
 	} else {
-		if (rand_bool()) {
+		switch(rand() % 4) {
+		case 0:	/* use current thread */
 			pid = 0;
-		} else {
+			break;
+		case 1: /* get an arbitrary pid */
 			pid = get_pid();
+			break;
+		case 2:	/* measure *all* pids.  Might require root */
+			pid = -1;
+			break;
+		case 3: /* measure our actual pid */
+			pid=getpid();
+			break;
+		default:
+			pid = 0;
+			break;
 		}
 	}
 	shm->a2[childno] = pid;
 
 	/* set up attr structure */
-#ifdef HAVE_ARC4RANDOM
-	switch (arc4random() % 3) {
-#else
 	switch (rand() % 3) {
-#endif
 	case 0:
 		create_mostly_valid_counting_event(attr,group_leader);
 		break;
diff --git a/syscalls/prctl.c b/syscalls/prctl.c
index 8920d82..3a09297 100644
--- a/syscalls/prctl.c
+++ b/syscalls/prctl.c
@@ -2,7 +2,6 @@
  * SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 	 unsigned long, arg4, unsigned long, arg5)
  */
-
 #include "config.h"
 
 #include <stdlib.h>
@@ -32,34 +31,24 @@ static int prctl_opts[NR_PRCTL_OPTS] = {
 /* We already got a generic_sanitise at this point */
 void sanitise_prctl(int childno)
 {
-#ifdef HAVE_ARC4RANDOM
-	int option = prctl_opts[arc4random() % NR_PRCTL_OPTS];
-#else
 	int option = prctl_opts[rand() % NR_PRCTL_OPTS];
-#endif
+
+// For now, just do SECCOMP, the other options need some attention.
+option = PR_SET_SECCOMP;
 
 	/* Also allow crap by small chance */
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 100 != 0)
-		shm->a1[childno] = option;
-#else
 	if (rand() % 100 != 0)
 		shm->a1[childno] = option;
-#endif
 
 	switch (option) {
 	case PR_SET_SECCOMP:
 #ifdef USE_SECCOMP
-#ifdef HAVE_ARC4RANDOM
-		if (arc4random() % 3 == SECCOMP_MODE_FILTER) {
-#else
-		if (rand() % 3 == SECCOMP_MODE_FILTER) {
-#endif /* HAVE_ARC4RANDOM */
+//		if (rand() % 3 == SECCOMP_MODE_FILTER) {
 			gen_seccomp_bpf((unsigned long *) page_rand, NULL);
 
 			shm->a2[childno] = SECCOMP_MODE_FILTER;
 			shm->a3[childno] = (unsigned long) page_rand;
-		}
+//		}
 #endif
 		break;
 	default:
@@ -69,7 +58,6 @@ void sanitise_prctl(int childno)
 
 struct syscall syscall_prctl = {
 	.name = "prctl",
-	.flags = AVOID_SYSCALL,
 	.num_args = 5,
 	.arg1name = "option",
 	.arg2name = "arg2",
diff --git a/syscalls/ptrace.c b/syscalls/ptrace.c
index 2eaaa9d..7ef4828 100644
--- a/syscalls/ptrace.c
+++ b/syscalls/ptrace.c
@@ -2,14 +2,12 @@
  * SYSCALL_DEFINE4(ptrace, long, request, long, pid, long, addr, long, data)
  */
 #include <stdlib.h>
-#ifdef __LINUX__
 #include <linux/ptrace.h>
-#endif
 #include "sanitise.h"
 #include "shm.h"
 #include "compat.h"
 #include "arch.h"
-#include "config.h"	// arc4random
+
 
 static void sanitise_ptrace(int childno)
 {
@@ -25,11 +23,7 @@ static void sanitise_ptrace(int childno)
 	 * Or at least, that's the theory. In reality, this is currently causing 'no such process' errors.
 	 *  but broken is at least better than hanging.
 	 */
-#ifdef HAVE_ARC4RANDOM
-	i  = arc4random() % shm->running_childs;
-#else
 	i  = rand() % shm->running_childs;
-#endif
 	shm->a2[childno] = shm->pids[i];
 }
 
@@ -41,7 +35,6 @@ struct syscall syscall_ptrace = {
 	.arg1type = ARG_OP,
 	.arg1list = {
 		.num = 25,
-#ifdef __LINUX__
 		.values = { PTRACE_TRACEME, PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR,
 				PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR, PTRACE_GETREGS,
 				PTRACE_GETFPREGS, PTRACE_GETSIGINFO, PTRACE_SETREGS, PTRACE_SETFPREGS,
@@ -49,9 +42,6 @@ struct syscall syscall_ptrace = {
 				PTRACE_SYSCALL, PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP,
 				PTRACE_KILL, PTRACE_ATTACH, PTRACE_DETACH, PTRACE_GETSIGMASK,
 				PTRACE_SETSIGMASK },
-#endif
-		.values = { PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP,
-			PTRACE_GETSIGMASK, PTRACE_SETSIGMASK },
 	},
 	.arg2name = "pid",
 	.arg3name = "addr",
diff --git a/syscalls/read.c b/syscalls/read.c
index 5ebd83a..dc7c5b9 100644
--- a/syscalls/read.c
+++ b/syscalls/read.c
@@ -7,16 +7,11 @@
 #include "sanitise.h"
 #include "shm.h"
 #include "arch.h"
-#include "config.h"	// arc4random
 
 static void sanitise_read(int childno)
 {
 	shm->a2[childno] = (unsigned long) page_rand;
-#ifdef HAVE_ARC4RANDOM
-	shm->a3[childno] = arc4random() % page_size;
-#else
 	shm->a3[childno] = rand() % page_size;
-#endif
 }
 
 struct syscall syscall_read = {
diff --git a/syscalls/recv.c b/syscalls/recv.c
index c989e9e..b989822 100644
--- a/syscalls/recv.c
+++ b/syscalls/recv.c
@@ -20,29 +20,10 @@ struct syscall syscall_recv = {
 	.arg4type = ARG_LIST,
 	.arg4list = {
 		.num = 20,
-		.values = {
-				MSG_DONTWAIT,
-#ifdef __LINUX__
-				MSG_ERRQUEUE,
-				MSG_ERRQUEUE,
-			    MSG_ERRQUEUE,
-#endif
-				MSG_OOB,
-				MSG_PEEK,
-#ifdef __LINUX__
-				MSG_TRUNC,
-#endif
-			    MSG_WAITALL,
-#ifdef __LINUX__
-				MSG_EOR,
-				MSG_TRUNC,
-				MSG_CTRUNC,
-#endif
-			    MSG_OOB,
-#ifdef __LINUX__
-				MSG_ERRQUEUE
-#endif
-		},
+		.values = { MSG_DONTWAIT, MSG_ERRQUEUE, MSG_ERRQUEUE,
+			    MSG_ERRQUEUE, MSG_OOB, MSG_PEEK, MSG_TRUNC,
+			    MSG_WAITALL, MSG_EOR, MSG_TRUNC, MSG_CTRUNC,
+			    MSG_OOB, MSG_ERRQUEUE },
 	},
 	.flags = NEED_ALARM,
 };
diff --git a/syscalls/recvfrom.c b/syscalls/recvfrom.c
index f08abc0..ffa3406 100644
--- a/syscalls/recvfrom.c
+++ b/syscalls/recvfrom.c
@@ -21,34 +21,11 @@ struct syscall syscall_recvfrom = {
 	.arg4type = ARG_LIST,
 	.arg4list = {
 		.num = 20,
-		.values = {
-				MSG_OOB,
-				MSG_PEEK,
-                MSG_DONTROUTE,
-#ifdef __LINUX__
-                MSG_CTRUNC,
-                MSG_PROBE,
-                MSG_TRUNC,
-                MSG_DONTWAIT,
-#endif
-                MSG_EOR,
-                MSG_WAITALL,
-#ifdef __LINUX__
-                MSG_FIN,
-                MSG_SYN,
-                MSG_CONFIRM,
-                MSG_RST,
-                MSG_ERRQUEUE,
-#endif
-                MSG_NOSIGNAL,
-#ifdef __LINUX__
-                MSG_MORE,
-                MSG_WAITFORONE,
-                MSG_CMSG_CLOEXEC,
-                MSG_FASTOPEN,
-                MSG_CMSG_COMPAT
-#endif
-		}
+		.values = { MSG_OOB, MSG_PEEK, MSG_DONTROUTE, MSG_CTRUNC,
+			    MSG_PROBE, MSG_TRUNC, MSG_DONTWAIT, MSG_EOR,
+			    MSG_WAITALL, MSG_FIN, MSG_SYN, MSG_CONFIRM,
+			    MSG_RST, MSG_ERRQUEUE, MSG_NOSIGNAL, MSG_MORE,
+			    MSG_WAITFORONE, MSG_FASTOPEN, MSG_CMSG_CLOEXEC, MSG_CMSG_COMPAT },
 	},
 	.arg5name = "addr",
 	.arg5type = ARG_SOCKADDR,
diff --git a/syscalls/recvmsg.c b/syscalls/recvmsg.c
index 296c426..8ae816d 100644
--- a/syscalls/recvmsg.c
+++ b/syscalls/recvmsg.c
@@ -17,34 +17,11 @@ struct syscall syscall_recvmsg = {
 	.arg3type = ARG_LIST,
 	.arg3list = {
 		.num = 20,
-		.values = {
-				MSG_OOB,
-				MSG_PEEK,
-#ifdef __LINUX__
-				MSG_DONTROUTE,
-				MSG_CTRUNC,
-				MSG_PROBE,
-				MSG_TRUNC,
-#endif
-				MSG_DONTWAIT,
-#ifdef __LINUX__
-				MSG_EOR,
-#endif
-				MSG_WAITALL,
-#ifdef __LINUX__
-				MSG_FIN,
-				MSG_SYN,
-				MSG_CONFIRM,
-				MSG_RST,
-				MSG_ERRQUEUE,
-				MSG_NOSIGNAL,
-				MSG_MORE,
-				MSG_WAITFORONE,
-				MSG_CMSG_CLOEXEC,
-				MSG_FASTOPEN,
-				MSG_CMSG_COMPAT
-#endif
-		},
+		.values = { MSG_OOB, MSG_PEEK, MSG_DONTROUTE, MSG_CTRUNC,
+				MSG_PROBE, MSG_TRUNC, MSG_DONTWAIT, MSG_EOR,
+				MSG_WAITALL, MSG_FIN, MSG_SYN, MSG_CONFIRM,
+				MSG_RST, MSG_ERRQUEUE, MSG_NOSIGNAL, MSG_MORE,
+				MSG_WAITFORONE, MSG_CMSG_CLOEXEC, MSG_FASTOPEN, MSG_CMSG_COMPAT },
 	},
 	.flags = NEED_ALARM,
 };
diff --git a/syscalls/send.c b/syscalls/send.c
index 3dec66e..a6ad7e1 100644
--- a/syscalls/send.c
+++ b/syscalls/send.c
@@ -18,18 +18,7 @@ struct syscall syscall_send = {
         .arg4type = ARG_LIST,
         .arg4list = {
                 .num = 7,
-                .values = {
-#ifdef __LINUX__
-					MSG_CONFIRM,
-#endif /* __LINUX__ */
-					MSG_DONTROUTE,
-					MSG_DONTWAIT,
-#ifdef __LINUX__
-					MSG_EOR,
-					MSG_MORE,
-#endif /* __LINUX__ */
-					MSG_NOSIGNAL,
-					MSG_OOB
-			},
+                .values = { MSG_CONFIRM, MSG_DONTROUTE, MSG_DONTWAIT,
+			    MSG_EOR, MSG_MORE, MSG_NOSIGNAL, MSG_OOB },
 	},
 };
diff --git a/syscalls/sendmmsg.c b/syscalls/sendmmsg.c
index 59a832d..d2277c9 100644
--- a/syscalls/sendmmsg.c
+++ b/syscalls/sendmmsg.c
@@ -19,34 +19,11 @@ struct syscall syscall_sendmmsg = {
 	.arg4type = ARG_LIST,
 	.arg4list = {
 		.num = 20,
-		.values = {
-				MSG_OOB,
-				MSG_PEEK,
-				MSG_DONTROUTE,
-#ifdef __LINUX__
-				MSG_CTRUNC,
-				MSG_PROBE,
-				MSG_TRUNC,
-				MSG_DONTWAIT,
-#endif
-				MSG_EOR,
-				MSG_WAITALL,
-#ifdef __LINUX__
-				MSG_FIN,
-				MSG_SYN,
-				MSG_CONFIRM,
-				MSG_RST,
-				MSG_ERRQUEUE,
-#endif
-				MSG_NOSIGNAL,
-#ifdef __LINUX__
-				MSG_MORE,
-				MSG_WAITFORONE,
-				MSG_CMSG_CLOEXEC,
-				MSG_FASTOPEN,
-				MSG_CMSG_COMPAT
-#endif
-		},
+		.values = { MSG_OOB, MSG_PEEK, MSG_DONTROUTE, MSG_CTRUNC,
+				MSG_PROBE, MSG_TRUNC, MSG_DONTWAIT, MSG_EOR,
+				MSG_WAITALL, MSG_FIN, MSG_SYN, MSG_CONFIRM,
+				MSG_RST, MSG_ERRQUEUE, MSG_NOSIGNAL, MSG_MORE,
+				MSG_WAITFORONE, MSG_CMSG_CLOEXEC, MSG_FASTOPEN, MSG_CMSG_COMPAT },
 	},
 	.flags = NEED_ALARM,
 };
diff --git a/syscalls/sendmsg.c b/syscalls/sendmsg.c
index 82cfc0d..71ac549 100644
--- a/syscalls/sendmsg.c
+++ b/syscalls/sendmsg.c
@@ -42,30 +42,11 @@ struct syscall syscall_sendmsg = {
 	.arg3type = ARG_LIST,
 	.arg3list = {
 		.num = 20,
-		.values = {
-				MSG_OOB,
-				MSG_PEEK,
-				MSG_DONTROUTE,
-				MSG_CTRUNC,
-				MSG_TRUNC,
-				MSG_DONTWAIT, MSG_EOR,
-				MSG_WAITALL,
-#ifdef __LINUX__
-				MSG_FIN,
-				MSG_SYN,
-				MSG_CONFIRM,
-				MSG_RST,
-				MSG_ERRQUEUE,
-#endif
-				MSG_NOSIGNAL,
-#ifdef __LINUX__
-				MSG_MORE,
-				MSG_WAITFORONE,
-				MSG_CMSG_CLOEXEC,
-				MSG_FASTOPEN,
-				MSG_CMSG_COMPAT
-#endif
-		},
+		.values = { MSG_OOB, MSG_PEEK, MSG_DONTROUTE, MSG_CTRUNC,
+				MSG_TRUNC, MSG_DONTWAIT, MSG_EOR,
+				MSG_WAITALL, MSG_FIN, MSG_SYN, MSG_CONFIRM,
+				MSG_RST, MSG_ERRQUEUE, MSG_NOSIGNAL, MSG_MORE,
+				MSG_WAITFORONE, MSG_CMSG_CLOEXEC, MSG_FASTOPEN, MSG_CMSG_COMPAT },
 	},
 	.sanitise = sanitise_sendmsg,
 	.flags = NEED_ALARM,
diff --git a/syscalls/sendto.c b/syscalls/sendto.c
index 276394e..9711f39 100644
--- a/syscalls/sendto.c
+++ b/syscalls/sendto.c
@@ -22,34 +22,11 @@ struct syscall syscall_sendto = {
 	.arg4type = ARG_LIST,
 	.arg4list = {
 		.num = 20,
-		.values = {
-				MSG_OOB,
-				MSG_PEEK,
-				MSG_DONTROUTE,
-				MSG_CTRUNC,
-#ifdef __LINUX__
-				MSG_PROBE,
-#endif
-				MSG_TRUNC,
-				MSG_DONTWAIT,
-				MSG_EOR,
-				MSG_WAITALL,
-#ifdef __LINUX__
-				MSG_FIN,
-				MSG_SYN,
-				MSG_CONFIRM,
-				MSG_RST,
-				MSG_ERRQUEUE,
-#endif
-				MSG_NOSIGNAL,
-#ifdef __LINUX__
-				MSG_MORE,
-				MSG_WAITFORONE,
-				MSG_FASTOPEN,
-				MSG_CMSG_CLOEXEC,
-				MSG_CMSG_COMPAT
-#endif
-		},
+		.values = { MSG_OOB, MSG_PEEK, MSG_DONTROUTE, MSG_CTRUNC,
+				MSG_PROBE, MSG_TRUNC, MSG_DONTWAIT, MSG_EOR,
+				MSG_WAITALL, MSG_FIN, MSG_SYN, MSG_CONFIRM,
+				MSG_RST, MSG_ERRQUEUE, MSG_NOSIGNAL, MSG_MORE,
+				MSG_WAITFORONE, MSG_FASTOPEN, MSG_CMSG_CLOEXEC, MSG_CMSG_COMPAT },
 	},
 	.arg5name = "addr",
 	.arg5type = ARG_SOCKADDR,
diff --git a/syscalls/setns.c b/syscalls/setns.c
index f23c73d..a296a7e 100644
--- a/syscalls/setns.c
+++ b/syscalls/setns.c
@@ -1,7 +1,6 @@
 /*
  * SYSCALL_DEFINE2(setns, int, fd, int, nstype)
  */
-
 #include <sched.h>
 #include "sanitise.h"
 
diff --git a/syscalls/setsockopt.c b/syscalls/setsockopt.c
index 2716c99..3e985a4 100644
--- a/syscalls/setsockopt.c
+++ b/syscalls/setsockopt.c
@@ -56,51 +56,43 @@ static const struct sso_funcptr ssoptrs[] = {
 	{ .func = &nfc_setsockopt },
 };
 
-static void sanitise_setsockopt(int childno)
+void do_setsockopt(struct sockopt *so)
 {
-	struct sockopt so = { 0,0,0,0 };
-
-	so.optval = (unsigned long) page_rand;
+	so->optval = (unsigned long) page_rand;
 	// pick a size for optlen. At the minimum, we want an int (overridden below)
 	if (rand_bool())
-		so.optlen = sizeof(int);
+		so->optlen = sizeof(int);
 	else
-#ifdef HAVE_ARC4RANDOM
-		so.optlen = arc4random() % 256;
-#else
-		so.optlen = rand() % 256;
-#endif
+		so->optlen = rand() % 256;
 
-#ifdef HAVE_ARC4RANDOM
-	if (arc4random() % 100 > 0) {
-		ssoptrs[arc4random() % ARRAY_SIZE(ssoptrs)].func(&so);
-	} else {
-		so.level = arc4random();
-		so.optname = (arc4random() % 0x100);	/* random operation. */
-	}
-#else
 	if (rand() % 100 > 0) {
-		ssoptrs[rand() % ARRAY_SIZE(ssoptrs)].func(&so);
+		ssoptrs[rand() % ARRAY_SIZE(ssoptrs)].func(so);
 	} else {
-		so.level = rand();
-		so.optname = (rand() % 0x100);	/* random operation. */
+		so->level = rand();
+		so->optname = (rand() % 0x100);	/* random operation. */
 	}
-#endif
 
 	/*
 	 * 10% of the time, mangle the options.
 	 * This should catch new options we don't know about, and also maybe some missing bounds checks.
 	 */
 	if ((rand() % 100) < 10)
-		so.optname |= (1 << (rand() % 32));
+		so->optname |= (1 << (rand() % 32));
 
 
 	/* optval should be nonzero to enable a boolean option, or zero if the option is to be disabled.
 	 * Let's disable it half the time.
 	 */
 	if (rand_bool())
-		so.optval = 0;
+		so->optval = 0;
+
+}
+
+static void sanitise_setsockopt(int childno)
+{
+	struct sockopt so = { 0, 0, 0, 0 };
 
+	do_setsockopt(&so);
 
 	/* copy the generated values to the shm. */
 	shm->a2[childno] = so.level;
diff --git a/syscalls/socket.c b/syscalls/socket.c
index 8221471..3badd86 100644
--- a/syscalls/socket.c
+++ b/syscalls/socket.c
@@ -12,6 +12,7 @@
 #include "shm.h"
 #include "config.h"
 #include "params.h"
+#include "protocols.h"
 #include "trinity.h"
 
 struct socket_ptr {
@@ -19,7 +20,6 @@ struct socket_ptr {
 	void (*func)(struct socket_triplet *st);
 };
 static const struct socket_ptr socketptrs[] = {
-#ifdef __LINUX__
 	{ .family = AF_APPLETALK, .func = &atalk_rand_socket },
 	{ .family = AF_AX25, .func = &ax25_rand_socket },
 #ifdef USE_CAIF
@@ -27,10 +27,8 @@ static const struct socket_ptr socketptrs[] = {
 #endif
 	{ .family = AF_CAN, .func = &can_rand_socket },
 	{ .family = AF_DECnet, .func = &decnet_rand_socket },
-#endif
 	{ .family = AF_INET, .func = &inet_rand_socket },
 	{ .family = AF_INET6, .func = &inet6_rand_socket },
-#ifdef __LINUX__
 	{ .family = AF_IPX, .func = &ipx_rand_socket },
 	{ .family = AF_IRDA, .func = &irda_rand_socket },
 	{ .family = AF_LLC, .func = &llc_rand_socket },
@@ -41,33 +39,37 @@ static const struct socket_ptr socketptrs[] = {
 	{ .family = AF_PHONET, .func = &phonet_rand_socket },
 	{ .family = AF_RDS, .func = &rds_rand_socket },
 	{ .family = AF_TIPC, .func = &tipc_rand_socket },
-#endif
 	{ .family = AF_UNIX, .func = &unix_rand_socket },
-#ifdef __LINUX__
 	{ .family = AF_X25, .func = &x25_rand_socket },
-#endif
 };
 
 void rand_proto_type(struct socket_triplet *st)
 {
-#ifdef HAVE_ARC4RANDOM
-	st->protocol = arc4random() % PROTO_MAX;
+	int n;
+
+	/*
+	 * One special moment on packet sockets. They
+	 * can be created with SOCK_PACKET, so if
+	 * PF_PACKET is disabled, choose some other type.
+	 */
 
-	switch (arc4random() % 6) {
-#else
 	st->protocol = rand() % PROTO_MAX;
 
-	switch (rand() % 6) {
-#endif
+	if (st->family == PF_INET && no_protos[PF_PACKET])
+		n = 5;
+	else
+		n = 6;
 
+	switch (rand() % n) {
 	case 0:	st->type = SOCK_DGRAM;	break;
 	case 1:	st->type = SOCK_STREAM;	break;
 	case 2:	st->type = SOCK_SEQPACKET;	break;
 	case 3:	st->type = SOCK_RAW;	break;
 	case 4:	st->type = SOCK_RDM;	break;
-#ifdef __LINUX__
+	/*
+	 * Make sure it's last one.
+	 */
 	case 5:	st->type = SOCK_PACKET;	break;
-#endif
 	default: break;
 	}
 }
@@ -92,19 +94,26 @@ void gen_socket_args(struct socket_triplet *st)
 {
 	if (do_specific_proto == TRUE)
 		st->family = specific_proto;
-	else
-#ifdef HAVE_ARC4RANDOM
-		st->family = arc4random() % TRINITY_PF_MAX;
-#else
+
+	else {
 		st->family = rand() % TRINITY_PF_MAX;
-#endif
+
+		/*
+		 * If we get a disabled family, try to find
+		 * first next allowed.
+		 */
+		BUG_ON(st->family >= ARRAY_SIZE(no_protos));
+		if (no_protos[st->family]) {
+			st->family = find_next_enabled_proto(st->family);
+			if (st->family == -1u) {
+				outputerr("No available socket family found\n");
+				exit(EXIT_FAILURE);
+			}
+		}
+	}
 
 	/* sometimes, still gen rand crap */
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 100) == 0) {
-#else
 	if ((rand() % 100) == 0) {
-#endif
 		rand_proto_type(st);
 		goto done;
 	}
@@ -115,17 +124,10 @@ void gen_socket_args(struct socket_triplet *st)
 
 
 done:
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 100) < 25)
-		st->type |= SOCK_CLOEXEC;
-	if ((arc4random() % 100) < 25)
-		st->type |= SOCK_NONBLOCK;
-#else
 	if ((rand() % 100) < 25)
 		st->type |= SOCK_CLOEXEC;
 	if ((rand() % 100) < 25)
 		st->type |= SOCK_NONBLOCK;
-#endif
 }
 
 
diff --git a/syscalls/socketcall.c b/syscalls/socketcall.c
index 18a630e..d925acd 100644
--- a/syscalls/socketcall.c
+++ b/syscalls/socketcall.c
@@ -58,11 +58,7 @@ static void sanitise_socketcall(int childno)
 
 	args = malloc(6 * sizeof(unsigned long));
 
-#ifdef HAVE_ARC4RANDOM
-	shm->a1[childno] = arc4random() % 20;
-#else
 	shm->a1[childno] = rand() % 20;
-#endif
 	shm->a1[childno] = SYS_SOCKET;
 
 	for (i = 0; i < ARRAY_SIZE(socketcallptrs); i++) {
diff --git a/syscalls/splice.c b/syscalls/splice.c
index 438aa29..d136c15 100644
--- a/syscalls/splice.c
+++ b/syscalls/splice.c
@@ -17,28 +17,16 @@
 
 static void sanitise_splice(int childno)
 {
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 10) < 3)
-#else
 	if ((rand() % 10) < 3)
-#endif
 		return;
 
 	if (rand_bool()) {
-#ifdef HAVE_ARC4RANDOM
-		shm->a1[childno] = shm->pipe_fds[arc4random() % MAX_PIPE_FDS];
-#else
 		shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
-#endif
 		shm->a2[childno] = 0;
 	}
 
 	if (rand_bool()) {
-#ifdef HAVE_ARC4RANDOM
-		shm->a3[childno] = shm->pipe_fds[arc4random() % MAX_PIPE_FDS];
-#else
 		shm->a3[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
-#endif
 		shm->a4[childno] = 0;
 	}
 }
diff --git a/syscalls/syscalls.h b/syscalls/syscalls.h
index 60f58ec..59f1a20 100644
--- a/syscalls/syscalls.h
+++ b/syscalls/syscalls.h
@@ -30,14 +30,11 @@ extern struct syscall syscall_delete_module;
 extern struct syscall syscall_dup2;
 extern struct syscall syscall_dup3;
 extern struct syscall syscall_dup;
-
-
 extern struct syscall syscall_epoll_create1;
 extern struct syscall syscall_epoll_create;
 extern struct syscall syscall_epoll_ctl;
 extern struct syscall syscall_epoll_pwait;
 extern struct syscall syscall_epoll_wait;
-
 extern struct syscall syscall_eventfd2;
 extern struct syscall syscall_eventfd;
 extern struct syscall syscall_execve;
@@ -331,11 +328,9 @@ extern struct syscall syscall_tgkill;
 extern struct syscall syscall_time;
 extern struct syscall syscall_timer_create;
 extern struct syscall syscall_timer_delete;
-
 extern struct syscall syscall_timerfd_create;
 extern struct syscall syscall_timerfd_gettime;
 extern struct syscall syscall_timerfd_settime;
-
 extern struct syscall syscall_timer_getoverrun;
 extern struct syscall syscall_timer_gettime;
 extern struct syscall syscall_timer_settime;
diff --git a/syscalls/tee.c b/syscalls/tee.c
index 7f275ec..9e591d1 100644
--- a/syscalls/tee.c
+++ b/syscalls/tee.c
@@ -14,17 +14,10 @@
 
 static void sanitise_tee(int childno)
 {
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 10) > 0) {
-		shm->a1[childno] = shm->pipe_fds[arc4random() % MAX_PIPE_FDS];
-		shm->a2[childno] = shm->pipe_fds[arc4random() % MAX_PIPE_FDS];
-	}
-#else
 	if ((rand() % 10) > 0) {
 		shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 		shm->a2[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 	}
-#endif
 }
 
 struct syscall syscall_tee = {
diff --git a/syscalls/timerfd_create.c b/syscalls/timerfd_create.c
index f3002c2..92caaa4 100644
--- a/syscalls/timerfd_create.c
+++ b/syscalls/timerfd_create.c
@@ -1,7 +1,6 @@
 /*
  * SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)
  */
-#ifdef _LINUX__
 #include <time.h>
 #include "sanitise.h"
 #include "compat.h"
@@ -22,4 +21,3 @@ struct syscall syscall_timerfd_create = {
 		.values = { TFD_NONBLOCK, TFD_CLOEXEC },
 	},
 };
-#endif
diff --git a/syscalls/unshare.c b/syscalls/unshare.c
index fe50a1c..04b3a69 100644
--- a/syscalls/unshare.c
+++ b/syscalls/unshare.c
@@ -1,8 +1,6 @@
 /*
  * SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
  */
-
-#ifdef __LINUX
 #include <linux/sched.h>
 #include "sanitise.h"
 
@@ -19,4 +17,3 @@ struct syscall syscall_unshare = {
 		},
 	},
 };
-#endif
diff --git a/syscalls/vmsplice.c b/syscalls/vmsplice.c
index e34a565..4b3ab5e 100644
--- a/syscalls/vmsplice.c
+++ b/syscalls/vmsplice.c
@@ -11,15 +11,9 @@
 
 static void sanitise_vmsplice(int childno)
 {
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 10) > 0)
-		shm->a1[childno] = shm->pipe_fds[arc4random() % MAX_PIPE_FDS];
-	shm->a3[childno] = arc4random() % UIO_MAXIOV;
-#else
 	if ((rand() % 10) > 0)
 		shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 	shm->a3[childno] = rand() % UIO_MAXIOV;
-#endif
 }
 
 struct syscall syscall_vmsplice = {
diff --git a/syscalls/write.c b/syscalls/write.c
index 0e50228..d57bce8 100644
--- a/syscalls/write.c
+++ b/syscalls/write.c
@@ -6,23 +6,14 @@
 #include "sanitise.h"
 #include "shm.h"
 #include "arch.h"	// page_size
-#include "config.h"	// arc4random
 
 static void sanitise_write(int childno)
 {
 	shm->a2[childno] = (unsigned long) page_rand;
-#ifdef HAVE_ARC4RANDOM
-	if ((arc4random() % 100) > 50)
-#else
 	if ((rand() % 100) > 50)
-#endif
 		shm->a3[childno] = 1;
 	else
-#ifdef HAVE_ARC4RANDOM
-		shm->a3[childno] = arc4random() % page_size;
-#else
 		shm->a3[childno] = rand() % page_size;
-#endif
 }
 
 struct syscall syscall_write = {
diff --git a/tables-biarch.c b/tables-biarch.c
index 8bbb788..4b46200 100644
--- a/tables-biarch.c
+++ b/tables-biarch.c
@@ -149,11 +149,7 @@ retry:
 
 	//Search for 64 bit version
 	if (do_64_arch) {
-#ifdef HAVE_ARC4RANDOM
-		call64 = arc4random() % max_nr_64bit_syscalls;
-#else
 		call64 = rand() % max_nr_64bit_syscalls;
-#endif
 		if (validate_specific_syscall_silent(syscalls_64bit, call64) == FALSE)
 			goto retry;
 
@@ -183,11 +179,7 @@ try32bit:
 			if (syscalls_64bit[call64].entry->flags & TO_BE_DEACTIVATED)
 				call64 = NOTFOUND; //mark as not found in order not to increment i.
 		} else {
-#ifdef HAVE_ARC4RANDOM
-			call32 = arc4random() % max_nr_32bit_syscalls;
-#else
 			call32 = rand() % max_nr_32bit_syscalls;
-#endif
 		}
 
 		if (validate_specific_syscall_silent(syscalls_32bit, call32) == FALSE) {
diff --git a/tables-uniarch.c b/tables-uniarch.c
index bcf98b1..ac0602b 100644
--- a/tables-uniarch.c
+++ b/tables-uniarch.c
@@ -57,11 +57,7 @@ void enable_random_syscalls_uniarch(void)
 	unsigned int call;
 
 retry:
-#ifdef HAVE_ARC4RANDOM
-	call = arc4random() % max_nr_syscalls;
-#else
 	call = rand() % max_nr_syscalls;
-#endif
 
 	if (validate_specific_syscall_silent(syscalls, call) == FALSE)
 		goto retry;
diff --git a/trinity.c b/trinity.c
index f40cc1b..a66c849 100644
--- a/trinity.c
+++ b/trinity.c
@@ -7,10 +7,8 @@
 #include <ctype.h>
 #include <unistd.h>
 #include <setjmp.h>
-#ifdef __LINUX__
 #include <malloc.h>
 #include <asm/unistd.h>
-#endif /* __LINUX__ */
 #include <sys/time.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -34,6 +32,7 @@
 #include "syscall.h"
 #include "tables.h"
 #include "ioctls.h"
+#include "protocols.h"
 #include "config.h"	// for VERSION
 
 char *progname = NULL;
@@ -205,11 +204,9 @@ int main(int argc, char* argv[])
 	parse_args(argc, argv);
 	outputstd("Done parsing arguments.\n");
 
-#ifndef __BSD__
 	if (kernel_taint_mask != (int)0xFFFFFFFF) {
 		outputstd("Custom kernel taint mask has been specified: 0x%08x (%d).\n", kernel_taint_mask, kernel_taint_mask);
 	}
-#endif
 
 	setup_shm_postargs();
 
@@ -261,12 +258,11 @@ int main(int argc, char* argv[])
 
 	setup_main_signals();
 
-#ifdef __LINUX__
 	kernel_taint_initial = check_tainted();
 	if (kernel_taint_initial != 0) {
 		output(0, "Kernel was tainted on startup. Will ignore flags that are already set.\n");
 	}
-#endif
+
 	change_tmp_dir();
 
 	/* check if we ctrl'c or something went wrong during init. */
@@ -287,19 +283,7 @@ int main(int argc, char* argv[])
 
 cleanup_fds:
 
-	for (i = 0; i < nr_sockets; i++) {
-		int r = 0;
-		struct linger ling = { .l_onoff = FALSE, };
-
-		ling.l_onoff = FALSE;	/* linger active */
-		r = setsockopt(shm->socket_fds[i], SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
-		if (r)
-			perror("setsockopt");
-		r = shutdown(shm->socket_fds[i], SHUT_RDWR);
-		if (r)
-			perror("shutdown");
-		close(shm->socket_fds[i]);
-	}
+	close_sockets();
 
 	destroy_maps();
 
diff --git a/unicode.c b/unicode.c
index dabb8a1..9bc5b83 100644
--- a/unicode.c
+++ b/unicode.c
@@ -16,7 +16,6 @@
 #include <unistd.h>
 #include <string.h>
 #include "arch.h"
-#include "config.h"	// arc4random
 #include "sanitise.h"
 
 void gen_unicode_page(char *page)
@@ -41,11 +40,7 @@ void gen_unicode_page(char *page)
 
 	while (i < (page_size - zalgolen)) {
 
-#ifdef HAVE_ARC4RANDOM
-		j = arc4random() % 9;
-#else
 		j = rand() % 9;
-#endif
 
 		switch (j) {
 
@@ -55,11 +50,7 @@ void gen_unicode_page(char *page)
 			i += 4;
 			break;
 
-#ifdef HAVE_ARC4RANDOM
-		case 1: unilen = arc4random() % 10;
-#else
 		case 1: unilen = rand() % 10;
-#endif
 			for (l = 0; l < unilen; l++) {
 				strncpy(ptr, unicode2, 6);
 				ptr += 6;
@@ -83,11 +74,7 @@ void gen_unicode_page(char *page)
 			ptr += 4;
 			break;
 
-#ifdef HAVE_ARC4RANDOM
-		case 5: unilen = arc4random() % 10;
-#else
 		case 5: unilen = rand() % 10;
-#endif
 			for (l = 0; l < unilen; l++) {
 				strncpy(ptr, unicode6, 4);
 				ptr += 4;
@@ -118,12 +105,7 @@ void gen_unicode_page(char *page)
 		}
 	}
 
-#ifdef HAVE_ARC4RANDOM
-	page[arc4random() % page_size] = 0;
-#else
 	page[rand() % page_size] = 0;
-#endif
-
 }
 
 #ifdef STANDALONE
@@ -143,11 +125,7 @@ void main(int argc, char* argv[])
 	struct timeval t;
 
 	gettimeofday(&t, 0);
-#ifdef HAVE_ARC4RANDOM
-	arc4random_uniform((t.tv_sec * getpid()) ^ t.tv_usec);
-#else
 	srand((t.tv_sec * getpid()) ^ t.tv_usec);
-#endif
 
 	page = malloc(4096);
 	memset(page, 0, 4096);
diff --git a/watchdog.c b/watchdog.c
index bd516f7..fbd6545 100644
--- a/watchdog.c
+++ b/watchdog.c
@@ -5,9 +5,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <signal.h>
-#ifdef __LINUX__
 #include <sys/prctl.h>
-#endif /* __LINUX__ */
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
@@ -25,6 +23,8 @@
 
 pid_t watchdog_pid;
 
+static unsigned long hiscore = 0;
+
 static int check_shm_sanity(void)
 {
 	unsigned int i;
@@ -61,10 +61,16 @@ static int check_main_alive(void)
 {
 	int ret;
 
-	ret = kill(mainpid, 0);
+	if (shm->mainpid == 0) {
+		output(0, "main pid was zero!\n");
+		shm->exit_reason = EXIT_MAIN_DISAPPEARED;
+		return FALSE;
+	}
+
+	ret = kill(shm->mainpid, 0);
 	if (ret == -1) {
 		if (errno == ESRCH) {
-			output(0, "main pid %d has disappeared.\n", mainpid);
+			output(0, "main pid %d has disappeared.\n", shm->mainpid);
 			shm->exit_reason = EXIT_MAIN_DISAPPEARED;
 
 			/* if main crashed while regenerating, we'll hang the watchdog,
@@ -72,7 +78,7 @@ static int check_main_alive(void)
 			 */
 			shm->regenerating = FALSE;
 		} else {
-			output(0, "problem checking on pid %d (%d:%s)\n", mainpid, errno, strerror(errno));
+			output(0, "problem checking on pid %d (%d:%s)\n", shm->mainpid, errno, strerror(errno));
 		}
 		return FALSE;
 	}
@@ -273,19 +279,20 @@ static void kill_all_kids(void)
 
 static void watchdog(void)
 {
-#ifdef __LINUX__
 	static const char watchdogname[17]="trinity-watchdog";
-#endif
 	static unsigned long lastcount = 0;
 	bool watchdog_exit = FALSE;
-#ifdef __LINUX__
 	int ret = 0;
-#endif
+
+	while (shm->ready == FALSE) {
+		sleep(1);
+		if (shm->exit_reason != STILL_RUNNING)
+			return;
+	}
 
 	output(0, "Watchdog is alive. (pid:%d)\n", watchdog_pid);
-#ifdef __LINUX__
+
 	prctl(PR_SET_NAME, (unsigned long) &watchdogname);
-#endif
 	(void)signal(SIGSEGV, SIG_DFL);
 
 	while (watchdog_exit == FALSE) {
@@ -297,6 +304,7 @@ static void watchdog(void)
 			goto main_dead;
 
 		if (shm->regenerating == FALSE) {
+			unsigned int i;
 
 			reap_dead_kids();
 
@@ -311,16 +319,23 @@ static void watchdog(void)
 			if (shm->total_syscalls_done % 1000 == 0)
 				synclogs();
 
+			for_each_pidslot(i) {
+				if (shm->child_syscall_count[i] > hiscore)
+					hiscore = shm->child_syscall_count[i];
+			}
+
 			if (shm->total_syscalls_done > 1) {
 				if (shm->total_syscalls_done - lastcount > 10000) {
-					output(0, "%ld iterations. [F:%ld S:%ld]\n",
-						shm->total_syscalls_done, shm->failures, shm->successes);
+					output(0, "%ld iterations. [F:%ld S:%ld HI:%ld]\n",
+						shm->total_syscalls_done,
+						shm->failures, shm->successes,
+						hiscore);
 					lastcount = shm->total_syscalls_done;
 				}
 			}
+
 		}
 
-#ifdef __LINUX__
 		/* Only check taint if it mask allows it */
 		if (kernel_taint_mask != 0) {
 			ret = check_tainted();
@@ -329,7 +344,6 @@ static void watchdog(void)
 				shm->exit_reason = EXIT_KERNEL_TAINTED;
 			}
 		}
-#endif
 
 		if (shm->need_reseed == FALSE) {
 			shm->reseed_counter++;
